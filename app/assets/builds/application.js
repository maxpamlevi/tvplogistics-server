(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/@rails/actioncable/src/adapters.js
  var adapters_default;
  var init_adapters = __esm({
    "node_modules/@rails/actioncable/src/adapters.js"() {
      adapters_default = {
        logger: typeof console !== "undefined" ? console : void 0,
        WebSocket: typeof WebSocket !== "undefined" ? WebSocket : void 0
      };
    }
  });

  // node_modules/@rails/actioncable/src/logger.js
  var logger_default;
  var init_logger = __esm({
    "node_modules/@rails/actioncable/src/logger.js"() {
      init_adapters();
      logger_default = {
        log(...messages) {
          if (this.enabled) {
            messages.push(Date.now());
            adapters_default.logger.log("[ActionCable]", ...messages);
          }
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection_monitor.js
  var now, secondsSince, ConnectionMonitor, connection_monitor_default;
  var init_connection_monitor = __esm({
    "node_modules/@rails/actioncable/src/connection_monitor.js"() {
      init_logger();
      now = () => (/* @__PURE__ */ new Date()).getTime();
      secondsSince = (time) => (now() - time) / 1e3;
      ConnectionMonitor = class {
        constructor(connection) {
          this.visibilityDidChange = this.visibilityDidChange.bind(this);
          this.connection = connection;
          this.reconnectAttempts = 0;
        }
        start() {
          if (!this.isRunning()) {
            this.startedAt = now();
            delete this.stoppedAt;
            this.startPolling();
            addEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
          }
        }
        stop() {
          if (this.isRunning()) {
            this.stoppedAt = now();
            this.stopPolling();
            removeEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log("ConnectionMonitor stopped");
          }
        }
        isRunning() {
          return this.startedAt && !this.stoppedAt;
        }
        recordPing() {
          this.pingedAt = now();
        }
        recordConnect() {
          this.reconnectAttempts = 0;
          this.recordPing();
          delete this.disconnectedAt;
          logger_default.log("ConnectionMonitor recorded connect");
        }
        recordDisconnect() {
          this.disconnectedAt = now();
          logger_default.log("ConnectionMonitor recorded disconnect");
        }
        // Private
        startPolling() {
          this.stopPolling();
          this.poll();
        }
        stopPolling() {
          clearTimeout(this.pollTimeout);
        }
        poll() {
          this.pollTimeout = setTimeout(
            () => {
              this.reconnectIfStale();
              this.poll();
            },
            this.getPollInterval()
          );
        }
        getPollInterval() {
          const { staleThreshold, reconnectionBackoffRate } = this.constructor;
          const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
          const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
          const jitter = jitterMax * Math.random();
          return staleThreshold * 1e3 * backoff * (1 + jitter);
        }
        reconnectIfStale() {
          if (this.connectionIsStale()) {
            logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
            this.reconnectAttempts++;
            if (this.disconnectedRecently()) {
              logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
            } else {
              logger_default.log("ConnectionMonitor reopening");
              this.connection.reopen();
            }
          }
        }
        get refreshedAt() {
          return this.pingedAt ? this.pingedAt : this.startedAt;
        }
        connectionIsStale() {
          return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
        }
        disconnectedRecently() {
          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
        }
        visibilityDidChange() {
          if (document.visibilityState === "visible") {
            setTimeout(
              () => {
                if (this.connectionIsStale() || !this.connection.isOpen()) {
                  logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
                  this.connection.reopen();
                }
              },
              200
            );
          }
        }
      };
      ConnectionMonitor.staleThreshold = 6;
      ConnectionMonitor.reconnectionBackoffRate = 0.15;
      connection_monitor_default = ConnectionMonitor;
    }
  });

  // node_modules/@rails/actioncable/src/internal.js
  var internal_default;
  var init_internal = __esm({
    "node_modules/@rails/actioncable/src/internal.js"() {
      internal_default = {
        "message_types": {
          "welcome": "welcome",
          "disconnect": "disconnect",
          "ping": "ping",
          "confirmation": "confirm_subscription",
          "rejection": "reject_subscription"
        },
        "disconnect_reasons": {
          "unauthorized": "unauthorized",
          "invalid_request": "invalid_request",
          "server_restart": "server_restart",
          "remote": "remote"
        },
        "default_mount_path": "/cable",
        "protocols": [
          "actioncable-v1-json",
          "actioncable-unsupported"
        ]
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection.js
  var message_types, protocols, supportedProtocols, indexOf, Connection, connection_default;
  var init_connection = __esm({
    "node_modules/@rails/actioncable/src/connection.js"() {
      init_adapters();
      init_connection_monitor();
      init_internal();
      init_logger();
      ({ message_types, protocols } = internal_default);
      supportedProtocols = protocols.slice(0, protocols.length - 1);
      indexOf = [].indexOf;
      Connection = class {
        constructor(consumer2) {
          this.open = this.open.bind(this);
          this.consumer = consumer2;
          this.subscriptions = this.consumer.subscriptions;
          this.monitor = new connection_monitor_default(this);
          this.disconnected = true;
        }
        send(data) {
          if (this.isOpen()) {
            this.webSocket.send(JSON.stringify(data));
            return true;
          } else {
            return false;
          }
        }
        open() {
          if (this.isActive()) {
            logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
            return false;
          } else {
            const socketProtocols = [...protocols, ...this.consumer.subprotocols || []];
            logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);
            if (this.webSocket) {
              this.uninstallEventHandlers();
            }
            this.webSocket = new adapters_default.WebSocket(this.consumer.url, socketProtocols);
            this.installEventHandlers();
            this.monitor.start();
            return true;
          }
        }
        close({ allowReconnect } = { allowReconnect: true }) {
          if (!allowReconnect) {
            this.monitor.stop();
          }
          if (this.isOpen()) {
            return this.webSocket.close();
          }
        }
        reopen() {
          logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
          if (this.isActive()) {
            try {
              return this.close();
            } catch (error2) {
              logger_default.log("Failed to reopen WebSocket", error2);
            } finally {
              logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
              setTimeout(this.open, this.constructor.reopenDelay);
            }
          } else {
            return this.open();
          }
        }
        getProtocol() {
          if (this.webSocket) {
            return this.webSocket.protocol;
          }
        }
        isOpen() {
          return this.isState("open");
        }
        isActive() {
          return this.isState("open", "connecting");
        }
        triedToReconnect() {
          return this.monitor.reconnectAttempts > 0;
        }
        // Private
        isProtocolSupported() {
          return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
        }
        isState(...states) {
          return indexOf.call(states, this.getState()) >= 0;
        }
        getState() {
          if (this.webSocket) {
            for (let state in adapters_default.WebSocket) {
              if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
                return state.toLowerCase();
              }
            }
          }
          return null;
        }
        installEventHandlers() {
          for (let eventName in this.events) {
            const handler = this.events[eventName].bind(this);
            this.webSocket[`on${eventName}`] = handler;
          }
        }
        uninstallEventHandlers() {
          for (let eventName in this.events) {
            this.webSocket[`on${eventName}`] = function() {
            };
          }
        }
      };
      Connection.reopenDelay = 500;
      Connection.prototype.events = {
        message(event) {
          if (!this.isProtocolSupported()) {
            return;
          }
          const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
          switch (type) {
            case message_types.welcome:
              if (this.triedToReconnect()) {
                this.reconnectAttempted = true;
              }
              this.monitor.recordConnect();
              return this.subscriptions.reload();
            case message_types.disconnect:
              logger_default.log(`Disconnecting. Reason: ${reason}`);
              return this.close({ allowReconnect: reconnect });
            case message_types.ping:
              return this.monitor.recordPing();
            case message_types.confirmation:
              this.subscriptions.confirmSubscription(identifier);
              if (this.reconnectAttempted) {
                this.reconnectAttempted = false;
                return this.subscriptions.notify(identifier, "connected", { reconnected: true });
              } else {
                return this.subscriptions.notify(identifier, "connected", { reconnected: false });
              }
            case message_types.rejection:
              return this.subscriptions.reject(identifier);
            default:
              return this.subscriptions.notify(identifier, "received", message);
          }
        },
        open() {
          logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
          this.disconnected = false;
          if (!this.isProtocolSupported()) {
            logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
            return this.close({ allowReconnect: false });
          }
        },
        close(event) {
          logger_default.log("WebSocket onclose event");
          if (this.disconnected) {
            return;
          }
          this.disconnected = true;
          this.monitor.recordDisconnect();
          return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
        },
        error() {
          logger_default.log("WebSocket onerror event");
        }
      };
      connection_default = Connection;
    }
  });

  // node_modules/@rails/actioncable/src/subscription.js
  var extend, Subscription;
  var init_subscription = __esm({
    "node_modules/@rails/actioncable/src/subscription.js"() {
      extend = function(object, properties) {
        if (properties != null) {
          for (let key in properties) {
            const value = properties[key];
            object[key] = value;
          }
        }
        return object;
      };
      Subscription = class {
        constructor(consumer2, params = {}, mixin) {
          this.consumer = consumer2;
          this.identifier = JSON.stringify(params);
          extend(this, mixin);
        }
        // Perform a channel action with the optional data passed as an attribute
        perform(action, data = {}) {
          data.action = action;
          return this.send(data);
        }
        send(data) {
          return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data) });
        }
        unsubscribe() {
          return this.consumer.subscriptions.remove(this);
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/subscription_guarantor.js
  var SubscriptionGuarantor, subscription_guarantor_default;
  var init_subscription_guarantor = __esm({
    "node_modules/@rails/actioncable/src/subscription_guarantor.js"() {
      init_logger();
      SubscriptionGuarantor = class {
        constructor(subscriptions) {
          this.subscriptions = subscriptions;
          this.pendingSubscriptions = [];
        }
        guarantee(subscription) {
          if (this.pendingSubscriptions.indexOf(subscription) == -1) {
            logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
            this.pendingSubscriptions.push(subscription);
          } else {
            logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
          }
          this.startGuaranteeing();
        }
        forget(subscription) {
          logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
          this.pendingSubscriptions = this.pendingSubscriptions.filter((s) => s !== subscription);
        }
        startGuaranteeing() {
          this.stopGuaranteeing();
          this.retrySubscribing();
        }
        stopGuaranteeing() {
          clearTimeout(this.retryTimeout);
        }
        retrySubscribing() {
          this.retryTimeout = setTimeout(
            () => {
              if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
                this.pendingSubscriptions.map((subscription) => {
                  logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
                  this.subscriptions.subscribe(subscription);
                });
              }
            },
            500
          );
        }
      };
      subscription_guarantor_default = SubscriptionGuarantor;
    }
  });

  // node_modules/@rails/actioncable/src/subscriptions.js
  var Subscriptions;
  var init_subscriptions = __esm({
    "node_modules/@rails/actioncable/src/subscriptions.js"() {
      init_subscription();
      init_subscription_guarantor();
      init_logger();
      Subscriptions = class {
        constructor(consumer2) {
          this.consumer = consumer2;
          this.guarantor = new subscription_guarantor_default(this);
          this.subscriptions = [];
        }
        create(channelName, mixin) {
          const channel = channelName;
          const params = typeof channel === "object" ? channel : { channel };
          const subscription = new Subscription(this.consumer, params, mixin);
          return this.add(subscription);
        }
        // Private
        add(subscription) {
          this.subscriptions.push(subscription);
          this.consumer.ensureActiveConnection();
          this.notify(subscription, "initialized");
          this.subscribe(subscription);
          return subscription;
        }
        remove(subscription) {
          this.forget(subscription);
          if (!this.findAll(subscription.identifier).length) {
            this.sendCommand(subscription, "unsubscribe");
          }
          return subscription;
        }
        reject(identifier) {
          return this.findAll(identifier).map((subscription) => {
            this.forget(subscription);
            this.notify(subscription, "rejected");
            return subscription;
          });
        }
        forget(subscription) {
          this.guarantor.forget(subscription);
          this.subscriptions = this.subscriptions.filter((s) => s !== subscription);
          return subscription;
        }
        findAll(identifier) {
          return this.subscriptions.filter((s) => s.identifier === identifier);
        }
        reload() {
          return this.subscriptions.map((subscription) => this.subscribe(subscription));
        }
        notifyAll(callbackName, ...args) {
          return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
        }
        notify(subscription, callbackName, ...args) {
          let subscriptions;
          if (typeof subscription === "string") {
            subscriptions = this.findAll(subscription);
          } else {
            subscriptions = [subscription];
          }
          return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
        }
        subscribe(subscription) {
          if (this.sendCommand(subscription, "subscribe")) {
            this.guarantor.guarantee(subscription);
          }
        }
        confirmSubscription(identifier) {
          logger_default.log(`Subscription confirmed ${identifier}`);
          this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
        }
        sendCommand(subscription, command) {
          const { identifier } = subscription;
          return this.consumer.send({ command, identifier });
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/consumer.js
  function createWebSocketURL(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      const a = document.createElement("a");
      a.href = url;
      a.href = a.href;
      a.protocol = a.protocol.replace("http", "ws");
      return a.href;
    } else {
      return url;
    }
  }
  var Consumer;
  var init_consumer = __esm({
    "node_modules/@rails/actioncable/src/consumer.js"() {
      init_connection();
      init_subscriptions();
      Consumer = class {
        constructor(url) {
          this._url = url;
          this.subscriptions = new Subscriptions(this);
          this.connection = new connection_default(this);
          this.subprotocols = [];
        }
        get url() {
          return createWebSocketURL(this._url);
        }
        send(data) {
          return this.connection.send(data);
        }
        connect() {
          return this.connection.open();
        }
        disconnect() {
          return this.connection.close({ allowReconnect: false });
        }
        ensureActiveConnection() {
          if (!this.connection.isActive()) {
            return this.connection.open();
          }
        }
        addSubProtocol(subprotocol) {
          this.subprotocols = [...this.subprotocols, subprotocol];
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/index.js
  var src_exports = {};
  __export(src_exports, {
    Connection: () => connection_default,
    ConnectionMonitor: () => connection_monitor_default,
    Consumer: () => Consumer,
    INTERNAL: () => internal_default,
    Subscription: () => Subscription,
    SubscriptionGuarantor: () => subscription_guarantor_default,
    Subscriptions: () => Subscriptions,
    adapters: () => adapters_default,
    createConsumer: () => createConsumer,
    createWebSocketURL: () => createWebSocketURL,
    getConfig: () => getConfig,
    logger: () => logger_default
  });
  function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
    return new Consumer(url);
  }
  function getConfig(name) {
    const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  var init_src = __esm({
    "node_modules/@rails/actioncable/src/index.js"() {
      init_connection();
      init_connection_monitor();
      init_consumer();
      init_internal();
      init_subscription();
      init_subscriptions();
      init_subscription_guarantor();
      init_adapters();
      init_logger();
    }
  });

  // node_modules/jquery/dist/jquery.js
  var require_jquery = __commonJS({
    "node_modules/jquery/dist/jquery.js"(exports, module) {
      (function(global2, factory) {
        "use strict";
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global2.document ? factory(global2, true) : function(w) {
            if (!w.document) {
              throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global2);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        "use strict";
        var arr = [];
        var getProto2 = Object.getPrototypeOf;
        var slice = arr.slice;
        var flat = arr.flat ? function(array) {
          return arr.flat.call(array);
        } : function(array) {
          return arr.concat.apply([], array);
        };
        var push = arr.push;
        var indexOf2 = arr.indexOf;
        var class2type = {};
        var toString = class2type.toString;
        var hasOwn2 = class2type.hasOwnProperty;
        var fnToString = hasOwn2.toString;
        var ObjectFunctionString = fnToString.call(Object);
        var support = {};
        var isFunction3 = function isFunction4(obj) {
          return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
        };
        var isWindow = function isWindow2(obj) {
          return obj != null && obj === obj.window;
        };
        var document2 = window2.document;
        var preservedScriptAttributes = {
          type: true,
          src: true,
          nonce: true,
          noModule: true
        };
        function DOMEval(code, node, doc2) {
          doc2 = doc2 || document2;
          var i, val, script = doc2.createElement("script");
          script.text = code;
          if (node) {
            for (i in preservedScriptAttributes) {
              val = node[i] || node.getAttribute && node.getAttribute(i);
              if (val) {
                script.setAttribute(i, val);
              }
            }
          }
          doc2.head.appendChild(script).parentNode.removeChild(script);
        }
        function toType(obj) {
          if (obj == null) {
            return obj + "";
          }
          return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        }
        var version2 = "3.7.1", rhtmlSuffix = /HTML$/i, jQuery4 = function(selector, context) {
          return new jQuery4.fn.init(selector, context);
        };
        jQuery4.fn = jQuery4.prototype = {
          // The current version of jQuery being used
          jquery: version2,
          constructor: jQuery4,
          // The default length of a jQuery object is 0
          length: 0,
          toArray: function() {
            return slice.call(this);
          },
          // Get the Nth element in the matched element set OR
          // Get the whole matched element set as a clean array
          get: function(num) {
            if (num == null) {
              return slice.call(this);
            }
            return num < 0 ? this[num + this.length] : this[num];
          },
          // Take an array of elements and push it onto the stack
          // (returning the new matched element set)
          pushStack: function(elems) {
            var ret = jQuery4.merge(this.constructor(), elems);
            ret.prevObject = this;
            return ret;
          },
          // Execute a callback for every element in the matched set.
          each: function(callback) {
            return jQuery4.each(this, callback);
          },
          map: function(callback) {
            return this.pushStack(jQuery4.map(this, function(elem, i) {
              return callback.call(elem, i, elem);
            }));
          },
          slice: function() {
            return this.pushStack(slice.apply(this, arguments));
          },
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          even: function() {
            return this.pushStack(jQuery4.grep(this, function(_elem, i) {
              return (i + 1) % 2;
            }));
          },
          odd: function() {
            return this.pushStack(jQuery4.grep(this, function(_elem, i) {
              return i % 2;
            }));
          },
          eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
          },
          end: function() {
            return this.prevObject || this.constructor();
          },
          // For internal use only.
          // Behaves like an Array's method, not like a jQuery method.
          push,
          sort: arr.sort,
          splice: arr.splice
        };
        jQuery4.extend = jQuery4.fn.extend = function() {
          var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
          if (typeof target === "boolean") {
            deep = target;
            target = arguments[i] || {};
            i++;
          }
          if (typeof target !== "object" && !isFunction3(target)) {
            target = {};
          }
          if (i === length) {
            target = this;
            i--;
          }
          for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
              for (name in options) {
                copy = options[name];
                if (name === "__proto__" || target === copy) {
                  continue;
                }
                if (deep && copy && (jQuery4.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                  src = target[name];
                  if (copyIsArray && !Array.isArray(src)) {
                    clone = [];
                  } else if (!copyIsArray && !jQuery4.isPlainObject(src)) {
                    clone = {};
                  } else {
                    clone = src;
                  }
                  copyIsArray = false;
                  target[name] = jQuery4.extend(deep, clone, copy);
                } else if (copy !== void 0) {
                  target[name] = copy;
                }
              }
            }
          }
          return target;
        };
        jQuery4.extend({
          // Unique for each copy of jQuery on the page
          expando: "jQuery" + (version2 + Math.random()).replace(/\D/g, ""),
          // Assume jQuery is ready without the ready module
          isReady: true,
          error: function(msg) {
            throw new Error(msg);
          },
          noop: function() {
          },
          isPlainObject: function(obj) {
            var proto, Ctor;
            if (!obj || toString.call(obj) !== "[object Object]") {
              return false;
            }
            proto = getProto2(obj);
            if (!proto) {
              return true;
            }
            Ctor = hasOwn2.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
          },
          isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
              return false;
            }
            return true;
          },
          // Evaluates a script in a provided context; falls back to the global one
          // if not specified.
          globalEval: function(code, options, doc2) {
            DOMEval(code, { nonce: options && options.nonce }, doc2);
          },
          each: function(obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
              length = obj.length;
              for (; i < length; i++) {
                if (callback.call(obj[i], i, obj[i]) === false) {
                  break;
                }
              }
            } else {
              for (i in obj) {
                if (callback.call(obj[i], i, obj[i]) === false) {
                  break;
                }
              }
            }
            return obj;
          },
          // Retrieve the text value of an array of DOM nodes
          text: function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
              while (node = elem[i++]) {
                ret += jQuery4.text(node);
              }
            }
            if (nodeType === 1 || nodeType === 11) {
              return elem.textContent;
            }
            if (nodeType === 9) {
              return elem.documentElement.textContent;
            }
            if (nodeType === 3 || nodeType === 4) {
              return elem.nodeValue;
            }
            return ret;
          },
          // results is for internal usage only
          makeArray: function(arr2, results) {
            var ret = results || [];
            if (arr2 != null) {
              if (isArrayLike(Object(arr2))) {
                jQuery4.merge(
                  ret,
                  typeof arr2 === "string" ? [arr2] : arr2
                );
              } else {
                push.call(ret, arr2);
              }
            }
            return ret;
          },
          inArray: function(elem, arr2, i) {
            return arr2 == null ? -1 : indexOf2.call(arr2, elem, i);
          },
          isXMLDoc: function(elem) {
            var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
            return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
          },
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          merge: function(first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (; j < len; j++) {
              first[i++] = second[j];
            }
            first.length = i;
            return first;
          },
          grep: function(elems, callback, invert) {
            var callbackInverse, matches2 = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (; i < length; i++) {
              callbackInverse = !callback(elems[i], i);
              if (callbackInverse !== callbackExpect) {
                matches2.push(elems[i]);
              }
            }
            return matches2;
          },
          // arg is for internal usage only
          map: function(elems, callback, arg) {
            var length, value, i = 0, ret = [];
            if (isArrayLike(elems)) {
              length = elems.length;
              for (; i < length; i++) {
                value = callback(elems[i], i, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            } else {
              for (i in elems) {
                value = callback(elems[i], i, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            }
            return flat(ret);
          },
          // A global GUID counter for objects
          guid: 1,
          // jQuery.support is not used in Core but other projects attach their
          // properties to it so it needs to exist.
          support
        });
        if (typeof Symbol === "function") {
          jQuery4.fn[Symbol.iterator] = arr[Symbol.iterator];
        }
        jQuery4.each(
          "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
          function(_i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
          }
        );
        function isArrayLike(obj) {
          var length = !!obj && "length" in obj && obj.length, type = toType(obj);
          if (isFunction3(obj) || isWindow(obj)) {
            return false;
          }
          return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
        }
        function nodeName(elem, name) {
          return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        }
        var pop = arr.pop;
        var sort = arr.sort;
        var splice = arr.splice;
        var whitespace = "[\\x20\\t\\r\\n\\f]";
        var rtrimCSS = new RegExp(
          "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
          "g"
        );
        jQuery4.contains = function(a, b) {
          var bup = b && b.parentNode;
          return a === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
          // IE doesn't have `contains` on SVG.
          (a.contains ? a.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
        };
        var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
        function fcssescape(ch, asCodePoint) {
          if (asCodePoint) {
            if (ch === "\0") {
              return "\uFFFD";
            }
            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
          }
          return "\\" + ch;
        }
        jQuery4.escapeSelector = function(sel) {
          return (sel + "").replace(rcssescape, fcssescape);
        };
        var preferredDoc = document2, pushNative = push;
        (function() {
          var i, Expr, outermostContext, sortInput, hasDuplicate, push2 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches2, expando = jQuery4.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
            if (a === b) {
              hasDuplicate = true;
            }
            return 0;
          }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
          "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
          `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + identifier + ")"),
            CLASS: new RegExp("^\\.(" + identifier + ")"),
            TAG: new RegExp("^(" + identifier + "|[*])"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp(
              "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
              "i"
            ),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
          }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape, nonHex) {
            var high = "0x" + escape.slice(1) - 65536;
            if (nonHex) {
              return nonHex;
            }
            return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
          }, unloadHandler = function() {
            setDocument();
          }, inDisabledFieldset = addCombinator(
            function(elem) {
              return elem.disabled === true && nodeName(elem, "fieldset");
            },
            { dir: "parentNode", next: "legend" }
          );
          function safeActiveElement() {
            try {
              return document3.activeElement;
            } catch (err) {
            }
          }
          try {
            push2.apply(
              arr = slice.call(preferredDoc.childNodes),
              preferredDoc.childNodes
            );
            arr[preferredDoc.childNodes.length].nodeType;
          } catch (e) {
            push2 = {
              apply: function(target, els) {
                pushNative.apply(target, slice.call(els));
              },
              call: function(target) {
                pushNative.apply(target, slice.call(arguments, 1));
              }
            };
          }
          function find(selector, context, results, seed) {
            var m, i2, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            results = results || [];
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
              return results;
            }
            if (!seed) {
              setDocument(context);
              context = context || document3;
              if (documentIsHTML) {
                if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                  if (m = match[1]) {
                    if (nodeType === 9) {
                      if (elem = context.getElementById(m)) {
                        if (elem.id === m) {
                          push2.call(results, elem);
                          return results;
                        }
                      } else {
                        return results;
                      }
                    } else {
                      if (newContext && (elem = newContext.getElementById(m)) && find.contains(context, elem) && elem.id === m) {
                        push2.call(results, elem);
                        return results;
                      }
                    }
                  } else if (match[2]) {
                    push2.apply(results, context.getElementsByTagName(selector));
                    return results;
                  } else if ((m = match[3]) && context.getElementsByClassName) {
                    push2.apply(results, context.getElementsByClassName(m));
                    return results;
                  }
                }
                if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                  newSelector = selector;
                  newContext = context;
                  if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                    newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                    if (newContext != context || !support.scope) {
                      if (nid = context.getAttribute("id")) {
                        nid = jQuery4.escapeSelector(nid);
                      } else {
                        context.setAttribute("id", nid = expando);
                      }
                    }
                    groups = tokenize2(selector);
                    i2 = groups.length;
                    while (i2--) {
                      groups[i2] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i2]);
                    }
                    newSelector = groups.join(",");
                  }
                  try {
                    push2.apply(
                      results,
                      newContext.querySelectorAll(newSelector)
                    );
                    return results;
                  } catch (qsaError) {
                    nonnativeSelectorCache(selector, true);
                  } finally {
                    if (nid === expando) {
                      context.removeAttribute("id");
                    }
                  }
                }
              }
            }
            return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
          }
          function createCache() {
            var keys2 = [];
            function cache2(key, value) {
              if (keys2.push(key + " ") > Expr.cacheLength) {
                delete cache2[keys2.shift()];
              }
              return cache2[key + " "] = value;
            }
            return cache2;
          }
          function markFunction(fn) {
            fn[expando] = true;
            return fn;
          }
          function assert2(fn) {
            var el = document3.createElement("fieldset");
            try {
              return !!fn(el);
            } catch (e) {
              return false;
            } finally {
              if (el.parentNode) {
                el.parentNode.removeChild(el);
              }
              el = null;
            }
          }
          function createInputPseudo(type) {
            return function(elem) {
              return nodeName(elem, "input") && elem.type === type;
            };
          }
          function createButtonPseudo(type) {
            return function(elem) {
              return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
            };
          }
          function createDisabledPseudo(disabled) {
            return function(elem) {
              if ("form" in elem) {
                if (elem.parentNode && elem.disabled === false) {
                  if ("label" in elem) {
                    if ("label" in elem.parentNode) {
                      return elem.parentNode.disabled === disabled;
                    } else {
                      return elem.disabled === disabled;
                    }
                  }
                  return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                  elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                }
                return elem.disabled === disabled;
              } else if ("label" in elem) {
                return elem.disabled === disabled;
              }
              return false;
            };
          }
          function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
              argument = +argument;
              return markFunction(function(seed, matches3) {
                var j, matchIndexes = fn([], seed.length, argument), i2 = matchIndexes.length;
                while (i2--) {
                  if (seed[j = matchIndexes[i2]]) {
                    seed[j] = !(matches3[j] = seed[j]);
                  }
                }
              });
            });
          }
          function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
          }
          function setDocument(node) {
            var subWindow, doc2 = node ? node.ownerDocument || node : preferredDoc;
            if (doc2 == document3 || doc2.nodeType !== 9 || !doc2.documentElement) {
              return document3;
            }
            document3 = doc2;
            documentElement2 = document3.documentElement;
            documentIsHTML = !jQuery4.isXMLDoc(document3);
            matches2 = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
            if (documentElement2.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
              subWindow.addEventListener("unload", unloadHandler);
            }
            support.getById = assert2(function(el) {
              documentElement2.appendChild(el).id = jQuery4.expando;
              return !document3.getElementsByName || !document3.getElementsByName(jQuery4.expando).length;
            });
            support.disconnectedMatch = assert2(function(el) {
              return matches2.call(el, "*");
            });
            support.scope = assert2(function() {
              return document3.querySelectorAll(":scope");
            });
            support.cssHas = assert2(function() {
              try {
                document3.querySelector(":has(*,:jqfake)");
                return false;
              } catch (e) {
                return true;
              }
            });
            if (support.getById) {
              Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                  return elem.getAttribute("id") === attrId;
                };
              };
              Expr.find.ID = function(id, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var elem = context.getElementById(id);
                  return elem ? [elem] : [];
                }
              };
            } else {
              Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                  var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                  return node2 && node2.value === attrId;
                };
              };
              Expr.find.ID = function(id, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var node2, i2, elems, elem = context.getElementById(id);
                  if (elem) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id) {
                      return [elem];
                    }
                    elems = context.getElementsByName(id);
                    i2 = 0;
                    while (elem = elems[i2++]) {
                      node2 = elem.getAttributeNode("id");
                      if (node2 && node2.value === id) {
                        return [elem];
                      }
                    }
                  }
                  return [];
                }
              };
            }
            Expr.find.TAG = function(tag, context) {
              if (typeof context.getElementsByTagName !== "undefined") {
                return context.getElementsByTagName(tag);
              } else {
                return context.querySelectorAll(tag);
              }
            };
            Expr.find.CLASS = function(className, context) {
              if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                return context.getElementsByClassName(className);
              }
            };
            rbuggyQSA = [];
            assert2(function(el) {
              var input;
              documentElement2.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
              if (!el.querySelectorAll("[selected]").length) {
                rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
              }
              if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                rbuggyQSA.push("~=");
              }
              if (!el.querySelectorAll("a#" + expando + "+*").length) {
                rbuggyQSA.push(".#.+[+~]");
              }
              if (!el.querySelectorAll(":checked").length) {
                rbuggyQSA.push(":checked");
              }
              input = document3.createElement("input");
              input.setAttribute("type", "hidden");
              el.appendChild(input).setAttribute("name", "D");
              documentElement2.appendChild(el).disabled = true;
              if (el.querySelectorAll(":disabled").length !== 2) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              input = document3.createElement("input");
              input.setAttribute("name", "");
              el.appendChild(input);
              if (!el.querySelectorAll("[name='']").length) {
                rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
              }
            });
            if (!support.cssHas) {
              rbuggyQSA.push(":has");
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            sortOrder = function(a, b) {
              if (a === b) {
                hasDuplicate = true;
                return 0;
              }
              var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
              if (compare) {
                return compare;
              }
              compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : (
                // Otherwise we know they are disconnected
                1
              );
              if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                if (a === document3 || a.ownerDocument == preferredDoc && find.contains(preferredDoc, a)) {
                  return -1;
                }
                if (b === document3 || b.ownerDocument == preferredDoc && find.contains(preferredDoc, b)) {
                  return 1;
                }
                return sortInput ? indexOf2.call(sortInput, a) - indexOf2.call(sortInput, b) : 0;
              }
              return compare & 4 ? -1 : 1;
            };
            return document3;
          }
          find.matches = function(expr, elements) {
            return find(expr, null, null, elements);
          };
          find.matchesSelector = function(elem, expr) {
            setDocument(elem);
            if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
              try {
                var ret = matches2.call(elem, expr);
                if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                // fragment in IE 9
                elem.document && elem.document.nodeType !== 11) {
                  return ret;
                }
              } catch (e) {
                nonnativeSelectorCache(expr, true);
              }
            }
            return find(expr, document3, null, [elem]).length > 0;
          };
          find.contains = function(context, elem) {
            if ((context.ownerDocument || context) != document3) {
              setDocument(context);
            }
            return jQuery4.contains(context, elem);
          };
          find.attr = function(elem, name) {
            if ((elem.ownerDocument || elem) != document3) {
              setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn2.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
            if (val !== void 0) {
              return val;
            }
            return elem.getAttribute(name);
          };
          find.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
          };
          jQuery4.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i2 = 0;
            hasDuplicate = !support.sortStable;
            sortInput = !support.sortStable && slice.call(results, 0);
            sort.call(results, sortOrder);
            if (hasDuplicate) {
              while (elem = results[i2++]) {
                if (elem === results[i2]) {
                  j = duplicates.push(i2);
                }
              }
              while (j--) {
                splice.call(results, duplicates[j], 1);
              }
            }
            sortInput = null;
            return results;
          };
          jQuery4.fn.uniqueSort = function() {
            return this.pushStack(jQuery4.uniqueSort(slice.apply(this)));
          };
          Expr = jQuery4.expr = {
            // Can be adjusted by the user
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
              ">": { dir: "parentNode", first: true },
              " ": { dir: "parentNode" },
              "+": { dir: "previousSibling", first: true },
              "~": { dir: "previousSibling" }
            },
            preFilter: {
              ATTR: function(match) {
                match[1] = match[1].replace(runescape, funescape);
                match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                if (match[2] === "~=") {
                  match[3] = " " + match[3] + " ";
                }
                return match.slice(0, 4);
              },
              CHILD: function(match) {
                match[1] = match[1].toLowerCase();
                if (match[1].slice(0, 3) === "nth") {
                  if (!match[3]) {
                    find.error(match[0]);
                  }
                  match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                  match[5] = +(match[7] + match[8] || match[3] === "odd");
                } else if (match[3]) {
                  find.error(match[0]);
                }
                return match;
              },
              PSEUDO: function(match) {
                var excess, unquoted = !match[6] && match[2];
                if (matchExpr.CHILD.test(match[0])) {
                  return null;
                }
                if (match[3]) {
                  match[2] = match[4] || match[5] || "";
                } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
                (excess = tokenize2(unquoted, true)) && // advance to the next closing parenthesis
                (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                  match[0] = match[0].slice(0, excess);
                  match[2] = unquoted.slice(0, excess);
                }
                return match.slice(0, 3);
              }
            },
            filter: {
              TAG: function(nodeNameSelector) {
                var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                return nodeNameSelector === "*" ? function() {
                  return true;
                } : function(elem) {
                  return nodeName(elem, expectedNodeName);
                };
              },
              CLASS: function(className) {
                var pattern = classCache[className + " "];
                return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                  return pattern.test(
                    typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                  );
                });
              },
              ATTR: function(name, operator, check) {
                return function(elem) {
                  var result = find.attr(elem, name);
                  if (result == null) {
                    return operator === "!=";
                  }
                  if (!operator) {
                    return true;
                  }
                  result += "";
                  if (operator === "=") {
                    return result === check;
                  }
                  if (operator === "!=") {
                    return result !== check;
                  }
                  if (operator === "^=") {
                    return check && result.indexOf(check) === 0;
                  }
                  if (operator === "*=") {
                    return check && result.indexOf(check) > -1;
                  }
                  if (operator === "$=") {
                    return check && result.slice(-check.length) === check;
                  }
                  if (operator === "~=") {
                    return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
                  }
                  if (operator === "|=") {
                    return result === check || result.slice(0, check.length + 1) === check + "-";
                  }
                  return false;
                };
              },
              CHILD: function(type, what, _argument, first, last2) {
                var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                return first === 1 && last2 === 0 ? (
                  // Shortcut for :nth-*(n)
                  function(elem) {
                    return !!elem.parentNode;
                  }
                ) : function(elem, _context, xml) {
                  var cache2, outerCache, node, nodeIndex, start2, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                  if (parent) {
                    if (simple) {
                      while (dir2) {
                        node = elem;
                        while (node = node[dir2]) {
                          if (ofType ? nodeName(node, name) : node.nodeType === 1) {
                            return false;
                          }
                        }
                        start2 = dir2 = type === "only" && !start2 && "nextSibling";
                      }
                      return true;
                    }
                    start2 = [forward ? parent.firstChild : parent.lastChild];
                    if (forward && useCache) {
                      outerCache = parent[expando] || (parent[expando] = {});
                      cache2 = outerCache[type] || [];
                      nodeIndex = cache2[0] === dirruns && cache2[1];
                      diff = nodeIndex && cache2[2];
                      node = nodeIndex && parent.childNodes[nodeIndex];
                      while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                      (diff = nodeIndex = 0) || start2.pop()) {
                        if (node.nodeType === 1 && ++diff && node === elem) {
                          outerCache[type] = [dirruns, nodeIndex, diff];
                          break;
                        }
                      }
                    } else {
                      if (useCache) {
                        outerCache = elem[expando] || (elem[expando] = {});
                        cache2 = outerCache[type] || [];
                        nodeIndex = cache2[0] === dirruns && cache2[1];
                        diff = nodeIndex;
                      }
                      if (diff === false) {
                        while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start2.pop()) {
                          if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
                            if (useCache) {
                              outerCache = node[expando] || (node[expando] = {});
                              outerCache[type] = [dirruns, diff];
                            }
                            if (node === elem) {
                              break;
                            }
                          }
                        }
                      }
                    }
                    diff -= last2;
                    return diff === first || diff % first === 0 && diff / first >= 0;
                  }
                };
              },
              PSEUDO: function(pseudo, argument) {
                var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find.error("unsupported pseudo: " + pseudo);
                if (fn[expando]) {
                  return fn(argument);
                }
                if (fn.length > 1) {
                  args = [pseudo, pseudo, "", argument];
                  return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches3) {
                    var idx, matched = fn(seed, argument), i2 = matched.length;
                    while (i2--) {
                      idx = indexOf2.call(seed, matched[i2]);
                      seed[idx] = !(matches3[idx] = matched[i2]);
                    }
                  }) : function(elem) {
                    return fn(elem, 0, args);
                  };
                }
                return fn;
              }
            },
            pseudos: {
              // Potentially complex pseudos
              not: markFunction(function(selector) {
                var input = [], results = [], matcher = compile3(selector.replace(rtrimCSS, "$1"));
                return matcher[expando] ? markFunction(function(seed, matches3, _context, xml) {
                  var elem, unmatched = matcher(seed, null, xml, []), i2 = seed.length;
                  while (i2--) {
                    if (elem = unmatched[i2]) {
                      seed[i2] = !(matches3[i2] = elem);
                    }
                  }
                }) : function(elem, _context, xml) {
                  input[0] = elem;
                  matcher(input, null, xml, results);
                  input[0] = null;
                  return !results.pop();
                };
              }),
              has: markFunction(function(selector) {
                return function(elem) {
                  return find(selector, elem).length > 0;
                };
              }),
              contains: markFunction(function(text) {
                text = text.replace(runescape, funescape);
                return function(elem) {
                  return (elem.textContent || jQuery4.text(elem)).indexOf(text) > -1;
                };
              }),
              // "Whether an element is represented by a :lang() selector
              // is based solely on the element's language value
              // being equal to the identifier C,
              // or beginning with the identifier C immediately followed by "-".
              // The matching of C against the element's language value is performed case-insensitively.
              // The identifier C does not have to be a valid language name."
              // https://www.w3.org/TR/selectors/#lang-pseudo
              lang: markFunction(function(lang) {
                if (!ridentifier.test(lang || "")) {
                  find.error("unsupported lang: " + lang);
                }
                lang = lang.replace(runescape, funescape).toLowerCase();
                return function(elem) {
                  var elemLang;
                  do {
                    if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                      elemLang = elemLang.toLowerCase();
                      return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                    }
                  } while ((elem = elem.parentNode) && elem.nodeType === 1);
                  return false;
                };
              }),
              // Miscellaneous
              target: function(elem) {
                var hash = window2.location && window2.location.hash;
                return hash && hash.slice(1) === elem.id;
              },
              root: function(elem) {
                return elem === documentElement2;
              },
              focus: function(elem) {
                return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
              },
              // Boolean properties
              enabled: createDisabledPseudo(false),
              disabled: createDisabledPseudo(true),
              checked: function(elem) {
                return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
              },
              selected: function(elem) {
                if (elem.parentNode) {
                  elem.parentNode.selectedIndex;
                }
                return elem.selected === true;
              },
              // Contents
              empty: function(elem) {
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                  if (elem.nodeType < 6) {
                    return false;
                  }
                }
                return true;
              },
              parent: function(elem) {
                return !Expr.pseudos.empty(elem);
              },
              // Element/input types
              header: function(elem) {
                return rheader.test(elem.nodeName);
              },
              input: function(elem) {
                return rinputs.test(elem.nodeName);
              },
              button: function(elem) {
                return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
              },
              text: function(elem) {
                var attr;
                return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
                // New HTML5 attribute values (e.g., "search") appear
                // with elem.type === "text"
                ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
              },
              // Position-in-collection
              first: createPositionalPseudo(function() {
                return [0];
              }),
              last: createPositionalPseudo(function(_matchIndexes, length) {
                return [length - 1];
              }),
              eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
                return [argument < 0 ? argument + length : argument];
              }),
              even: createPositionalPseudo(function(matchIndexes, length) {
                var i2 = 0;
                for (; i2 < length; i2 += 2) {
                  matchIndexes.push(i2);
                }
                return matchIndexes;
              }),
              odd: createPositionalPseudo(function(matchIndexes, length) {
                var i2 = 1;
                for (; i2 < length; i2 += 2) {
                  matchIndexes.push(i2);
                }
                return matchIndexes;
              }),
              lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                var i2;
                if (argument < 0) {
                  i2 = argument + length;
                } else if (argument > length) {
                  i2 = length;
                } else {
                  i2 = argument;
                }
                for (; --i2 >= 0; ) {
                  matchIndexes.push(i2);
                }
                return matchIndexes;
              }),
              gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                var i2 = argument < 0 ? argument + length : argument;
                for (; ++i2 < length; ) {
                  matchIndexes.push(i2);
                }
                return matchIndexes;
              })
            }
          };
          Expr.pseudos.nth = Expr.pseudos.eq;
          for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
            Expr.pseudos[i] = createInputPseudo(i);
          }
          for (i in { submit: true, reset: true }) {
            Expr.pseudos[i] = createButtonPseudo(i);
          }
          function setFilters() {
          }
          setFilters.prototype = Expr.filters = Expr.pseudos;
          Expr.setFilters = new setFilters();
          function tokenize2(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
              return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
              if (!matched || (match = rcomma.exec(soFar))) {
                if (match) {
                  soFar = soFar.slice(match[0].length) || soFar;
                }
                groups.push(tokens = []);
              }
              matched = false;
              if (match = rleadingCombinator.exec(soFar)) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  // Cast descendant combinators to space
                  type: match[0].replace(rtrimCSS, " ")
                });
                soFar = soFar.slice(matched.length);
              }
              for (type in Expr.filter) {
                if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                  matched = match.shift();
                  tokens.push({
                    value: matched,
                    type,
                    matches: match
                  });
                  soFar = soFar.slice(matched.length);
                }
              }
              if (!matched) {
                break;
              }
            }
            if (parseOnly) {
              return soFar.length;
            }
            return soFar ? find.error(selector) : (
              // Cache the tokens
              tokenCache(selector, groups).slice(0)
            );
          }
          function toSelector(tokens) {
            var i2 = 0, len = tokens.length, selector = "";
            for (; i2 < len; i2++) {
              selector += tokens[i2].value;
            }
            return selector;
          }
          function addCombinator(matcher, combinator, base) {
            var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
            return combinator.first ? (
              // Check against closest ancestor/preceding element
              function(elem, context, xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    return matcher(elem, context, xml);
                  }
                }
                return false;
              }
            ) : (
              // Check against all ancestor/preceding elements
              function(elem, context, xml) {
                var oldCache, outerCache, newCache = [dirruns, doneName];
                if (xml) {
                  while (elem = elem[dir2]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                      if (matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                } else {
                  while (elem = elem[dir2]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                      outerCache = elem[expando] || (elem[expando] = {});
                      if (skip && nodeName(elem, skip)) {
                        elem = elem[dir2] || elem;
                      } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                        return newCache[2] = oldCache[2];
                      } else {
                        outerCache[key] = newCache;
                        if (newCache[2] = matcher(elem, context, xml)) {
                          return true;
                        }
                      }
                    }
                  }
                }
                return false;
              }
            );
          }
          function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
              var i2 = matchers.length;
              while (i2--) {
                if (!matchers[i2](elem, context, xml)) {
                  return false;
                }
              }
              return true;
            } : matchers[0];
          }
          function multipleContexts(selector, contexts, results) {
            var i2 = 0, len = contexts.length;
            for (; i2 < len; i2++) {
              find(selector, contexts[i2], results);
            }
            return results;
          }
          function condense2(unmatched, map2, filter, context, xml) {
            var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map2 != null;
            for (; i2 < len; i2++) {
              if (elem = unmatched[i2]) {
                if (!filter || filter(elem, context, xml)) {
                  newUnmatched.push(elem);
                  if (mapped) {
                    map2.push(i2);
                  }
                }
              }
            }
            return newUnmatched;
          }
          function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
              postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
              postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
              var temp, i2, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
                selector || "*",
                context.nodeType ? [context] : context,
                []
              ), matcherIn = preFilter && (seed || !selector) ? condense2(elems, preMap, preFilter, context, xml) : elems;
              if (matcher) {
                matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                  // ...intermediate processing is necessary
                  []
                ) : (
                  // ...otherwise use results directly
                  results
                );
                matcher(matcherIn, matcherOut, context, xml);
              } else {
                matcherOut = matcherIn;
              }
              if (postFilter) {
                temp = condense2(matcherOut, postMap);
                postFilter(temp, [], context, xml);
                i2 = temp.length;
                while (i2--) {
                  if (elem = temp[i2]) {
                    matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
                  }
                }
              }
              if (seed) {
                if (postFinder || preFilter) {
                  if (postFinder) {
                    temp = [];
                    i2 = matcherOut.length;
                    while (i2--) {
                      if (elem = matcherOut[i2]) {
                        temp.push(matcherIn[i2] = elem);
                      }
                    }
                    postFinder(null, matcherOut = [], temp, xml);
                  }
                  i2 = matcherOut.length;
                  while (i2--) {
                    if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf2.call(seed, elem) : preMap[i2]) > -1) {
                      seed[temp] = !(results[temp] = elem);
                    }
                  }
                }
              } else {
                matcherOut = condense2(
                  matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
                );
                if (postFinder) {
                  postFinder(null, results, matcherOut, xml);
                } else {
                  push2.apply(results, matcherOut);
                }
              }
            });
          }
          function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
              return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
              return indexOf2.call(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [function(elem, context, xml) {
              var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
              checkContext = null;
              return ret;
            }];
            for (; i2 < len; i2++) {
              if (matcher = Expr.relative[tokens[i2].type]) {
                matchers = [addCombinator(elementMatcher(matchers), matcher)];
              } else {
                matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
                if (matcher[expando]) {
                  j = ++i2;
                  for (; j < len; j++) {
                    if (Expr.relative[tokens[j].type]) {
                      break;
                    }
                  }
                  return setMatcher(
                    i2 > 1 && elementMatcher(matchers),
                    i2 > 1 && toSelector(
                      // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                      tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })
                    ).replace(rtrimCSS, "$1"),
                    matcher,
                    i2 < j && matcherFromTokens(tokens.slice(i2, j)),
                    j < len && matcherFromTokens(tokens = tokens.slice(j)),
                    j < len && toSelector(tokens)
                  );
                }
                matchers.push(matcher);
              }
            }
            return elementMatcher(matchers);
          }
          function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
              var elem, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
              if (outermost) {
                outermostContext = context == document3 || context || outermost;
              }
              for (; i2 !== len && (elem = elems[i2]) != null; i2++) {
                if (byElement && elem) {
                  j = 0;
                  if (!context && elem.ownerDocument != document3) {
                    setDocument(elem);
                    xml = !documentIsHTML;
                  }
                  while (matcher = elementMatchers[j++]) {
                    if (matcher(elem, context || document3, xml)) {
                      push2.call(results, elem);
                      break;
                    }
                  }
                  if (outermost) {
                    dirruns = dirrunsUnique;
                  }
                }
                if (bySet) {
                  if (elem = !matcher && elem) {
                    matchedCount--;
                  }
                  if (seed) {
                    unmatched.push(elem);
                  }
                }
              }
              matchedCount += i2;
              if (bySet && i2 !== matchedCount) {
                j = 0;
                while (matcher = setMatchers[j++]) {
                  matcher(unmatched, setMatched, context, xml);
                }
                if (seed) {
                  if (matchedCount > 0) {
                    while (i2--) {
                      if (!(unmatched[i2] || setMatched[i2])) {
                        setMatched[i2] = pop.call(results);
                      }
                    }
                  }
                  setMatched = condense2(setMatched);
                }
                push2.apply(results, setMatched);
                if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                  jQuery4.uniqueSort(results);
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
              }
              return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
          }
          function compile3(selector, match) {
            var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
              if (!match) {
                match = tokenize2(selector);
              }
              i2 = match.length;
              while (i2--) {
                cached = matcherFromTokens(match[i2]);
                if (cached[expando]) {
                  setMatchers.push(cached);
                } else {
                  elementMatchers.push(cached);
                }
              }
              cached = compilerCache(
                selector,
                matcherFromGroupMatchers(elementMatchers, setMatchers)
              );
              cached.selector = selector;
            }
            return cached;
          }
          function select(selector, context, results, seed) {
            var i2, tokens, token, type, find2, compiled = typeof selector === "function" && selector, match = !seed && tokenize2(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
              tokens = match[0] = match[0].slice(0);
              if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                context = (Expr.find.ID(
                  token.matches[0].replace(runescape, funescape),
                  context
                ) || [])[0];
                if (!context) {
                  return results;
                } else if (compiled) {
                  context = context.parentNode;
                }
                selector = selector.slice(tokens.shift().value.length);
              }
              i2 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
              while (i2--) {
                token = tokens[i2];
                if (Expr.relative[type = token.type]) {
                  break;
                }
                if (find2 = Expr.find[type]) {
                  if (seed = find2(
                    token.matches[0].replace(runescape, funescape),
                    rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                  )) {
                    tokens.splice(i2, 1);
                    selector = seed.length && toSelector(tokens);
                    if (!selector) {
                      push2.apply(results, seed);
                      return results;
                    }
                    break;
                  }
                }
              }
            }
            (compiled || compile3(selector, match))(
              seed,
              context,
              !documentIsHTML,
              results,
              !context || rsibling.test(selector) && testContext(context.parentNode) || context
            );
            return results;
          }
          support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
          setDocument();
          support.sortDetached = assert2(function(el) {
            return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
          });
          jQuery4.find = find;
          jQuery4.expr[":"] = jQuery4.expr.pseudos;
          jQuery4.unique = jQuery4.uniqueSort;
          find.compile = compile3;
          find.select = select;
          find.setDocument = setDocument;
          find.tokenize = tokenize2;
          find.escape = jQuery4.escapeSelector;
          find.getText = jQuery4.text;
          find.isXML = jQuery4.isXMLDoc;
          find.selectors = jQuery4.expr;
          find.support = jQuery4.support;
          find.uniqueSort = jQuery4.uniqueSort;
        })();
        var dir = function(elem, dir2, until) {
          var matched = [], truncate = until !== void 0;
          while ((elem = elem[dir2]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
              if (truncate && jQuery4(elem).is(until)) {
                break;
              }
              matched.push(elem);
            }
          }
          return matched;
        };
        var siblings = function(n, elem) {
          var matched = [];
          for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
              matched.push(n);
            }
          }
          return matched;
        };
        var rneedsContext = jQuery4.expr.match.needsContext;
        var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
        function winnow(elements, qualifier, not) {
          if (isFunction3(qualifier)) {
            return jQuery4.grep(elements, function(elem, i) {
              return !!qualifier.call(elem, i, elem) !== not;
            });
          }
          if (qualifier.nodeType) {
            return jQuery4.grep(elements, function(elem) {
              return elem === qualifier !== not;
            });
          }
          if (typeof qualifier !== "string") {
            return jQuery4.grep(elements, function(elem) {
              return indexOf2.call(qualifier, elem) > -1 !== not;
            });
          }
          return jQuery4.filter(qualifier, elements, not);
        }
        jQuery4.filter = function(expr, elems, not) {
          var elem = elems[0];
          if (not) {
            expr = ":not(" + expr + ")";
          }
          if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery4.find.matchesSelector(elem, expr) ? [elem] : [];
          }
          return jQuery4.find.matches(expr, jQuery4.grep(elems, function(elem2) {
            return elem2.nodeType === 1;
          }));
        };
        jQuery4.fn.extend({
          find: function(selector) {
            var i, ret, len = this.length, self2 = this;
            if (typeof selector !== "string") {
              return this.pushStack(jQuery4(selector).filter(function() {
                for (i = 0; i < len; i++) {
                  if (jQuery4.contains(self2[i], this)) {
                    return true;
                  }
                }
              }));
            }
            ret = this.pushStack([]);
            for (i = 0; i < len; i++) {
              jQuery4.find(selector, self2[i], ret);
            }
            return len > 1 ? jQuery4.uniqueSort(ret) : ret;
          },
          filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
          },
          not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
          },
          is: function(selector) {
            return !!winnow(
              this,
              // If this is a positional/relative selector, check membership in the returned set
              // so $("p:first").is("p:last") won't return true for a doc with two "p".
              typeof selector === "string" && rneedsContext.test(selector) ? jQuery4(selector) : selector || [],
              false
            ).length;
          }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery4.fn.init = function(selector, context, root) {
          var match, elem;
          if (!selector) {
            return this;
          }
          root = root || rootjQuery;
          if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
              match = [null, selector, null];
            } else {
              match = rquickExpr.exec(selector);
            }
            if (match && (match[1] || !context)) {
              if (match[1]) {
                context = context instanceof jQuery4 ? context[0] : context;
                jQuery4.merge(this, jQuery4.parseHTML(
                  match[1],
                  context && context.nodeType ? context.ownerDocument || context : document2,
                  true
                ));
                if (rsingleTag.test(match[1]) && jQuery4.isPlainObject(context)) {
                  for (match in context) {
                    if (isFunction3(this[match])) {
                      this[match](context[match]);
                    } else {
                      this.attr(match, context[match]);
                    }
                  }
                }
                return this;
              } else {
                elem = document2.getElementById(match[2]);
                if (elem) {
                  this[0] = elem;
                  this.length = 1;
                }
                return this;
              }
            } else if (!context || context.jquery) {
              return (context || root).find(selector);
            } else {
              return this.constructor(context).find(selector);
            }
          } else if (selector.nodeType) {
            this[0] = selector;
            this.length = 1;
            return this;
          } else if (isFunction3(selector)) {
            return root.ready !== void 0 ? root.ready(selector) : (
              // Execute immediately if ready is not present
              selector(jQuery4)
            );
          }
          return jQuery4.makeArray(selector, this);
        };
        init.prototype = jQuery4.fn;
        rootjQuery = jQuery4(document2);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
          children: true,
          contents: true,
          next: true,
          prev: true
        };
        jQuery4.fn.extend({
          has: function(target) {
            var targets = jQuery4(target, this), l = targets.length;
            return this.filter(function() {
              var i = 0;
              for (; i < l; i++) {
                if (jQuery4.contains(this, targets[i])) {
                  return true;
                }
              }
            });
          },
          closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery4(selectors);
            if (!rneedsContext.test(selectors)) {
              for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                  if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                    // Don't pass non-elements to jQuery#find
                    cur.nodeType === 1 && jQuery4.find.matchesSelector(cur, selectors)
                  ))) {
                    matched.push(cur);
                    break;
                  }
                }
              }
            }
            return this.pushStack(matched.length > 1 ? jQuery4.uniqueSort(matched) : matched);
          },
          // Determine the position of an element within the set
          index: function(elem) {
            if (!elem) {
              return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
              return indexOf2.call(jQuery4(elem), this[0]);
            }
            return indexOf2.call(
              this,
              // If it receives a jQuery object, the first element is used
              elem.jquery ? elem[0] : elem
            );
          },
          add: function(selector, context) {
            return this.pushStack(
              jQuery4.uniqueSort(
                jQuery4.merge(this.get(), jQuery4(selector, context))
              )
            );
          },
          addBack: function(selector) {
            return this.add(
              selector == null ? this.prevObject : this.prevObject.filter(selector)
            );
          }
        });
        function sibling(cur, dir2) {
          while ((cur = cur[dir2]) && cur.nodeType !== 1) {
          }
          return cur;
        }
        jQuery4.each({
          parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
          },
          parents: function(elem) {
            return dir(elem, "parentNode");
          },
          parentsUntil: function(elem, _i, until) {
            return dir(elem, "parentNode", until);
          },
          next: function(elem) {
            return sibling(elem, "nextSibling");
          },
          prev: function(elem) {
            return sibling(elem, "previousSibling");
          },
          nextAll: function(elem) {
            return dir(elem, "nextSibling");
          },
          prevAll: function(elem) {
            return dir(elem, "previousSibling");
          },
          nextUntil: function(elem, _i, until) {
            return dir(elem, "nextSibling", until);
          },
          prevUntil: function(elem, _i, until) {
            return dir(elem, "previousSibling", until);
          },
          siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
          },
          children: function(elem) {
            return siblings(elem.firstChild);
          },
          contents: function(elem) {
            if (elem.contentDocument != null && // Support: IE 11+
            // <object> elements with no `data` attribute has an object
            // `contentDocument` with a `null` prototype.
            getProto2(elem.contentDocument)) {
              return elem.contentDocument;
            }
            if (nodeName(elem, "template")) {
              elem = elem.content || elem;
            }
            return jQuery4.merge([], elem.childNodes);
          }
        }, function(name, fn) {
          jQuery4.fn[name] = function(until, selector) {
            var matched = jQuery4.map(this, fn, until);
            if (name.slice(-5) !== "Until") {
              selector = until;
            }
            if (selector && typeof selector === "string") {
              matched = jQuery4.filter(selector, matched);
            }
            if (this.length > 1) {
              if (!guaranteedUnique[name]) {
                jQuery4.uniqueSort(matched);
              }
              if (rparentsprev.test(name)) {
                matched.reverse();
              }
            }
            return this.pushStack(matched);
          };
        });
        var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
        function createOptions(options) {
          var object = {};
          jQuery4.each(options.match(rnothtmlwhite) || [], function(_2, flag) {
            object[flag] = true;
          });
          return object;
        }
        jQuery4.Callbacks = function(options) {
          options = typeof options === "string" ? createOptions(options) : jQuery4.extend({}, options);
          var firing, memory, fired, locked, list = [], queue2 = [], firingIndex = -1, fire = function() {
            locked = locked || options.once;
            fired = firing = true;
            for (; queue2.length; firingIndex = -1) {
              memory = queue2.shift();
              while (++firingIndex < list.length) {
                if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                  firingIndex = list.length;
                  memory = false;
                }
              }
            }
            if (!options.memory) {
              memory = false;
            }
            firing = false;
            if (locked) {
              if (memory) {
                list = [];
              } else {
                list = "";
              }
            }
          }, self2 = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
              if (list) {
                if (memory && !firing) {
                  firingIndex = list.length - 1;
                  queue2.push(memory);
                }
                (function add3(args) {
                  jQuery4.each(args, function(_2, arg) {
                    if (isFunction3(arg)) {
                      if (!options.unique || !self2.has(arg)) {
                        list.push(arg);
                      }
                    } else if (arg && arg.length && toType(arg) !== "string") {
                      add3(arg);
                    }
                  });
                })(arguments);
                if (memory && !firing) {
                  fire();
                }
              }
              return this;
            },
            // Remove a callback from the list
            remove: function() {
              jQuery4.each(arguments, function(_2, arg) {
                var index;
                while ((index = jQuery4.inArray(arg, list, index)) > -1) {
                  list.splice(index, 1);
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              });
              return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function(fn) {
              return fn ? jQuery4.inArray(fn, list) > -1 : list.length > 0;
            },
            // Remove all callbacks from the list
            empty: function() {
              if (list) {
                list = [];
              }
              return this;
            },
            // Disable .fire and .add
            // Abort any current/pending executions
            // Clear all callbacks and values
            disable: function() {
              locked = queue2 = [];
              list = memory = "";
              return this;
            },
            disabled: function() {
              return !list;
            },
            // Disable .fire
            // Also disable .add unless we have memory (since it would have no effect)
            // Abort any pending executions
            lock: function() {
              locked = queue2 = [];
              if (!memory && !firing) {
                list = memory = "";
              }
              return this;
            },
            locked: function() {
              return !!locked;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function(context, args) {
              if (!locked) {
                args = args || [];
                args = [context, args.slice ? args.slice() : args];
                queue2.push(args);
                if (!firing) {
                  fire();
                }
              }
              return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
              self2.fireWith(this, arguments);
              return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
              return !!fired;
            }
          };
          return self2;
        };
        function Identity(v) {
          return v;
        }
        function Thrower(ex) {
          throw ex;
        }
        function adoptValue(value, resolve2, reject, noValue) {
          var method;
          try {
            if (value && isFunction3(method = value.promise)) {
              method.call(value).done(resolve2).fail(reject);
            } else if (value && isFunction3(method = value.then)) {
              method.call(value, resolve2, reject);
            } else {
              resolve2.apply(void 0, [value].slice(noValue));
            }
          } catch (value2) {
            reject.apply(void 0, [value2]);
          }
        }
        jQuery4.extend({
          Deferred: function(func) {
            var tuples = [
              // action, add listener, callbacks,
              // ... .then handlers, argument index, [final state]
              [
                "notify",
                "progress",
                jQuery4.Callbacks("memory"),
                jQuery4.Callbacks("memory"),
                2
              ],
              [
                "resolve",
                "done",
                jQuery4.Callbacks("once memory"),
                jQuery4.Callbacks("once memory"),
                0,
                "resolved"
              ],
              [
                "reject",
                "fail",
                jQuery4.Callbacks("once memory"),
                jQuery4.Callbacks("once memory"),
                1,
                "rejected"
              ]
            ], state = "pending", promise = {
              state: function() {
                return state;
              },
              always: function() {
                deferred.done(arguments).fail(arguments);
                return this;
              },
              "catch": function(fn) {
                return promise.then(null, fn);
              },
              // Keep pipe for back-compat
              pipe: function() {
                var fns = arguments;
                return jQuery4.Deferred(function(newDefer) {
                  jQuery4.each(tuples, function(_i, tuple) {
                    var fn = isFunction3(fns[tuple[4]]) && fns[tuple[4]];
                    deferred[tuple[1]](function() {
                      var returned = fn && fn.apply(this, arguments);
                      if (returned && isFunction3(returned.promise)) {
                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                      } else {
                        newDefer[tuple[0] + "With"](
                          this,
                          fn ? [returned] : arguments
                        );
                      }
                    });
                  });
                  fns = null;
                }).promise();
              },
              then: function(onFulfilled, onRejected, onProgress) {
                var maxDepth = 0;
                function resolve2(depth, deferred2, handler, special) {
                  return function() {
                    var that = this, args = arguments, mightThrow = function() {
                      var returned, then;
                      if (depth < maxDepth) {
                        return;
                      }
                      returned = handler.apply(that, args);
                      if (returned === deferred2.promise()) {
                        throw new TypeError("Thenable self-resolution");
                      }
                      then = returned && // Support: Promises/A+ section 2.3.4
                      // https://promisesaplus.com/#point-64
                      // Only check objects and functions for thenability
                      (typeof returned === "object" || typeof returned === "function") && returned.then;
                      if (isFunction3(then)) {
                        if (special) {
                          then.call(
                            returned,
                            resolve2(maxDepth, deferred2, Identity, special),
                            resolve2(maxDepth, deferred2, Thrower, special)
                          );
                        } else {
                          maxDepth++;
                          then.call(
                            returned,
                            resolve2(maxDepth, deferred2, Identity, special),
                            resolve2(maxDepth, deferred2, Thrower, special),
                            resolve2(
                              maxDepth,
                              deferred2,
                              Identity,
                              deferred2.notifyWith
                            )
                          );
                        }
                      } else {
                        if (handler !== Identity) {
                          that = void 0;
                          args = [returned];
                        }
                        (special || deferred2.resolveWith)(that, args);
                      }
                    }, process2 = special ? mightThrow : function() {
                      try {
                        mightThrow();
                      } catch (e) {
                        if (jQuery4.Deferred.exceptionHook) {
                          jQuery4.Deferred.exceptionHook(
                            e,
                            process2.error
                          );
                        }
                        if (depth + 1 >= maxDepth) {
                          if (handler !== Thrower) {
                            that = void 0;
                            args = [e];
                          }
                          deferred2.rejectWith(that, args);
                        }
                      }
                    };
                    if (depth) {
                      process2();
                    } else {
                      if (jQuery4.Deferred.getErrorHook) {
                        process2.error = jQuery4.Deferred.getErrorHook();
                      } else if (jQuery4.Deferred.getStackHook) {
                        process2.error = jQuery4.Deferred.getStackHook();
                      }
                      window2.setTimeout(process2);
                    }
                  };
                }
                return jQuery4.Deferred(function(newDefer) {
                  tuples[0][3].add(
                    resolve2(
                      0,
                      newDefer,
                      isFunction3(onProgress) ? onProgress : Identity,
                      newDefer.notifyWith
                    )
                  );
                  tuples[1][3].add(
                    resolve2(
                      0,
                      newDefer,
                      isFunction3(onFulfilled) ? onFulfilled : Identity
                    )
                  );
                  tuples[2][3].add(
                    resolve2(
                      0,
                      newDefer,
                      isFunction3(onRejected) ? onRejected : Thrower
                    )
                  );
                }).promise();
              },
              // Get a promise for this deferred
              // If obj is provided, the promise aspect is added to the object
              promise: function(obj) {
                return obj != null ? jQuery4.extend(obj, promise) : promise;
              }
            }, deferred = {};
            jQuery4.each(tuples, function(i, tuple) {
              var list = tuple[2], stateString = tuple[5];
              promise[tuple[1]] = list.add;
              if (stateString) {
                list.add(
                  function() {
                    state = stateString;
                  },
                  // rejected_callbacks.disable
                  // fulfilled_callbacks.disable
                  tuples[3 - i][2].disable,
                  // rejected_handlers.disable
                  // fulfilled_handlers.disable
                  tuples[3 - i][3].disable,
                  // progress_callbacks.lock
                  tuples[0][2].lock,
                  // progress_handlers.lock
                  tuples[0][3].lock
                );
              }
              list.add(tuple[3].fire);
              deferred[tuple[0]] = function() {
                deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
                return this;
              };
              deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
              func.call(deferred, deferred);
            }
            return deferred;
          },
          // Deferred helper
          when: function(singleValue) {
            var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), primary = jQuery4.Deferred(), updateFunc = function(i2) {
              return function(value) {
                resolveContexts[i2] = this;
                resolveValues[i2] = arguments.length > 1 ? slice.call(arguments) : value;
                if (!--remaining) {
                  primary.resolveWith(resolveContexts, resolveValues);
                }
              };
            };
            if (remaining <= 1) {
              adoptValue(
                singleValue,
                primary.done(updateFunc(i)).resolve,
                primary.reject,
                !remaining
              );
              if (primary.state() === "pending" || isFunction3(resolveValues[i] && resolveValues[i].then)) {
                return primary.then();
              }
            }
            while (i--) {
              adoptValue(resolveValues[i], updateFunc(i), primary.reject);
            }
            return primary.promise();
          }
        });
        var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        jQuery4.Deferred.exceptionHook = function(error2, asyncError) {
          if (window2.console && window2.console.warn && error2 && rerrorNames.test(error2.name)) {
            window2.console.warn(
              "jQuery.Deferred exception: " + error2.message,
              error2.stack,
              asyncError
            );
          }
        };
        jQuery4.readyException = function(error2) {
          window2.setTimeout(function() {
            throw error2;
          });
        };
        var readyList = jQuery4.Deferred();
        jQuery4.fn.ready = function(fn) {
          readyList.then(fn).catch(function(error2) {
            jQuery4.readyException(error2);
          });
          return this;
        };
        jQuery4.extend({
          // Is the DOM ready to be used? Set to true once it occurs.
          isReady: false,
          // A counter to track how many items to wait for before
          // the ready event fires. See trac-6781
          readyWait: 1,
          // Handle when the DOM is ready
          ready: function(wait) {
            if (wait === true ? --jQuery4.readyWait : jQuery4.isReady) {
              return;
            }
            jQuery4.isReady = true;
            if (wait !== true && --jQuery4.readyWait > 0) {
              return;
            }
            readyList.resolveWith(document2, [jQuery4]);
          }
        });
        jQuery4.ready.then = readyList.then;
        function completed() {
          document2.removeEventListener("DOMContentLoaded", completed);
          window2.removeEventListener("load", completed);
          jQuery4.ready();
        }
        if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
          window2.setTimeout(jQuery4.ready);
        } else {
          document2.addEventListener("DOMContentLoaded", completed);
          window2.addEventListener("load", completed);
        }
        var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
          var i = 0, len = elems.length, bulk = key == null;
          if (toType(key) === "object") {
            chainable = true;
            for (i in key) {
              access(elems, fn, i, key[i], true, emptyGet, raw);
            }
          } else if (value !== void 0) {
            chainable = true;
            if (!isFunction3(value)) {
              raw = true;
            }
            if (bulk) {
              if (raw) {
                fn.call(elems, value);
                fn = null;
              } else {
                bulk = fn;
                fn = function(elem, _key, value2) {
                  return bulk.call(jQuery4(elem), value2);
                };
              }
            }
            if (fn) {
              for (; i < len; i++) {
                fn(
                  elems[i],
                  key,
                  raw ? value : value.call(elems[i], i, fn(elems[i], key))
                );
              }
            }
          }
          if (chainable) {
            return elems;
          }
          if (bulk) {
            return fn.call(elems);
          }
          return len ? fn(elems[0], key) : emptyGet;
        };
        var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
        function fcamelCase(_all, letter) {
          return letter.toUpperCase();
        }
        function camelCase(string) {
          return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        }
        var acceptData = function(owner) {
          return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
        };
        function Data() {
          this.expando = jQuery4.expando + Data.uid++;
        }
        Data.uid = 1;
        Data.prototype = {
          cache: function(owner) {
            var value = owner[this.expando];
            if (!value) {
              value = {};
              if (acceptData(owner)) {
                if (owner.nodeType) {
                  owner[this.expando] = value;
                } else {
                  Object.defineProperty(owner, this.expando, {
                    value,
                    configurable: true
                  });
                }
              }
            }
            return value;
          },
          set: function(owner, data, value) {
            var prop, cache2 = this.cache(owner);
            if (typeof data === "string") {
              cache2[camelCase(data)] = value;
            } else {
              for (prop in data) {
                cache2[camelCase(prop)] = data[prop];
              }
            }
            return cache2;
          },
          get: function(owner, key) {
            return key === void 0 ? this.cache(owner) : (
              // Always use camelCase key (gh-2257)
              owner[this.expando] && owner[this.expando][camelCase(key)]
            );
          },
          access: function(owner, key, value) {
            if (key === void 0 || key && typeof key === "string" && value === void 0) {
              return this.get(owner, key);
            }
            this.set(owner, key, value);
            return value !== void 0 ? value : key;
          },
          remove: function(owner, key) {
            var i, cache2 = owner[this.expando];
            if (cache2 === void 0) {
              return;
            }
            if (key !== void 0) {
              if (Array.isArray(key)) {
                key = key.map(camelCase);
              } else {
                key = camelCase(key);
                key = key in cache2 ? [key] : key.match(rnothtmlwhite) || [];
              }
              i = key.length;
              while (i--) {
                delete cache2[key[i]];
              }
            }
            if (key === void 0 || jQuery4.isEmptyObject(cache2)) {
              if (owner.nodeType) {
                owner[this.expando] = void 0;
              } else {
                delete owner[this.expando];
              }
            }
          },
          hasData: function(owner) {
            var cache2 = owner[this.expando];
            return cache2 !== void 0 && !jQuery4.isEmptyObject(cache2);
          }
        };
        var dataPriv = new Data();
        var dataUser = new Data();
        var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
        function getData(data) {
          if (data === "true") {
            return true;
          }
          if (data === "false") {
            return false;
          }
          if (data === "null") {
            return null;
          }
          if (data === +data + "") {
            return +data;
          }
          if (rbrace.test(data)) {
            return JSON.parse(data);
          }
          return data;
        }
        function dataAttr(elem, key, data) {
          var name;
          if (data === void 0 && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
              try {
                data = getData(data);
              } catch (e) {
              }
              dataUser.set(elem, key, data);
            } else {
              data = void 0;
            }
          }
          return data;
        }
        jQuery4.extend({
          hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
          },
          data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
          },
          removeData: function(elem, name) {
            dataUser.remove(elem, name);
          },
          // TODO: Now that all calls to _data and _removeData have been replaced
          // with direct calls to dataPriv methods, these can be deprecated.
          _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
          },
          _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
          }
        });
        jQuery4.fn.extend({
          data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === void 0) {
              if (this.length) {
                data = dataUser.get(elem);
                if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                  i = attrs.length;
                  while (i--) {
                    if (attrs[i]) {
                      name = attrs[i].name;
                      if (name.indexOf("data-") === 0) {
                        name = camelCase(name.slice(5));
                        dataAttr(elem, name, data[name]);
                      }
                    }
                  }
                  dataPriv.set(elem, "hasDataAttrs", true);
                }
              }
              return data;
            }
            if (typeof key === "object") {
              return this.each(function() {
                dataUser.set(this, key);
              });
            }
            return access(this, function(value2) {
              var data2;
              if (elem && value2 === void 0) {
                data2 = dataUser.get(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                data2 = dataAttr(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                return;
              }
              this.each(function() {
                dataUser.set(this, key, value2);
              });
            }, null, value, arguments.length > 1, null, true);
          },
          removeData: function(key) {
            return this.each(function() {
              dataUser.remove(this, key);
            });
          }
        });
        jQuery4.extend({
          queue: function(elem, type, data) {
            var queue2;
            if (elem) {
              type = (type || "fx") + "queue";
              queue2 = dataPriv.get(elem, type);
              if (data) {
                if (!queue2 || Array.isArray(data)) {
                  queue2 = dataPriv.access(elem, type, jQuery4.makeArray(data));
                } else {
                  queue2.push(data);
                }
              }
              return queue2 || [];
            }
          },
          dequeue: function(elem, type) {
            type = type || "fx";
            var queue2 = jQuery4.queue(elem, type), startLength = queue2.length, fn = queue2.shift(), hooks = jQuery4._queueHooks(elem, type), next = function() {
              jQuery4.dequeue(elem, type);
            };
            if (fn === "inprogress") {
              fn = queue2.shift();
              startLength--;
            }
            if (fn) {
              if (type === "fx") {
                queue2.unshift("inprogress");
              }
              delete hooks.stop;
              fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
              hooks.empty.fire();
            }
          },
          // Not public - generate a queueHooks object, or return the current one
          _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
              empty: jQuery4.Callbacks("once memory").add(function() {
                dataPriv.remove(elem, [type + "queue", key]);
              })
            });
          }
        });
        jQuery4.fn.extend({
          queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
              data = type;
              type = "fx";
              setter--;
            }
            if (arguments.length < setter) {
              return jQuery4.queue(this[0], type);
            }
            return data === void 0 ? this : this.each(function() {
              var queue2 = jQuery4.queue(this, type, data);
              jQuery4._queueHooks(this, type);
              if (type === "fx" && queue2[0] !== "inprogress") {
                jQuery4.dequeue(this, type);
              }
            });
          },
          dequeue: function(type) {
            return this.each(function() {
              jQuery4.dequeue(this, type);
            });
          },
          clearQueue: function(type) {
            return this.queue(type || "fx", []);
          },
          // Get a promise resolved when queues of a certain type
          // are emptied (fx is the type by default)
          promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery4.Deferred(), elements = this, i = this.length, resolve2 = function() {
              if (!--count) {
                defer.resolveWith(elements, [elements]);
              }
            };
            if (typeof type !== "string") {
              obj = type;
              type = void 0;
            }
            type = type || "fx";
            while (i--) {
              tmp = dataPriv.get(elements[i], type + "queueHooks");
              if (tmp && tmp.empty) {
                count++;
                tmp.empty.add(resolve2);
              }
            }
            resolve2();
            return defer.promise(obj);
          }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
        var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
        var cssExpand = ["Top", "Right", "Bottom", "Left"];
        var documentElement = document2.documentElement;
        var isAttached = function(elem) {
          return jQuery4.contains(elem.ownerDocument, elem);
        }, composed = { composed: true };
        if (documentElement.getRootNode) {
          isAttached = function(elem) {
            return jQuery4.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
          };
        }
        var isHiddenWithinTree = function(elem, el) {
          elem = el || elem;
          return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
          // Support: Firefox <=43 - 45
          // Disconnected elements can have computed display: none, so first confirm that elem is
          // in the document.
          isAttached(elem) && jQuery4.css(elem, "display") === "none";
        };
        function adjustCSS(elem, prop, valueParts, tween) {
          var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
          } : function() {
            return jQuery4.css(elem, prop, "");
          }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery4.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery4.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery4.css(elem, prop));
          if (initialInUnit && initialInUnit[3] !== unit) {
            initial = initial / 2;
            unit = unit || initialInUnit[3];
            initialInUnit = +initial || 1;
            while (maxIterations--) {
              jQuery4.style(elem, prop, initialInUnit + unit);
              if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                maxIterations = 0;
              }
              initialInUnit = initialInUnit / scale;
            }
            initialInUnit = initialInUnit * 2;
            jQuery4.style(elem, prop, initialInUnit + unit);
            valueParts = valueParts || [];
          }
          if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
              tween.unit = unit;
              tween.start = initialInUnit;
              tween.end = adjusted;
            }
          }
          return adjusted;
        }
        var defaultDisplayMap = {};
        function getDefaultDisplay(elem) {
          var temp, doc2 = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
          if (display) {
            return display;
          }
          temp = doc2.body.appendChild(doc2.createElement(nodeName2));
          display = jQuery4.css(temp, "display");
          temp.parentNode.removeChild(temp);
          if (display === "none") {
            display = "block";
          }
          defaultDisplayMap[nodeName2] = display;
          return display;
        }
        function showHide(elements, show) {
          var display, elem, values2 = [], index = 0, length = elements.length;
          for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
              continue;
            }
            display = elem.style.display;
            if (show) {
              if (display === "none") {
                values2[index] = dataPriv.get(elem, "display") || null;
                if (!values2[index]) {
                  elem.style.display = "";
                }
              }
              if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                values2[index] = getDefaultDisplay(elem);
              }
            } else {
              if (display !== "none") {
                values2[index] = "none";
                dataPriv.set(elem, "display", display);
              }
            }
          }
          for (index = 0; index < length; index++) {
            if (values2[index] != null) {
              elements[index].style.display = values2[index];
            }
          }
          return elements;
        }
        jQuery4.fn.extend({
          show: function() {
            return showHide(this, true);
          },
          hide: function() {
            return showHide(this);
          },
          toggle: function(state) {
            if (typeof state === "boolean") {
              return state ? this.show() : this.hide();
            }
            return this.each(function() {
              if (isHiddenWithinTree(this)) {
                jQuery4(this).show();
              } else {
                jQuery4(this).hide();
              }
            });
          }
        });
        var rcheckableType = /^(?:checkbox|radio)$/i;
        var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
        var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
        (function() {
          var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
          input.setAttribute("type", "radio");
          input.setAttribute("checked", "checked");
          input.setAttribute("name", "t");
          div.appendChild(input);
          support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
          div.innerHTML = "<textarea>x</textarea>";
          support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
          div.innerHTML = "<option></option>";
          support.option = !!div.lastChild;
        })();
        var wrapMap = {
          // XHTML parsers do not magically insert elements in the
          // same way that tag soup parsers do. So we cannot shorten
          // this by omitting <tbody> or other required elements.
          thead: [1, "<table>", "</table>"],
          col: [2, "<table><colgroup>", "</colgroup></table>"],
          tr: [2, "<table><tbody>", "</tbody></table>"],
          td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
          _default: [0, "", ""]
        };
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        if (!support.option) {
          wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
        }
        function getAll(context, tag) {
          var ret;
          if (typeof context.getElementsByTagName !== "undefined") {
            ret = context.getElementsByTagName(tag || "*");
          } else if (typeof context.querySelectorAll !== "undefined") {
            ret = context.querySelectorAll(tag || "*");
          } else {
            ret = [];
          }
          if (tag === void 0 || tag && nodeName(context, tag)) {
            return jQuery4.merge([context], ret);
          }
          return ret;
        }
        function setGlobalEval(elems, refElements) {
          var i = 0, l = elems.length;
          for (; i < l; i++) {
            dataPriv.set(
              elems[i],
              "globalEval",
              !refElements || dataPriv.get(refElements[i], "globalEval")
            );
          }
        }
        var rhtml = /<|&#?\w+;/;
        function buildFragment(elems, context, scripts, selection, ignored) {
          var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
          for (; i < l; i++) {
            elem = elems[i];
            if (elem || elem === 0) {
              if (toType(elem) === "object") {
                jQuery4.merge(nodes, elem.nodeType ? [elem] : elem);
              } else if (!rhtml.test(elem)) {
                nodes.push(context.createTextNode(elem));
              } else {
                tmp = tmp || fragment.appendChild(context.createElement("div"));
                tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                wrap = wrapMap[tag] || wrapMap._default;
                tmp.innerHTML = wrap[1] + jQuery4.htmlPrefilter(elem) + wrap[2];
                j = wrap[0];
                while (j--) {
                  tmp = tmp.lastChild;
                }
                jQuery4.merge(nodes, tmp.childNodes);
                tmp = fragment.firstChild;
                tmp.textContent = "";
              }
            }
          }
          fragment.textContent = "";
          i = 0;
          while (elem = nodes[i++]) {
            if (selection && jQuery4.inArray(elem, selection) > -1) {
              if (ignored) {
                ignored.push(elem);
              }
              continue;
            }
            attached = isAttached(elem);
            tmp = getAll(fragment.appendChild(elem), "script");
            if (attached) {
              setGlobalEval(tmp);
            }
            if (scripts) {
              j = 0;
              while (elem = tmp[j++]) {
                if (rscriptType.test(elem.type || "")) {
                  scripts.push(elem);
                }
              }
            }
          }
          return fragment;
        }
        var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
        function returnTrue() {
          return true;
        }
        function returnFalse() {
          return false;
        }
        function on(elem, types, selector, data, fn, one) {
          var origFn, type;
          if (typeof types === "object") {
            if (typeof selector !== "string") {
              data = data || selector;
              selector = void 0;
            }
            for (type in types) {
              on(elem, type, selector, data, types[type], one);
            }
            return elem;
          }
          if (data == null && fn == null) {
            fn = selector;
            data = selector = void 0;
          } else if (fn == null) {
            if (typeof selector === "string") {
              fn = data;
              data = void 0;
            } else {
              fn = data;
              data = selector;
              selector = void 0;
            }
          }
          if (fn === false) {
            fn = returnFalse;
          } else if (!fn) {
            return elem;
          }
          if (one === 1) {
            origFn = fn;
            fn = function(event) {
              jQuery4().off(event);
              return origFn.apply(this, arguments);
            };
            fn.guid = origFn.guid || (origFn.guid = jQuery4.guid++);
          }
          return elem.each(function() {
            jQuery4.event.add(this, types, fn, data, selector);
          });
        }
        jQuery4.event = {
          global: {},
          add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!acceptData(elem)) {
              return;
            }
            if (handler.handler) {
              handleObjIn = handler;
              handler = handleObjIn.handler;
              selector = handleObjIn.selector;
            }
            if (selector) {
              jQuery4.find.matchesSelector(documentElement, selector);
            }
            if (!handler.guid) {
              handler.guid = jQuery4.guid++;
            }
            if (!(events = elemData.events)) {
              events = elemData.events = /* @__PURE__ */ Object.create(null);
            }
            if (!(eventHandle = elemData.handle)) {
              eventHandle = elemData.handle = function(e) {
                return typeof jQuery4 !== "undefined" && jQuery4.event.triggered !== e.type ? jQuery4.event.dispatch.apply(elem, arguments) : void 0;
              };
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t = types.length;
            while (t--) {
              tmp = rtypenamespace.exec(types[t]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                continue;
              }
              special = jQuery4.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              special = jQuery4.event.special[type] || {};
              handleObj = jQuery4.extend({
                type,
                origType,
                data,
                handler,
                guid: handler.guid,
                selector,
                needsContext: selector && jQuery4.expr.match.needsContext.test(selector),
                namespace: namespaces.join(".")
              }, handleObjIn);
              if (!(handlers = events[type])) {
                handlers = events[type] = [];
                handlers.delegateCount = 0;
                if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                  if (elem.addEventListener) {
                    elem.addEventListener(type, eventHandle);
                  }
                }
              }
              if (special.add) {
                special.add.call(elem, handleObj);
                if (!handleObj.handler.guid) {
                  handleObj.handler.guid = handler.guid;
                }
              }
              if (selector) {
                handlers.splice(handlers.delegateCount++, 0, handleObj);
              } else {
                handlers.push(handleObj);
              }
              jQuery4.event.global[type] = true;
            }
          },
          // Detach an event or set of events from an element
          remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
              return;
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t = types.length;
            while (t--) {
              tmp = rtypenamespace.exec(types[t]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                for (type in events) {
                  jQuery4.event.remove(elem, type + types[t], handler, selector, true);
                }
                continue;
              }
              special = jQuery4.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              handlers = events[type] || [];
              tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
              origCount = j = handlers.length;
              while (j--) {
                handleObj = handlers[j];
                if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                  handlers.splice(j, 1);
                  if (handleObj.selector) {
                    handlers.delegateCount--;
                  }
                  if (special.remove) {
                    special.remove.call(elem, handleObj);
                  }
                }
              }
              if (origCount && !handlers.length) {
                if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                  jQuery4.removeEvent(elem, type, elemData.handle);
                }
                delete events[type];
              }
            }
            if (jQuery4.isEmptyObject(events)) {
              dataPriv.remove(elem, "handle events");
            }
          },
          dispatch: function(nativeEvent) {
            var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery4.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery4.event.special[event.type] || {};
            args[0] = event;
            for (i = 1; i < arguments.length; i++) {
              args[i] = arguments[i];
            }
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
              return;
            }
            handlerQueue = jQuery4.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
              event.currentTarget = matched.elem;
              j = 0;
              while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                  event.handleObj = handleObj;
                  event.data = handleObj.data;
                  ret = ((jQuery4.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                  if (ret !== void 0) {
                    if ((event.result = ret) === false) {
                      event.preventDefault();
                      event.stopPropagation();
                    }
                  }
                }
              }
            }
            if (special.postDispatch) {
              special.postDispatch.call(this, event);
            }
            return event.result;
          },
          handlers: function(event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && // Support: IE <=9
            // Black-hole SVG <use> instance trees (trac-13180)
            cur.nodeType && // Support: Firefox <=42
            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
            // Support: IE 11 only
            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
            !(event.type === "click" && event.button >= 1)) {
              for (; cur !== this; cur = cur.parentNode || this) {
                if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                  matchedHandlers = [];
                  matchedSelectors = {};
                  for (i = 0; i < delegateCount; i++) {
                    handleObj = handlers[i];
                    sel = handleObj.selector + " ";
                    if (matchedSelectors[sel] === void 0) {
                      matchedSelectors[sel] = handleObj.needsContext ? jQuery4(sel, this).index(cur) > -1 : jQuery4.find(sel, this, null, [cur]).length;
                    }
                    if (matchedSelectors[sel]) {
                      matchedHandlers.push(handleObj);
                    }
                  }
                  if (matchedHandlers.length) {
                    handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                  }
                }
              }
            }
            cur = this;
            if (delegateCount < handlers.length) {
              handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
            }
            return handlerQueue;
          },
          addProp: function(name, hook) {
            Object.defineProperty(jQuery4.Event.prototype, name, {
              enumerable: true,
              configurable: true,
              get: isFunction3(hook) ? function() {
                if (this.originalEvent) {
                  return hook(this.originalEvent);
                }
              } : function() {
                if (this.originalEvent) {
                  return this.originalEvent[name];
                }
              },
              set: function(value) {
                Object.defineProperty(this, name, {
                  enumerable: true,
                  configurable: true,
                  writable: true,
                  value
                });
              }
            });
          },
          fix: function(originalEvent) {
            return originalEvent[jQuery4.expando] ? originalEvent : new jQuery4.Event(originalEvent);
          },
          special: {
            load: {
              // Prevent triggered image.load events from bubbling to window.load
              noBubble: true
            },
            click: {
              // Utilize native event to ensure correct state for checkable inputs
              setup: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click", true);
                }
                return false;
              },
              trigger: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click");
                }
                return true;
              },
              // For cross-browser consistency, suppress native .click() on links
              // Also prevent it if we're currently inside a leveraged native-event stack
              _default: function(event) {
                var target = event.target;
                return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
              }
            },
            beforeunload: {
              postDispatch: function(event) {
                if (event.result !== void 0 && event.originalEvent) {
                  event.originalEvent.returnValue = event.result;
                }
              }
            }
          }
        };
        function leverageNative(el, type, isSetup) {
          if (!isSetup) {
            if (dataPriv.get(el, type) === void 0) {
              jQuery4.event.add(el, type, returnTrue);
            }
            return;
          }
          dataPriv.set(el, type, false);
          jQuery4.event.add(el, type, {
            namespace: false,
            handler: function(event) {
              var result, saved = dataPriv.get(this, type);
              if (event.isTrigger & 1 && this[type]) {
                if (!saved) {
                  saved = slice.call(arguments);
                  dataPriv.set(this, type, saved);
                  this[type]();
                  result = dataPriv.get(this, type);
                  dataPriv.set(this, type, false);
                  if (saved !== result) {
                    event.stopImmediatePropagation();
                    event.preventDefault();
                    return result;
                  }
                } else if ((jQuery4.event.special[type] || {}).delegateType) {
                  event.stopPropagation();
                }
              } else if (saved) {
                dataPriv.set(this, type, jQuery4.event.trigger(
                  saved[0],
                  saved.slice(1),
                  this
                ));
                event.stopPropagation();
                event.isImmediatePropagationStopped = returnTrue;
              }
            }
          });
        }
        jQuery4.removeEvent = function(elem, type, handle) {
          if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
          }
        };
        jQuery4.Event = function(src, props) {
          if (!(this instanceof jQuery4.Event)) {
            return new jQuery4.Event(src, props);
          }
          if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
            src.returnValue === false ? returnTrue : returnFalse;
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
          } else {
            this.type = src;
          }
          if (props) {
            jQuery4.extend(this, props);
          }
          this.timeStamp = src && src.timeStamp || Date.now();
          this[jQuery4.expando] = true;
        };
        jQuery4.Event.prototype = {
          constructor: jQuery4.Event,
          isDefaultPrevented: returnFalse,
          isPropagationStopped: returnFalse,
          isImmediatePropagationStopped: returnFalse,
          isSimulated: false,
          preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && !this.isSimulated) {
              e.preventDefault();
            }
          },
          stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
              e.stopPropagation();
            }
          },
          stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
              e.stopImmediatePropagation();
            }
            this.stopPropagation();
          }
        };
        jQuery4.each({
          altKey: true,
          bubbles: true,
          cancelable: true,
          changedTouches: true,
          ctrlKey: true,
          detail: true,
          eventPhase: true,
          metaKey: true,
          pageX: true,
          pageY: true,
          shiftKey: true,
          view: true,
          "char": true,
          code: true,
          charCode: true,
          key: true,
          keyCode: true,
          button: true,
          buttons: true,
          clientX: true,
          clientY: true,
          offsetX: true,
          offsetY: true,
          pointerId: true,
          pointerType: true,
          screenX: true,
          screenY: true,
          targetTouches: true,
          toElement: true,
          touches: true,
          which: true
        }, jQuery4.event.addProp);
        jQuery4.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
          function focusMappedHandler(nativeEvent) {
            if (document2.documentMode) {
              var handle = dataPriv.get(this, "handle"), event = jQuery4.event.fix(nativeEvent);
              event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
              event.isSimulated = true;
              handle(nativeEvent);
              if (event.target === event.currentTarget) {
                handle(event);
              }
            } else {
              jQuery4.event.simulate(
                delegateType,
                nativeEvent.target,
                jQuery4.event.fix(nativeEvent)
              );
            }
          }
          jQuery4.event.special[type] = {
            // Utilize native event if possible so blur/focus sequence is correct
            setup: function() {
              var attaches;
              leverageNative(this, type, true);
              if (document2.documentMode) {
                attaches = dataPriv.get(this, delegateType);
                if (!attaches) {
                  this.addEventListener(delegateType, focusMappedHandler);
                }
                dataPriv.set(this, delegateType, (attaches || 0) + 1);
              } else {
                return false;
              }
            },
            trigger: function() {
              leverageNative(this, type);
              return true;
            },
            teardown: function() {
              var attaches;
              if (document2.documentMode) {
                attaches = dataPriv.get(this, delegateType) - 1;
                if (!attaches) {
                  this.removeEventListener(delegateType, focusMappedHandler);
                  dataPriv.remove(this, delegateType);
                } else {
                  dataPriv.set(this, delegateType, attaches);
                }
              } else {
                return false;
              }
            },
            // Suppress native focus or blur if we're currently inside
            // a leveraged native-event stack
            _default: function(event) {
              return dataPriv.get(event.target, type);
            },
            delegateType
          };
          jQuery4.event.special[delegateType] = {
            setup: function() {
              var doc2 = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc2, attaches = dataPriv.get(dataHolder, delegateType);
              if (!attaches) {
                if (document2.documentMode) {
                  this.addEventListener(delegateType, focusMappedHandler);
                } else {
                  doc2.addEventListener(type, focusMappedHandler, true);
                }
              }
              dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
            },
            teardown: function() {
              var doc2 = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc2, attaches = dataPriv.get(dataHolder, delegateType) - 1;
              if (!attaches) {
                if (document2.documentMode) {
                  this.removeEventListener(delegateType, focusMappedHandler);
                } else {
                  doc2.removeEventListener(type, focusMappedHandler, true);
                }
                dataPriv.remove(dataHolder, delegateType);
              } else {
                dataPriv.set(dataHolder, delegateType, attaches);
              }
            }
          };
        });
        jQuery4.each({
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          pointerenter: "pointerover",
          pointerleave: "pointerout"
        }, function(orig, fix) {
          jQuery4.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
              var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
              if (!related || related !== target && !jQuery4.contains(target, related)) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply(this, arguments);
                event.type = fix;
              }
              return ret;
            }
          };
        });
        jQuery4.fn.extend({
          on: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn);
          },
          one: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
          },
          off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
              handleObj = types.handleObj;
              jQuery4(types.delegateTarget).off(
                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
              );
              return this;
            }
            if (typeof types === "object") {
              for (type in types) {
                this.off(type, selector, types[type]);
              }
              return this;
            }
            if (selector === false || typeof selector === "function") {
              fn = selector;
              selector = void 0;
            }
            if (fn === false) {
              fn = returnFalse;
            }
            return this.each(function() {
              jQuery4.event.remove(this, types, fn, selector);
            });
          }
        });
        var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
        function manipulationTarget(elem, content) {
          if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
            return jQuery4(elem).children("tbody")[0] || elem;
          }
          return elem;
        }
        function disableScript(elem) {
          elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
          return elem;
        }
        function restoreScript(elem) {
          if ((elem.type || "").slice(0, 5) === "true/") {
            elem.type = elem.type.slice(5);
          } else {
            elem.removeAttribute("type");
          }
          return elem;
        }
        function cloneCopyEvent(src, dest) {
          var i, l, type, pdataOld, udataOld, udataCur, events;
          if (dest.nodeType !== 1) {
            return;
          }
          if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.get(src);
            events = pdataOld.events;
            if (events) {
              dataPriv.remove(dest, "handle events");
              for (type in events) {
                for (i = 0, l = events[type].length; i < l; i++) {
                  jQuery4.event.add(dest, type, events[type][i]);
                }
              }
            }
          }
          if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery4.extend({}, udataOld);
            dataUser.set(dest, udataCur);
          }
        }
        function fixInput(src, dest) {
          var nodeName2 = dest.nodeName.toLowerCase();
          if (nodeName2 === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
          } else if (nodeName2 === "input" || nodeName2 === "textarea") {
            dest.defaultValue = src.defaultValue;
          }
        }
        function domManip(collection, args, callback, ignored) {
          args = flat(args);
          var fragment, first, scripts, hasScripts, node, doc2, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction3(value);
          if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
            return collection.each(function(index) {
              var self2 = collection.eq(index);
              if (valueIsFunction) {
                args[0] = value.call(this, index, self2.html());
              }
              domManip(self2, args, callback, ignored);
            });
          }
          if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
              fragment = first;
            }
            if (first || ignored) {
              scripts = jQuery4.map(getAll(fragment, "script"), disableScript);
              hasScripts = scripts.length;
              for (; i < l; i++) {
                node = fragment;
                if (i !== iNoClone) {
                  node = jQuery4.clone(node, true, true);
                  if (hasScripts) {
                    jQuery4.merge(scripts, getAll(node, "script"));
                  }
                }
                callback.call(collection[i], node, i);
              }
              if (hasScripts) {
                doc2 = scripts[scripts.length - 1].ownerDocument;
                jQuery4.map(scripts, restoreScript);
                for (i = 0; i < hasScripts; i++) {
                  node = scripts[i];
                  if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery4.contains(doc2, node)) {
                    if (node.src && (node.type || "").toLowerCase() !== "module") {
                      if (jQuery4._evalUrl && !node.noModule) {
                        jQuery4._evalUrl(node.src, {
                          nonce: node.nonce || node.getAttribute("nonce")
                        }, doc2);
                      }
                    } else {
                      DOMEval(node.textContent.replace(rcleanScript, ""), node, doc2);
                    }
                  }
                }
              }
            }
          }
          return collection;
        }
        function remove2(elem, selector, keepData) {
          var node, nodes = selector ? jQuery4.filter(selector, elem) : elem, i = 0;
          for (; (node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
              jQuery4.cleanData(getAll(node));
            }
            if (node.parentNode) {
              if (keepData && isAttached(node)) {
                setGlobalEval(getAll(node, "script"));
              }
              node.parentNode.removeChild(node);
            }
          }
          return elem;
        }
        jQuery4.extend({
          htmlPrefilter: function(html) {
            return html;
          },
          clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery4.isXMLDoc(elem)) {
              destElements = getAll(clone);
              srcElements = getAll(elem);
              for (i = 0, l = srcElements.length; i < l; i++) {
                fixInput(srcElements[i], destElements[i]);
              }
            }
            if (dataAndEvents) {
              if (deepDataAndEvents) {
                srcElements = srcElements || getAll(elem);
                destElements = destElements || getAll(clone);
                for (i = 0, l = srcElements.length; i < l; i++) {
                  cloneCopyEvent(srcElements[i], destElements[i]);
                }
              } else {
                cloneCopyEvent(elem, clone);
              }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
              setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone;
          },
          cleanData: function(elems) {
            var data, elem, type, special = jQuery4.event.special, i = 0;
            for (; (elem = elems[i]) !== void 0; i++) {
              if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                  if (data.events) {
                    for (type in data.events) {
                      if (special[type]) {
                        jQuery4.event.remove(elem, type);
                      } else {
                        jQuery4.removeEvent(elem, type, data.handle);
                      }
                    }
                  }
                  elem[dataPriv.expando] = void 0;
                }
                if (elem[dataUser.expando]) {
                  elem[dataUser.expando] = void 0;
                }
              }
            }
          }
        });
        jQuery4.fn.extend({
          detach: function(selector) {
            return remove2(this, selector, true);
          },
          remove: function(selector) {
            return remove2(this, selector);
          },
          text: function(value) {
            return access(this, function(value2) {
              return value2 === void 0 ? jQuery4.text(this) : this.empty().each(function() {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                  this.textContent = value2;
                }
              });
            }, null, value, arguments.length);
          },
          append: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.appendChild(elem);
              }
            });
          },
          prepend: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.insertBefore(elem, target.firstChild);
              }
            });
          },
          before: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this);
              }
            });
          },
          after: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this.nextSibling);
              }
            });
          },
          empty: function() {
            var elem, i = 0;
            for (; (elem = this[i]) != null; i++) {
              if (elem.nodeType === 1) {
                jQuery4.cleanData(getAll(elem, false));
                elem.textContent = "";
              }
            }
            return this;
          },
          clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
              return jQuery4.clone(this, dataAndEvents, deepDataAndEvents);
            });
          },
          html: function(value) {
            return access(this, function(value2) {
              var elem = this[0] || {}, i = 0, l = this.length;
              if (value2 === void 0 && elem.nodeType === 1) {
                return elem.innerHTML;
              }
              if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
                value2 = jQuery4.htmlPrefilter(value2);
                try {
                  for (; i < l; i++) {
                    elem = this[i] || {};
                    if (elem.nodeType === 1) {
                      jQuery4.cleanData(getAll(elem, false));
                      elem.innerHTML = value2;
                    }
                  }
                  elem = 0;
                } catch (e) {
                }
              }
              if (elem) {
                this.empty().append(value2);
              }
            }, null, value, arguments.length);
          },
          replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
              var parent = this.parentNode;
              if (jQuery4.inArray(this, ignored) < 0) {
                jQuery4.cleanData(getAll(this));
                if (parent) {
                  parent.replaceChild(elem, this);
                }
              }
            }, ignored);
          }
        });
        jQuery4.each({
          appendTo: "append",
          prependTo: "prepend",
          insertBefore: "before",
          insertAfter: "after",
          replaceAll: "replaceWith"
        }, function(name, original) {
          jQuery4.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery4(selector), last2 = insert.length - 1, i = 0;
            for (; i <= last2; i++) {
              elems = i === last2 ? this : this.clone(true);
              jQuery4(insert[i])[original](elems);
              push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
          };
        });
        var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
        var rcustomProp = /^--/;
        var getStyles = function(elem) {
          var view = elem.ownerDocument.defaultView;
          if (!view || !view.opener) {
            view = window2;
          }
          return view.getComputedStyle(elem);
        };
        var swap = function(elem, options, callback) {
          var ret, name, old = {};
          for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
          }
          ret = callback.call(elem);
          for (name in options) {
            elem.style[name] = old[name];
          }
          return ret;
        };
        var rboxStyle = new RegExp(cssExpand.join("|"), "i");
        (function() {
          function computeStyleTests() {
            if (!div) {
              return;
            }
            container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
            div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div);
            var divStyle = window2.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
            div.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
            div.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
            documentElement.removeChild(container);
            div = null;
          }
          function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
          }
          var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
          if (!div.style) {
            return;
          }
          div.style.backgroundClip = "content-box";
          div.cloneNode(true).style.backgroundClip = "";
          support.clearCloneStyle = div.style.backgroundClip === "content-box";
          jQuery4.extend(support, {
            boxSizingReliable: function() {
              computeStyleTests();
              return boxSizingReliableVal;
            },
            pixelBoxStyles: function() {
              computeStyleTests();
              return pixelBoxStylesVal;
            },
            pixelPosition: function() {
              computeStyleTests();
              return pixelPositionVal;
            },
            reliableMarginLeft: function() {
              computeStyleTests();
              return reliableMarginLeftVal;
            },
            scrollboxSize: function() {
              computeStyleTests();
              return scrollboxSizeVal;
            },
            // Support: IE 9 - 11+, Edge 15 - 18+
            // IE/Edge misreport `getComputedStyle` of table rows with width/height
            // set in CSS while `offset*` properties report correct values.
            // Behavior in IE 9 is more subtle than in newer versions & it passes
            // some versions of this test; make sure not to make it pass there!
            //
            // Support: Firefox 70+
            // Only Firefox includes border widths
            // in computed dimensions. (gh-4529)
            reliableTrDimensions: function() {
              var table, tr, trChild, trStyle;
              if (reliableTrDimensionsVal == null) {
                table = document2.createElement("table");
                tr = document2.createElement("tr");
                trChild = document2.createElement("div");
                table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
                tr.style.cssText = "box-sizing:content-box;border:1px solid";
                tr.style.height = "1px";
                trChild.style.height = "9px";
                trChild.style.display = "block";
                documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
                trStyle = window2.getComputedStyle(tr);
                reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
                documentElement.removeChild(table);
              }
              return reliableTrDimensionsVal;
            }
          });
        })();
        function curCSS(elem, name, computed3) {
          var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style = elem.style;
          computed3 = computed3 || getStyles(elem);
          if (computed3) {
            ret = computed3.getPropertyValue(name) || computed3[name];
            if (isCustomProp && ret) {
              ret = ret.replace(rtrimCSS, "$1") || void 0;
            }
            if (ret === "" && !isAttached(elem)) {
              ret = jQuery4.style(elem, name);
            }
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
              width = style.width;
              minWidth = style.minWidth;
              maxWidth = style.maxWidth;
              style.minWidth = style.maxWidth = style.width = ret;
              ret = computed3.width;
              style.width = width;
              style.minWidth = minWidth;
              style.maxWidth = maxWidth;
            }
          }
          return ret !== void 0 ? (
            // Support: IE <=9 - 11 only
            // IE returns zIndex value as an integer.
            ret + ""
          ) : ret;
        }
        function addGetHookIf(conditionFn, hookFn) {
          return {
            get: function() {
              if (conditionFn()) {
                delete this.get;
                return;
              }
              return (this.get = hookFn).apply(this, arguments);
            }
          };
        }
        var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
        function vendorPropName(name) {
          var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
          while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
              return name;
            }
          }
        }
        function finalPropName(name) {
          var final = jQuery4.cssProps[name] || vendorProps[name];
          if (final) {
            return final;
          }
          if (name in emptyStyle) {
            return name;
          }
          return vendorProps[name] = vendorPropName(name) || name;
        }
        var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
          letterSpacing: "0",
          fontWeight: "400"
        };
        function setPositiveNumber(_elem, value, subtract) {
          var matches2 = rcssNum.exec(value);
          return matches2 ? (
            // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max(0, matches2[2] - (subtract || 0)) + (matches2[3] || "px")
          ) : value;
        }
        function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
          var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
          if (box === (isBorderBox ? "border" : "content")) {
            return 0;
          }
          for (; i < 4; i += 2) {
            if (box === "margin") {
              marginDelta += jQuery4.css(elem, box + cssExpand[i], true, styles);
            }
            if (!isBorderBox) {
              delta += jQuery4.css(elem, "padding" + cssExpand[i], true, styles);
              if (box !== "padding") {
                delta += jQuery4.css(elem, "border" + cssExpand[i] + "Width", true, styles);
              } else {
                extra += jQuery4.css(elem, "border" + cssExpand[i] + "Width", true, styles);
              }
            } else {
              if (box === "content") {
                delta -= jQuery4.css(elem, "padding" + cssExpand[i], true, styles);
              }
              if (box !== "margin") {
                delta -= jQuery4.css(elem, "border" + cssExpand[i] + "Width", true, styles);
              }
            }
          }
          if (!isBorderBox && computedVal >= 0) {
            delta += Math.max(0, Math.ceil(
              elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
              // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
              // Use an explicit zero to avoid NaN (gh-3964)
            )) || 0;
          }
          return delta + marginDelta;
        }
        function getWidthOrHeight(elem, dimension, extra) {
          var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery4.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
          if (rnumnonpx.test(val)) {
            if (!extra) {
              return val;
            }
            val = "auto";
          }
          if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Interestingly, in some cases IE 9 doesn't suffer from this issue.
          !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
          // This happens for inline elements with no explicit setting (gh-3571)
          val === "auto" || // Support: Android <=4.1 - 4.3 only
          // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
          !parseFloat(val) && jQuery4.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
          elem.getClientRects().length) {
            isBorderBox = jQuery4.css(elem, "boxSizing", false, styles) === "border-box";
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) {
              val = elem[offsetProp];
            }
          }
          val = parseFloat(val) || 0;
          return val + boxModelAdjustment(
            elem,
            dimension,
            extra || (isBorderBox ? "border" : "content"),
            valueIsBorderBox,
            styles,
            // Provide the current computed size to request scroll gutter calculation (gh-3589)
            val
          ) + "px";
        }
        jQuery4.extend({
          // Add in style property hooks for overriding the default
          // behavior of getting and setting a style property
          cssHooks: {
            opacity: {
              get: function(elem, computed3) {
                if (computed3) {
                  var ret = curCSS(elem, "opacity");
                  return ret === "" ? "1" : ret;
                }
              }
            }
          },
          // Don't automatically add "px" to these possibly-unitless properties
          cssNumber: {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageSlice: true,
            columnCount: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            gridArea: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnStart: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowStart: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            scale: true,
            widows: true,
            zIndex: true,
            zoom: true,
            // SVG-related
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeMiterlimit: true,
            strokeOpacity: true
          },
          // Add in properties whose names you wish to fix before
          // setting or getting the value
          cssProps: {},
          // Get and set the style property on a DOM Node
          style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
              return;
            }
            var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery4.cssHooks[name] || jQuery4.cssHooks[origName];
            if (value !== void 0) {
              type = typeof value;
              if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                value = adjustCSS(elem, name, ret);
                type = "number";
              }
              if (value == null || value !== value) {
                return;
              }
              if (type === "number" && !isCustomProp) {
                value += ret && ret[3] || (jQuery4.cssNumber[origName] ? "" : "px");
              }
              if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                style[name] = "inherit";
              }
              if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
                if (isCustomProp) {
                  style.setProperty(name, value);
                } else {
                  style[name] = value;
                }
              }
            } else {
              if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
                return ret;
              }
              return style[name];
            }
          },
          css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery4.cssHooks[name] || jQuery4.cssHooks[origName];
            if (hooks && "get" in hooks) {
              val = hooks.get(elem, true, extra);
            }
            if (val === void 0) {
              val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
              val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
              num = parseFloat(val);
              return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
          }
        });
        jQuery4.each(["height", "width"], function(_i, dimension) {
          jQuery4.cssHooks[dimension] = {
            get: function(elem, computed3, extra) {
              if (computed3) {
                return rdisplayswap.test(jQuery4.css(elem, "display")) && // Support: Safari 8+
                // Table columns in Safari have non-zero offsetWidth & zero
                // getBoundingClientRect().width unless display is changed.
                // Support: IE <=11 only
                // Running getBoundingClientRect on a disconnected node
                // in IE throws an error.
                (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                  return getWidthOrHeight(elem, dimension, extra);
                }) : getWidthOrHeight(elem, dimension, extra);
              }
            },
            set: function(elem, value, extra) {
              var matches2, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery4.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
                elem,
                dimension,
                extra,
                isBorderBox,
                styles
              ) : 0;
              if (isBorderBox && scrollboxSizeBuggy) {
                subtract -= Math.ceil(
                  elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
                );
              }
              if (subtract && (matches2 = rcssNum.exec(value)) && (matches2[3] || "px") !== "px") {
                elem.style[dimension] = value;
                value = jQuery4.css(elem, dimension);
              }
              return setPositiveNumber(elem, value, subtract);
            }
          };
        });
        jQuery4.cssHooks.marginLeft = addGetHookIf(
          support.reliableMarginLeft,
          function(elem, computed3) {
            if (computed3) {
              return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
                return elem.getBoundingClientRect().left;
              })) + "px";
            }
          }
        );
        jQuery4.each({
          margin: "",
          padding: "",
          border: "Width"
        }, function(prefix, suffix) {
          jQuery4.cssHooks[prefix + suffix] = {
            expand: function(value) {
              var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
              for (; i < 4; i++) {
                expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
              }
              return expanded;
            }
          };
          if (prefix !== "margin") {
            jQuery4.cssHooks[prefix + suffix].set = setPositiveNumber;
          }
        });
        jQuery4.fn.extend({
          css: function(name, value) {
            return access(this, function(elem, name2, value2) {
              var styles, len, map2 = {}, i = 0;
              if (Array.isArray(name2)) {
                styles = getStyles(elem);
                len = name2.length;
                for (; i < len; i++) {
                  map2[name2[i]] = jQuery4.css(elem, name2[i], false, styles);
                }
                return map2;
              }
              return value2 !== void 0 ? jQuery4.style(elem, name2, value2) : jQuery4.css(elem, name2);
            }, name, value, arguments.length > 1);
          }
        });
        function Tween(elem, options, prop, end, easing) {
          return new Tween.prototype.init(elem, options, prop, end, easing);
        }
        jQuery4.Tween = Tween;
        Tween.prototype = {
          constructor: Tween,
          init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery4.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery4.cssNumber[prop] ? "" : "px");
          },
          cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
          },
          run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
              this.pos = eased = jQuery4.easing[this.easing](
                percent,
                this.options.duration * percent,
                0,
                1,
                this.options.duration
              );
            } else {
              this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
              this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
              hooks.set(this);
            } else {
              Tween.propHooks._default.set(this);
            }
            return this;
          }
        };
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {
          _default: {
            get: function(tween) {
              var result;
              if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                return tween.elem[tween.prop];
              }
              result = jQuery4.css(tween.elem, tween.prop, "");
              return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
              if (jQuery4.fx.step[tween.prop]) {
                jQuery4.fx.step[tween.prop](tween);
              } else if (tween.elem.nodeType === 1 && (jQuery4.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
                jQuery4.style(tween.elem, tween.prop, tween.now + tween.unit);
              } else {
                tween.elem[tween.prop] = tween.now;
              }
            }
          }
        };
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
          set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
              tween.elem[tween.prop] = tween.now;
            }
          }
        };
        jQuery4.easing = {
          linear: function(p2) {
            return p2;
          },
          swing: function(p2) {
            return 0.5 - Math.cos(p2 * Math.PI) / 2;
          },
          _default: "swing"
        };
        jQuery4.fx = Tween.prototype.init;
        jQuery4.fx.step = {};
        var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
        function schedule() {
          if (inProgress) {
            if (document2.hidden === false && window2.requestAnimationFrame) {
              window2.requestAnimationFrame(schedule);
            } else {
              window2.setTimeout(schedule, jQuery4.fx.interval);
            }
            jQuery4.fx.tick();
          }
        }
        function createFxNow() {
          window2.setTimeout(function() {
            fxNow = void 0;
          });
          return fxNow = Date.now();
        }
        function genFx(type, includeWidth) {
          var which, i = 0, attrs = { height: type };
          includeWidth = includeWidth ? 1 : 0;
          for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
          }
          if (includeWidth) {
            attrs.opacity = attrs.width = type;
          }
          return attrs;
        }
        function createTween(value, prop, animation) {
          var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
          for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
              return tween;
            }
          }
        }
        function defaultPrefilter(elem, props, opts) {
          var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
          if (!opts.queue) {
            hooks = jQuery4._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
              hooks.unqueued = 0;
              oldfire = hooks.empty.fire;
              hooks.empty.fire = function() {
                if (!hooks.unqueued) {
                  oldfire();
                }
              };
            }
            hooks.unqueued++;
            anim.always(function() {
              anim.always(function() {
                hooks.unqueued--;
                if (!jQuery4.queue(elem, "fx").length) {
                  hooks.empty.fire();
                }
              });
            });
          }
          for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
              delete props[prop];
              toggle = toggle || value === "toggle";
              if (value === (hidden ? "hide" : "show")) {
                if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                  hidden = true;
                } else {
                  continue;
                }
              }
              orig[prop] = dataShow && dataShow[prop] || jQuery4.style(elem, prop);
            }
          }
          propTween = !jQuery4.isEmptyObject(props);
          if (!propTween && jQuery4.isEmptyObject(orig)) {
            return;
          }
          if (isBox && elem.nodeType === 1) {
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
              restoreDisplay = dataPriv.get(elem, "display");
            }
            display = jQuery4.css(elem, "display");
            if (display === "none") {
              if (restoreDisplay) {
                display = restoreDisplay;
              } else {
                showHide([elem], true);
                restoreDisplay = elem.style.display || restoreDisplay;
                display = jQuery4.css(elem, "display");
                showHide([elem]);
              }
            }
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
              if (jQuery4.css(elem, "float") === "none") {
                if (!propTween) {
                  anim.done(function() {
                    style.display = restoreDisplay;
                  });
                  if (restoreDisplay == null) {
                    display = style.display;
                    restoreDisplay = display === "none" ? "" : display;
                  }
                }
                style.display = "inline-block";
              }
            }
          }
          if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
              style.overflow = opts.overflow[0];
              style.overflowX = opts.overflow[1];
              style.overflowY = opts.overflow[2];
            });
          }
          propTween = false;
          for (prop in orig) {
            if (!propTween) {
              if (dataShow) {
                if ("hidden" in dataShow) {
                  hidden = dataShow.hidden;
                }
              } else {
                dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
              }
              if (toggle) {
                dataShow.hidden = !hidden;
              }
              if (hidden) {
                showHide([elem], true);
              }
              anim.done(function() {
                if (!hidden) {
                  showHide([elem]);
                }
                dataPriv.remove(elem, "fxshow");
                for (prop in orig) {
                  jQuery4.style(elem, prop, orig[prop]);
                }
              });
            }
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
              dataShow[prop] = propTween.start;
              if (hidden) {
                propTween.end = propTween.start;
                propTween.start = 0;
              }
            }
          }
        }
        function propFilter(props, specialEasing) {
          var index, name, easing, value, hooks;
          for (index in props) {
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
              easing = value[1];
              value = props[index] = value[0];
            }
            if (index !== name) {
              props[name] = value;
              delete props[index];
            }
            hooks = jQuery4.cssHooks[name];
            if (hooks && "expand" in hooks) {
              value = hooks.expand(value);
              delete props[name];
              for (index in value) {
                if (!(index in props)) {
                  props[index] = value[index];
                  specialEasing[index] = easing;
                }
              }
            } else {
              specialEasing[name] = easing;
            }
          }
        }
        function Animation(elem, properties, options) {
          var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery4.Deferred().always(function() {
            delete tick.elem;
          }), tick = function() {
            if (stopped) {
              return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
            for (; index2 < length2; index2++) {
              animation.tweens[index2].run(percent);
            }
            deferred.notifyWith(elem, [animation, percent, remaining]);
            if (percent < 1 && length2) {
              return remaining;
            }
            if (!length2) {
              deferred.notifyWith(elem, [animation, 1, 0]);
            }
            deferred.resolveWith(elem, [animation]);
            return false;
          }, animation = deferred.promise({
            elem,
            props: jQuery4.extend({}, properties),
            opts: jQuery4.extend(true, {
              specialEasing: {},
              easing: jQuery4.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
              var tween = jQuery4.Tween(
                elem,
                animation.opts,
                prop,
                end,
                animation.opts.specialEasing[prop] || animation.opts.easing
              );
              animation.tweens.push(tween);
              return tween;
            },
            stop: function(gotoEnd) {
              var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
              if (stopped) {
                return this;
              }
              stopped = true;
              for (; index2 < length2; index2++) {
                animation.tweens[index2].run(1);
              }
              if (gotoEnd) {
                deferred.notifyWith(elem, [animation, 1, 0]);
                deferred.resolveWith(elem, [animation, gotoEnd]);
              } else {
                deferred.rejectWith(elem, [animation, gotoEnd]);
              }
              return this;
            }
          }), props = animation.props;
          propFilter(props, animation.opts.specialEasing);
          for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
              if (isFunction3(result.stop)) {
                jQuery4._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
              }
              return result;
            }
          }
          jQuery4.map(props, createTween, animation);
          if (isFunction3(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
          }
          animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
          jQuery4.fx.timer(
            jQuery4.extend(tick, {
              elem,
              anim: animation,
              queue: animation.opts.queue
            })
          );
          return animation;
        }
        jQuery4.Animation = jQuery4.extend(Animation, {
          tweeners: {
            "*": [function(prop, value) {
              var tween = this.createTween(prop, value);
              adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
              return tween;
            }]
          },
          tweener: function(props, callback) {
            if (isFunction3(props)) {
              callback = props;
              props = ["*"];
            } else {
              props = props.match(rnothtmlwhite);
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
              prop = props[index];
              Animation.tweeners[prop] = Animation.tweeners[prop] || [];
              Animation.tweeners[prop].unshift(callback);
            }
          },
          prefilters: [defaultPrefilter],
          prefilter: function(callback, prepend) {
            if (prepend) {
              Animation.prefilters.unshift(callback);
            } else {
              Animation.prefilters.push(callback);
            }
          }
        });
        jQuery4.speed = function(speed, easing, fn) {
          var opt = speed && typeof speed === "object" ? jQuery4.extend({}, speed) : {
            complete: fn || !fn && easing || isFunction3(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !isFunction3(easing) && easing
          };
          if (jQuery4.fx.off) {
            opt.duration = 0;
          } else {
            if (typeof opt.duration !== "number") {
              if (opt.duration in jQuery4.fx.speeds) {
                opt.duration = jQuery4.fx.speeds[opt.duration];
              } else {
                opt.duration = jQuery4.fx.speeds._default;
              }
            }
          }
          if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
          }
          opt.old = opt.complete;
          opt.complete = function() {
            if (isFunction3(opt.old)) {
              opt.old.call(this);
            }
            if (opt.queue) {
              jQuery4.dequeue(this, opt.queue);
            }
          };
          return opt;
        };
        jQuery4.fn.extend({
          fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
          },
          animate: function(prop, speed, easing, callback) {
            var empty = jQuery4.isEmptyObject(prop), optall = jQuery4.speed(speed, easing, callback), doAnimation = function() {
              var anim = Animation(this, jQuery4.extend({}, prop), optall);
              if (empty || dataPriv.get(this, "finish")) {
                anim.stop(true);
              }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
          },
          stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
              var stop2 = hooks.stop;
              delete hooks.stop;
              stop2(gotoEnd);
            };
            if (typeof type !== "string") {
              gotoEnd = clearQueue;
              clearQueue = type;
              type = void 0;
            }
            if (clearQueue) {
              this.queue(type || "fx", []);
            }
            return this.each(function() {
              var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery4.timers, data = dataPriv.get(this);
              if (index) {
                if (data[index] && data[index].stop) {
                  stopQueue(data[index]);
                }
              } else {
                for (index in data) {
                  if (data[index] && data[index].stop && rrun.test(index)) {
                    stopQueue(data[index]);
                  }
                }
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                  timers[index].anim.stop(gotoEnd);
                  dequeue = false;
                  timers.splice(index, 1);
                }
              }
              if (dequeue || !gotoEnd) {
                jQuery4.dequeue(this, type);
              }
            });
          },
          finish: function(type) {
            if (type !== false) {
              type = type || "fx";
            }
            return this.each(function() {
              var index, data = dataPriv.get(this), queue2 = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery4.timers, length = queue2 ? queue2.length : 0;
              data.finish = true;
              jQuery4.queue(this, type, []);
              if (hooks && hooks.stop) {
                hooks.stop.call(this, true);
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && timers[index].queue === type) {
                  timers[index].anim.stop(true);
                  timers.splice(index, 1);
                }
              }
              for (index = 0; index < length; index++) {
                if (queue2[index] && queue2[index].finish) {
                  queue2[index].finish.call(this);
                }
              }
              delete data.finish;
            });
          }
        });
        jQuery4.each(["toggle", "show", "hide"], function(_i, name) {
          var cssFn = jQuery4.fn[name];
          jQuery4.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
          };
        });
        jQuery4.each({
          slideDown: genFx("show"),
          slideUp: genFx("hide"),
          slideToggle: genFx("toggle"),
          fadeIn: { opacity: "show" },
          fadeOut: { opacity: "hide" },
          fadeToggle: { opacity: "toggle" }
        }, function(name, props) {
          jQuery4.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
          };
        });
        jQuery4.timers = [];
        jQuery4.fx.tick = function() {
          var timer, i = 0, timers = jQuery4.timers;
          fxNow = Date.now();
          for (; i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
              timers.splice(i--, 1);
            }
          }
          if (!timers.length) {
            jQuery4.fx.stop();
          }
          fxNow = void 0;
        };
        jQuery4.fx.timer = function(timer) {
          jQuery4.timers.push(timer);
          jQuery4.fx.start();
        };
        jQuery4.fx.interval = 13;
        jQuery4.fx.start = function() {
          if (inProgress) {
            return;
          }
          inProgress = true;
          schedule();
        };
        jQuery4.fx.stop = function() {
          inProgress = null;
        };
        jQuery4.fx.speeds = {
          slow: 600,
          fast: 200,
          // Default speed
          _default: 400
        };
        jQuery4.fn.delay = function(time, type) {
          time = jQuery4.fx ? jQuery4.fx.speeds[time] || time : time;
          type = type || "fx";
          return this.queue(type, function(next, hooks) {
            var timeout = window2.setTimeout(next, time);
            hooks.stop = function() {
              window2.clearTimeout(timeout);
            };
          });
        };
        (function() {
          var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
          input.type = "checkbox";
          support.checkOn = input.value !== "";
          support.optSelected = opt.selected;
          input = document2.createElement("input");
          input.value = "t";
          input.type = "radio";
          support.radioValue = input.value === "t";
        })();
        var boolHook, attrHandle = jQuery4.expr.attrHandle;
        jQuery4.fn.extend({
          attr: function(name, value) {
            return access(this, jQuery4.attr, name, value, arguments.length > 1);
          },
          removeAttr: function(name) {
            return this.each(function() {
              jQuery4.removeAttr(this, name);
            });
          }
        });
        jQuery4.extend({
          attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (typeof elem.getAttribute === "undefined") {
              return jQuery4.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery4.isXMLDoc(elem)) {
              hooks = jQuery4.attrHooks[name.toLowerCase()] || (jQuery4.expr.match.bool.test(name) ? boolHook : void 0);
            }
            if (value !== void 0) {
              if (value === null) {
                jQuery4.removeAttr(elem, name);
                return;
              }
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              elem.setAttribute(name, value + "");
              return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            ret = jQuery4.find.attr(elem, name);
            return ret == null ? void 0 : ret;
          },
          attrHooks: {
            type: {
              set: function(elem, value) {
                if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                  var val = elem.value;
                  elem.setAttribute("type", value);
                  if (val) {
                    elem.value = val;
                  }
                  return value;
                }
              }
            }
          },
          removeAttr: function(elem, value) {
            var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) {
              while (name = attrNames[i++]) {
                elem.removeAttribute(name);
              }
            }
          }
        });
        boolHook = {
          set: function(elem, value, name) {
            if (value === false) {
              jQuery4.removeAttr(elem, name);
            } else {
              elem.setAttribute(name, name);
            }
            return name;
          }
        };
        jQuery4.each(jQuery4.expr.match.bool.source.match(/\w+/g), function(_i, name) {
          var getter = attrHandle[name] || jQuery4.find.attr;
          attrHandle[name] = function(elem, name2, isXML) {
            var ret, handle, lowercaseName = name2.toLowerCase();
            if (!isXML) {
              handle = attrHandle[lowercaseName];
              attrHandle[lowercaseName] = ret;
              ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
              attrHandle[lowercaseName] = handle;
            }
            return ret;
          };
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
        jQuery4.fn.extend({
          prop: function(name, value) {
            return access(this, jQuery4.prop, name, value, arguments.length > 1);
          },
          removeProp: function(name) {
            return this.each(function() {
              delete this[jQuery4.propFix[name] || name];
            });
          }
        });
        jQuery4.extend({
          prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (nType !== 1 || !jQuery4.isXMLDoc(elem)) {
              name = jQuery4.propFix[name] || name;
              hooks = jQuery4.propHooks[name];
            }
            if (value !== void 0) {
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              return elem[name] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            return elem[name];
          },
          propHooks: {
            tabIndex: {
              get: function(elem) {
                var tabindex = jQuery4.find.attr(elem, "tabindex");
                if (tabindex) {
                  return parseInt(tabindex, 10);
                }
                if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                  return 0;
                }
                return -1;
              }
            }
          },
          propFix: {
            "for": "htmlFor",
            "class": "className"
          }
        });
        if (!support.optSelected) {
          jQuery4.propHooks.selected = {
            get: function(elem) {
              var parent = elem.parentNode;
              if (parent && parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
              return null;
            },
            set: function(elem) {
              var parent = elem.parentNode;
              if (parent) {
                parent.selectedIndex;
                if (parent.parentNode) {
                  parent.parentNode.selectedIndex;
                }
              }
            }
          };
        }
        jQuery4.each([
          "tabIndex",
          "readOnly",
          "maxLength",
          "cellSpacing",
          "cellPadding",
          "rowSpan",
          "colSpan",
          "useMap",
          "frameBorder",
          "contentEditable"
        ], function() {
          jQuery4.propFix[this.toLowerCase()] = this;
        });
        function stripAndCollapse(value) {
          var tokens = value.match(rnothtmlwhite) || [];
          return tokens.join(" ");
        }
        function getClass(elem) {
          return elem.getAttribute && elem.getAttribute("class") || "";
        }
        function classesToArray(value) {
          if (Array.isArray(value)) {
            return value;
          }
          if (typeof value === "string") {
            return value.match(rnothtmlwhite) || [];
          }
          return [];
        }
        jQuery4.fn.extend({
          addClass: function(value) {
            var classNames, cur, curValue, className, i, finalValue;
            if (isFunction3(value)) {
              return this.each(function(j) {
                jQuery4(this).addClass(value.call(this, j, getClass(this)));
              });
            }
            classNames = classesToArray(value);
            if (classNames.length) {
              return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  for (i = 0; i < classNames.length; i++) {
                    className = classNames[i];
                    if (cur.indexOf(" " + className + " ") < 0) {
                      cur += className + " ";
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    this.setAttribute("class", finalValue);
                  }
                }
              });
            }
            return this;
          },
          removeClass: function(value) {
            var classNames, cur, curValue, className, i, finalValue;
            if (isFunction3(value)) {
              return this.each(function(j) {
                jQuery4(this).removeClass(value.call(this, j, getClass(this)));
              });
            }
            if (!arguments.length) {
              return this.attr("class", "");
            }
            classNames = classesToArray(value);
            if (classNames.length) {
              return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  for (i = 0; i < classNames.length; i++) {
                    className = classNames[i];
                    while (cur.indexOf(" " + className + " ") > -1) {
                      cur = cur.replace(" " + className + " ", " ");
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    this.setAttribute("class", finalValue);
                  }
                }
              });
            }
            return this;
          },
          toggleClass: function(value, stateVal) {
            var classNames, className, i, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
            if (isFunction3(value)) {
              return this.each(function(i2) {
                jQuery4(this).toggleClass(
                  value.call(this, i2, getClass(this), stateVal),
                  stateVal
                );
              });
            }
            if (typeof stateVal === "boolean" && isValidValue) {
              return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            classNames = classesToArray(value);
            return this.each(function() {
              if (isValidValue) {
                self2 = jQuery4(this);
                for (i = 0; i < classNames.length; i++) {
                  className = classNames[i];
                  if (self2.hasClass(className)) {
                    self2.removeClass(className);
                  } else {
                    self2.addClass(className);
                  }
                }
              } else if (value === void 0 || type === "boolean") {
                className = getClass(this);
                if (className) {
                  dataPriv.set(this, "__className__", className);
                }
                if (this.setAttribute) {
                  this.setAttribute(
                    "class",
                    className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                  );
                }
              }
            });
          },
          hasClass: function(selector) {
            var className, elem, i = 0;
            className = " " + selector + " ";
            while (elem = this[i++]) {
              if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                return true;
              }
            }
            return false;
          }
        });
        var rreturn = /\r/g;
        jQuery4.fn.extend({
          val: function(value) {
            var hooks, ret, valueIsFunction, elem = this[0];
            if (!arguments.length) {
              if (elem) {
                hooks = jQuery4.valHooks[elem.type] || jQuery4.valHooks[elem.nodeName.toLowerCase()];
                if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                  return ret;
                }
                ret = elem.value;
                if (typeof ret === "string") {
                  return ret.replace(rreturn, "");
                }
                return ret == null ? "" : ret;
              }
              return;
            }
            valueIsFunction = isFunction3(value);
            return this.each(function(i) {
              var val;
              if (this.nodeType !== 1) {
                return;
              }
              if (valueIsFunction) {
                val = value.call(this, i, jQuery4(this).val());
              } else {
                val = value;
              }
              if (val == null) {
                val = "";
              } else if (typeof val === "number") {
                val += "";
              } else if (Array.isArray(val)) {
                val = jQuery4.map(val, function(value2) {
                  return value2 == null ? "" : value2 + "";
                });
              }
              hooks = jQuery4.valHooks[this.type] || jQuery4.valHooks[this.nodeName.toLowerCase()];
              if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
                this.value = val;
              }
            });
          }
        });
        jQuery4.extend({
          valHooks: {
            option: {
              get: function(elem) {
                var val = jQuery4.find.attr(elem, "value");
                return val != null ? val : (
                  // Support: IE <=10 - 11 only
                  // option.text throws exceptions (trac-14686, trac-14858)
                  // Strip and collapse whitespace
                  // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                  stripAndCollapse(jQuery4.text(elem))
                );
              }
            },
            select: {
              get: function(elem) {
                var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values2 = one ? null : [], max = one ? index + 1 : options.length;
                if (index < 0) {
                  i = max;
                } else {
                  i = one ? index : 0;
                }
                for (; i < max; i++) {
                  option = options[i];
                  if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
                  !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                    value = jQuery4(option).val();
                    if (one) {
                      return value;
                    }
                    values2.push(value);
                  }
                }
                return values2;
              },
              set: function(elem, value) {
                var optionSet, option, options = elem.options, values2 = jQuery4.makeArray(value), i = options.length;
                while (i--) {
                  option = options[i];
                  if (option.selected = jQuery4.inArray(jQuery4.valHooks.option.get(option), values2) > -1) {
                    optionSet = true;
                  }
                }
                if (!optionSet) {
                  elem.selectedIndex = -1;
                }
                return values2;
              }
            }
          }
        });
        jQuery4.each(["radio", "checkbox"], function() {
          jQuery4.valHooks[this] = {
            set: function(elem, value) {
              if (Array.isArray(value)) {
                return elem.checked = jQuery4.inArray(jQuery4(elem).val(), value) > -1;
              }
            }
          };
          if (!support.checkOn) {
            jQuery4.valHooks[this].get = function(elem) {
              return elem.getAttribute("value") === null ? "on" : elem.value;
            };
          }
        });
        var location2 = window2.location;
        var nonce = { guid: Date.now() };
        var rquery = /\?/;
        jQuery4.parseXML = function(data) {
          var xml, parserErrorElem;
          if (!data || typeof data !== "string") {
            return null;
          }
          try {
            xml = new window2.DOMParser().parseFromString(data, "text/xml");
          } catch (e) {
          }
          parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
          if (!xml || parserErrorElem) {
            jQuery4.error("Invalid XML: " + (parserErrorElem ? jQuery4.map(parserErrorElem.childNodes, function(el) {
              return el.textContent;
            }).join("\n") : data));
          }
          return xml;
        };
        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
          e.stopPropagation();
        };
        jQuery4.extend(jQuery4.event, {
          trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn2.call(event, "type") ? event.type : event, namespaces = hasOwn2.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = lastElement = tmp = elem = elem || document2;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
              return;
            }
            if (rfocusMorph.test(type + jQuery4.event.triggered)) {
              return;
            }
            if (type.indexOf(".") > -1) {
              namespaces = type.split(".");
              type = namespaces.shift();
              namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery4.expando] ? event : new jQuery4.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = void 0;
            if (!event.target) {
              event.target = elem;
            }
            data = data == null ? [event] : jQuery4.makeArray(data, [event]);
            special = jQuery4.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
              return;
            }
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
              bubbleType = special.delegateType || type;
              if (!rfocusMorph.test(bubbleType + type)) {
                cur = cur.parentNode;
              }
              for (; cur; cur = cur.parentNode) {
                eventPath.push(cur);
                tmp = cur;
              }
              if (tmp === (elem.ownerDocument || document2)) {
                eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
              }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
              lastElement = cur;
              event.type = i > 1 ? bubbleType : special.bindType || type;
              handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
              if (handle) {
                handle.apply(cur, data);
              }
              handle = ontype && cur[ontype];
              if (handle && handle.apply && acceptData(cur)) {
                event.result = handle.apply(cur, data);
                if (event.result === false) {
                  event.preventDefault();
                }
              }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
              if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                if (ontype && isFunction3(elem[type]) && !isWindow(elem)) {
                  tmp = elem[ontype];
                  if (tmp) {
                    elem[ontype] = null;
                  }
                  jQuery4.event.triggered = type;
                  if (event.isPropagationStopped()) {
                    lastElement.addEventListener(type, stopPropagationCallback);
                  }
                  elem[type]();
                  if (event.isPropagationStopped()) {
                    lastElement.removeEventListener(type, stopPropagationCallback);
                  }
                  jQuery4.event.triggered = void 0;
                  if (tmp) {
                    elem[ontype] = tmp;
                  }
                }
              }
            }
            return event.result;
          },
          // Piggyback on a donor event to simulate a different one
          // Used only for `focus(in | out)` events
          simulate: function(type, elem, event) {
            var e = jQuery4.extend(
              new jQuery4.Event(),
              event,
              {
                type,
                isSimulated: true
              }
            );
            jQuery4.event.trigger(e, null, elem);
          }
        });
        jQuery4.fn.extend({
          trigger: function(type, data) {
            return this.each(function() {
              jQuery4.event.trigger(type, data, this);
            });
          },
          triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
              return jQuery4.event.trigger(type, data, elem, true);
            }
          }
        });
        var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        function buildParams(prefix, obj, traditional, add3) {
          var name;
          if (Array.isArray(obj)) {
            jQuery4.each(obj, function(i, v) {
              if (traditional || rbracket.test(prefix)) {
                add3(prefix, v);
              } else {
                buildParams(
                  prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
                  v,
                  traditional,
                  add3
                );
              }
            });
          } else if (!traditional && toType(obj) === "object") {
            for (name in obj) {
              buildParams(prefix + "[" + name + "]", obj[name], traditional, add3);
            }
          } else {
            add3(prefix, obj);
          }
        }
        jQuery4.param = function(a, traditional) {
          var prefix, s = [], add3 = function(key, valueOrFunction) {
            var value = isFunction3(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
          };
          if (a == null) {
            return "";
          }
          if (Array.isArray(a) || a.jquery && !jQuery4.isPlainObject(a)) {
            jQuery4.each(a, function() {
              add3(this.name, this.value);
            });
          } else {
            for (prefix in a) {
              buildParams(prefix, a[prefix], traditional, add3);
            }
          }
          return s.join("&");
        };
        jQuery4.fn.extend({
          serialize: function() {
            return jQuery4.param(this.serializeArray());
          },
          serializeArray: function() {
            return this.map(function() {
              var elements = jQuery4.prop(this, "elements");
              return elements ? jQuery4.makeArray(elements) : this;
            }).filter(function() {
              var type = this.type;
              return this.name && !jQuery4(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(_i, elem) {
              var val = jQuery4(this).val();
              if (val == null) {
                return null;
              }
              if (Array.isArray(val)) {
                return jQuery4.map(val, function(val2) {
                  return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
                });
              }
              return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            }).get();
          }
        });
        var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
        originAnchor.href = location2.href;
        function addToPrefiltersOrTransports(structure) {
          return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
              func = dataTypeExpression;
              dataTypeExpression = "*";
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (isFunction3(func)) {
              while (dataType = dataTypes[i++]) {
                if (dataType[0] === "+") {
                  dataType = dataType.slice(1) || "*";
                  (structure[dataType] = structure[dataType] || []).unshift(func);
                } else {
                  (structure[dataType] = structure[dataType] || []).push(func);
                }
              }
            }
          };
        }
        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
          var inspected = {}, seekingTransport = structure === transports;
          function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery4.each(structure[dataType] || [], function(_2, prefilterOrFactory) {
              var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
              if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                options.dataTypes.unshift(dataTypeOrTransport);
                inspect(dataTypeOrTransport);
                return false;
              } else if (seekingTransport) {
                return !(selected = dataTypeOrTransport);
              }
            });
            return selected;
          }
          return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
        }
        function ajaxExtend(target, src) {
          var key, deep, flatOptions = jQuery4.ajaxSettings.flatOptions || {};
          for (key in src) {
            if (src[key] !== void 0) {
              (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
          }
          if (deep) {
            jQuery4.extend(true, target, deep);
          }
          return target;
        }
        function ajaxHandleResponses(s, jqXHR, responses) {
          var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
          while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === void 0) {
              ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
          }
          if (ct) {
            for (type in contents) {
              if (contents[type] && contents[type].test(ct)) {
                dataTypes.unshift(type);
                break;
              }
            }
          }
          if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
          } else {
            for (type in responses) {
              if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                finalDataType = type;
                break;
              }
              if (!firstDataType) {
                firstDataType = type;
              }
            }
            finalDataType = finalDataType || firstDataType;
          }
          if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
              dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
          }
        }
        function ajaxConvert(s, response, jqXHR, isSuccess) {
          var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
          if (dataTypes[1]) {
            for (conv in s.converters) {
              converters[conv.toLowerCase()] = s.converters[conv];
            }
          }
          current = dataTypes.shift();
          while (current) {
            if (s.responseFields[current]) {
              jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
              response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
              if (current === "*") {
                current = prev;
              } else if (prev !== "*" && prev !== current) {
                conv = converters[prev + " " + current] || converters["* " + current];
                if (!conv) {
                  for (conv2 in converters) {
                    tmp = conv2.split(" ");
                    if (tmp[1] === current) {
                      conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                      if (conv) {
                        if (conv === true) {
                          conv = converters[conv2];
                        } else if (converters[conv2] !== true) {
                          current = tmp[0];
                          dataTypes.unshift(tmp[1]);
                        }
                        break;
                      }
                    }
                  }
                }
                if (conv !== true) {
                  if (conv && s.throws) {
                    response = conv(response);
                  } else {
                    try {
                      response = conv(response);
                    } catch (e) {
                      return {
                        state: "parsererror",
                        error: conv ? e : "No conversion from " + prev + " to " + current
                      };
                    }
                  }
                }
              }
            }
          }
          return { state: "success", data: response };
        }
        jQuery4.extend({
          // Counter for holding the number of active queries
          active: 0,
          // Last-Modified header cache for next request
          lastModified: {},
          etag: {},
          ajaxSettings: {
            url: location2.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location2.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            throws: false,
            traditional: false,
            headers: {},
            */
            accepts: {
              "*": allTypes,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript"
            },
            contents: {
              xml: /\bxml\b/,
              html: /\bhtml/,
              json: /\bjson\b/
            },
            responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON"
            },
            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {
              // Convert anything to text
              "* text": String,
              // Text to html (true = no transformation)
              "text html": true,
              // Evaluate text as a json expression
              "text json": JSON.parse,
              // Parse text as xml
              "text xml": jQuery4.parseXML
            },
            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
              url: true,
              context: true
            }
          },
          // Creates a full fledged settings object into target
          // with both ajaxSettings and settings fields.
          // If target is omitted, writes into ajaxSettings.
          ajaxSetup: function(target, settings) {
            return settings ? (
              // Building a settings object
              ajaxExtend(ajaxExtend(target, jQuery4.ajaxSettings), settings)
            ) : (
              // Extending ajaxSettings
              ajaxExtend(jQuery4.ajaxSettings, target)
            );
          },
          ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
          ajaxTransport: addToPrefiltersOrTransports(transports),
          // Main method
          ajax: function(url, options) {
            if (typeof url === "object") {
              options = url;
              url = void 0;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i, uncached, s = jQuery4.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery4(callbackContext) : jQuery4.event, deferred = jQuery4.Deferred(), completeDeferred = jQuery4.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
              readyState: 0,
              // Builds headers hashtable if needed
              getResponseHeader: function(key) {
                var match;
                if (completed2) {
                  if (!responseHeaders) {
                    responseHeaders = {};
                    while (match = rheaders.exec(responseHeadersString)) {
                      responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                    }
                  }
                  match = responseHeaders[key.toLowerCase() + " "];
                }
                return match == null ? null : match.join(", ");
              },
              // Raw string
              getAllResponseHeaders: function() {
                return completed2 ? responseHeadersString : null;
              },
              // Caches the header
              setRequestHeader: function(name, value) {
                if (completed2 == null) {
                  name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                  requestHeaders[name] = value;
                }
                return this;
              },
              // Overrides response content-type header
              overrideMimeType: function(type) {
                if (completed2 == null) {
                  s.mimeType = type;
                }
                return this;
              },
              // Status-dependent callbacks
              statusCode: function(map2) {
                var code;
                if (map2) {
                  if (completed2) {
                    jqXHR.always(map2[jqXHR.status]);
                  } else {
                    for (code in map2) {
                      statusCode[code] = [statusCode[code], map2[code]];
                    }
                  }
                }
                return this;
              },
              // Cancel the request
              abort: function(statusText) {
                var finalText = statusText || strAbort;
                if (transport) {
                  transport.abort(finalText);
                }
                done(0, finalText);
                return this;
              }
            };
            deferred.promise(jqXHR);
            s.url = ((url || s.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
            if (s.crossDomain == null) {
              urlAnchor = document2.createElement("a");
              try {
                urlAnchor.href = s.url;
                urlAnchor.href = urlAnchor.href;
                s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
              } catch (e) {
                s.crossDomain = true;
              }
            }
            if (s.data && s.processData && typeof s.data !== "string") {
              s.data = jQuery4.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (completed2) {
              return jqXHR;
            }
            fireGlobals = jQuery4.event && s.global;
            if (fireGlobals && jQuery4.active++ === 0) {
              jQuery4.event.trigger("ajaxStart");
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url.replace(rhash, "");
            if (!s.hasContent) {
              uncached = s.url.slice(cacheURL.length);
              if (s.data && (s.processData || typeof s.data === "string")) {
                cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                delete s.data;
              }
              if (s.cache === false) {
                cacheURL = cacheURL.replace(rantiCache, "$1");
                uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
              }
              s.url = cacheURL + uncached;
            } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
              s.data = s.data.replace(r20, "+");
            }
            if (s.ifModified) {
              if (jQuery4.lastModified[cacheURL]) {
                jqXHR.setRequestHeader("If-Modified-Since", jQuery4.lastModified[cacheURL]);
              }
              if (jQuery4.etag[cacheURL]) {
                jqXHR.setRequestHeader("If-None-Match", jQuery4.etag[cacheURL]);
              }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
              jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            jqXHR.setRequestHeader(
              "Accept",
              s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]
            );
            for (i in s.headers) {
              jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed2)) {
              return jqXHR.abort();
            }
            strAbort = "abort";
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
              done(-1, "No Transport");
            } else {
              jqXHR.readyState = 1;
              if (fireGlobals) {
                globalEventContext.trigger("ajaxSend", [jqXHR, s]);
              }
              if (completed2) {
                return jqXHR;
              }
              if (s.async && s.timeout > 0) {
                timeoutTimer = window2.setTimeout(function() {
                  jqXHR.abort("timeout");
                }, s.timeout);
              }
              try {
                completed2 = false;
                transport.send(requestHeaders, done);
              } catch (e) {
                if (completed2) {
                  throw e;
                }
                done(-1, e);
              }
            }
            function done(status, nativeStatusText, responses, headers) {
              var isSuccess, success, error2, response, modified, statusText = nativeStatusText;
              if (completed2) {
                return;
              }
              completed2 = true;
              if (timeoutTimer) {
                window2.clearTimeout(timeoutTimer);
              }
              transport = void 0;
              responseHeadersString = headers || "";
              jqXHR.readyState = status > 0 ? 4 : 0;
              isSuccess = status >= 200 && status < 300 || status === 304;
              if (responses) {
                response = ajaxHandleResponses(s, jqXHR, responses);
              }
              if (!isSuccess && jQuery4.inArray("script", s.dataTypes) > -1 && jQuery4.inArray("json", s.dataTypes) < 0) {
                s.converters["text script"] = function() {
                };
              }
              response = ajaxConvert(s, response, jqXHR, isSuccess);
              if (isSuccess) {
                if (s.ifModified) {
                  modified = jqXHR.getResponseHeader("Last-Modified");
                  if (modified) {
                    jQuery4.lastModified[cacheURL] = modified;
                  }
                  modified = jqXHR.getResponseHeader("etag");
                  if (modified) {
                    jQuery4.etag[cacheURL] = modified;
                  }
                }
                if (status === 204 || s.type === "HEAD") {
                  statusText = "nocontent";
                } else if (status === 304) {
                  statusText = "notmodified";
                } else {
                  statusText = response.state;
                  success = response.data;
                  error2 = response.error;
                  isSuccess = !error2;
                }
              } else {
                error2 = statusText;
                if (status || !statusText) {
                  statusText = "error";
                  if (status < 0) {
                    status = 0;
                  }
                }
              }
              jqXHR.status = status;
              jqXHR.statusText = (nativeStatusText || statusText) + "";
              if (isSuccess) {
                deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
              } else {
                deferred.rejectWith(callbackContext, [jqXHR, statusText, error2]);
              }
              jqXHR.statusCode(statusCode);
              statusCode = void 0;
              if (fireGlobals) {
                globalEventContext.trigger(
                  isSuccess ? "ajaxSuccess" : "ajaxError",
                  [jqXHR, s, isSuccess ? success : error2]
                );
              }
              completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
              if (fireGlobals) {
                globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                if (!--jQuery4.active) {
                  jQuery4.event.trigger("ajaxStop");
                }
              }
            }
            return jqXHR;
          },
          getJSON: function(url, data, callback) {
            return jQuery4.get(url, data, callback, "json");
          },
          getScript: function(url, callback) {
            return jQuery4.get(url, void 0, callback, "script");
          }
        });
        jQuery4.each(["get", "post"], function(_i, method) {
          jQuery4[method] = function(url, data, callback, type) {
            if (isFunction3(data)) {
              type = type || callback;
              callback = data;
              data = void 0;
            }
            return jQuery4.ajax(jQuery4.extend({
              url,
              type: method,
              dataType: type,
              data,
              success: callback
            }, jQuery4.isPlainObject(url) && url));
          };
        });
        jQuery4.ajaxPrefilter(function(s) {
          var i;
          for (i in s.headers) {
            if (i.toLowerCase() === "content-type") {
              s.contentType = s.headers[i] || "";
            }
          }
        });
        jQuery4._evalUrl = function(url, options, doc2) {
          return jQuery4.ajax({
            url,
            // Make this explicit, since user can override this through ajaxSetup (trac-11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            // Only evaluate the response if it is successful (gh-4126)
            // dataFilter is not invoked for failure responses, so using it instead
            // of the default converter is kludgy but it works.
            converters: {
              "text script": function() {
              }
            },
            dataFilter: function(response) {
              jQuery4.globalEval(response, options, doc2);
            }
          });
        };
        jQuery4.fn.extend({
          wrapAll: function(html) {
            var wrap;
            if (this[0]) {
              if (isFunction3(html)) {
                html = html.call(this[0]);
              }
              wrap = jQuery4(html, this[0].ownerDocument).eq(0).clone(true);
              if (this[0].parentNode) {
                wrap.insertBefore(this[0]);
              }
              wrap.map(function() {
                var elem = this;
                while (elem.firstElementChild) {
                  elem = elem.firstElementChild;
                }
                return elem;
              }).append(this);
            }
            return this;
          },
          wrapInner: function(html) {
            if (isFunction3(html)) {
              return this.each(function(i) {
                jQuery4(this).wrapInner(html.call(this, i));
              });
            }
            return this.each(function() {
              var self2 = jQuery4(this), contents = self2.contents();
              if (contents.length) {
                contents.wrapAll(html);
              } else {
                self2.append(html);
              }
            });
          },
          wrap: function(html) {
            var htmlIsFunction = isFunction3(html);
            return this.each(function(i) {
              jQuery4(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
            });
          },
          unwrap: function(selector) {
            this.parent(selector).not("body").each(function() {
              jQuery4(this).replaceWith(this.childNodes);
            });
            return this;
          }
        });
        jQuery4.expr.pseudos.hidden = function(elem) {
          return !jQuery4.expr.pseudos.visible(elem);
        };
        jQuery4.expr.pseudos.visible = function(elem) {
          return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
        };
        jQuery4.ajaxSettings.xhr = function() {
          try {
            return new window2.XMLHttpRequest();
          } catch (e) {
          }
        };
        var xhrSuccessStatus = {
          // File protocol always yields status code 0, assume 200
          0: 200,
          // Support: IE <=9 only
          // trac-1450: sometimes IE returns 1223 when it should be 204
          1223: 204
        }, xhrSupported = jQuery4.ajaxSettings.xhr();
        support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
        support.ajax = xhrSupported = !!xhrSupported;
        jQuery4.ajaxTransport(function(options) {
          var callback, errorCallback;
          if (support.cors || xhrSupported && !options.crossDomain) {
            return {
              send: function(headers, complete) {
                var i, xhr = options.xhr();
                xhr.open(
                  options.type,
                  options.url,
                  options.async,
                  options.username,
                  options.password
                );
                if (options.xhrFields) {
                  for (i in options.xhrFields) {
                    xhr[i] = options.xhrFields[i];
                  }
                }
                if (options.mimeType && xhr.overrideMimeType) {
                  xhr.overrideMimeType(options.mimeType);
                }
                if (!options.crossDomain && !headers["X-Requested-With"]) {
                  headers["X-Requested-With"] = "XMLHttpRequest";
                }
                for (i in headers) {
                  xhr.setRequestHeader(i, headers[i]);
                }
                callback = function(type) {
                  return function() {
                    if (callback) {
                      callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                      if (type === "abort") {
                        xhr.abort();
                      } else if (type === "error") {
                        if (typeof xhr.status !== "number") {
                          complete(0, "error");
                        } else {
                          complete(
                            // File: protocol always yields status 0; see trac-8605, trac-14207
                            xhr.status,
                            xhr.statusText
                          );
                        }
                      } else {
                        complete(
                          xhrSuccessStatus[xhr.status] || xhr.status,
                          xhr.statusText,
                          // Support: IE <=9 only
                          // IE9 has no XHR2 but throws on binary (trac-11426)
                          // For XHR2 non-text, let the caller handle it (gh-2498)
                          (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                          xhr.getAllResponseHeaders()
                        );
                      }
                    }
                  };
                };
                xhr.onload = callback();
                errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                if (xhr.onabort !== void 0) {
                  xhr.onabort = errorCallback;
                } else {
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                      window2.setTimeout(function() {
                        if (callback) {
                          errorCallback();
                        }
                      });
                    }
                  };
                }
                callback = callback("abort");
                try {
                  xhr.send(options.hasContent && options.data || null);
                } catch (e) {
                  if (callback) {
                    throw e;
                  }
                }
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        jQuery4.ajaxPrefilter(function(s) {
          if (s.crossDomain) {
            s.contents.script = false;
          }
        });
        jQuery4.ajaxSetup({
          accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
          },
          contents: {
            script: /\b(?:java|ecma)script\b/
          },
          converters: {
            "text script": function(text) {
              jQuery4.globalEval(text);
              return text;
            }
          }
        });
        jQuery4.ajaxPrefilter("script", function(s) {
          if (s.cache === void 0) {
            s.cache = false;
          }
          if (s.crossDomain) {
            s.type = "GET";
          }
        });
        jQuery4.ajaxTransport("script", function(s) {
          if (s.crossDomain || s.scriptAttrs) {
            var script, callback;
            return {
              send: function(_2, complete) {
                script = jQuery4("<script>").attr(s.scriptAttrs || {}).prop({ charset: s.scriptCharset, src: s.url }).on("load error", callback = function(evt) {
                  script.remove();
                  callback = null;
                  if (evt) {
                    complete(evt.type === "error" ? 404 : 200, evt.type);
                  }
                });
                document2.head.appendChild(script[0]);
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery4.ajaxSetup({
          jsonp: "callback",
          jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery4.expando + "_" + nonce.guid++;
            this[callback] = true;
            return callback;
          }
        });
        jQuery4.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
          var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
          if (jsonProp || s.dataTypes[0] === "jsonp") {
            callbackName = s.jsonpCallback = isFunction3(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
              s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
              s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            s.converters["script json"] = function() {
              if (!responseContainer) {
                jQuery4.error(callbackName + " was not called");
              }
              return responseContainer[0];
            };
            s.dataTypes[0] = "json";
            overwritten = window2[callbackName];
            window2[callbackName] = function() {
              responseContainer = arguments;
            };
            jqXHR.always(function() {
              if (overwritten === void 0) {
                jQuery4(window2).removeProp(callbackName);
              } else {
                window2[callbackName] = overwritten;
              }
              if (s[callbackName]) {
                s.jsonpCallback = originalSettings.jsonpCallback;
                oldCallbacks.push(callbackName);
              }
              if (responseContainer && isFunction3(overwritten)) {
                overwritten(responseContainer[0]);
              }
              responseContainer = overwritten = void 0;
            });
            return "script";
          }
        });
        support.createHTMLDocument = function() {
          var body = document2.implementation.createHTMLDocument("").body;
          body.innerHTML = "<form></form><form></form>";
          return body.childNodes.length === 2;
        }();
        jQuery4.parseHTML = function(data, context, keepScripts) {
          if (typeof data !== "string") {
            return [];
          }
          if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
          }
          var base, parsed, scripts;
          if (!context) {
            if (support.createHTMLDocument) {
              context = document2.implementation.createHTMLDocument("");
              base = context.createElement("base");
              base.href = document2.location.href;
              context.head.appendChild(base);
            } else {
              context = document2;
            }
          }
          parsed = rsingleTag.exec(data);
          scripts = !keepScripts && [];
          if (parsed) {
            return [context.createElement(parsed[1])];
          }
          parsed = buildFragment([data], context, scripts);
          if (scripts && scripts.length) {
            jQuery4(scripts).remove();
          }
          return jQuery4.merge([], parsed.childNodes);
        };
        jQuery4.fn.load = function(url, params, callback) {
          var selector, type, response, self2 = this, off = url.indexOf(" ");
          if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
          }
          if (isFunction3(params)) {
            callback = params;
            params = void 0;
          } else if (params && typeof params === "object") {
            type = "POST";
          }
          if (self2.length > 0) {
            jQuery4.ajax({
              url,
              // If "type" variable is undefined, then "GET" method will be used.
              // Make value of this field explicit since
              // user can override it through ajaxSetup method
              type: type || "GET",
              dataType: "html",
              data: params
            }).done(function(responseText) {
              response = arguments;
              self2.html(selector ? (
                // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery4("<div>").append(jQuery4.parseHTML(responseText)).find(selector)
              ) : (
                // Otherwise use the full result
                responseText
              ));
            }).always(callback && function(jqXHR, status) {
              self2.each(function() {
                callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
              });
            });
          }
          return this;
        };
        jQuery4.expr.pseudos.animated = function(elem) {
          return jQuery4.grep(jQuery4.timers, function(fn) {
            return elem === fn.elem;
          }).length;
        };
        jQuery4.offset = {
          setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery4.css(elem, "position"), curElem = jQuery4(elem), props = {};
            if (position === "static") {
              elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery4.css(elem, "top");
            curCSSLeft = jQuery4.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
              curPosition = curElem.position();
              curTop = curPosition.top;
              curLeft = curPosition.left;
            } else {
              curTop = parseFloat(curCSSTop) || 0;
              curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (isFunction3(options)) {
              options = options.call(elem, i, jQuery4.extend({}, curOffset));
            }
            if (options.top != null) {
              props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
              props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
              options.using.call(elem, props);
            } else {
              curElem.css(props);
            }
          }
        };
        jQuery4.fn.extend({
          // offset() relates an element's border box to the document origin
          offset: function(options) {
            if (arguments.length) {
              return options === void 0 ? this : this.each(function(i) {
                jQuery4.offset.setOffset(this, options, i);
              });
            }
            var rect, win, elem = this[0];
            if (!elem) {
              return;
            }
            if (!elem.getClientRects().length) {
              return { top: 0, left: 0 };
            }
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
              top: rect.top + win.pageYOffset,
              left: rect.left + win.pageXOffset
            };
          },
          // position() relates an element's margin box to its offset parent's padding box
          // This corresponds to the behavior of CSS absolute positioning
          position: function() {
            if (!this[0]) {
              return;
            }
            var offsetParent, offset, doc2, elem = this[0], parentOffset = { top: 0, left: 0 };
            if (jQuery4.css(elem, "position") === "fixed") {
              offset = elem.getBoundingClientRect();
            } else {
              offset = this.offset();
              doc2 = elem.ownerDocument;
              offsetParent = elem.offsetParent || doc2.documentElement;
              while (offsetParent && (offsetParent === doc2.body || offsetParent === doc2.documentElement) && jQuery4.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.parentNode;
              }
              if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                parentOffset = jQuery4(offsetParent).offset();
                parentOffset.top += jQuery4.css(offsetParent, "borderTopWidth", true);
                parentOffset.left += jQuery4.css(offsetParent, "borderLeftWidth", true);
              }
            }
            return {
              top: offset.top - parentOffset.top - jQuery4.css(elem, "marginTop", true),
              left: offset.left - parentOffset.left - jQuery4.css(elem, "marginLeft", true)
            };
          },
          // This method will return documentElement in the following cases:
          // 1) For the element inside the iframe without offsetParent, this method will return
          //    documentElement of the parent window
          // 2) For the hidden or detached element
          // 3) For body or html element, i.e. in case of the html node - it will return itself
          //
          // but those exceptions were never presented as a real life use-cases
          // and might be considered as more preferable results.
          //
          // This logic, however, is not guaranteed and can change at any point in the future
          offsetParent: function() {
            return this.map(function() {
              var offsetParent = this.offsetParent;
              while (offsetParent && jQuery4.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.offsetParent;
              }
              return offsetParent || documentElement;
            });
          }
        });
        jQuery4.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
          var top = "pageYOffset" === prop;
          jQuery4.fn[method] = function(val) {
            return access(this, function(elem, method2, val2) {
              var win;
              if (isWindow(elem)) {
                win = elem;
              } else if (elem.nodeType === 9) {
                win = elem.defaultView;
              }
              if (val2 === void 0) {
                return win ? win[prop] : elem[method2];
              }
              if (win) {
                win.scrollTo(
                  !top ? val2 : win.pageXOffset,
                  top ? val2 : win.pageYOffset
                );
              } else {
                elem[method2] = val2;
              }
            }, method, val, arguments.length);
          };
        });
        jQuery4.each(["top", "left"], function(_i, prop) {
          jQuery4.cssHooks[prop] = addGetHookIf(
            support.pixelPosition,
            function(elem, computed3) {
              if (computed3) {
                computed3 = curCSS(elem, prop);
                return rnumnonpx.test(computed3) ? jQuery4(elem).position()[prop] + "px" : computed3;
              }
            }
          );
        });
        jQuery4.each({ Height: "height", Width: "width" }, function(name, type) {
          jQuery4.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
          }, function(defaultExtra, funcName) {
            jQuery4.fn[funcName] = function(margin, value) {
              var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
              return access(this, function(elem, type2, value2) {
                var doc2;
                if (isWindow(elem)) {
                  return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                }
                if (elem.nodeType === 9) {
                  doc2 = elem.documentElement;
                  return Math.max(
                    elem.body["scroll" + name],
                    doc2["scroll" + name],
                    elem.body["offset" + name],
                    doc2["offset" + name],
                    doc2["client" + name]
                  );
                }
                return value2 === void 0 ? (
                  // Get width or height on the element, requesting but not forcing parseFloat
                  jQuery4.css(elem, type2, extra)
                ) : (
                  // Set width or height on the element
                  jQuery4.style(elem, type2, value2, extra)
                );
              }, type, chainable ? margin : void 0, chainable);
            };
          });
        });
        jQuery4.each([
          "ajaxStart",
          "ajaxStop",
          "ajaxComplete",
          "ajaxError",
          "ajaxSuccess",
          "ajaxSend"
        ], function(_i, type) {
          jQuery4.fn[type] = function(fn) {
            return this.on(type, fn);
          };
        });
        jQuery4.fn.extend({
          bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
          },
          unbind: function(types, fn) {
            return this.off(types, null, fn);
          },
          delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
          },
          undelegate: function(selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
          },
          hover: function(fnOver, fnOut) {
            return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
          }
        });
        jQuery4.each(
          "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
          function(_i, name) {
            jQuery4.fn[name] = function(data, fn) {
              return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
            };
          }
        );
        var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
        jQuery4.proxy = function(fn, context) {
          var tmp, args, proxy;
          if (typeof context === "string") {
            tmp = fn[context];
            context = fn;
            fn = tmp;
          }
          if (!isFunction3(fn)) {
            return void 0;
          }
          args = slice.call(arguments, 2);
          proxy = function() {
            return fn.apply(context || this, args.concat(slice.call(arguments)));
          };
          proxy.guid = fn.guid = fn.guid || jQuery4.guid++;
          return proxy;
        };
        jQuery4.holdReady = function(hold) {
          if (hold) {
            jQuery4.readyWait++;
          } else {
            jQuery4.ready(true);
          }
        };
        jQuery4.isArray = Array.isArray;
        jQuery4.parseJSON = JSON.parse;
        jQuery4.nodeName = nodeName;
        jQuery4.isFunction = isFunction3;
        jQuery4.isWindow = isWindow;
        jQuery4.camelCase = camelCase;
        jQuery4.type = toType;
        jQuery4.now = Date.now;
        jQuery4.isNumeric = function(obj) {
          var type = jQuery4.type(obj);
          return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
          // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
          // subtraction forces infinities to NaN
          !isNaN(obj - parseFloat(obj));
        };
        jQuery4.trim = function(text) {
          return text == null ? "" : (text + "").replace(rtrim, "$1");
        };
        if (typeof define === "function" && define.amd) {
          define("jquery", [], function() {
            return jQuery4;
          });
        }
        var _jQuery = window2.jQuery, _$ = window2.$;
        jQuery4.noConflict = function(deep) {
          if (window2.$ === jQuery4) {
            window2.$ = _$;
          }
          if (deep && window2.jQuery === jQuery4) {
            window2.jQuery = _jQuery;
          }
          return jQuery4;
        };
        if (typeof noGlobal === "undefined") {
          window2.jQuery = window2.$ = jQuery4;
        }
        return jQuery4;
      });
    }
  });

  // node_modules/moment/moment.js
  var require_moment = __commonJS({
    "node_modules/moment/moment.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
      })(exports, function() {
        "use strict";
        var hookCallback;
        function hooks() {
          return hookCallback.apply(null, arguments);
        }
        function setHookCallback(callback) {
          hookCallback = callback;
        }
        function isArray2(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
        }
        function isObject2(input) {
          return input != null && Object.prototype.toString.call(input) === "[object Object]";
        }
        function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }
        function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
          } else {
            var k;
            for (k in obj) {
              if (hasOwnProp(obj, k)) {
                return false;
              }
            }
            return true;
          }
        }
        function isUndefined(input) {
          return input === void 0;
        }
        function isNumber(input) {
          return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
        }
        function isDate2(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
        }
        function map2(arr, fn) {
          var res = [], i, arrLen = arr.length;
          for (i = 0; i < arrLen; ++i) {
            res.push(fn(arr[i], i));
          }
          return res;
        }
        function extend4(a, b) {
          for (var i in b) {
            if (hasOwnProp(b, i)) {
              a[i] = b[i];
            }
          }
          if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
          }
          if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
          }
          return a;
        }
        function createUTC(input, format2, locale2, strict) {
          return createLocalOrUTC(input, format2, locale2, strict, true).utc();
        }
        function defaultParsingFlags() {
          return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
          };
        }
        function getParsingFlags(m) {
          if (m._pf == null) {
            m._pf = defaultParsingFlags();
          }
          return m._pf;
        }
        var some;
        if (Array.prototype.some) {
          some = Array.prototype.some;
        } else {
          some = function(fun) {
            var t = Object(this), len = t.length >>> 0, i;
            for (i = 0; i < len; i++) {
              if (i in t && fun.call(this, t[i], i, t)) {
                return true;
              }
            }
            return false;
          };
        }
        function isValid(m) {
          var flags = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
          if (isNowValid) {
            flags = getParsingFlags(m);
            parsedParts = some.call(flags.parsedDateParts, function(i) {
              return i != null;
            });
            isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict) {
              isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
            }
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
          return m._isValid;
        }
        function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
            extend4(getParsingFlags(m), flags);
          } else {
            getParsingFlags(m).userInvalidated = true;
          }
          return m;
        }
        var momentProperties = hooks.momentProperties = [], updateInProgress = false;
        function copyConfig(to2, from2) {
          var i, prop, val, momentPropertiesLen = momentProperties.length;
          if (!isUndefined(from2._isAMomentObject)) {
            to2._isAMomentObject = from2._isAMomentObject;
          }
          if (!isUndefined(from2._i)) {
            to2._i = from2._i;
          }
          if (!isUndefined(from2._f)) {
            to2._f = from2._f;
          }
          if (!isUndefined(from2._l)) {
            to2._l = from2._l;
          }
          if (!isUndefined(from2._strict)) {
            to2._strict = from2._strict;
          }
          if (!isUndefined(from2._tzm)) {
            to2._tzm = from2._tzm;
          }
          if (!isUndefined(from2._isUTC)) {
            to2._isUTC = from2._isUTC;
          }
          if (!isUndefined(from2._offset)) {
            to2._offset = from2._offset;
          }
          if (!isUndefined(from2._pf)) {
            to2._pf = getParsingFlags(from2);
          }
          if (!isUndefined(from2._locale)) {
            to2._locale = from2._locale;
          }
          if (momentPropertiesLen > 0) {
            for (i = 0; i < momentPropertiesLen; i++) {
              prop = momentProperties[i];
              val = from2[prop];
              if (!isUndefined(val)) {
                to2[prop] = val;
              }
            }
          }
          return to2;
        }
        function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
            this._d = /* @__PURE__ */ new Date(NaN);
          }
          if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
          }
        }
        function isMoment(obj) {
          return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
        }
        function warn3(msg) {
          if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
          }
        }
        function deprecate(msg, fn) {
          var firstTime = true;
          return extend4(function() {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
              var args = [], arg, i, key, argLen = arguments.length;
              for (i = 0; i < argLen; i++) {
                arg = "";
                if (typeof arguments[i] === "object") {
                  arg += "\n[" + i + "] ";
                  for (key in arguments[0]) {
                    if (hasOwnProp(arguments[0], key)) {
                      arg += key + ": " + arguments[0][key] + ", ";
                    }
                  }
                  arg = arg.slice(0, -2);
                } else {
                  arg = arguments[i];
                }
                args.push(arg);
              }
              warn3(
                msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
              );
              firstTime = false;
            }
            return fn.apply(this, arguments);
          }, fn);
        }
        var deprecations = {};
        function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
            warn3(msg);
            deprecations[name] = true;
          }
        }
        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;
        function isFunction3(input) {
          return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
        }
        function set2(config) {
          var prop, i;
          for (i in config) {
            if (hasOwnProp(config, i)) {
              prop = config[i];
              if (isFunction3(prop)) {
                this[i] = prop;
              } else {
                this["_" + i] = prop;
              }
            }
          }
          this._config = config;
          this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
          );
        }
        function mergeConfigs(parentConfig, childConfig) {
          var res = extend4({}, parentConfig), prop;
          for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
              if (isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {
                res[prop] = {};
                extend4(res[prop], parentConfig[prop]);
                extend4(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
              } else {
                delete res[prop];
              }
            }
          }
          for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject2(parentConfig[prop])) {
              res[prop] = extend4({}, res[prop]);
            }
          }
          return res;
        }
        function Locale(config) {
          if (config != null) {
            this.set(config);
          }
        }
        var keys2;
        if (Object.keys) {
          keys2 = Object.keys;
        } else {
          keys2 = function(obj) {
            var i, res = [];
            for (i in obj) {
              if (hasOwnProp(obj, i)) {
                res.push(i);
              }
            }
            return res;
          };
        }
        var defaultCalendar = {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        };
        function calendar(key, mom, now3) {
          var output = this._calendar[key] || this._calendar["sameElse"];
          return isFunction3(output) ? output.call(mom, now3) : output;
        }
        function zeroFill(number, targetLength, forceSign) {
          var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
          return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
        }
        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
        function addFormatToken(token2, padded, ordinal2, callback) {
          var func = callback;
          if (typeof callback === "string") {
            func = function() {
              return this[callback]();
            };
          }
          if (token2) {
            formatTokenFunctions[token2] = func;
          }
          if (padded) {
            formatTokenFunctions[padded[0]] = function() {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
          }
          if (ordinal2) {
            formatTokenFunctions[ordinal2] = function() {
              return this.localeData().ordinal(
                func.apply(this, arguments),
                token2
              );
            };
          }
        }
        function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
          }
          return input.replace(/\\/g, "");
        }
        function makeFormatFunction(format2) {
          var array = format2.match(formattingTokens), i, length;
          for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
              array[i] = formatTokenFunctions[array[i]];
            } else {
              array[i] = removeFormattingTokens(array[i]);
            }
          }
          return function(mom) {
            var output = "", i2;
            for (i2 = 0; i2 < length; i2++) {
              output += isFunction3(array[i2]) ? array[i2].call(mom, format2) : array[i2];
            }
            return output;
          };
        }
        function formatMoment(m, format2) {
          if (!m.isValid()) {
            return m.localeData().invalidDate();
          }
          format2 = expandFormat(format2, m.localeData());
          formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
          return formatFunctions[format2](m);
        }
        function expandFormat(format2, locale2) {
          var i = 5;
          function replaceLongDateFormatTokens(input) {
            return locale2.longDateFormat(input) || input;
          }
          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format2)) {
            format2 = format2.replace(
              localFormattingTokens,
              replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
          }
          return format2;
        }
        var defaultLongDateFormat = {
          LTS: "h:mm:ss A",
          LT: "h:mm A",
          L: "MM/DD/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY h:mm A",
          LLLL: "dddd, MMMM D, YYYY h:mm A"
        };
        function longDateFormat(key) {
          var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
          if (format2 || !formatUpper) {
            return format2;
          }
          this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
            if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
              return tok.slice(1);
            }
            return tok;
          }).join("");
          return this._longDateFormat[key];
        }
        var defaultInvalidDate = "Invalid date";
        function invalidDate() {
          return this._invalidDate;
        }
        var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
        function ordinal(number) {
          return this._ordinal.replace("%d", number);
        }
        var defaultRelativeTime = {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          w: "a week",
          ww: "%d weeks",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        };
        function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction3(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        }
        function pastFuture(diff2, output) {
          var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
          return isFunction3(format2) ? format2(output) : format2.replace(/%s/i, output);
        }
        var aliases = {
          D: "date",
          dates: "date",
          date: "date",
          d: "day",
          days: "day",
          day: "day",
          e: "weekday",
          weekdays: "weekday",
          weekday: "weekday",
          E: "isoWeekday",
          isoweekdays: "isoWeekday",
          isoweekday: "isoWeekday",
          DDD: "dayOfYear",
          dayofyears: "dayOfYear",
          dayofyear: "dayOfYear",
          h: "hour",
          hours: "hour",
          hour: "hour",
          ms: "millisecond",
          milliseconds: "millisecond",
          millisecond: "millisecond",
          m: "minute",
          minutes: "minute",
          minute: "minute",
          M: "month",
          months: "month",
          month: "month",
          Q: "quarter",
          quarters: "quarter",
          quarter: "quarter",
          s: "second",
          seconds: "second",
          second: "second",
          gg: "weekYear",
          weekyears: "weekYear",
          weekyear: "weekYear",
          GG: "isoWeekYear",
          isoweekyears: "isoWeekYear",
          isoweekyear: "isoWeekYear",
          w: "week",
          weeks: "week",
          week: "week",
          W: "isoWeek",
          isoweeks: "isoWeek",
          isoweek: "isoWeek",
          y: "year",
          years: "year",
          year: "year"
        };
        function normalizeUnits(units) {
          return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
        }
        function normalizeObjectUnits(inputObject) {
          var normalizedInput = {}, normalizedProp, prop;
          for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);
              if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
              }
            }
          }
          return normalizedInput;
        }
        var priorities = {
          date: 9,
          day: 11,
          weekday: 11,
          isoWeekday: 11,
          dayOfYear: 4,
          hour: 13,
          millisecond: 16,
          minute: 14,
          month: 8,
          quarter: 7,
          second: 15,
          weekYear: 1,
          isoWeekYear: 1,
          week: 5,
          isoWeek: 5,
          year: 1
        };
        function getPrioritizedUnits(unitsObj) {
          var units = [], u;
          for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
              units.push({ unit: u, priority: priorities[u] });
            }
          }
          units.sort(function(a, b) {
            return a.priority - b.priority;
          });
          return units;
        }
        var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
        regexes = {};
        function addRegexToken(token2, regex, strictRegex) {
          regexes[token2] = isFunction3(regex) ? regex : function(isStrict, localeData2) {
            return isStrict && strictRegex ? strictRegex : regex;
          };
        }
        function getParseRegexForToken(token2, config) {
          if (!hasOwnProp(regexes, token2)) {
            return new RegExp(unescapeFormat(token2));
          }
          return regexes[token2](config._strict, config._locale);
        }
        function unescapeFormat(s) {
          return regexEscape(
            s.replace("\\", "").replace(
              /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
              function(matched, p1, p2, p3, p4) {
                return p1 || p2 || p3 || p4;
              }
            )
          );
        }
        function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        function absFloor(number) {
          if (number < 0) {
            return Math.ceil(number) || 0;
          } else {
            return Math.floor(number);
          }
        }
        function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion, value = 0;
          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
          }
          return value;
        }
        var tokens = {};
        function addParseToken(token2, callback) {
          var i, func = callback, tokenLen;
          if (typeof token2 === "string") {
            token2 = [token2];
          }
          if (isNumber(callback)) {
            func = function(input, array) {
              array[callback] = toInt(input);
            };
          }
          tokenLen = token2.length;
          for (i = 0; i < tokenLen; i++) {
            tokens[token2[i]] = func;
          }
        }
        function addWeekParseToken(token2, callback) {
          addParseToken(token2, function(input, array, config, token3) {
            config._w = config._w || {};
            callback(input, config._w, config, token3);
          });
        }
        function addTimeToArrayFromToken(token2, input, config) {
          if (input != null && hasOwnProp(tokens, token2)) {
            tokens[token2](input, config._a, config, token2);
          }
        }
        function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
        addFormatToken("Y", 0, 0, function() {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : "+" + y;
        });
        addFormatToken(0, ["YY", 2], 0, function() {
          return this.year() % 100;
        });
        addFormatToken(0, ["YYYY", 4], 0, "year");
        addFormatToken(0, ["YYYYY", 5], 0, "year");
        addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
        addRegexToken("Y", matchSigned);
        addRegexToken("YY", match1to2, match2);
        addRegexToken("YYYY", match1to4, match4);
        addRegexToken("YYYYY", match1to6, match6);
        addRegexToken("YYYYYY", match1to6, match6);
        addParseToken(["YYYYY", "YYYYYY"], YEAR);
        addParseToken("YYYY", function(input, array) {
          array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken("YY", function(input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken("Y", function(input, array) {
          array[YEAR] = parseInt(input, 10);
        });
        function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
        }
        hooks.parseTwoDigitYear = function(input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
        };
        var getSetYear = makeGetSet("FullYear", true);
        function getIsLeapYear() {
          return isLeapYear(this.year());
        }
        function makeGetSet(unit, keepTime) {
          return function(value) {
            if (value != null) {
              set$1(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
            } else {
              return get2(this, unit);
            }
          };
        }
        function get2(mom, unit) {
          if (!mom.isValid()) {
            return NaN;
          }
          var d = mom._d, isUTC = mom._isUTC;
          switch (unit) {
            case "Milliseconds":
              return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
            case "Seconds":
              return isUTC ? d.getUTCSeconds() : d.getSeconds();
            case "Minutes":
              return isUTC ? d.getUTCMinutes() : d.getMinutes();
            case "Hours":
              return isUTC ? d.getUTCHours() : d.getHours();
            case "Date":
              return isUTC ? d.getUTCDate() : d.getDate();
            case "Day":
              return isUTC ? d.getUTCDay() : d.getDay();
            case "Month":
              return isUTC ? d.getUTCMonth() : d.getMonth();
            case "FullYear":
              return isUTC ? d.getUTCFullYear() : d.getFullYear();
            default:
              return NaN;
          }
        }
        function set$1(mom, unit, value) {
          var d, isUTC, year, month, date;
          if (!mom.isValid() || isNaN(value)) {
            return;
          }
          d = mom._d;
          isUTC = mom._isUTC;
          switch (unit) {
            case "Milliseconds":
              return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
            case "Seconds":
              return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
            case "Minutes":
              return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
            case "Hours":
              return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
            case "Date":
              return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
            case "FullYear":
              break;
            default:
              return;
          }
          year = value;
          month = mom.month();
          date = mom.date();
          date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
          void (isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date));
        }
        function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction3(this[units])) {
            return this[units]();
          }
          return this;
        }
        function stringSet(units, value) {
          if (typeof units === "object") {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
            for (i = 0; i < prioritizedLen; i++) {
              this[prioritized[i].unit](units[prioritized[i].unit]);
            }
          } else {
            units = normalizeUnits(units);
            if (isFunction3(this[units])) {
              return this[units](value);
            }
          }
          return this;
        }
        function mod(n, x) {
          return (n % x + x) % x;
        }
        var indexOf2;
        if (Array.prototype.indexOf) {
          indexOf2 = Array.prototype.indexOf;
        } else {
          indexOf2 = function(o) {
            var i;
            for (i = 0; i < this.length; ++i) {
              if (this[i] === o) {
                return i;
              }
            }
            return -1;
          };
        }
        function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
            return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
        }
        addFormatToken("M", ["MM", 2], "Mo", function() {
          return this.month() + 1;
        });
        addFormatToken("MMM", 0, 0, function(format2) {
          return this.localeData().monthsShort(this, format2);
        });
        addFormatToken("MMMM", 0, 0, function(format2) {
          return this.localeData().months(this, format2);
        });
        addRegexToken("M", match1to2, match1to2NoLeadingZero);
        addRegexToken("MM", match1to2, match2);
        addRegexToken("MMM", function(isStrict, locale2) {
          return locale2.monthsShortRegex(isStrict);
        });
        addRegexToken("MMMM", function(isStrict, locale2) {
          return locale2.monthsRegex(isStrict);
        });
        addParseToken(["M", "MM"], function(input, array) {
          array[MONTH] = toInt(input) - 1;
        });
        addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
          var month = config._locale.monthsParse(input, token2, config._strict);
          if (month != null) {
            array[MONTH] = month;
          } else {
            getParsingFlags(config).invalidMonth = input;
          }
        });
        var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
          "_"
        ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
        function localeMonths(m, format2) {
          if (!m) {
            return isArray2(this._months) ? this._months : this._months["standalone"];
          }
          return isArray2(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
        }
        function localeMonthsShort(m, format2) {
          if (!m) {
            return isArray2(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
          }
          return isArray2(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
        }
        function handleStrictParse(monthName, format2, strict) {
          var i, ii, mom, llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
              mom = createUTC([2e3, i]);
              this._shortMonthsParse[i] = this.monthsShort(
                mom,
                ""
              ).toLocaleLowerCase();
              this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format2 === "MMM") {
              ii = indexOf2.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf2.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format2 === "MMM") {
              ii = indexOf2.call(this._shortMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf2.call(this._longMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeMonthsParse(monthName, format2, strict) {
          var i, mom, regex;
          if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format2, strict);
          }
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          }
          for (i = 0; i < 12; i++) {
            mom = createUTC([2e3, i]);
            if (strict && !this._longMonthsParse[i]) {
              this._longMonthsParse[i] = new RegExp(
                "^" + this.months(mom, "").replace(".", "") + "$",
                "i"
              );
              this._shortMonthsParse[i] = new RegExp(
                "^" + this.monthsShort(mom, "").replace(".", "") + "$",
                "i"
              );
            }
            if (!strict && !this._monthsParse[i]) {
              regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
              this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
              return i;
            } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
              return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
              return i;
            }
          }
        }
        function setMonth(mom, value) {
          if (!mom.isValid()) {
            return mom;
          }
          if (typeof value === "string") {
            if (/^\d+$/.test(value)) {
              value = toInt(value);
            } else {
              value = mom.localeData().monthsParse(value);
              if (!isNumber(value)) {
                return mom;
              }
            }
          }
          var month = value, date = mom.date();
          date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
          void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
          return mom;
        }
        function getSetMonth(value) {
          if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
          } else {
            return get2(this, "Month");
          }
        }
        function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
        }
        function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsShortStrictRegex;
            } else {
              return this._monthsShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsShortRegex")) {
              this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
          }
        }
        function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsStrictRegex;
            } else {
              return this._monthsRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsRegex")) {
              this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
          }
        }
        function computeMonthsParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
          for (i = 0; i < 12; i++) {
            mom = createUTC([2e3, i]);
            shortP = regexEscape(this.monthsShort(mom, ""));
            longP = regexEscape(this.months(mom, ""));
            shortPieces.push(shortP);
            longPieces.push(longP);
            mixedPieces.push(longP);
            mixedPieces.push(shortP);
          }
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp(
            "^(" + longPieces.join("|") + ")",
            "i"
          );
          this._monthsShortStrictRegex = new RegExp(
            "^(" + shortPieces.join("|") + ")",
            "i"
          );
        }
        function createDate(y, m, d, h2, M, s, ms) {
          var date;
          if (y < 100 && y >= 0) {
            date = new Date(y + 400, m, d, h2, M, s, ms);
            if (isFinite(date.getFullYear())) {
              date.setFullYear(y);
            }
          } else {
            date = new Date(y, m, d, h2, M, s, ms);
          }
          return date;
        }
        function createUTCDate(y) {
          var date, args;
          if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
            }
          } else {
            date = new Date(Date.UTC.apply(null, arguments));
          }
          return date;
        }
        function firstWeekOffset(year, dow, doy) {
          var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        }
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
          if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
          } else {
            resYear = year;
            resDayOfYear = dayOfYear;
          }
          return {
            year: resYear,
            dayOfYear: resDayOfYear
          };
        }
        function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
          if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
          } else {
            resYear = mom.year();
            resWeek = week;
          }
          return {
            week: resWeek,
            year: resYear
          };
        }
        function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }
        addFormatToken("w", ["ww", 2], "wo", "week");
        addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
        addRegexToken("w", match1to2, match1to2NoLeadingZero);
        addRegexToken("ww", match1to2, match2);
        addRegexToken("W", match1to2, match1to2NoLeadingZero);
        addRegexToken("WW", match1to2, match2);
        addWeekParseToken(
          ["w", "ww", "W", "WW"],
          function(input, week, config, token2) {
            week[token2.substr(0, 1)] = toInt(input);
          }
        );
        function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }
        var defaultLocaleWeek = {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        };
        function localeFirstDayOfWeek() {
          return this._week.dow;
        }
        function localeFirstDayOfYear() {
          return this._week.doy;
        }
        function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        addFormatToken("d", 0, "do", "day");
        addFormatToken("dd", 0, 0, function(format2) {
          return this.localeData().weekdaysMin(this, format2);
        });
        addFormatToken("ddd", 0, 0, function(format2) {
          return this.localeData().weekdaysShort(this, format2);
        });
        addFormatToken("dddd", 0, 0, function(format2) {
          return this.localeData().weekdays(this, format2);
        });
        addFormatToken("e", 0, 0, "weekday");
        addFormatToken("E", 0, 0, "isoWeekday");
        addRegexToken("d", match1to2);
        addRegexToken("e", match1to2);
        addRegexToken("E", match1to2);
        addRegexToken("dd", function(isStrict, locale2) {
          return locale2.weekdaysMinRegex(isStrict);
        });
        addRegexToken("ddd", function(isStrict, locale2) {
          return locale2.weekdaysShortRegex(isStrict);
        });
        addRegexToken("dddd", function(isStrict, locale2) {
          return locale2.weekdaysRegex(isStrict);
        });
        addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
          var weekday = config._locale.weekdaysParse(input, token2, config._strict);
          if (weekday != null) {
            week.d = weekday;
          } else {
            getParsingFlags(config).invalidWeekday = input;
          }
        });
        addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
          week[token2] = toInt(input);
        });
        function parseWeekday(input, locale2) {
          if (typeof input !== "string") {
            return input;
          }
          if (!isNaN(input)) {
            return parseInt(input, 10);
          }
          input = locale2.weekdaysParse(input);
          if (typeof input === "number") {
            return input;
          }
          return null;
        }
        function parseIsoWeekday(input, locale2) {
          if (typeof input === "string") {
            return locale2.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
        }
        function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
        }
        var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
        function localeWeekdays(m, format2) {
          var weekdays = isArray2(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
          return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
        }
        function localeWeekdaysShort(m) {
          return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
        }
        function localeWeekdaysMin(m) {
          return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
        }
        function handleStrictParse$1(weekdayName, format2, strict) {
          var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
              mom = createUTC([2e3, 1]).day(i);
              this._minWeekdaysParse[i] = this.weekdaysMin(
                mom,
                ""
              ).toLocaleLowerCase();
              this._shortWeekdaysParse[i] = this.weekdaysShort(
                mom,
                ""
              ).toLocaleLowerCase();
              this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format2 === "dddd") {
              ii = indexOf2.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format2 === "ddd") {
              ii = indexOf2.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf2.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format2 === "dddd") {
              ii = indexOf2.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format2 === "ddd") {
              ii = indexOf2.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf2.call(this._minWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeWeekdaysParse(weekdayName, format2, strict) {
          var i, mom, regex;
          if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format2, strict);
          }
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
          }
          for (i = 0; i < 7; i++) {
            mom = createUTC([2e3, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
              this._fullWeekdaysParse[i] = new RegExp(
                "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
              this._shortWeekdaysParse[i] = new RegExp(
                "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
              this._minWeekdaysParse[i] = new RegExp(
                "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
            }
            if (!this._weekdaysParse[i]) {
              regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
              this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
              return i;
            }
          }
        }
        function getSetDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var day = get2(this, "Day");
          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, "d");
          } else {
            return day;
          }
        }
        function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, "d");
        }
        function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
            return this.day() || 7;
          }
        }
        function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysStrictRegex;
            } else {
              return this._weekdaysRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
          }
        }
        function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysShortStrictRegex;
            } else {
              return this._weekdaysShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysShortRegex")) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
        }
        function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysMinStrictRegex;
            } else {
              return this._weekdaysMinRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysMinRegex")) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
        }
        function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
          for (i = 0; i < 7; i++) {
            mom = createUTC([2e3, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ""));
            shortp = regexEscape(this.weekdaysShort(mom, ""));
            longp = regexEscape(this.weekdays(mom, ""));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
          }
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;
          this._weekdaysStrictRegex = new RegExp(
            "^(" + longPieces.join("|") + ")",
            "i"
          );
          this._weekdaysShortStrictRegex = new RegExp(
            "^(" + shortPieces.join("|") + ")",
            "i"
          );
          this._weekdaysMinStrictRegex = new RegExp(
            "^(" + minPieces.join("|") + ")",
            "i"
          );
        }
        function hFormat() {
          return this.hours() % 12 || 12;
        }
        function kFormat() {
          return this.hours() || 24;
        }
        addFormatToken("H", ["HH", 2], 0, "hour");
        addFormatToken("h", ["hh", 2], 0, hFormat);
        addFormatToken("k", ["kk", 2], 0, kFormat);
        addFormatToken("hmm", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });
        addFormatToken("hmmss", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        addFormatToken("Hmm", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2);
        });
        addFormatToken("Hmmss", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        function meridiem(token2, lowercase) {
          addFormatToken(token2, 0, 0, function() {
            return this.localeData().meridiem(
              this.hours(),
              this.minutes(),
              lowercase
            );
          });
        }
        meridiem("a", true);
        meridiem("A", false);
        function matchMeridiem(isStrict, locale2) {
          return locale2._meridiemParse;
        }
        addRegexToken("a", matchMeridiem);
        addRegexToken("A", matchMeridiem);
        addRegexToken("H", match1to2, match1to2HasZero);
        addRegexToken("h", match1to2, match1to2NoLeadingZero);
        addRegexToken("k", match1to2, match1to2NoLeadingZero);
        addRegexToken("HH", match1to2, match2);
        addRegexToken("hh", match1to2, match2);
        addRegexToken("kk", match1to2, match2);
        addRegexToken("hmm", match3to4);
        addRegexToken("hmmss", match5to6);
        addRegexToken("Hmm", match3to4);
        addRegexToken("Hmmss", match5to6);
        addParseToken(["H", "HH"], HOUR);
        addParseToken(["k", "kk"], function(input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(["a", "A"], function(input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
        });
        addParseToken(["h", "hh"], function(input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmm", function(input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("hmmss", function(input, array, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
        });
        addParseToken("Hmm", function(input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken("Hmmss", function(input, array, config) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
        });
        function localeIsPM(input) {
          return (input + "").toLowerCase().charAt(0) === "p";
        }
        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
        function localeMeridiem(hours2, minutes2, isLower) {
          if (hours2 > 11) {
            return isLower ? "pm" : "PM";
          } else {
            return isLower ? "am" : "AM";
          }
        }
        var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,
          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,
          week: defaultLocaleWeek,
          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,
          meridiemParse: defaultLocaleMeridiemParse
        };
        var locales = {}, localeFamilies = {}, globalLocale;
        function commonPrefix(arr1, arr2) {
          var i, minl = Math.min(arr1.length, arr2.length);
          for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
              return i;
            }
          }
          return minl;
        }
        function normalizeLocale(key) {
          return key ? key.toLowerCase().replace("_", "-") : key;
        }
        function chooseLocale(names) {
          var i = 0, j, next, locale2, split;
          while (i < names.length) {
            split = normalizeLocale(names[i]).split("-");
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
              locale2 = loadLocale(split.slice(0, j).join("-"));
              if (locale2) {
                return locale2;
              }
              if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
                break;
              }
              j--;
            }
            i++;
          }
          return globalLocale;
        }
        function isLocaleNameSane(name) {
          return !!(name && name.match("^[^/\\\\]*$"));
        }
        function loadLocale(name) {
          var oldLocale = null, aliasedRequire;
          if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
            try {
              oldLocale = globalLocale._abbr;
              aliasedRequire = __require;
              aliasedRequire("./locale/" + name);
              getSetGlobalLocale(oldLocale);
            } catch (e) {
              locales[name] = null;
            }
          }
          return locales[name];
        }
        function getSetGlobalLocale(key, values2) {
          var data;
          if (key) {
            if (isUndefined(values2)) {
              data = getLocale(key);
            } else {
              data = defineLocale(key, values2);
            }
            if (data) {
              globalLocale = data;
            } else {
              if (typeof console !== "undefined" && console.warn) {
                console.warn(
                  "Locale " + key + " not found. Did you forget to load it?"
                );
              }
            }
          }
          return globalLocale._abbr;
        }
        function defineLocale(name, config) {
          if (config !== null) {
            var locale2, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
              deprecateSimple(
                "defineLocaleOverride",
                "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
              );
              parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
              if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
              } else {
                locale2 = loadLocale(config.parentLocale);
                if (locale2 != null) {
                  parentConfig = locale2._config;
                } else {
                  if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                  }
                  localeFamilies[config.parentLocale].push({
                    name,
                    config
                  });
                  return null;
                }
              }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            if (localeFamilies[name]) {
              localeFamilies[name].forEach(function(x) {
                defineLocale(x.name, x.config);
              });
            }
            getSetGlobalLocale(name);
            return locales[name];
          } else {
            delete locales[name];
            return null;
          }
        }
        function updateLocale(name, config) {
          if (config != null) {
            var locale2, tmpLocale, parentConfig = baseConfig;
            if (locales[name] != null && locales[name].parentLocale != null) {
              locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              if (tmpLocale == null) {
                config.abbr = name;
              }
              locale2 = new Locale(config);
              locale2.parentLocale = locales[name];
              locales[name] = locale2;
            }
            getSetGlobalLocale(name);
          } else {
            if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
                if (name === getSetGlobalLocale()) {
                  getSetGlobalLocale(name);
                }
              } else if (locales[name] != null) {
                delete locales[name];
              }
            }
          }
          return locales[name];
        }
        function getLocale(key) {
          var locale2;
          if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
          }
          if (!key) {
            return globalLocale;
          }
          if (!isArray2(key)) {
            locale2 = loadLocale(key);
            if (locale2) {
              return locale2;
            }
            key = [key];
          }
          return chooseLocale(key);
        }
        function listLocales() {
          return keys2(locales);
        }
        function checkOverflow(m) {
          var overflow, a = m._a;
          if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
          }
          return m;
        }
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
          ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
          ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
          ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
          ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
          ["YYYY-DDD", /\d{4}-\d{3}/],
          ["YYYY-MM", /\d{4}-\d\d/, false],
          ["YYYYYYMMDD", /[+-]\d{10}/],
          ["YYYYMMDD", /\d{8}/],
          ["GGGG[W]WWE", /\d{4}W\d{3}/],
          ["GGGG[W]WW", /\d{4}W\d{2}/, false],
          ["YYYYDDD", /\d{7}/],
          ["YYYYMM", /\d{6}/, false],
          ["YYYY", /\d{4}/, false]
        ], isoTimes = [
          ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
          ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
          ["HH:mm:ss", /\d\d:\d\d:\d\d/],
          ["HH:mm", /\d\d:\d\d/],
          ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
          ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
          ["HHmmss", /\d\d\d\d\d\d/],
          ["HHmm", /\d\d\d\d/],
          ["HH", /\d\d/]
        ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
          UT: 0,
          GMT: 0,
          EDT: -4 * 60,
          EST: -5 * 60,
          CDT: -5 * 60,
          CST: -6 * 60,
          MDT: -6 * 60,
          MST: -7 * 60,
          PDT: -7 * 60,
          PST: -8 * 60
        };
        function configFromISO(config) {
          var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
          if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDatesLen; i < l; i++) {
              if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
              }
            }
            if (dateFormat == null) {
              config._isValid = false;
              return;
            }
            if (match[3]) {
              for (i = 0, l = isoTimesLen; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                  timeFormat = (match[2] || " ") + isoTimes[i][0];
                  break;
                }
              }
              if (timeFormat == null) {
                config._isValid = false;
                return;
              }
            }
            if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
            }
            if (match[4]) {
              if (tzRegex.exec(match[4])) {
                tzFormat = "Z";
              } else {
                config._isValid = false;
                return;
              }
            }
            config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
            configFromStringAndFormat(config);
          } else {
            config._isValid = false;
          }
        }
        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
          ];
          if (secondStr) {
            result.push(parseInt(secondStr, 10));
          }
          return result;
        }
        function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
            return 2e3 + year;
          } else if (year <= 999) {
            return 1900 + year;
          }
          return year;
        }
        function preprocessRFC2822(s) {
          return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        }
        function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
              parsedInput[0],
              parsedInput[1],
              parsedInput[2]
            ).getDay();
            if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config).weekdayMismatch = true;
              config._isValid = false;
              return false;
            }
          }
          return true;
        }
        function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
            return obsOffsets[obsOffset];
          } else if (militaryOffset) {
            return 0;
          } else {
            var hm = parseInt(numOffset, 10), m = hm % 100, h2 = (hm - m) / 100;
            return h2 * 60 + m;
          }
        }
        function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
          if (match) {
            parsedArray = extractFromRFC2822Strings(
              match[4],
              match[3],
              match[2],
              match[5],
              match[6],
              match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
              return;
            }
            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);
            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            getParsingFlags(config).rfc2822 = true;
          } else {
            config._isValid = false;
          }
        }
        function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
            config._d = /* @__PURE__ */ new Date(+matched[1]);
            return;
          }
          configFromISO(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          configFromRFC2822(config);
          if (config._isValid === false) {
            delete config._isValid;
          } else {
            return;
          }
          if (config._strict) {
            config._isValid = false;
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        hooks.createFromInputFallback = deprecate(
          "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
          function(config) {
            config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
          }
        );
        function defaults(a, b, c) {
          if (a != null) {
            return a;
          }
          if (b != null) {
            return b;
          }
          return c;
        }
        function currentDateArray(config) {
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
            return [
              nowValue.getUTCFullYear(),
              nowValue.getUTCMonth(),
              nowValue.getUTCDate()
            ];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }
        function configFromArray(config) {
          var i, date, input = [], currentDate, expectedWeekday, yearToUse;
          if (config._d) {
            return;
          }
          currentDate = currentDateArray(config);
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
          }
          if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
              getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
          }
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
          }
          for (; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
          }
          if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
          }
          config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
          );
          expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
          if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }
          if (config._nextDay) {
            config._a[HOUR] = 24;
          }
          if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
          }
        }
        function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults(
              w.GG,
              config._a[YEAR],
              weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
            }
          } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
            week = defaults(w.w, curWeek.week);
            if (w.d != null) {
              weekday = w.d;
              if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
              }
            } else if (w.e != null) {
              weekday = w.e + dow;
              if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
              }
            } else {
              weekday = dow;
            }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
          } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
          }
        }
        hooks.ISO_8601 = function() {
        };
        hooks.RFC_2822 = function() {
        };
        function configFromStringAndFormat(config) {
          if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
          }
          if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;
          var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
          tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
          tokenLen = tokens2.length;
          for (i = 0; i < tokenLen; i++) {
            token2 = tokens2[i];
            parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
            if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));
              if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
              }
              string = string.slice(
                string.indexOf(parsedInput) + parsedInput.length
              );
              totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token2]) {
              if (parsedInput) {
                getParsingFlags(config).empty = false;
              } else {
                getParsingFlags(config).unusedTokens.push(token2);
              }
              addTimeToArrayFromToken(token2, parsedInput, config);
            } else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token2);
            }
          }
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
          }
          if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = void 0;
          }
          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
          );
          era = getParsingFlags(config).era;
          if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }
          configFromArray(config);
          checkOverflow(config);
        }
        function meridiemFixWrap(locale2, hour, meridiem2) {
          var isPm;
          if (meridiem2 == null) {
            return hour;
          }
          if (locale2.meridiemHour != null) {
            return locale2.meridiemHour(hour, meridiem2);
          } else if (locale2.isPM != null) {
            isPm = locale2.isPM(meridiem2);
            if (isPm && hour < 12) {
              hour += 12;
            }
            if (!isPm && hour === 12) {
              hour = 0;
            }
            return hour;
          } else {
            return hour;
          }
        }
        function configFromStringAndArray(config) {
          var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
          if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = /* @__PURE__ */ new Date(NaN);
            return;
          }
          for (i = 0; i < configfLen; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
              validFormatFound = true;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
              if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
                if (validFormatFound) {
                  bestFormatIsValid = true;
                }
              }
            } else {
              if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
              }
            }
          }
          extend4(config, bestMoment || tempConfig);
        }
        function configFromObject(config) {
          if (config._d) {
            return;
          }
          var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
          config._a = map2(
            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
            function(obj) {
              return obj && parseInt(obj, 10);
            }
          );
          configFromArray(config);
        }
        function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = void 0;
          }
          return res;
        }
        function prepareConfig(config) {
          var input = config._i, format2 = config._f;
          config._locale = config._locale || getLocale(config._l);
          if (input === null || format2 === void 0 && input === "") {
            return createInvalid({ nullInput: true });
          }
          if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
          }
          if (isMoment(input)) {
            return new Moment(checkOverflow(input));
          } else if (isDate2(input)) {
            config._d = input;
          } else if (isArray2(format2)) {
            configFromStringAndArray(config);
          } else if (format2) {
            configFromStringAndFormat(config);
          } else {
            configFromInput(config);
          }
          if (!isValid(config)) {
            config._d = null;
          }
          return config;
        }
        function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
            config._d = new Date(hooks.now());
          } else if (isDate2(input)) {
            config._d = new Date(input.valueOf());
          } else if (typeof input === "string") {
            configFromString(config);
          } else if (isArray2(input)) {
            config._a = map2(input.slice(0), function(obj) {
              return parseInt(obj, 10);
            });
            configFromArray(config);
          } else if (isObject2(input)) {
            configFromObject(config);
          } else if (isNumber(input)) {
            config._d = new Date(input);
          } else {
            hooks.createFromInputFallback(config);
          }
        }
        function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
          var c = {};
          if (format2 === true || format2 === false) {
            strict = format2;
            format2 = void 0;
          }
          if (locale2 === true || locale2 === false) {
            strict = locale2;
            locale2 = void 0;
          }
          if (isObject2(input) && isObjectEmpty(input) || isArray2(input) && input.length === 0) {
            input = void 0;
          }
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale2;
          c._i = input;
          c._f = format2;
          c._strict = strict;
          return createFromConfig(c);
        }
        function createLocal(input, format2, locale2, strict) {
          return createLocalOrUTC(input, format2, locale2, strict, false);
        }
        var prototypeMin = deprecate(
          "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
          function() {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other < this ? this : other;
            } else {
              return createInvalid();
            }
          }
        ), prototypeMax = deprecate(
          "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
          function() {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other > this ? this : other;
            } else {
              return createInvalid();
            }
          }
        );
        function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray2(moments[0])) {
            moments = moments[0];
          }
          if (!moments.length) {
            return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
              res = moments[i];
            }
          }
          return res;
        }
        function min() {
          var args = [].slice.call(arguments, 0);
          return pickBy("isBefore", args);
        }
        function max() {
          var args = [].slice.call(arguments, 0);
          return pickBy("isAfter", args);
        }
        var now2 = function() {
          return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
        };
        var ordering = [
          "year",
          "quarter",
          "month",
          "week",
          "day",
          "hour",
          "minute",
          "second",
          "millisecond"
        ];
        function isDurationValid(m) {
          var key, unitHasDecimal = false, i, orderLen = ordering.length;
          for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf2.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
              return false;
            }
          }
          for (i = 0; i < orderLen; ++i) {
            if (m[ordering[i]]) {
              if (unitHasDecimal) {
                return false;
              }
              if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
              }
            }
          }
          return true;
        }
        function isValid$1() {
          return this._isValid;
        }
        function createInvalid$1() {
          return createDuration(NaN);
        }
        function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
          this._isValid = isDurationValid(normalizedInput);
          this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
          minutes2 * 6e4 + // 1000 * 60
          hours2 * 1e3 * 60 * 60;
          this._days = +days2 + weeks2 * 7;
          this._months = +months2 + quarters * 3 + years2 * 12;
          this._data = {};
          this._locale = getLocale();
          this._bubble();
        }
        function isDuration(obj) {
          return obj instanceof Duration;
        }
        function absRound(number) {
          if (number < 0) {
            return Math.round(-1 * number) * -1;
          } else {
            return Math.round(number);
          }
        }
        function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
          for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
              diffs++;
            }
          }
          return diffs + lengthDiff;
        }
        function offset(token2, separator) {
          addFormatToken(token2, 0, 0, function() {
            var offset2 = this.utcOffset(), sign2 = "+";
            if (offset2 < 0) {
              offset2 = -offset2;
              sign2 = "-";
            }
            return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
          });
        }
        offset("Z", ":");
        offset("ZZ", "");
        addRegexToken("Z", matchShortOffset);
        addRegexToken("ZZ", matchShortOffset);
        addParseToken(["Z", "ZZ"], function(input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
        });
        var chunkOffset = /([\+\-]|\d\d)/gi;
        function offsetFromString(matcher, string) {
          var matches2 = (string || "").match(matcher), chunk, parts, minutes2;
          if (matches2 === null) {
            return null;
          }
          chunk = matches2[matches2.length - 1] || [];
          parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
          minutes2 = +(parts[1] * 60) + toInt(parts[2]);
          return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
        }
        function cloneWithOffset(input, model) {
          var res, diff2;
          if (model._isUTC) {
            res = model.clone();
            diff2 = (isMoment(input) || isDate2(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            res._d.setTime(res._d.valueOf() + diff2);
            hooks.updateOffset(res, false);
            return res;
          } else {
            return createLocal(input).local();
          }
        }
        function getDateOffset(m) {
          return -Math.round(m._d.getTimezoneOffset());
        }
        hooks.updateOffset = function() {
        };
        function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset2 = this._offset || 0, localAdjust;
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            if (typeof input === "string") {
              input = offsetFromString(matchShortOffset, input);
              if (input === null) {
                return this;
              }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
              this.add(localAdjust, "m");
            }
            if (offset2 !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addSubtract(
                  this,
                  createDuration(input - offset2, "m"),
                  1,
                  false
                );
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }
            return this;
          } else {
            return this._isUTC ? offset2 : getDateOffset(this);
          }
        }
        function getSetZone(input, keepLocalTime) {
          if (input != null) {
            if (typeof input !== "string") {
              input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
          } else {
            return -this.utcOffset();
          }
        }
        function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
        }
        function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
              this.subtract(getDateOffset(this), "m");
            }
          }
          return this;
        }
        function setOffsetToParsedOffset() {
          if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === "string") {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
              this.utcOffset(tZone);
            } else {
              this.utcOffset(0, true);
            }
          }
          return this;
        }
        function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
            return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;
          return (this.utcOffset() - input) % 60 === 0;
        }
        function isDaylightSavingTime() {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        }
        function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
          }
          var c = {}, other;
          copyConfig(c, this);
          c = prepareConfig(c);
          if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
            this._isDSTShifted = false;
          }
          return this._isDSTShifted;
        }
        function isLocal() {
          return this.isValid() ? !this._isUTC : false;
        }
        function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
        }
        function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        function createDuration(input, key) {
          var duration = input, match = null, sign2, ret, diffRes;
          if (isDuration(input)) {
            duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months
            };
          } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
              duration[key] = +input;
            } else {
              duration.milliseconds = +input;
            }
          } else if (match = aspNetRegex.exec(input)) {
            sign2 = match[1] === "-" ? -1 : 1;
            duration = {
              y: 0,
              d: toInt(match[DATE]) * sign2,
              h: toInt(match[HOUR]) * sign2,
              m: toInt(match[MINUTE]) * sign2,
              s: toInt(match[SECOND]) * sign2,
              ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
              // the millisecond decimal point is included in the match
            };
          } else if (match = isoRegex.exec(input)) {
            sign2 = match[1] === "-" ? -1 : 1;
            duration = {
              y: parseIso(match[2], sign2),
              M: parseIso(match[3], sign2),
              w: parseIso(match[4], sign2),
              d: parseIso(match[5], sign2),
              h: parseIso(match[6], sign2),
              m: parseIso(match[7], sign2),
              s: parseIso(match[8], sign2)
            };
          } else if (duration == null) {
            duration = {};
          } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(
              createLocal(duration.from),
              createLocal(duration.to)
            );
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
          }
          ret = new Duration(duration);
          if (isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
          }
          if (isDuration(input) && hasOwnProp(input, "_isValid")) {
            ret._isValid = input._isValid;
          }
          return ret;
        }
        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;
        function parseIso(inp, sign2) {
          var res = inp && parseFloat(inp.replace(",", "."));
          return (isNaN(res) ? 0 : res) * sign2;
        }
        function positiveMomentsDifference(base, other) {
          var res = {};
          res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
          }
          res.milliseconds = +other - +base.clone().add(res.months, "M");
          return res;
        }
        function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
          }
          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
          } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
          }
          return res;
        }
        function createAdder(direction, name) {
          return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
              deprecateSimple(
                name,
                "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
              );
              tmp = val;
              val = period;
              period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
          };
        }
        function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
          if (!mom.isValid()) {
            return;
          }
          updateOffset = updateOffset == null ? true : updateOffset;
          if (months2) {
            setMonth(mom, get2(mom, "Month") + months2 * isAdding);
          }
          if (days2) {
            set$1(mom, "Date", get2(mom, "Date") + days2 * isAdding);
          }
          if (milliseconds2) {
            mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
          }
          if (updateOffset) {
            hooks.updateOffset(mom, days2 || months2);
          }
        }
        var add3 = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
        function isString2(input) {
          return typeof input === "string" || input instanceof String;
        }
        function isMomentInput(input) {
          return isMoment(input) || isDate2(input) || isString2(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
        }
        function isMomentInputObject(input) {
          var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "years",
            "year",
            "y",
            "months",
            "month",
            "M",
            "days",
            "day",
            "d",
            "dates",
            "date",
            "D",
            "hours",
            "hour",
            "h",
            "minutes",
            "minute",
            "m",
            "seconds",
            "second",
            "s",
            "milliseconds",
            "millisecond",
            "ms"
          ], i, property, propertyLen = properties.length;
          for (i = 0; i < propertyLen; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function isNumberOrStringArray(input) {
          var arrayTest = isArray2(input), dataTypeTest = false;
          if (arrayTest) {
            dataTypeTest = input.filter(function(item) {
              return !isNumber(item) && isString2(input);
            }).length === 0;
          }
          return arrayTest && dataTypeTest;
        }
        function isCalendarSpec(input) {
          var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "sameDay",
            "nextDay",
            "lastDay",
            "nextWeek",
            "lastWeek",
            "sameElse"
          ], i, property;
          for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function getCalendarFormat(myMoment, now3) {
          var diff2 = myMoment.diff(now3, "days", true);
          return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
        }
        function calendar$1(time, formats) {
          if (arguments.length === 1) {
            if (!arguments[0]) {
              time = void 0;
              formats = void 0;
            } else if (isMomentInput(arguments[0])) {
              time = arguments[0];
              formats = void 0;
            } else if (isCalendarSpec(arguments[0])) {
              formats = arguments[0];
              time = void 0;
            }
          }
          var now3 = time || createLocal(), sod = cloneWithOffset(now3, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction3(formats[format2]) ? formats[format2].call(this, now3) : formats[format2]);
          return this.format(
            output || this.localeData().calendar(format2, this, createLocal(now3))
          );
        }
        function clone() {
          return new Moment(this);
        }
        function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() > localInput.valueOf();
          } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
        }
        function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() < localInput.valueOf();
          } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
        }
        function isBetween(from2, to2, units, inclusivity) {
          var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
          }
          inclusivity = inclusivity || "()";
          return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
        }
        function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input), inputMs;
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() === localInput.valueOf();
          } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
        }
        function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
        }
        function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
        }
        function diff(input, units, asFloat) {
          var that, zoneDelta, output;
          if (!this.isValid()) {
            return NaN;
          }
          that = cloneWithOffset(input, this);
          if (!that.isValid()) {
            return NaN;
          }
          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
          units = normalizeUnits(units);
          switch (units) {
            case "year":
              output = monthDiff(this, that) / 12;
              break;
            case "month":
              output = monthDiff(this, that);
              break;
            case "quarter":
              output = monthDiff(this, that) / 3;
              break;
            case "second":
              output = (this - that) / 1e3;
              break;
            case "minute":
              output = (this - that) / 6e4;
              break;
            case "hour":
              output = (this - that) / 36e5;
              break;
            case "day":
              output = (this - that - zoneDelta) / 864e5;
              break;
            case "week":
              output = (this - that - zoneDelta) / 6048e5;
              break;
            default:
              output = this - that;
          }
          return asFloat ? output : absFloor(output);
        }
        function monthDiff(a, b) {
          if (a.date() < b.date()) {
            return -monthDiff(b, a);
          }
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
          if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b - anchor) / (anchor - anchor2);
          } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b - anchor) / (anchor2 - anchor);
          }
          return -(wholeMonthDiff + adjust) || 0;
        }
        hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
        hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
        function toString() {
          return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        }
        function toISOString(keepOffset) {
          if (!this.isValid()) {
            return null;
          }
          var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
              m,
              utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
            );
          }
          if (isFunction3(Date.prototype.toISOString)) {
            if (utc) {
              return this.toDate().toISOString();
            } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
            }
          }
          return formatMoment(
            m,
            utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        function inspect() {
          if (!this.isValid()) {
            return "moment.invalid(/* " + this._i + " */)";
          }
          var func = "moment", zone = "", prefix, year, datetime, suffix;
          if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
            zone = "Z";
          }
          prefix = "[" + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
          datetime = "-MM-DD[T]HH:mm:ss.SSS";
          suffix = zone + '[")]';
          return this.format(prefix + year + datetime + suffix);
        }
        function format(inputString) {
          if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
        }
        function from(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
        }
        function to(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
        }
        function locale(key) {
          var newLocaleData;
          if (key === void 0) {
            return this._locale._abbr;
          } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }
            return this;
          }
        }
        var lang = deprecate(
          "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
          function(key) {
            if (key === void 0) {
              return this.localeData();
            } else {
              return this.locale(key);
            }
          }
        );
        function localeData() {
          return this._locale;
        }
        var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
        function mod$1(dividend, divisor) {
          return (dividend % divisor + divisor) % divisor;
        }
        function localStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return new Date(y, m, d).valueOf();
          }
        }
        function utcStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return Date.UTC(y, m, d);
          }
        }
        function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year(), 0, 1);
              break;
            case "quarter":
              time = startOfDate(
                this.year(),
                this.month() - this.month() % 3,
                1
              );
              break;
            case "month":
              time = startOfDate(this.year(), this.month(), 1);
              break;
            case "week":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - this.weekday()
              );
              break;
            case "isoWeek":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - (this.isoWeekday() - 1)
              );
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date());
              break;
            case "hour":
              time = this._d.valueOf();
              time -= mod$1(
                time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                MS_PER_HOUR
              );
              break;
            case "minute":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;
            case "second":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;
            case "quarter":
              time = startOfDate(
                this.year(),
                this.month() - this.month() % 3 + 3,
                1
              ) - 1;
              break;
            case "month":
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;
            case "week":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - this.weekday() + 7
              ) - 1;
              break;
            case "isoWeek":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - (this.isoWeekday() - 1) + 7
              ) - 1;
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;
            case "hour":
              time = this._d.valueOf();
              time += MS_PER_HOUR - mod$1(
                time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                MS_PER_HOUR
              ) - 1;
              break;
            case "minute":
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;
            case "second":
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 6e4;
        }
        function unix() {
          return Math.floor(this.valueOf() / 1e3);
        }
        function toDate() {
          return new Date(this.valueOf());
        }
        function toArray() {
          var m = this;
          return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond()
          ];
        }
        function toObject() {
          var m = this;
          return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
          };
        }
        function toJSON() {
          return this.isValid() ? this.toISOString() : null;
        }
        function isValid$2() {
          return isValid(this);
        }
        function parsingFlags() {
          return extend4({}, getParsingFlags(this));
        }
        function invalidAt() {
          return getParsingFlags(this).overflow;
        }
        function creationData() {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          };
        }
        addFormatToken("N", 0, 0, "eraAbbr");
        addFormatToken("NN", 0, 0, "eraAbbr");
        addFormatToken("NNN", 0, 0, "eraAbbr");
        addFormatToken("NNNN", 0, 0, "eraName");
        addFormatToken("NNNNN", 0, 0, "eraNarrow");
        addFormatToken("y", ["y", 1], "yo", "eraYear");
        addFormatToken("y", ["yy", 2], 0, "eraYear");
        addFormatToken("y", ["yyy", 3], 0, "eraYear");
        addFormatToken("y", ["yyyy", 4], 0, "eraYear");
        addRegexToken("N", matchEraAbbr);
        addRegexToken("NN", matchEraAbbr);
        addRegexToken("NNN", matchEraAbbr);
        addRegexToken("NNNN", matchEraName);
        addRegexToken("NNNNN", matchEraNarrow);
        addParseToken(
          ["N", "NN", "NNN", "NNNN", "NNNNN"],
          function(input, array, config, token2) {
            var era = config._locale.erasParse(input, token2, config._strict);
            if (era) {
              getParsingFlags(config).era = era;
            } else {
              getParsingFlags(config).invalidEra = input;
            }
          }
        );
        addRegexToken("y", matchUnsigned);
        addRegexToken("yy", matchUnsigned);
        addRegexToken("yyy", matchUnsigned);
        addRegexToken("yyyy", matchUnsigned);
        addRegexToken("yo", matchEraYearOrdinal);
        addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
        addParseToken(["yo"], function(input, array, config, token2) {
          var match;
          if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
          }
          if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
            array[YEAR] = parseInt(input, 10);
          }
        });
        function localeEras(m, format2) {
          var i, l, date, eras = this._eras || getLocale("en")._eras;
          for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
              case "string":
                date = hooks(eras[i].since).startOf("day");
                eras[i].since = date.valueOf();
                break;
            }
            switch (typeof eras[i].until) {
              case "undefined":
                eras[i].until = Infinity;
                break;
              case "string":
                date = hooks(eras[i].until).startOf("day").valueOf();
                eras[i].until = date.valueOf();
                break;
            }
          }
          return eras;
        }
        function localeErasParse(eraName, format2, strict) {
          var i, l, eras = this.eras(), name, abbr, narrow;
          eraName = eraName.toUpperCase();
          for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();
            if (strict) {
              switch (format2) {
                case "N":
                case "NN":
                case "NNN":
                  if (abbr === eraName) {
                    return eras[i];
                  }
                  break;
                case "NNNN":
                  if (name === eraName) {
                    return eras[i];
                  }
                  break;
                case "NNNNN":
                  if (narrow === eraName) {
                    return eras[i];
                  }
                  break;
              }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
              return eras[i];
            }
          }
        }
        function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? 1 : -1;
          if (year === void 0) {
            return hooks(era.since).year();
          } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
          }
        }
        function getEraName() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].name;
            }
          }
          return "";
        }
        function getEraNarrow() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].narrow;
            }
          }
          return "";
        }
        function getEraAbbr() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].abbr;
            }
          }
          return "";
        }
        function getEraYear() {
          var i, l, dir, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? 1 : -1;
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
              return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
            }
          }
          return this.year();
        }
        function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNameRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
        }
        function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, "_erasAbbrRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }
        function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNarrowRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }
        function matchEraAbbr(isStrict, locale2) {
          return locale2.erasAbbrRegex(isStrict);
        }
        function matchEraName(isStrict, locale2) {
          return locale2.erasNameRegex(isStrict);
        }
        function matchEraNarrow(isStrict, locale2) {
          return locale2.erasNarrowRegex(isStrict);
        }
        function matchEraYearOrdinal(isStrict, locale2) {
          return locale2._eraYearOrdinalRegex || matchUnsigned;
        }
        function computeErasParse() {
          var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            erasName = regexEscape(eras[i].name);
            erasAbbr = regexEscape(eras[i].abbr);
            erasNarrow = regexEscape(eras[i].narrow);
            namePieces.push(erasName);
            abbrPieces.push(erasAbbr);
            narrowPieces.push(erasNarrow);
            mixedPieces.push(erasName);
            mixedPieces.push(erasAbbr);
            mixedPieces.push(erasNarrow);
          }
          this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
          this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
          this._erasNarrowRegex = new RegExp(
            "^(" + narrowPieces.join("|") + ")",
            "i"
          );
        }
        addFormatToken(0, ["gg", 2], 0, function() {
          return this.weekYear() % 100;
        });
        addFormatToken(0, ["GG", 2], 0, function() {
          return this.isoWeekYear() % 100;
        });
        function addWeekYearFormatToken(token2, getter) {
          addFormatToken(0, [token2, token2.length], 0, getter);
        }
        addWeekYearFormatToken("gggg", "weekYear");
        addWeekYearFormatToken("ggggg", "weekYear");
        addWeekYearFormatToken("GGGG", "isoWeekYear");
        addWeekYearFormatToken("GGGGG", "isoWeekYear");
        addRegexToken("G", matchSigned);
        addRegexToken("g", matchSigned);
        addRegexToken("GG", match1to2, match2);
        addRegexToken("gg", match1to2, match2);
        addRegexToken("GGGG", match1to4, match4);
        addRegexToken("gggg", match1to4, match4);
        addRegexToken("GGGGG", match1to6, match6);
        addRegexToken("ggggg", match1to6, match6);
        addWeekParseToken(
          ["gggg", "ggggg", "GGGG", "GGGGG"],
          function(input, week, config, token2) {
            week[token2.substr(0, 2)] = toInt(input);
          }
        );
        addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
          week[token2] = hooks.parseTwoDigitYear(input);
        });
        function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday() + this.localeData()._week.dow,
            this.localeData()._week.dow,
            this.localeData()._week.doy
          );
        }
        function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
          );
        }
        function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
        }
        function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
        }
        function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }
        function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }
        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
            return weekOfYear(this, dow, doy).year;
          } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
              week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
        }
        function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
        }
        addFormatToken("Q", 0, "Qo", "quarter");
        addRegexToken("Q", match1);
        addParseToken("Q", function(input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
        });
        function getSetQuarter(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        }
        addFormatToken("D", ["DD", 2], "Do", "date");
        addRegexToken("D", match1to2, match1to2NoLeadingZero);
        addRegexToken("DD", match1to2, match2);
        addRegexToken("Do", function(isStrict, locale2) {
          return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
        });
        addParseToken(["D", "DD"], DATE);
        addParseToken("Do", function(input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
        });
        var getSetDayOfMonth = makeGetSet("Date", true);
        addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
        addRegexToken("DDD", match1to3);
        addRegexToken("DDDD", match3);
        addParseToken(["DDD", "DDDD"], function(input, array, config) {
          config._dayOfYear = toInt(input);
        });
        function getSetDayOfYear(input) {
          var dayOfYear = Math.round(
            (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
          ) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
        }
        addFormatToken("m", ["mm", 2], 0, "minute");
        addRegexToken("m", match1to2, match1to2HasZero);
        addRegexToken("mm", match1to2, match2);
        addParseToken(["m", "mm"], MINUTE);
        var getSetMinute = makeGetSet("Minutes", false);
        addFormatToken("s", ["ss", 2], 0, "second");
        addRegexToken("s", match1to2, match1to2HasZero);
        addRegexToken("ss", match1to2, match2);
        addParseToken(["s", "ss"], SECOND);
        var getSetSecond = makeGetSet("Seconds", false);
        addFormatToken("S", 0, 0, function() {
          return ~~(this.millisecond() / 100);
        });
        addFormatToken(0, ["SS", 2], 0, function() {
          return ~~(this.millisecond() / 10);
        });
        addFormatToken(0, ["SSS", 3], 0, "millisecond");
        addFormatToken(0, ["SSSS", 4], 0, function() {
          return this.millisecond() * 10;
        });
        addFormatToken(0, ["SSSSS", 5], 0, function() {
          return this.millisecond() * 100;
        });
        addFormatToken(0, ["SSSSSS", 6], 0, function() {
          return this.millisecond() * 1e3;
        });
        addFormatToken(0, ["SSSSSSS", 7], 0, function() {
          return this.millisecond() * 1e4;
        });
        addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
          return this.millisecond() * 1e5;
        });
        addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
          return this.millisecond() * 1e6;
        });
        addRegexToken("S", match1to3, match1);
        addRegexToken("SS", match1to3, match2);
        addRegexToken("SSS", match1to3, match3);
        var token, getSetMillisecond;
        for (token = "SSSS"; token.length <= 9; token += "S") {
          addRegexToken(token, matchUnsigned);
        }
        function parseMs(input, array) {
          array[MILLISECOND] = toInt(("0." + input) * 1e3);
        }
        for (token = "S"; token.length <= 9; token += "S") {
          addParseToken(token, parseMs);
        }
        getSetMillisecond = makeGetSet("Milliseconds", false);
        addFormatToken("z", 0, 0, "zoneAbbr");
        addFormatToken("zz", 0, 0, "zoneName");
        function getZoneAbbr() {
          return this._isUTC ? "UTC" : "";
        }
        function getZoneName() {
          return this._isUTC ? "Coordinated Universal Time" : "";
        }
        var proto = Moment.prototype;
        proto.add = add3;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== "undefined" && Symbol.for != null) {
          proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
            return "Moment<" + this.format() + ">";
          };
        }
        proto.toJSON = toJSON;
        proto.toString = toString;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate(
          "dates accessor is deprecated. Use date instead.",
          getSetDayOfMonth
        );
        proto.months = deprecate(
          "months accessor is deprecated. Use month instead",
          getSetMonth
        );
        proto.years = deprecate(
          "years accessor is deprecated. Use year instead",
          getSetYear
        );
        proto.zone = deprecate(
          "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
          getSetZone
        );
        proto.isDSTShifted = deprecate(
          "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
          isDaylightSavingTimeShifted
        );
        function createUnix(input) {
          return createLocal(input * 1e3);
        }
        function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
        }
        function preParsePostFormat(string) {
          return string;
        }
        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set2;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;
        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;
        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;
        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;
        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;
        function get$1(format2, index, field, setter) {
          var locale2 = getLocale(), utc = createUTC().set(setter, index);
          return locale2[field](utc, format2);
        }
        function listMonthsImpl(format2, index, field) {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
          if (index != null) {
            return get$1(format2, index, field, "month");
          }
          var i, out = [];
          for (i = 0; i < 12; i++) {
            out[i] = get$1(format2, i, field, "month");
          }
          return out;
        }
        function listWeekdaysImpl(localeSorted, format2, index, field) {
          if (typeof localeSorted === "boolean") {
            if (isNumber(format2)) {
              index = format2;
              format2 = void 0;
            }
            format2 = format2 || "";
          } else {
            format2 = localeSorted;
            index = format2;
            localeSorted = false;
            if (isNumber(format2)) {
              index = format2;
              format2 = void 0;
            }
            format2 = format2 || "";
          }
          var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
          if (index != null) {
            return get$1(format2, (index + shift) % 7, field, "day");
          }
          for (i = 0; i < 7; i++) {
            out[i] = get$1(format2, (i + shift) % 7, field, "day");
          }
          return out;
        }
        function listMonths(format2, index) {
          return listMonthsImpl(format2, index, "months");
        }
        function listMonthsShort(format2, index) {
          return listMonthsImpl(format2, index, "monthsShort");
        }
        function listWeekdays(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
        }
        function listWeekdaysShort(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
        }
        function listWeekdaysMin(localeSorted, format2, index) {
          return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
        }
        getSetGlobalLocale("en", {
          eras: [
            {
              since: "0001-01-01",
              until: Infinity,
              offset: 1,
              name: "Anno Domini",
              narrow: "AD",
              abbr: "AD"
            },
            {
              since: "0000-12-31",
              until: -Infinity,
              offset: 1,
              name: "Before Christ",
              narrow: "BC",
              abbr: "BC"
            }
          ],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
          }
        });
        hooks.lang = deprecate(
          "moment.lang is deprecated. Use moment.locale instead.",
          getSetGlobalLocale
        );
        hooks.langData = deprecate(
          "moment.langData is deprecated. Use moment.localeData instead.",
          getLocale
        );
        var mathAbs = Math.abs;
        function abs() {
          var data = this._data;
          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);
          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);
          return this;
        }
        function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);
          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;
          return duration._bubble();
        }
        function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
        }
        function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
        }
        function absCeil(number) {
          if (number < 0) {
            return Math.floor(number);
          } else {
            return Math.ceil(number);
          }
        }
        function bubble() {
          var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
          if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
            milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
            days2 = 0;
            months2 = 0;
          }
          data.milliseconds = milliseconds2 % 1e3;
          seconds2 = absFloor(milliseconds2 / 1e3);
          data.seconds = seconds2 % 60;
          minutes2 = absFloor(seconds2 / 60);
          data.minutes = minutes2 % 60;
          hours2 = absFloor(minutes2 / 60);
          data.hours = hours2 % 24;
          days2 += absFloor(hours2 / 24);
          monthsFromDays = absFloor(daysToMonths(days2));
          months2 += monthsFromDays;
          days2 -= absCeil(monthsToDays(monthsFromDays));
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          data.days = days2;
          data.months = months2;
          data.years = years2;
          return this;
        }
        function daysToMonths(days2) {
          return days2 * 4800 / 146097;
        }
        function monthsToDays(months2) {
          return months2 * 146097 / 4800;
        }
        function as(units) {
          if (!this.isValid()) {
            return NaN;
          }
          var days2, months2, milliseconds2 = this._milliseconds;
          units = normalizeUnits(units);
          if (units === "month" || units === "quarter" || units === "year") {
            days2 = this._days + milliseconds2 / 864e5;
            months2 = this._months + daysToMonths(days2);
            switch (units) {
              case "month":
                return months2;
              case "quarter":
                return months2 / 3;
              case "year":
                return months2 / 12;
            }
          } else {
            days2 = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case "week":
                return days2 / 7 + milliseconds2 / 6048e5;
              case "day":
                return days2 + milliseconds2 / 864e5;
              case "hour":
                return days2 * 24 + milliseconds2 / 36e5;
              case "minute":
                return days2 * 1440 + milliseconds2 / 6e4;
              case "second":
                return days2 * 86400 + milliseconds2 / 1e3;
              case "millisecond":
                return Math.floor(days2 * 864e5) + milliseconds2;
              default:
                throw new Error("Unknown unit " + units);
            }
          }
        }
        function makeAs(alias) {
          return function() {
            return this.as(alias);
          };
        }
        var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
        function clone$1() {
          return createDuration(this);
        }
        function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + "s"]() : NaN;
        }
        function makeGetter(name) {
          return function() {
            return this.isValid() ? this._data[name] : NaN;
          };
        }
        var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
        function weeks() {
          return absFloor(this.days() / 7);
        }
        var round = Math.round, thresholds = {
          ss: 44,
          // a few seconds to seconds
          s: 45,
          // seconds to minute
          m: 45,
          // minutes to hour
          h: 22,
          // hours to day
          d: 26,
          // days to month/week
          w: null,
          // weeks to month
          M: 11
          // months to year
        };
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
          return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }
        function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
          var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
          if (thresholds2.w != null) {
            a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
          }
          a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale2;
          return substituteTimeAgo.apply(null, a);
        }
        function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === void 0) {
            return round;
          }
          if (typeof roundingFunction === "function") {
            round = roundingFunction;
            return true;
          }
          return false;
        }
        function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === void 0) {
            return false;
          }
          if (limit === void 0) {
            return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === "s") {
            thresholds.ss = limit - 1;
          }
          return true;
        }
        function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var withSuffix = false, th = thresholds, locale2, output;
          if (typeof argWithSuffix === "object") {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
          }
          if (typeof argWithSuffix === "boolean") {
            withSuffix = argWithSuffix;
          }
          if (typeof argThresholds === "object") {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
              th.ss = argThresholds.s - 1;
            }
          }
          locale2 = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale2);
          if (withSuffix) {
            output = locale2.pastFuture(+this, output);
          }
          return locale2.postformat(output);
        }
        var abs$1 = Math.abs;
        function sign(x) {
          return (x > 0) - (x < 0) || +x;
        }
        function toISOString$1() {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
          if (!total) {
            return "P0D";
          }
          minutes2 = absFloor(seconds2 / 60);
          hours2 = absFloor(minutes2 / 60);
          seconds2 %= 60;
          minutes2 %= 60;
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
          totalSign = total < 0 ? "-" : "";
          ymSign = sign(this._months) !== sign(total) ? "-" : "";
          daysSign = sign(this._days) !== sign(total) ? "-" : "";
          hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
          return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
        }
        var proto$2 = Duration.prototype;
        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;
        proto$2.toIsoString = deprecate(
          "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
          toISOString$1
        );
        proto$2.lang = lang;
        addFormatToken("X", 0, 0, "unix");
        addFormatToken("x", 0, 0, "valueOf");
        addRegexToken("x", matchSigned);
        addRegexToken("X", matchTimestamp);
        addParseToken("X", function(input, array, config) {
          config._d = new Date(parseFloat(input) * 1e3);
        });
        addParseToken("x", function(input, array, config) {
          config._d = new Date(toInt(input));
        });
        hooks.version = "2.30.1";
        setHookCallback(createLocal);
        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now2;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate2;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;
        hooks.HTML5_FMT = {
          DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
          // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
          // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
          // <input type="datetime-local" step="0.001" />
          DATE: "YYYY-MM-DD",
          // <input type="date" />
          TIME: "HH:mm",
          // <input type="time" />
          TIME_SECONDS: "HH:mm:ss",
          // <input type="time" step="1" />
          TIME_MS: "HH:mm:ss.SSS",
          // <input type="time" step="0.001" />
          WEEK: "GGGG-[W]WW",
          // <input type="week" />
          MONTH: "YYYY-MM"
          // <input type="month" />
        };
        return hooks;
      });
    }
  });

  // node_modules/select2/dist/js/select2.js
  var require_select2 = __commonJS({
    "node_modules/select2/dist/js/select2.js"(exports, module) {
      (function(factory) {
        if (typeof define === "function" && define.amd) {
          define(["jquery"], factory);
        } else if (typeof module === "object" && module.exports) {
          module.exports = function(root, jQuery4) {
            if (jQuery4 === void 0) {
              if (typeof window !== "undefined") {
                jQuery4 = require_jquery();
              } else {
                jQuery4 = require_jquery()(root);
              }
            }
            factory(jQuery4);
            return jQuery4;
          };
        } else {
          factory(jQuery);
        }
      })(function(jQuery4) {
        var S2 = function() {
          if (jQuery4 && jQuery4.fn && jQuery4.fn.select2 && jQuery4.fn.select2.amd) {
            var S22 = jQuery4.fn.select2.amd;
          }
          var S22;
          (function() {
            if (!S22 || !S22.requirejs) {
              if (!S22) {
                S22 = {};
              } else {
                require2 = S22;
              }
              var requirejs, require2, define2;
              (function(undef) {
                var main, req, makeMap2, handlers, defined = {}, waiting = {}, config = {}, defining = {}, hasOwn2 = Object.prototype.hasOwnProperty, aps = [].slice, jsSuffixRegExp = /\.js$/;
                function hasProp2(obj, prop) {
                  return hasOwn2.call(obj, prop);
                }
                function normalize(name, baseName) {
                  var nameParts, nameSegment, mapValue, foundMap, lastIndex, foundI, foundStarMap, starI, i, j, part, normalizedBaseParts, baseParts = baseName && baseName.split("/"), map2 = config.map, starMap = map2 && map2["*"] || {};
                  if (name) {
                    name = name.split("/");
                    lastIndex = name.length - 1;
                    if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                      name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, "");
                    }
                    if (name[0].charAt(0) === "." && baseParts) {
                      normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                      name = normalizedBaseParts.concat(name);
                    }
                    for (i = 0; i < name.length; i++) {
                      part = name[i];
                      if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                      } else if (part === "..") {
                        if (i === 0 || i === 1 && name[2] === ".." || name[i - 1] === "..") {
                          continue;
                        } else if (i > 0) {
                          name.splice(i - 1, 2);
                          i -= 2;
                        }
                      }
                    }
                    name = name.join("/");
                  }
                  if ((baseParts || starMap) && map2) {
                    nameParts = name.split("/");
                    for (i = nameParts.length; i > 0; i -= 1) {
                      nameSegment = nameParts.slice(0, i).join("/");
                      if (baseParts) {
                        for (j = baseParts.length; j > 0; j -= 1) {
                          mapValue = map2[baseParts.slice(0, j).join("/")];
                          if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                              foundMap = mapValue;
                              foundI = i;
                              break;
                            }
                          }
                        }
                      }
                      if (foundMap) {
                        break;
                      }
                      if (!foundStarMap && starMap && starMap[nameSegment]) {
                        foundStarMap = starMap[nameSegment];
                        starI = i;
                      }
                    }
                    if (!foundMap && foundStarMap) {
                      foundMap = foundStarMap;
                      foundI = starI;
                    }
                    if (foundMap) {
                      nameParts.splice(0, foundI, foundMap);
                      name = nameParts.join("/");
                    }
                  }
                  return name;
                }
                function makeRequire(relName, forceSync) {
                  return function() {
                    var args = aps.call(arguments, 0);
                    if (typeof args[0] !== "string" && args.length === 1) {
                      args.push(null);
                    }
                    return req.apply(undef, args.concat([relName, forceSync]));
                  };
                }
                function makeNormalize(relName) {
                  return function(name) {
                    return normalize(name, relName);
                  };
                }
                function makeLoad(depName) {
                  return function(value) {
                    defined[depName] = value;
                  };
                }
                function callDep(name) {
                  if (hasProp2(waiting, name)) {
                    var args = waiting[name];
                    delete waiting[name];
                    defining[name] = true;
                    main.apply(undef, args);
                  }
                  if (!hasProp2(defined, name) && !hasProp2(defining, name)) {
                    throw new Error("No " + name);
                  }
                  return defined[name];
                }
                function splitPrefix(name) {
                  var prefix, index = name ? name.indexOf("!") : -1;
                  if (index > -1) {
                    prefix = name.substring(0, index);
                    name = name.substring(index + 1, name.length);
                  }
                  return [prefix, name];
                }
                function makeRelParts(relName) {
                  return relName ? splitPrefix(relName) : [];
                }
                makeMap2 = function(name, relParts) {
                  var plugin, parts = splitPrefix(name), prefix = parts[0], relResourceName = relParts[1];
                  name = parts[1];
                  if (prefix) {
                    prefix = normalize(prefix, relResourceName);
                    plugin = callDep(prefix);
                  }
                  if (prefix) {
                    if (plugin && plugin.normalize) {
                      name = plugin.normalize(name, makeNormalize(relResourceName));
                    } else {
                      name = normalize(name, relResourceName);
                    }
                  } else {
                    name = normalize(name, relResourceName);
                    parts = splitPrefix(name);
                    prefix = parts[0];
                    name = parts[1];
                    if (prefix) {
                      plugin = callDep(prefix);
                    }
                  }
                  return {
                    f: prefix ? prefix + "!" + name : name,
                    //fullName
                    n: name,
                    pr: prefix,
                    p: plugin
                  };
                };
                function makeConfig(name) {
                  return function() {
                    return config && config.config && config.config[name] || {};
                  };
                }
                handlers = {
                  require: function(name) {
                    return makeRequire(name);
                  },
                  exports: function(name) {
                    var e = defined[name];
                    if (typeof e !== "undefined") {
                      return e;
                    } else {
                      return defined[name] = {};
                    }
                  },
                  module: function(name) {
                    return {
                      id: name,
                      uri: "",
                      exports: defined[name],
                      config: makeConfig(name)
                    };
                  }
                };
                main = function(name, deps, callback, relName) {
                  var cjsModule, depName, ret, map2, i, relParts, args = [], callbackType = typeof callback, usingExports;
                  relName = relName || name;
                  relParts = makeRelParts(relName);
                  if (callbackType === "undefined" || callbackType === "function") {
                    deps = !deps.length && callback.length ? ["require", "exports", "module"] : deps;
                    for (i = 0; i < deps.length; i += 1) {
                      map2 = makeMap2(deps[i], relParts);
                      depName = map2.f;
                      if (depName === "require") {
                        args[i] = handlers.require(name);
                      } else if (depName === "exports") {
                        args[i] = handlers.exports(name);
                        usingExports = true;
                      } else if (depName === "module") {
                        cjsModule = args[i] = handlers.module(name);
                      } else if (hasProp2(defined, depName) || hasProp2(waiting, depName) || hasProp2(defining, depName)) {
                        args[i] = callDep(depName);
                      } else if (map2.p) {
                        map2.p.load(map2.n, makeRequire(relName, true), makeLoad(depName), {});
                        args[i] = defined[depName];
                      } else {
                        throw new Error(name + " missing " + depName);
                      }
                    }
                    ret = callback ? callback.apply(defined[name], args) : void 0;
                    if (name) {
                      if (cjsModule && cjsModule.exports !== undef && cjsModule.exports !== defined[name]) {
                        defined[name] = cjsModule.exports;
                      } else if (ret !== undef || !usingExports) {
                        defined[name] = ret;
                      }
                    }
                  } else if (name) {
                    defined[name] = callback;
                  }
                };
                requirejs = require2 = req = function(deps, callback, relName, forceSync, alt) {
                  if (typeof deps === "string") {
                    if (handlers[deps]) {
                      return handlers[deps](callback);
                    }
                    return callDep(makeMap2(deps, makeRelParts(callback)).f);
                  } else if (!deps.splice) {
                    config = deps;
                    if (config.deps) {
                      req(config.deps, config.callback);
                    }
                    if (!callback) {
                      return;
                    }
                    if (callback.splice) {
                      deps = callback;
                      callback = relName;
                      relName = null;
                    } else {
                      deps = undef;
                    }
                  }
                  callback = callback || function() {
                  };
                  if (typeof relName === "function") {
                    relName = forceSync;
                    forceSync = alt;
                  }
                  if (forceSync) {
                    main(undef, deps, callback, relName);
                  } else {
                    setTimeout(function() {
                      main(undef, deps, callback, relName);
                    }, 4);
                  }
                  return req;
                };
                req.config = function(cfg) {
                  return req(cfg);
                };
                requirejs._defined = defined;
                define2 = function(name, deps, callback) {
                  if (typeof name !== "string") {
                    throw new Error("See almond README: incorrect module build, no module name");
                  }
                  if (!deps.splice) {
                    callback = deps;
                    deps = [];
                  }
                  if (!hasProp2(defined, name) && !hasProp2(waiting, name)) {
                    waiting[name] = [name, deps, callback];
                  }
                };
                define2.amd = {
                  jQuery: true
                };
              })();
              S22.requirejs = requirejs;
              S22.require = require2;
              S22.define = define2;
            }
          })();
          S22.define("almond", function() {
          });
          S22.define("jquery", [], function() {
            var _$ = jQuery4 || $;
            if (_$ == null && console && console.error) {
              console.error(
                "Select2: An instance of jQuery or a jQuery-compatible library was not found. Make sure that you are including jQuery before Select2 on your web page."
              );
            }
            return _$;
          });
          S22.define("select2/utils", [
            "jquery"
          ], function($3) {
            var Utils = {};
            Utils.Extend = function(ChildClass, SuperClass) {
              var __hasProp = {}.hasOwnProperty;
              function BaseConstructor() {
                this.constructor = ChildClass;
              }
              for (var key in SuperClass) {
                if (__hasProp.call(SuperClass, key)) {
                  ChildClass[key] = SuperClass[key];
                }
              }
              BaseConstructor.prototype = SuperClass.prototype;
              ChildClass.prototype = new BaseConstructor();
              ChildClass.__super__ = SuperClass.prototype;
              return ChildClass;
            };
            function getMethods(theClass) {
              var proto = theClass.prototype;
              var methods = [];
              for (var methodName in proto) {
                var m = proto[methodName];
                if (typeof m !== "function") {
                  continue;
                }
                if (methodName === "constructor") {
                  continue;
                }
                methods.push(methodName);
              }
              return methods;
            }
            Utils.Decorate = function(SuperClass, DecoratorClass) {
              var decoratedMethods = getMethods(DecoratorClass);
              var superMethods = getMethods(SuperClass);
              function DecoratedClass() {
                var unshift = Array.prototype.unshift;
                var argCount = DecoratorClass.prototype.constructor.length;
                var calledConstructor = SuperClass.prototype.constructor;
                if (argCount > 0) {
                  unshift.call(arguments, SuperClass.prototype.constructor);
                  calledConstructor = DecoratorClass.prototype.constructor;
                }
                calledConstructor.apply(this, arguments);
              }
              DecoratorClass.displayName = SuperClass.displayName;
              function ctr() {
                this.constructor = DecoratedClass;
              }
              DecoratedClass.prototype = new ctr();
              for (var m = 0; m < superMethods.length; m++) {
                var superMethod = superMethods[m];
                DecoratedClass.prototype[superMethod] = SuperClass.prototype[superMethod];
              }
              var calledMethod = function(methodName) {
                var originalMethod = function() {
                };
                if (methodName in DecoratedClass.prototype) {
                  originalMethod = DecoratedClass.prototype[methodName];
                }
                var decoratedMethod2 = DecoratorClass.prototype[methodName];
                return function() {
                  var unshift = Array.prototype.unshift;
                  unshift.call(arguments, originalMethod);
                  return decoratedMethod2.apply(this, arguments);
                };
              };
              for (var d = 0; d < decoratedMethods.length; d++) {
                var decoratedMethod = decoratedMethods[d];
                DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
              }
              return DecoratedClass;
            };
            var Observable = function() {
              this.listeners = {};
            };
            Observable.prototype.on = function(event, callback) {
              this.listeners = this.listeners || {};
              if (event in this.listeners) {
                this.listeners[event].push(callback);
              } else {
                this.listeners[event] = [callback];
              }
            };
            Observable.prototype.trigger = function(event) {
              var slice = Array.prototype.slice;
              var params = slice.call(arguments, 1);
              this.listeners = this.listeners || {};
              if (params == null) {
                params = [];
              }
              if (params.length === 0) {
                params.push({});
              }
              params[0]._type = event;
              if (event in this.listeners) {
                this.invoke(this.listeners[event], slice.call(arguments, 1));
              }
              if ("*" in this.listeners) {
                this.invoke(this.listeners["*"], arguments);
              }
            };
            Observable.prototype.invoke = function(listeners, params) {
              for (var i = 0, len = listeners.length; i < len; i++) {
                listeners[i].apply(this, params);
              }
            };
            Utils.Observable = Observable;
            Utils.generateChars = function(length) {
              var chars = "";
              for (var i = 0; i < length; i++) {
                var randomChar = Math.floor(Math.random() * 36);
                chars += randomChar.toString(36);
              }
              return chars;
            };
            Utils.bind = function(func, context) {
              return function() {
                func.apply(context, arguments);
              };
            };
            Utils._convertData = function(data) {
              for (var originalKey in data) {
                var keys2 = originalKey.split("-");
                var dataLevel = data;
                if (keys2.length === 1) {
                  continue;
                }
                for (var k = 0; k < keys2.length; k++) {
                  var key = keys2[k];
                  key = key.substring(0, 1).toLowerCase() + key.substring(1);
                  if (!(key in dataLevel)) {
                    dataLevel[key] = {};
                  }
                  if (k == keys2.length - 1) {
                    dataLevel[key] = data[originalKey];
                  }
                  dataLevel = dataLevel[key];
                }
                delete data[originalKey];
              }
              return data;
            };
            Utils.hasScroll = function(index, el) {
              var $el = $3(el);
              var overflowX = el.style.overflowX;
              var overflowY = el.style.overflowY;
              if (overflowX === overflowY && (overflowY === "hidden" || overflowY === "visible")) {
                return false;
              }
              if (overflowX === "scroll" || overflowY === "scroll") {
                return true;
              }
              return $el.innerHeight() < el.scrollHeight || $el.innerWidth() < el.scrollWidth;
            };
            Utils.escapeMarkup = function(markup) {
              var replaceMap = {
                "\\": "&#92;",
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;",
                "/": "&#47;"
              };
              if (typeof markup !== "string") {
                return markup;
              }
              return String(markup).replace(/[&<>"'\/\\]/g, function(match) {
                return replaceMap[match];
              });
            };
            Utils.__cache = {};
            var id = 0;
            Utils.GetUniqueElementId = function(element) {
              var select2Id = element.getAttribute("data-select2-id");
              if (select2Id != null) {
                return select2Id;
              }
              if (element.id) {
                select2Id = "select2-data-" + element.id;
              } else {
                select2Id = "select2-data-" + (++id).toString() + "-" + Utils.generateChars(4);
              }
              element.setAttribute("data-select2-id", select2Id);
              return select2Id;
            };
            Utils.StoreData = function(element, name, value) {
              var id2 = Utils.GetUniqueElementId(element);
              if (!Utils.__cache[id2]) {
                Utils.__cache[id2] = {};
              }
              Utils.__cache[id2][name] = value;
            };
            Utils.GetData = function(element, name) {
              var id2 = Utils.GetUniqueElementId(element);
              if (name) {
                if (Utils.__cache[id2]) {
                  if (Utils.__cache[id2][name] != null) {
                    return Utils.__cache[id2][name];
                  }
                  return $3(element).data(name);
                }
                return $3(element).data(name);
              } else {
                return Utils.__cache[id2];
              }
            };
            Utils.RemoveData = function(element) {
              var id2 = Utils.GetUniqueElementId(element);
              if (Utils.__cache[id2] != null) {
                delete Utils.__cache[id2];
              }
              element.removeAttribute("data-select2-id");
            };
            Utils.copyNonInternalCssClasses = function(dest, src) {
              var classes;
              var destinationClasses = dest.getAttribute("class").trim().split(/\s+/);
              destinationClasses = destinationClasses.filter(function(clazz) {
                return clazz.indexOf("select2-") === 0;
              });
              var sourceClasses = src.getAttribute("class").trim().split(/\s+/);
              sourceClasses = sourceClasses.filter(function(clazz) {
                return clazz.indexOf("select2-") !== 0;
              });
              var replacements = destinationClasses.concat(sourceClasses);
              dest.setAttribute("class", replacements.join(" "));
            };
            return Utils;
          });
          S22.define("select2/results", [
            "jquery",
            "./utils"
          ], function($3, Utils) {
            function Results($element, options, dataAdapter) {
              this.$element = $element;
              this.data = dataAdapter;
              this.options = options;
              Results.__super__.constructor.call(this);
            }
            Utils.Extend(Results, Utils.Observable);
            Results.prototype.render = function() {
              var $results = $3(
                '<ul class="select2-results__options" role="listbox"></ul>'
              );
              if (this.options.get("multiple")) {
                $results.attr("aria-multiselectable", "true");
              }
              this.$results = $results;
              return $results;
            };
            Results.prototype.clear = function() {
              this.$results.empty();
            };
            Results.prototype.displayMessage = function(params) {
              var escapeMarkup = this.options.get("escapeMarkup");
              this.clear();
              this.hideLoading();
              var $message = $3(
                '<li role="alert" aria-live="assertive" class="select2-results__option"></li>'
              );
              var message = this.options.get("translations").get(params.message);
              $message.append(
                escapeMarkup(
                  message(params.args)
                )
              );
              $message[0].className += " select2-results__message";
              this.$results.append($message);
            };
            Results.prototype.hideMessages = function() {
              this.$results.find(".select2-results__message").remove();
            };
            Results.prototype.append = function(data) {
              this.hideLoading();
              var $options = [];
              if (data.results == null || data.results.length === 0) {
                if (this.$results.children().length === 0) {
                  this.trigger("results:message", {
                    message: "noResults"
                  });
                }
                return;
              }
              data.results = this.sort(data.results);
              for (var d = 0; d < data.results.length; d++) {
                var item = data.results[d];
                var $option = this.option(item);
                $options.push($option);
              }
              this.$results.append($options);
            };
            Results.prototype.position = function($results, $dropdown) {
              var $resultsContainer = $dropdown.find(".select2-results");
              $resultsContainer.append($results);
            };
            Results.prototype.sort = function(data) {
              var sorter = this.options.get("sorter");
              return sorter(data);
            };
            Results.prototype.highlightFirstItem = function() {
              var $options = this.$results.find(".select2-results__option--selectable");
              var $selected = $options.filter(".select2-results__option--selected");
              if ($selected.length > 0) {
                $selected.first().trigger("mouseenter");
              } else {
                $options.first().trigger("mouseenter");
              }
              this.ensureHighlightVisible();
            };
            Results.prototype.setClasses = function() {
              var self2 = this;
              this.data.current(function(selected) {
                var selectedIds = selected.map(function(s) {
                  return s.id.toString();
                });
                var $options = self2.$results.find(".select2-results__option--selectable");
                $options.each(function() {
                  var $option = $3(this);
                  var item = Utils.GetData(this, "data");
                  var id = "" + item.id;
                  if (item.element != null && item.element.selected || item.element == null && selectedIds.indexOf(id) > -1) {
                    this.classList.add("select2-results__option--selected");
                    $option.attr("aria-selected", "true");
                  } else {
                    this.classList.remove("select2-results__option--selected");
                    $option.attr("aria-selected", "false");
                  }
                });
              });
            };
            Results.prototype.showLoading = function(params) {
              this.hideLoading();
              var loadingMore = this.options.get("translations").get("searching");
              var loading = {
                disabled: true,
                loading: true,
                text: loadingMore(params)
              };
              var $loading = this.option(loading);
              $loading.className += " loading-results";
              this.$results.prepend($loading);
            };
            Results.prototype.hideLoading = function() {
              this.$results.find(".loading-results").remove();
            };
            Results.prototype.option = function(data) {
              var option = document.createElement("li");
              option.classList.add("select2-results__option");
              option.classList.add("select2-results__option--selectable");
              var attrs = {
                "role": "option"
              };
              var matches2 = window.Element.prototype.matches || window.Element.prototype.msMatchesSelector || window.Element.prototype.webkitMatchesSelector;
              if (data.element != null && matches2.call(data.element, ":disabled") || data.element == null && data.disabled) {
                attrs["aria-disabled"] = "true";
                option.classList.remove("select2-results__option--selectable");
                option.classList.add("select2-results__option--disabled");
              }
              if (data.id == null) {
                option.classList.remove("select2-results__option--selectable");
              }
              if (data._resultId != null) {
                option.id = data._resultId;
              }
              if (data.title) {
                option.title = data.title;
              }
              if (data.children) {
                attrs.role = "group";
                attrs["aria-label"] = data.text;
                option.classList.remove("select2-results__option--selectable");
                option.classList.add("select2-results__option--group");
              }
              for (var attr in attrs) {
                var val = attrs[attr];
                option.setAttribute(attr, val);
              }
              if (data.children) {
                var $option = $3(option);
                var label = document.createElement("strong");
                label.className = "select2-results__group";
                this.template(data, label);
                var $children = [];
                for (var c = 0; c < data.children.length; c++) {
                  var child = data.children[c];
                  var $child = this.option(child);
                  $children.push($child);
                }
                var $childrenContainer = $3("<ul></ul>", {
                  "class": "select2-results__options select2-results__options--nested",
                  "role": "none"
                });
                $childrenContainer.append($children);
                $option.append(label);
                $option.append($childrenContainer);
              } else {
                this.template(data, option);
              }
              Utils.StoreData(option, "data", data);
              return option;
            };
            Results.prototype.bind = function(container, $container) {
              var self2 = this;
              var id = container.id + "-results";
              this.$results.attr("id", id);
              container.on("results:all", function(params) {
                self2.clear();
                self2.append(params.data);
                if (container.isOpen()) {
                  self2.setClasses();
                  self2.highlightFirstItem();
                }
              });
              container.on("results:append", function(params) {
                self2.append(params.data);
                if (container.isOpen()) {
                  self2.setClasses();
                }
              });
              container.on("query", function(params) {
                self2.hideMessages();
                self2.showLoading(params);
              });
              container.on("select", function() {
                if (!container.isOpen()) {
                  return;
                }
                self2.setClasses();
                if (self2.options.get("scrollAfterSelect")) {
                  self2.highlightFirstItem();
                }
              });
              container.on("unselect", function() {
                if (!container.isOpen()) {
                  return;
                }
                self2.setClasses();
                if (self2.options.get("scrollAfterSelect")) {
                  self2.highlightFirstItem();
                }
              });
              container.on("open", function() {
                self2.$results.attr("aria-expanded", "true");
                self2.$results.attr("aria-hidden", "false");
                self2.setClasses();
                self2.ensureHighlightVisible();
              });
              container.on("close", function() {
                self2.$results.attr("aria-expanded", "false");
                self2.$results.attr("aria-hidden", "true");
                self2.$results.removeAttr("aria-activedescendant");
              });
              container.on("results:toggle", function() {
                var $highlighted = self2.getHighlightedResults();
                if ($highlighted.length === 0) {
                  return;
                }
                $highlighted.trigger("mouseup");
              });
              container.on("results:select", function() {
                var $highlighted = self2.getHighlightedResults();
                if ($highlighted.length === 0) {
                  return;
                }
                var data = Utils.GetData($highlighted[0], "data");
                if ($highlighted.hasClass("select2-results__option--selected")) {
                  self2.trigger("close", {});
                } else {
                  self2.trigger("select", {
                    data
                  });
                }
              });
              container.on("results:previous", function() {
                var $highlighted = self2.getHighlightedResults();
                var $options = self2.$results.find(".select2-results__option--selectable");
                var currentIndex = $options.index($highlighted);
                if (currentIndex <= 0) {
                  return;
                }
                var nextIndex = currentIndex - 1;
                if ($highlighted.length === 0) {
                  nextIndex = 0;
                }
                var $next = $options.eq(nextIndex);
                $next.trigger("mouseenter");
                var currentOffset = self2.$results.offset().top;
                var nextTop = $next.offset().top;
                var nextOffset = self2.$results.scrollTop() + (nextTop - currentOffset);
                if (nextIndex === 0) {
                  self2.$results.scrollTop(0);
                } else if (nextTop - currentOffset < 0) {
                  self2.$results.scrollTop(nextOffset);
                }
              });
              container.on("results:next", function() {
                var $highlighted = self2.getHighlightedResults();
                var $options = self2.$results.find(".select2-results__option--selectable");
                var currentIndex = $options.index($highlighted);
                var nextIndex = currentIndex + 1;
                if (nextIndex >= $options.length) {
                  return;
                }
                var $next = $options.eq(nextIndex);
                $next.trigger("mouseenter");
                var currentOffset = self2.$results.offset().top + self2.$results.outerHeight(false);
                var nextBottom = $next.offset().top + $next.outerHeight(false);
                var nextOffset = self2.$results.scrollTop() + nextBottom - currentOffset;
                if (nextIndex === 0) {
                  self2.$results.scrollTop(0);
                } else if (nextBottom > currentOffset) {
                  self2.$results.scrollTop(nextOffset);
                }
              });
              container.on("results:focus", function(params) {
                params.element[0].classList.add("select2-results__option--highlighted");
                params.element[0].setAttribute("aria-selected", "true");
              });
              container.on("results:message", function(params) {
                self2.displayMessage(params);
              });
              if ($3.fn.mousewheel) {
                this.$results.on("mousewheel", function(e) {
                  var top = self2.$results.scrollTop();
                  var bottom = self2.$results.get(0).scrollHeight - top + e.deltaY;
                  var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
                  var isAtBottom = e.deltaY < 0 && bottom <= self2.$results.height();
                  if (isAtTop) {
                    self2.$results.scrollTop(0);
                    e.preventDefault();
                    e.stopPropagation();
                  } else if (isAtBottom) {
                    self2.$results.scrollTop(
                      self2.$results.get(0).scrollHeight - self2.$results.height()
                    );
                    e.preventDefault();
                    e.stopPropagation();
                  }
                });
              }
              this.$results.on(
                "mouseup",
                ".select2-results__option--selectable",
                function(evt) {
                  var $this = $3(this);
                  var data = Utils.GetData(this, "data");
                  if ($this.hasClass("select2-results__option--selected")) {
                    if (self2.options.get("multiple")) {
                      self2.trigger("unselect", {
                        originalEvent: evt,
                        data
                      });
                    } else {
                      self2.trigger("close", {});
                    }
                    return;
                  }
                  self2.trigger("select", {
                    originalEvent: evt,
                    data
                  });
                }
              );
              this.$results.on(
                "mouseenter",
                ".select2-results__option--selectable",
                function(evt) {
                  var data = Utils.GetData(this, "data");
                  self2.getHighlightedResults().removeClass("select2-results__option--highlighted").attr("aria-selected", "false");
                  self2.trigger("results:focus", {
                    data,
                    element: $3(this)
                  });
                }
              );
            };
            Results.prototype.getHighlightedResults = function() {
              var $highlighted = this.$results.find(".select2-results__option--highlighted");
              return $highlighted;
            };
            Results.prototype.destroy = function() {
              this.$results.remove();
            };
            Results.prototype.ensureHighlightVisible = function() {
              var $highlighted = this.getHighlightedResults();
              if ($highlighted.length === 0) {
                return;
              }
              var $options = this.$results.find(".select2-results__option--selectable");
              var currentIndex = $options.index($highlighted);
              var currentOffset = this.$results.offset().top;
              var nextTop = $highlighted.offset().top;
              var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);
              var offsetDelta = nextTop - currentOffset;
              nextOffset -= $highlighted.outerHeight(false) * 2;
              if (currentIndex <= 2) {
                this.$results.scrollTop(0);
              } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
                this.$results.scrollTop(nextOffset);
              }
            };
            Results.prototype.template = function(result, container) {
              var template = this.options.get("templateResult");
              var escapeMarkup = this.options.get("escapeMarkup");
              var content = template(result, container);
              if (content == null) {
                container.style.display = "none";
              } else if (typeof content === "string") {
                container.innerHTML = escapeMarkup(content);
              } else {
                $3(container).append(content);
              }
            };
            return Results;
          });
          S22.define("select2/keys", [], function() {
            var KEYS = {
              BACKSPACE: 8,
              TAB: 9,
              ENTER: 13,
              SHIFT: 16,
              CTRL: 17,
              ALT: 18,
              ESC: 27,
              SPACE: 32,
              PAGE_UP: 33,
              PAGE_DOWN: 34,
              END: 35,
              HOME: 36,
              LEFT: 37,
              UP: 38,
              RIGHT: 39,
              DOWN: 40,
              DELETE: 46
            };
            return KEYS;
          });
          S22.define("select2/selection/base", [
            "jquery",
            "../utils",
            "../keys"
          ], function($3, Utils, KEYS) {
            function BaseSelection($element, options) {
              this.$element = $element;
              this.options = options;
              BaseSelection.__super__.constructor.call(this);
            }
            Utils.Extend(BaseSelection, Utils.Observable);
            BaseSelection.prototype.render = function() {
              var $selection = $3(
                '<span class="select2-selection" role="combobox"  aria-haspopup="true" aria-expanded="false"></span>'
              );
              this._tabindex = 0;
              if (Utils.GetData(this.$element[0], "old-tabindex") != null) {
                this._tabindex = Utils.GetData(this.$element[0], "old-tabindex");
              } else if (this.$element.attr("tabindex") != null) {
                this._tabindex = this.$element.attr("tabindex");
              }
              $selection.attr("title", this.$element.attr("title"));
              $selection.attr("tabindex", this._tabindex);
              $selection.attr("aria-disabled", "false");
              this.$selection = $selection;
              return $selection;
            };
            BaseSelection.prototype.bind = function(container, $container) {
              var self2 = this;
              var resultsId = container.id + "-results";
              this.container = container;
              this.$selection.on("focus", function(evt) {
                self2.trigger("focus", evt);
              });
              this.$selection.on("blur", function(evt) {
                self2._handleBlur(evt);
              });
              this.$selection.on("keydown", function(evt) {
                self2.trigger("keypress", evt);
                if (evt.which === KEYS.SPACE) {
                  evt.preventDefault();
                }
              });
              container.on("results:focus", function(params) {
                self2.$selection.attr("aria-activedescendant", params.data._resultId);
              });
              container.on("selection:update", function(params) {
                self2.update(params.data);
              });
              container.on("open", function() {
                self2.$selection.attr("aria-expanded", "true");
                self2.$selection.attr("aria-owns", resultsId);
                self2._attachCloseHandler(container);
              });
              container.on("close", function() {
                self2.$selection.attr("aria-expanded", "false");
                self2.$selection.removeAttr("aria-activedescendant");
                self2.$selection.removeAttr("aria-owns");
                self2.$selection.trigger("focus");
                self2._detachCloseHandler(container);
              });
              container.on("enable", function() {
                self2.$selection.attr("tabindex", self2._tabindex);
                self2.$selection.attr("aria-disabled", "false");
              });
              container.on("disable", function() {
                self2.$selection.attr("tabindex", "-1");
                self2.$selection.attr("aria-disabled", "true");
              });
            };
            BaseSelection.prototype._handleBlur = function(evt) {
              var self2 = this;
              window.setTimeout(function() {
                if (document.activeElement == self2.$selection[0] || $3.contains(self2.$selection[0], document.activeElement)) {
                  return;
                }
                self2.trigger("blur", evt);
              }, 1);
            };
            BaseSelection.prototype._attachCloseHandler = function(container) {
              $3(document.body).on("mousedown.select2." + container.id, function(e) {
                var $target = $3(e.target);
                var $select = $target.closest(".select2");
                var $all = $3(".select2.select2-container--open");
                $all.each(function() {
                  if (this == $select[0]) {
                    return;
                  }
                  var $element = Utils.GetData(this, "element");
                  $element.select2("close");
                });
              });
            };
            BaseSelection.prototype._detachCloseHandler = function(container) {
              $3(document.body).off("mousedown.select2." + container.id);
            };
            BaseSelection.prototype.position = function($selection, $container) {
              var $selectionContainer = $container.find(".selection");
              $selectionContainer.append($selection);
            };
            BaseSelection.prototype.destroy = function() {
              this._detachCloseHandler(this.container);
            };
            BaseSelection.prototype.update = function(data) {
              throw new Error("The `update` method must be defined in child classes.");
            };
            BaseSelection.prototype.isEnabled = function() {
              return !this.isDisabled();
            };
            BaseSelection.prototype.isDisabled = function() {
              return this.options.get("disabled");
            };
            return BaseSelection;
          });
          S22.define("select2/selection/single", [
            "jquery",
            "./base",
            "../utils",
            "../keys"
          ], function($3, BaseSelection, Utils, KEYS) {
            function SingleSelection() {
              SingleSelection.__super__.constructor.apply(this, arguments);
            }
            Utils.Extend(SingleSelection, BaseSelection);
            SingleSelection.prototype.render = function() {
              var $selection = SingleSelection.__super__.render.call(this);
              $selection[0].classList.add("select2-selection--single");
              $selection.html(
                '<span class="select2-selection__rendered"></span><span class="select2-selection__arrow" role="presentation"><b role="presentation"></b></span>'
              );
              return $selection;
            };
            SingleSelection.prototype.bind = function(container, $container) {
              var self2 = this;
              SingleSelection.__super__.bind.apply(this, arguments);
              var id = container.id + "-container";
              this.$selection.find(".select2-selection__rendered").attr("id", id).attr("role", "textbox").attr("aria-readonly", "true");
              this.$selection.attr("aria-labelledby", id);
              this.$selection.attr("aria-controls", id);
              this.$selection.on("mousedown", function(evt) {
                if (evt.which !== 1) {
                  return;
                }
                self2.trigger("toggle", {
                  originalEvent: evt
                });
              });
              this.$selection.on("focus", function(evt) {
              });
              this.$selection.on("blur", function(evt) {
              });
              container.on("focus", function(evt) {
                if (!container.isOpen()) {
                  self2.$selection.trigger("focus");
                }
              });
            };
            SingleSelection.prototype.clear = function() {
              var $rendered = this.$selection.find(".select2-selection__rendered");
              $rendered.empty();
              $rendered.removeAttr("title");
            };
            SingleSelection.prototype.display = function(data, container) {
              var template = this.options.get("templateSelection");
              var escapeMarkup = this.options.get("escapeMarkup");
              return escapeMarkup(template(data, container));
            };
            SingleSelection.prototype.selectionContainer = function() {
              return $3("<span></span>");
            };
            SingleSelection.prototype.update = function(data) {
              if (data.length === 0) {
                this.clear();
                return;
              }
              var selection = data[0];
              var $rendered = this.$selection.find(".select2-selection__rendered");
              var formatted = this.display(selection, $rendered);
              $rendered.empty().append(formatted);
              var title = selection.title || selection.text;
              if (title) {
                $rendered.attr("title", title);
              } else {
                $rendered.removeAttr("title");
              }
            };
            return SingleSelection;
          });
          S22.define("select2/selection/multiple", [
            "jquery",
            "./base",
            "../utils"
          ], function($3, BaseSelection, Utils) {
            function MultipleSelection($element, options) {
              MultipleSelection.__super__.constructor.apply(this, arguments);
            }
            Utils.Extend(MultipleSelection, BaseSelection);
            MultipleSelection.prototype.render = function() {
              var $selection = MultipleSelection.__super__.render.call(this);
              $selection[0].classList.add("select2-selection--multiple");
              $selection.html(
                '<ul class="select2-selection__rendered"></ul>'
              );
              return $selection;
            };
            MultipleSelection.prototype.bind = function(container, $container) {
              var self2 = this;
              MultipleSelection.__super__.bind.apply(this, arguments);
              var id = container.id + "-container";
              this.$selection.find(".select2-selection__rendered").attr("id", id);
              this.$selection.on("click", function(evt) {
                self2.trigger("toggle", {
                  originalEvent: evt
                });
              });
              this.$selection.on(
                "click",
                ".select2-selection__choice__remove",
                function(evt) {
                  if (self2.isDisabled()) {
                    return;
                  }
                  var $remove = $3(this);
                  var $selection = $remove.parent();
                  var data = Utils.GetData($selection[0], "data");
                  self2.trigger("unselect", {
                    originalEvent: evt,
                    data
                  });
                }
              );
              this.$selection.on(
                "keydown",
                ".select2-selection__choice__remove",
                function(evt) {
                  if (self2.isDisabled()) {
                    return;
                  }
                  evt.stopPropagation();
                }
              );
            };
            MultipleSelection.prototype.clear = function() {
              var $rendered = this.$selection.find(".select2-selection__rendered");
              $rendered.empty();
              $rendered.removeAttr("title");
            };
            MultipleSelection.prototype.display = function(data, container) {
              var template = this.options.get("templateSelection");
              var escapeMarkup = this.options.get("escapeMarkup");
              return escapeMarkup(template(data, container));
            };
            MultipleSelection.prototype.selectionContainer = function() {
              var $container = $3(
                '<li class="select2-selection__choice"><button type="button" class="select2-selection__choice__remove" tabindex="-1"><span aria-hidden="true">&times;</span></button><span class="select2-selection__choice__display"></span></li>'
              );
              return $container;
            };
            MultipleSelection.prototype.update = function(data) {
              this.clear();
              if (data.length === 0) {
                return;
              }
              var $selections = [];
              var selectionIdPrefix = this.$selection.find(".select2-selection__rendered").attr("id") + "-choice-";
              for (var d = 0; d < data.length; d++) {
                var selection = data[d];
                var $selection = this.selectionContainer();
                var formatted = this.display(selection, $selection);
                var selectionId = selectionIdPrefix + Utils.generateChars(4) + "-";
                if (selection.id) {
                  selectionId += selection.id;
                } else {
                  selectionId += Utils.generateChars(4);
                }
                $selection.find(".select2-selection__choice__display").append(formatted).attr("id", selectionId);
                var title = selection.title || selection.text;
                if (title) {
                  $selection.attr("title", title);
                }
                var removeItem = this.options.get("translations").get("removeItem");
                var $remove = $selection.find(".select2-selection__choice__remove");
                $remove.attr("title", removeItem());
                $remove.attr("aria-label", removeItem());
                $remove.attr("aria-describedby", selectionId);
                Utils.StoreData($selection[0], "data", selection);
                $selections.push($selection);
              }
              var $rendered = this.$selection.find(".select2-selection__rendered");
              $rendered.append($selections);
            };
            return MultipleSelection;
          });
          S22.define("select2/selection/placeholder", [], function() {
            function Placeholder(decorated, $element, options) {
              this.placeholder = this.normalizePlaceholder(options.get("placeholder"));
              decorated.call(this, $element, options);
            }
            Placeholder.prototype.normalizePlaceholder = function(_2, placeholder) {
              if (typeof placeholder === "string") {
                placeholder = {
                  id: "",
                  text: placeholder
                };
              }
              return placeholder;
            };
            Placeholder.prototype.createPlaceholder = function(decorated, placeholder) {
              var $placeholder = this.selectionContainer();
              $placeholder.html(this.display(placeholder));
              $placeholder[0].classList.add("select2-selection__placeholder");
              $placeholder[0].classList.remove("select2-selection__choice");
              var placeholderTitle = placeholder.title || placeholder.text || $placeholder.text();
              this.$selection.find(".select2-selection__rendered").attr(
                "title",
                placeholderTitle
              );
              return $placeholder;
            };
            Placeholder.prototype.update = function(decorated, data) {
              var singlePlaceholder = data.length == 1 && data[0].id != this.placeholder.id;
              var multipleSelections = data.length > 1;
              if (multipleSelections || singlePlaceholder) {
                return decorated.call(this, data);
              }
              this.clear();
              var $placeholder = this.createPlaceholder(this.placeholder);
              this.$selection.find(".select2-selection__rendered").append($placeholder);
            };
            return Placeholder;
          });
          S22.define("select2/selection/allowClear", [
            "jquery",
            "../keys",
            "../utils"
          ], function($3, KEYS, Utils) {
            function AllowClear() {
            }
            AllowClear.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              if (this.placeholder == null) {
                if (this.options.get("debug") && window.console && console.error) {
                  console.error(
                    "Select2: The `allowClear` option should be used in combination with the `placeholder` option."
                  );
                }
              }
              this.$selection.on(
                "mousedown",
                ".select2-selection__clear",
                function(evt) {
                  self2._handleClear(evt);
                }
              );
              container.on("keypress", function(evt) {
                self2._handleKeyboardClear(evt, container);
              });
            };
            AllowClear.prototype._handleClear = function(_2, evt) {
              if (this.isDisabled()) {
                return;
              }
              var $clear = this.$selection.find(".select2-selection__clear");
              if ($clear.length === 0) {
                return;
              }
              evt.stopPropagation();
              var data = Utils.GetData($clear[0], "data");
              var previousVal = this.$element.val();
              this.$element.val(this.placeholder.id);
              var unselectData = {
                data
              };
              this.trigger("clear", unselectData);
              if (unselectData.prevented) {
                this.$element.val(previousVal);
                return;
              }
              for (var d = 0; d < data.length; d++) {
                unselectData = {
                  data: data[d]
                };
                this.trigger("unselect", unselectData);
                if (unselectData.prevented) {
                  this.$element.val(previousVal);
                  return;
                }
              }
              this.$element.trigger("input").trigger("change");
              this.trigger("toggle", {});
            };
            AllowClear.prototype._handleKeyboardClear = function(_2, evt, container) {
              if (container.isOpen()) {
                return;
              }
              if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
                this._handleClear(evt);
              }
            };
            AllowClear.prototype.update = function(decorated, data) {
              decorated.call(this, data);
              this.$selection.find(".select2-selection__clear").remove();
              this.$selection[0].classList.remove("select2-selection--clearable");
              if (this.$selection.find(".select2-selection__placeholder").length > 0 || data.length === 0) {
                return;
              }
              var selectionId = this.$selection.find(".select2-selection__rendered").attr("id");
              var removeAll = this.options.get("translations").get("removeAllItems");
              var $remove = $3(
                '<button type="button" class="select2-selection__clear" tabindex="-1"><span aria-hidden="true">&times;</span></button>'
              );
              $remove.attr("title", removeAll());
              $remove.attr("aria-label", removeAll());
              $remove.attr("aria-describedby", selectionId);
              Utils.StoreData($remove[0], "data", data);
              this.$selection.prepend($remove);
              this.$selection[0].classList.add("select2-selection--clearable");
            };
            return AllowClear;
          });
          S22.define("select2/selection/search", [
            "jquery",
            "../utils",
            "../keys"
          ], function($3, Utils, KEYS) {
            function Search(decorated, $element, options) {
              decorated.call(this, $element, options);
            }
            Search.prototype.render = function(decorated) {
              var searchLabel = this.options.get("translations").get("search");
              var $search = $3(
                '<span class="select2-search select2-search--inline"><textarea class="select2-search__field" type="search" tabindex="-1" autocorrect="off" autocapitalize="none" spellcheck="false" role="searchbox" aria-autocomplete="list" ></textarea></span>'
              );
              this.$searchContainer = $search;
              this.$search = $search.find("textarea");
              this.$search.prop("autocomplete", this.options.get("autocomplete"));
              this.$search.attr("aria-label", searchLabel());
              var $rendered = decorated.call(this);
              this._transferTabIndex();
              $rendered.append(this.$searchContainer);
              return $rendered;
            };
            Search.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              var resultsId = container.id + "-results";
              var selectionId = container.id + "-container";
              decorated.call(this, container, $container);
              self2.$search.attr("aria-describedby", selectionId);
              container.on("open", function() {
                self2.$search.attr("aria-controls", resultsId);
                self2.$search.trigger("focus");
              });
              container.on("close", function() {
                self2.$search.val("");
                self2.resizeSearch();
                self2.$search.removeAttr("aria-controls");
                self2.$search.removeAttr("aria-activedescendant");
                self2.$search.trigger("focus");
              });
              container.on("enable", function() {
                self2.$search.prop("disabled", false);
                self2._transferTabIndex();
              });
              container.on("disable", function() {
                self2.$search.prop("disabled", true);
              });
              container.on("focus", function(evt) {
                self2.$search.trigger("focus");
              });
              container.on("results:focus", function(params) {
                if (params.data._resultId) {
                  self2.$search.attr("aria-activedescendant", params.data._resultId);
                } else {
                  self2.$search.removeAttr("aria-activedescendant");
                }
              });
              this.$selection.on("focusin", ".select2-search--inline", function(evt) {
                self2.trigger("focus", evt);
              });
              this.$selection.on("focusout", ".select2-search--inline", function(evt) {
                self2._handleBlur(evt);
              });
              this.$selection.on("keydown", ".select2-search--inline", function(evt) {
                evt.stopPropagation();
                self2.trigger("keypress", evt);
                self2._keyUpPrevented = evt.isDefaultPrevented();
                var key = evt.which;
                if (key === KEYS.BACKSPACE && self2.$search.val() === "") {
                  var $previousChoice = self2.$selection.find(".select2-selection__choice").last();
                  if ($previousChoice.length > 0) {
                    var item = Utils.GetData($previousChoice[0], "data");
                    self2.searchRemoveChoice(item);
                    evt.preventDefault();
                  }
                }
              });
              this.$selection.on("click", ".select2-search--inline", function(evt) {
                if (self2.$search.val()) {
                  evt.stopPropagation();
                }
              });
              var msie = document.documentMode;
              var disableInputEvents = msie && msie <= 11;
              this.$selection.on(
                "input.searchcheck",
                ".select2-search--inline",
                function(evt) {
                  if (disableInputEvents) {
                    self2.$selection.off("input.search input.searchcheck");
                    return;
                  }
                  self2.$selection.off("keyup.search");
                }
              );
              this.$selection.on(
                "keyup.search input.search",
                ".select2-search--inline",
                function(evt) {
                  if (disableInputEvents && evt.type === "input") {
                    self2.$selection.off("input.search input.searchcheck");
                    return;
                  }
                  var key = evt.which;
                  if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
                    return;
                  }
                  if (key == KEYS.TAB) {
                    return;
                  }
                  self2.handleSearch(evt);
                }
              );
            };
            Search.prototype._transferTabIndex = function(decorated) {
              this.$search.attr("tabindex", this.$selection.attr("tabindex"));
              this.$selection.attr("tabindex", "-1");
            };
            Search.prototype.createPlaceholder = function(decorated, placeholder) {
              this.$search.attr("placeholder", placeholder.text);
            };
            Search.prototype.update = function(decorated, data) {
              var searchHadFocus = this.$search[0] == document.activeElement;
              this.$search.attr("placeholder", "");
              decorated.call(this, data);
              this.resizeSearch();
              if (searchHadFocus) {
                this.$search.trigger("focus");
              }
            };
            Search.prototype.handleSearch = function() {
              this.resizeSearch();
              if (!this._keyUpPrevented) {
                var input = this.$search.val();
                this.trigger("query", {
                  term: input
                });
              }
              this._keyUpPrevented = false;
            };
            Search.prototype.searchRemoveChoice = function(decorated, item) {
              this.trigger("unselect", {
                data: item
              });
              this.$search.val(item.text);
              this.handleSearch();
            };
            Search.prototype.resizeSearch = function() {
              this.$search.css("width", "25px");
              var width = "100%";
              if (this.$search.attr("placeholder") === "") {
                var minimumWidth = this.$search.val().length + 1;
                width = minimumWidth * 0.75 + "em";
              }
              this.$search.css("width", width);
            };
            return Search;
          });
          S22.define("select2/selection/selectionCss", [
            "../utils"
          ], function(Utils) {
            function SelectionCSS() {
            }
            SelectionCSS.prototype.render = function(decorated) {
              var $selection = decorated.call(this);
              var selectionCssClass = this.options.get("selectionCssClass") || "";
              if (selectionCssClass.indexOf(":all:") !== -1) {
                selectionCssClass = selectionCssClass.replace(":all:", "");
                Utils.copyNonInternalCssClasses($selection[0], this.$element[0]);
              }
              $selection.addClass(selectionCssClass);
              return $selection;
            };
            return SelectionCSS;
          });
          S22.define("select2/selection/eventRelay", [
            "jquery"
          ], function($3) {
            function EventRelay() {
            }
            EventRelay.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              var relayEvents = [
                "open",
                "opening",
                "close",
                "closing",
                "select",
                "selecting",
                "unselect",
                "unselecting",
                "clear",
                "clearing"
              ];
              var preventableEvents = [
                "opening",
                "closing",
                "selecting",
                "unselecting",
                "clearing"
              ];
              decorated.call(this, container, $container);
              container.on("*", function(name, params) {
                if (relayEvents.indexOf(name) === -1) {
                  return;
                }
                params = params || {};
                var evt = $3.Event("select2:" + name, {
                  params
                });
                self2.$element.trigger(evt);
                if (preventableEvents.indexOf(name) === -1) {
                  return;
                }
                params.prevented = evt.isDefaultPrevented();
              });
            };
            return EventRelay;
          });
          S22.define("select2/translation", [
            "jquery",
            "require"
          ], function($3, require2) {
            function Translation(dict) {
              this.dict = dict || {};
            }
            Translation.prototype.all = function() {
              return this.dict;
            };
            Translation.prototype.get = function(key) {
              return this.dict[key];
            };
            Translation.prototype.extend = function(translation) {
              this.dict = $3.extend({}, translation.all(), this.dict);
            };
            Translation._cache = {};
            Translation.loadPath = function(path) {
              if (!(path in Translation._cache)) {
                var translations = require2(path);
                Translation._cache[path] = translations;
              }
              return new Translation(Translation._cache[path]);
            };
            return Translation;
          });
          S22.define("select2/diacritics", [], function() {
            var diacritics = {
              "\u24B6": "A",
              "\uFF21": "A",
              "\xC0": "A",
              "\xC1": "A",
              "\xC2": "A",
              "\u1EA6": "A",
              "\u1EA4": "A",
              "\u1EAA": "A",
              "\u1EA8": "A",
              "\xC3": "A",
              "\u0100": "A",
              "\u0102": "A",
              "\u1EB0": "A",
              "\u1EAE": "A",
              "\u1EB4": "A",
              "\u1EB2": "A",
              "\u0226": "A",
              "\u01E0": "A",
              "\xC4": "A",
              "\u01DE": "A",
              "\u1EA2": "A",
              "\xC5": "A",
              "\u01FA": "A",
              "\u01CD": "A",
              "\u0200": "A",
              "\u0202": "A",
              "\u1EA0": "A",
              "\u1EAC": "A",
              "\u1EB6": "A",
              "\u1E00": "A",
              "\u0104": "A",
              "\u023A": "A",
              "\u2C6F": "A",
              "\uA732": "AA",
              "\xC6": "AE",
              "\u01FC": "AE",
              "\u01E2": "AE",
              "\uA734": "AO",
              "\uA736": "AU",
              "\uA738": "AV",
              "\uA73A": "AV",
              "\uA73C": "AY",
              "\u24B7": "B",
              "\uFF22": "B",
              "\u1E02": "B",
              "\u1E04": "B",
              "\u1E06": "B",
              "\u0243": "B",
              "\u0182": "B",
              "\u0181": "B",
              "\u24B8": "C",
              "\uFF23": "C",
              "\u0106": "C",
              "\u0108": "C",
              "\u010A": "C",
              "\u010C": "C",
              "\xC7": "C",
              "\u1E08": "C",
              "\u0187": "C",
              "\u023B": "C",
              "\uA73E": "C",
              "\u24B9": "D",
              "\uFF24": "D",
              "\u1E0A": "D",
              "\u010E": "D",
              "\u1E0C": "D",
              "\u1E10": "D",
              "\u1E12": "D",
              "\u1E0E": "D",
              "\u0110": "D",
              "\u018B": "D",
              "\u018A": "D",
              "\u0189": "D",
              "\uA779": "D",
              "\u01F1": "DZ",
              "\u01C4": "DZ",
              "\u01F2": "Dz",
              "\u01C5": "Dz",
              "\u24BA": "E",
              "\uFF25": "E",
              "\xC8": "E",
              "\xC9": "E",
              "\xCA": "E",
              "\u1EC0": "E",
              "\u1EBE": "E",
              "\u1EC4": "E",
              "\u1EC2": "E",
              "\u1EBC": "E",
              "\u0112": "E",
              "\u1E14": "E",
              "\u1E16": "E",
              "\u0114": "E",
              "\u0116": "E",
              "\xCB": "E",
              "\u1EBA": "E",
              "\u011A": "E",
              "\u0204": "E",
              "\u0206": "E",
              "\u1EB8": "E",
              "\u1EC6": "E",
              "\u0228": "E",
              "\u1E1C": "E",
              "\u0118": "E",
              "\u1E18": "E",
              "\u1E1A": "E",
              "\u0190": "E",
              "\u018E": "E",
              "\u24BB": "F",
              "\uFF26": "F",
              "\u1E1E": "F",
              "\u0191": "F",
              "\uA77B": "F",
              "\u24BC": "G",
              "\uFF27": "G",
              "\u01F4": "G",
              "\u011C": "G",
              "\u1E20": "G",
              "\u011E": "G",
              "\u0120": "G",
              "\u01E6": "G",
              "\u0122": "G",
              "\u01E4": "G",
              "\u0193": "G",
              "\uA7A0": "G",
              "\uA77D": "G",
              "\uA77E": "G",
              "\u24BD": "H",
              "\uFF28": "H",
              "\u0124": "H",
              "\u1E22": "H",
              "\u1E26": "H",
              "\u021E": "H",
              "\u1E24": "H",
              "\u1E28": "H",
              "\u1E2A": "H",
              "\u0126": "H",
              "\u2C67": "H",
              "\u2C75": "H",
              "\uA78D": "H",
              "\u24BE": "I",
              "\uFF29": "I",
              "\xCC": "I",
              "\xCD": "I",
              "\xCE": "I",
              "\u0128": "I",
              "\u012A": "I",
              "\u012C": "I",
              "\u0130": "I",
              "\xCF": "I",
              "\u1E2E": "I",
              "\u1EC8": "I",
              "\u01CF": "I",
              "\u0208": "I",
              "\u020A": "I",
              "\u1ECA": "I",
              "\u012E": "I",
              "\u1E2C": "I",
              "\u0197": "I",
              "\u24BF": "J",
              "\uFF2A": "J",
              "\u0134": "J",
              "\u0248": "J",
              "\u24C0": "K",
              "\uFF2B": "K",
              "\u1E30": "K",
              "\u01E8": "K",
              "\u1E32": "K",
              "\u0136": "K",
              "\u1E34": "K",
              "\u0198": "K",
              "\u2C69": "K",
              "\uA740": "K",
              "\uA742": "K",
              "\uA744": "K",
              "\uA7A2": "K",
              "\u24C1": "L",
              "\uFF2C": "L",
              "\u013F": "L",
              "\u0139": "L",
              "\u013D": "L",
              "\u1E36": "L",
              "\u1E38": "L",
              "\u013B": "L",
              "\u1E3C": "L",
              "\u1E3A": "L",
              "\u0141": "L",
              "\u023D": "L",
              "\u2C62": "L",
              "\u2C60": "L",
              "\uA748": "L",
              "\uA746": "L",
              "\uA780": "L",
              "\u01C7": "LJ",
              "\u01C8": "Lj",
              "\u24C2": "M",
              "\uFF2D": "M",
              "\u1E3E": "M",
              "\u1E40": "M",
              "\u1E42": "M",
              "\u2C6E": "M",
              "\u019C": "M",
              "\u24C3": "N",
              "\uFF2E": "N",
              "\u01F8": "N",
              "\u0143": "N",
              "\xD1": "N",
              "\u1E44": "N",
              "\u0147": "N",
              "\u1E46": "N",
              "\u0145": "N",
              "\u1E4A": "N",
              "\u1E48": "N",
              "\u0220": "N",
              "\u019D": "N",
              "\uA790": "N",
              "\uA7A4": "N",
              "\u01CA": "NJ",
              "\u01CB": "Nj",
              "\u24C4": "O",
              "\uFF2F": "O",
              "\xD2": "O",
              "\xD3": "O",
              "\xD4": "O",
              "\u1ED2": "O",
              "\u1ED0": "O",
              "\u1ED6": "O",
              "\u1ED4": "O",
              "\xD5": "O",
              "\u1E4C": "O",
              "\u022C": "O",
              "\u1E4E": "O",
              "\u014C": "O",
              "\u1E50": "O",
              "\u1E52": "O",
              "\u014E": "O",
              "\u022E": "O",
              "\u0230": "O",
              "\xD6": "O",
              "\u022A": "O",
              "\u1ECE": "O",
              "\u0150": "O",
              "\u01D1": "O",
              "\u020C": "O",
              "\u020E": "O",
              "\u01A0": "O",
              "\u1EDC": "O",
              "\u1EDA": "O",
              "\u1EE0": "O",
              "\u1EDE": "O",
              "\u1EE2": "O",
              "\u1ECC": "O",
              "\u1ED8": "O",
              "\u01EA": "O",
              "\u01EC": "O",
              "\xD8": "O",
              "\u01FE": "O",
              "\u0186": "O",
              "\u019F": "O",
              "\uA74A": "O",
              "\uA74C": "O",
              "\u0152": "OE",
              "\u01A2": "OI",
              "\uA74E": "OO",
              "\u0222": "OU",
              "\u24C5": "P",
              "\uFF30": "P",
              "\u1E54": "P",
              "\u1E56": "P",
              "\u01A4": "P",
              "\u2C63": "P",
              "\uA750": "P",
              "\uA752": "P",
              "\uA754": "P",
              "\u24C6": "Q",
              "\uFF31": "Q",
              "\uA756": "Q",
              "\uA758": "Q",
              "\u024A": "Q",
              "\u24C7": "R",
              "\uFF32": "R",
              "\u0154": "R",
              "\u1E58": "R",
              "\u0158": "R",
              "\u0210": "R",
              "\u0212": "R",
              "\u1E5A": "R",
              "\u1E5C": "R",
              "\u0156": "R",
              "\u1E5E": "R",
              "\u024C": "R",
              "\u2C64": "R",
              "\uA75A": "R",
              "\uA7A6": "R",
              "\uA782": "R",
              "\u24C8": "S",
              "\uFF33": "S",
              "\u1E9E": "S",
              "\u015A": "S",
              "\u1E64": "S",
              "\u015C": "S",
              "\u1E60": "S",
              "\u0160": "S",
              "\u1E66": "S",
              "\u1E62": "S",
              "\u1E68": "S",
              "\u0218": "S",
              "\u015E": "S",
              "\u2C7E": "S",
              "\uA7A8": "S",
              "\uA784": "S",
              "\u24C9": "T",
              "\uFF34": "T",
              "\u1E6A": "T",
              "\u0164": "T",
              "\u1E6C": "T",
              "\u021A": "T",
              "\u0162": "T",
              "\u1E70": "T",
              "\u1E6E": "T",
              "\u0166": "T",
              "\u01AC": "T",
              "\u01AE": "T",
              "\u023E": "T",
              "\uA786": "T",
              "\uA728": "TZ",
              "\u24CA": "U",
              "\uFF35": "U",
              "\xD9": "U",
              "\xDA": "U",
              "\xDB": "U",
              "\u0168": "U",
              "\u1E78": "U",
              "\u016A": "U",
              "\u1E7A": "U",
              "\u016C": "U",
              "\xDC": "U",
              "\u01DB": "U",
              "\u01D7": "U",
              "\u01D5": "U",
              "\u01D9": "U",
              "\u1EE6": "U",
              "\u016E": "U",
              "\u0170": "U",
              "\u01D3": "U",
              "\u0214": "U",
              "\u0216": "U",
              "\u01AF": "U",
              "\u1EEA": "U",
              "\u1EE8": "U",
              "\u1EEE": "U",
              "\u1EEC": "U",
              "\u1EF0": "U",
              "\u1EE4": "U",
              "\u1E72": "U",
              "\u0172": "U",
              "\u1E76": "U",
              "\u1E74": "U",
              "\u0244": "U",
              "\u24CB": "V",
              "\uFF36": "V",
              "\u1E7C": "V",
              "\u1E7E": "V",
              "\u01B2": "V",
              "\uA75E": "V",
              "\u0245": "V",
              "\uA760": "VY",
              "\u24CC": "W",
              "\uFF37": "W",
              "\u1E80": "W",
              "\u1E82": "W",
              "\u0174": "W",
              "\u1E86": "W",
              "\u1E84": "W",
              "\u1E88": "W",
              "\u2C72": "W",
              "\u24CD": "X",
              "\uFF38": "X",
              "\u1E8A": "X",
              "\u1E8C": "X",
              "\u24CE": "Y",
              "\uFF39": "Y",
              "\u1EF2": "Y",
              "\xDD": "Y",
              "\u0176": "Y",
              "\u1EF8": "Y",
              "\u0232": "Y",
              "\u1E8E": "Y",
              "\u0178": "Y",
              "\u1EF6": "Y",
              "\u1EF4": "Y",
              "\u01B3": "Y",
              "\u024E": "Y",
              "\u1EFE": "Y",
              "\u24CF": "Z",
              "\uFF3A": "Z",
              "\u0179": "Z",
              "\u1E90": "Z",
              "\u017B": "Z",
              "\u017D": "Z",
              "\u1E92": "Z",
              "\u1E94": "Z",
              "\u01B5": "Z",
              "\u0224": "Z",
              "\u2C7F": "Z",
              "\u2C6B": "Z",
              "\uA762": "Z",
              "\u24D0": "a",
              "\uFF41": "a",
              "\u1E9A": "a",
              "\xE0": "a",
              "\xE1": "a",
              "\xE2": "a",
              "\u1EA7": "a",
              "\u1EA5": "a",
              "\u1EAB": "a",
              "\u1EA9": "a",
              "\xE3": "a",
              "\u0101": "a",
              "\u0103": "a",
              "\u1EB1": "a",
              "\u1EAF": "a",
              "\u1EB5": "a",
              "\u1EB3": "a",
              "\u0227": "a",
              "\u01E1": "a",
              "\xE4": "a",
              "\u01DF": "a",
              "\u1EA3": "a",
              "\xE5": "a",
              "\u01FB": "a",
              "\u01CE": "a",
              "\u0201": "a",
              "\u0203": "a",
              "\u1EA1": "a",
              "\u1EAD": "a",
              "\u1EB7": "a",
              "\u1E01": "a",
              "\u0105": "a",
              "\u2C65": "a",
              "\u0250": "a",
              "\uA733": "aa",
              "\xE6": "ae",
              "\u01FD": "ae",
              "\u01E3": "ae",
              "\uA735": "ao",
              "\uA737": "au",
              "\uA739": "av",
              "\uA73B": "av",
              "\uA73D": "ay",
              "\u24D1": "b",
              "\uFF42": "b",
              "\u1E03": "b",
              "\u1E05": "b",
              "\u1E07": "b",
              "\u0180": "b",
              "\u0183": "b",
              "\u0253": "b",
              "\u24D2": "c",
              "\uFF43": "c",
              "\u0107": "c",
              "\u0109": "c",
              "\u010B": "c",
              "\u010D": "c",
              "\xE7": "c",
              "\u1E09": "c",
              "\u0188": "c",
              "\u023C": "c",
              "\uA73F": "c",
              "\u2184": "c",
              "\u24D3": "d",
              "\uFF44": "d",
              "\u1E0B": "d",
              "\u010F": "d",
              "\u1E0D": "d",
              "\u1E11": "d",
              "\u1E13": "d",
              "\u1E0F": "d",
              "\u0111": "d",
              "\u018C": "d",
              "\u0256": "d",
              "\u0257": "d",
              "\uA77A": "d",
              "\u01F3": "dz",
              "\u01C6": "dz",
              "\u24D4": "e",
              "\uFF45": "e",
              "\xE8": "e",
              "\xE9": "e",
              "\xEA": "e",
              "\u1EC1": "e",
              "\u1EBF": "e",
              "\u1EC5": "e",
              "\u1EC3": "e",
              "\u1EBD": "e",
              "\u0113": "e",
              "\u1E15": "e",
              "\u1E17": "e",
              "\u0115": "e",
              "\u0117": "e",
              "\xEB": "e",
              "\u1EBB": "e",
              "\u011B": "e",
              "\u0205": "e",
              "\u0207": "e",
              "\u1EB9": "e",
              "\u1EC7": "e",
              "\u0229": "e",
              "\u1E1D": "e",
              "\u0119": "e",
              "\u1E19": "e",
              "\u1E1B": "e",
              "\u0247": "e",
              "\u025B": "e",
              "\u01DD": "e",
              "\u24D5": "f",
              "\uFF46": "f",
              "\u1E1F": "f",
              "\u0192": "f",
              "\uA77C": "f",
              "\u24D6": "g",
              "\uFF47": "g",
              "\u01F5": "g",
              "\u011D": "g",
              "\u1E21": "g",
              "\u011F": "g",
              "\u0121": "g",
              "\u01E7": "g",
              "\u0123": "g",
              "\u01E5": "g",
              "\u0260": "g",
              "\uA7A1": "g",
              "\u1D79": "g",
              "\uA77F": "g",
              "\u24D7": "h",
              "\uFF48": "h",
              "\u0125": "h",
              "\u1E23": "h",
              "\u1E27": "h",
              "\u021F": "h",
              "\u1E25": "h",
              "\u1E29": "h",
              "\u1E2B": "h",
              "\u1E96": "h",
              "\u0127": "h",
              "\u2C68": "h",
              "\u2C76": "h",
              "\u0265": "h",
              "\u0195": "hv",
              "\u24D8": "i",
              "\uFF49": "i",
              "\xEC": "i",
              "\xED": "i",
              "\xEE": "i",
              "\u0129": "i",
              "\u012B": "i",
              "\u012D": "i",
              "\xEF": "i",
              "\u1E2F": "i",
              "\u1EC9": "i",
              "\u01D0": "i",
              "\u0209": "i",
              "\u020B": "i",
              "\u1ECB": "i",
              "\u012F": "i",
              "\u1E2D": "i",
              "\u0268": "i",
              "\u0131": "i",
              "\u24D9": "j",
              "\uFF4A": "j",
              "\u0135": "j",
              "\u01F0": "j",
              "\u0249": "j",
              "\u24DA": "k",
              "\uFF4B": "k",
              "\u1E31": "k",
              "\u01E9": "k",
              "\u1E33": "k",
              "\u0137": "k",
              "\u1E35": "k",
              "\u0199": "k",
              "\u2C6A": "k",
              "\uA741": "k",
              "\uA743": "k",
              "\uA745": "k",
              "\uA7A3": "k",
              "\u24DB": "l",
              "\uFF4C": "l",
              "\u0140": "l",
              "\u013A": "l",
              "\u013E": "l",
              "\u1E37": "l",
              "\u1E39": "l",
              "\u013C": "l",
              "\u1E3D": "l",
              "\u1E3B": "l",
              "\u017F": "l",
              "\u0142": "l",
              "\u019A": "l",
              "\u026B": "l",
              "\u2C61": "l",
              "\uA749": "l",
              "\uA781": "l",
              "\uA747": "l",
              "\u01C9": "lj",
              "\u24DC": "m",
              "\uFF4D": "m",
              "\u1E3F": "m",
              "\u1E41": "m",
              "\u1E43": "m",
              "\u0271": "m",
              "\u026F": "m",
              "\u24DD": "n",
              "\uFF4E": "n",
              "\u01F9": "n",
              "\u0144": "n",
              "\xF1": "n",
              "\u1E45": "n",
              "\u0148": "n",
              "\u1E47": "n",
              "\u0146": "n",
              "\u1E4B": "n",
              "\u1E49": "n",
              "\u019E": "n",
              "\u0272": "n",
              "\u0149": "n",
              "\uA791": "n",
              "\uA7A5": "n",
              "\u01CC": "nj",
              "\u24DE": "o",
              "\uFF4F": "o",
              "\xF2": "o",
              "\xF3": "o",
              "\xF4": "o",
              "\u1ED3": "o",
              "\u1ED1": "o",
              "\u1ED7": "o",
              "\u1ED5": "o",
              "\xF5": "o",
              "\u1E4D": "o",
              "\u022D": "o",
              "\u1E4F": "o",
              "\u014D": "o",
              "\u1E51": "o",
              "\u1E53": "o",
              "\u014F": "o",
              "\u022F": "o",
              "\u0231": "o",
              "\xF6": "o",
              "\u022B": "o",
              "\u1ECF": "o",
              "\u0151": "o",
              "\u01D2": "o",
              "\u020D": "o",
              "\u020F": "o",
              "\u01A1": "o",
              "\u1EDD": "o",
              "\u1EDB": "o",
              "\u1EE1": "o",
              "\u1EDF": "o",
              "\u1EE3": "o",
              "\u1ECD": "o",
              "\u1ED9": "o",
              "\u01EB": "o",
              "\u01ED": "o",
              "\xF8": "o",
              "\u01FF": "o",
              "\u0254": "o",
              "\uA74B": "o",
              "\uA74D": "o",
              "\u0275": "o",
              "\u0153": "oe",
              "\u01A3": "oi",
              "\u0223": "ou",
              "\uA74F": "oo",
              "\u24DF": "p",
              "\uFF50": "p",
              "\u1E55": "p",
              "\u1E57": "p",
              "\u01A5": "p",
              "\u1D7D": "p",
              "\uA751": "p",
              "\uA753": "p",
              "\uA755": "p",
              "\u24E0": "q",
              "\uFF51": "q",
              "\u024B": "q",
              "\uA757": "q",
              "\uA759": "q",
              "\u24E1": "r",
              "\uFF52": "r",
              "\u0155": "r",
              "\u1E59": "r",
              "\u0159": "r",
              "\u0211": "r",
              "\u0213": "r",
              "\u1E5B": "r",
              "\u1E5D": "r",
              "\u0157": "r",
              "\u1E5F": "r",
              "\u024D": "r",
              "\u027D": "r",
              "\uA75B": "r",
              "\uA7A7": "r",
              "\uA783": "r",
              "\u24E2": "s",
              "\uFF53": "s",
              "\xDF": "s",
              "\u015B": "s",
              "\u1E65": "s",
              "\u015D": "s",
              "\u1E61": "s",
              "\u0161": "s",
              "\u1E67": "s",
              "\u1E63": "s",
              "\u1E69": "s",
              "\u0219": "s",
              "\u015F": "s",
              "\u023F": "s",
              "\uA7A9": "s",
              "\uA785": "s",
              "\u1E9B": "s",
              "\u24E3": "t",
              "\uFF54": "t",
              "\u1E6B": "t",
              "\u1E97": "t",
              "\u0165": "t",
              "\u1E6D": "t",
              "\u021B": "t",
              "\u0163": "t",
              "\u1E71": "t",
              "\u1E6F": "t",
              "\u0167": "t",
              "\u01AD": "t",
              "\u0288": "t",
              "\u2C66": "t",
              "\uA787": "t",
              "\uA729": "tz",
              "\u24E4": "u",
              "\uFF55": "u",
              "\xF9": "u",
              "\xFA": "u",
              "\xFB": "u",
              "\u0169": "u",
              "\u1E79": "u",
              "\u016B": "u",
              "\u1E7B": "u",
              "\u016D": "u",
              "\xFC": "u",
              "\u01DC": "u",
              "\u01D8": "u",
              "\u01D6": "u",
              "\u01DA": "u",
              "\u1EE7": "u",
              "\u016F": "u",
              "\u0171": "u",
              "\u01D4": "u",
              "\u0215": "u",
              "\u0217": "u",
              "\u01B0": "u",
              "\u1EEB": "u",
              "\u1EE9": "u",
              "\u1EEF": "u",
              "\u1EED": "u",
              "\u1EF1": "u",
              "\u1EE5": "u",
              "\u1E73": "u",
              "\u0173": "u",
              "\u1E77": "u",
              "\u1E75": "u",
              "\u0289": "u",
              "\u24E5": "v",
              "\uFF56": "v",
              "\u1E7D": "v",
              "\u1E7F": "v",
              "\u028B": "v",
              "\uA75F": "v",
              "\u028C": "v",
              "\uA761": "vy",
              "\u24E6": "w",
              "\uFF57": "w",
              "\u1E81": "w",
              "\u1E83": "w",
              "\u0175": "w",
              "\u1E87": "w",
              "\u1E85": "w",
              "\u1E98": "w",
              "\u1E89": "w",
              "\u2C73": "w",
              "\u24E7": "x",
              "\uFF58": "x",
              "\u1E8B": "x",
              "\u1E8D": "x",
              "\u24E8": "y",
              "\uFF59": "y",
              "\u1EF3": "y",
              "\xFD": "y",
              "\u0177": "y",
              "\u1EF9": "y",
              "\u0233": "y",
              "\u1E8F": "y",
              "\xFF": "y",
              "\u1EF7": "y",
              "\u1E99": "y",
              "\u1EF5": "y",
              "\u01B4": "y",
              "\u024F": "y",
              "\u1EFF": "y",
              "\u24E9": "z",
              "\uFF5A": "z",
              "\u017A": "z",
              "\u1E91": "z",
              "\u017C": "z",
              "\u017E": "z",
              "\u1E93": "z",
              "\u1E95": "z",
              "\u01B6": "z",
              "\u0225": "z",
              "\u0240": "z",
              "\u2C6C": "z",
              "\uA763": "z",
              "\u0386": "\u0391",
              "\u0388": "\u0395",
              "\u0389": "\u0397",
              "\u038A": "\u0399",
              "\u03AA": "\u0399",
              "\u038C": "\u039F",
              "\u038E": "\u03A5",
              "\u03AB": "\u03A5",
              "\u038F": "\u03A9",
              "\u03AC": "\u03B1",
              "\u03AD": "\u03B5",
              "\u03AE": "\u03B7",
              "\u03AF": "\u03B9",
              "\u03CA": "\u03B9",
              "\u0390": "\u03B9",
              "\u03CC": "\u03BF",
              "\u03CD": "\u03C5",
              "\u03CB": "\u03C5",
              "\u03B0": "\u03C5",
              "\u03CE": "\u03C9",
              "\u03C2": "\u03C3",
              "\u2019": "'"
            };
            return diacritics;
          });
          S22.define("select2/data/base", [
            "../utils"
          ], function(Utils) {
            function BaseAdapter($element, options) {
              BaseAdapter.__super__.constructor.call(this);
            }
            Utils.Extend(BaseAdapter, Utils.Observable);
            BaseAdapter.prototype.current = function(callback) {
              throw new Error("The `current` method must be defined in child classes.");
            };
            BaseAdapter.prototype.query = function(params, callback) {
              throw new Error("The `query` method must be defined in child classes.");
            };
            BaseAdapter.prototype.bind = function(container, $container) {
            };
            BaseAdapter.prototype.destroy = function() {
            };
            BaseAdapter.prototype.generateResultId = function(container, data) {
              var id = container.id + "-result-";
              id += Utils.generateChars(4);
              if (data.id != null) {
                id += "-" + data.id.toString();
              } else {
                id += "-" + Utils.generateChars(4);
              }
              return id;
            };
            return BaseAdapter;
          });
          S22.define("select2/data/select", [
            "./base",
            "../utils",
            "jquery"
          ], function(BaseAdapter, Utils, $3) {
            function SelectAdapter($element, options) {
              this.$element = $element;
              this.options = options;
              SelectAdapter.__super__.constructor.call(this);
            }
            Utils.Extend(SelectAdapter, BaseAdapter);
            SelectAdapter.prototype.current = function(callback) {
              var self2 = this;
              var data = Array.prototype.map.call(
                this.$element[0].querySelectorAll(":checked"),
                function(selectedElement) {
                  return self2.item($3(selectedElement));
                }
              );
              callback(data);
            };
            SelectAdapter.prototype.select = function(data) {
              var self2 = this;
              data.selected = true;
              if (data.element != null && data.element.tagName.toLowerCase() === "option") {
                data.element.selected = true;
                this.$element.trigger("input").trigger("change");
                return;
              }
              if (this.$element.prop("multiple")) {
                this.current(function(currentData) {
                  var val2 = [];
                  data = [data];
                  data.push.apply(data, currentData);
                  for (var d = 0; d < data.length; d++) {
                    var id = data[d].id;
                    if (val2.indexOf(id) === -1) {
                      val2.push(id);
                    }
                  }
                  self2.$element.val(val2);
                  self2.$element.trigger("input").trigger("change");
                });
              } else {
                var val = data.id;
                this.$element.val(val);
                this.$element.trigger("input").trigger("change");
              }
            };
            SelectAdapter.prototype.unselect = function(data) {
              var self2 = this;
              if (!this.$element.prop("multiple")) {
                return;
              }
              data.selected = false;
              if (data.element != null && data.element.tagName.toLowerCase() === "option") {
                data.element.selected = false;
                this.$element.trigger("input").trigger("change");
                return;
              }
              this.current(function(currentData) {
                var val = [];
                for (var d = 0; d < currentData.length; d++) {
                  var id = currentData[d].id;
                  if (id !== data.id && val.indexOf(id) === -1) {
                    val.push(id);
                  }
                }
                self2.$element.val(val);
                self2.$element.trigger("input").trigger("change");
              });
            };
            SelectAdapter.prototype.bind = function(container, $container) {
              var self2 = this;
              this.container = container;
              container.on("select", function(params) {
                self2.select(params.data);
              });
              container.on("unselect", function(params) {
                self2.unselect(params.data);
              });
            };
            SelectAdapter.prototype.destroy = function() {
              this.$element.find("*").each(function() {
                Utils.RemoveData(this);
              });
            };
            SelectAdapter.prototype.query = function(params, callback) {
              var data = [];
              var self2 = this;
              var $options = this.$element.children();
              $options.each(function() {
                if (this.tagName.toLowerCase() !== "option" && this.tagName.toLowerCase() !== "optgroup") {
                  return;
                }
                var $option = $3(this);
                var option = self2.item($option);
                var matches2 = self2.matches(params, option);
                if (matches2 !== null) {
                  data.push(matches2);
                }
              });
              callback({
                results: data
              });
            };
            SelectAdapter.prototype.addOptions = function($options) {
              this.$element.append($options);
            };
            SelectAdapter.prototype.option = function(data) {
              var option;
              if (data.children) {
                option = document.createElement("optgroup");
                option.label = data.text;
              } else {
                option = document.createElement("option");
                if (option.textContent !== void 0) {
                  option.textContent = data.text;
                } else {
                  option.innerText = data.text;
                }
              }
              if (data.id !== void 0) {
                option.value = data.id;
              }
              if (data.disabled) {
                option.disabled = true;
              }
              if (data.selected) {
                option.selected = true;
              }
              if (data.title) {
                option.title = data.title;
              }
              var normalizedData = this._normalizeItem(data);
              normalizedData.element = option;
              Utils.StoreData(option, "data", normalizedData);
              return $3(option);
            };
            SelectAdapter.prototype.item = function($option) {
              var data = {};
              data = Utils.GetData($option[0], "data");
              if (data != null) {
                return data;
              }
              var option = $option[0];
              if (option.tagName.toLowerCase() === "option") {
                data = {
                  id: $option.val(),
                  text: $option.text(),
                  disabled: $option.prop("disabled"),
                  selected: $option.prop("selected"),
                  title: $option.prop("title")
                };
              } else if (option.tagName.toLowerCase() === "optgroup") {
                data = {
                  text: $option.prop("label"),
                  children: [],
                  title: $option.prop("title")
                };
                var $children = $option.children("option");
                var children = [];
                for (var c = 0; c < $children.length; c++) {
                  var $child = $3($children[c]);
                  var child = this.item($child);
                  children.push(child);
                }
                data.children = children;
              }
              data = this._normalizeItem(data);
              data.element = $option[0];
              Utils.StoreData($option[0], "data", data);
              return data;
            };
            SelectAdapter.prototype._normalizeItem = function(item) {
              if (item !== Object(item)) {
                item = {
                  id: item,
                  text: item
                };
              }
              item = $3.extend({}, {
                text: ""
              }, item);
              var defaults = {
                selected: false,
                disabled: false
              };
              if (item.id != null) {
                item.id = item.id.toString();
              }
              if (item.text != null) {
                item.text = item.text.toString();
              }
              if (item._resultId == null && item.id && this.container != null) {
                item._resultId = this.generateResultId(this.container, item);
              }
              return $3.extend({}, defaults, item);
            };
            SelectAdapter.prototype.matches = function(params, data) {
              var matcher = this.options.get("matcher");
              return matcher(params, data);
            };
            return SelectAdapter;
          });
          S22.define("select2/data/array", [
            "./select",
            "../utils",
            "jquery"
          ], function(SelectAdapter, Utils, $3) {
            function ArrayAdapter($element, options) {
              this._dataToConvert = options.get("data") || [];
              ArrayAdapter.__super__.constructor.call(this, $element, options);
            }
            Utils.Extend(ArrayAdapter, SelectAdapter);
            ArrayAdapter.prototype.bind = function(container, $container) {
              ArrayAdapter.__super__.bind.call(this, container, $container);
              this.addOptions(this.convertToOptions(this._dataToConvert));
            };
            ArrayAdapter.prototype.select = function(data) {
              var $option = this.$element.find("option").filter(function(i, elm) {
                return elm.value == data.id.toString();
              });
              if ($option.length === 0) {
                $option = this.option(data);
                this.addOptions($option);
              }
              ArrayAdapter.__super__.select.call(this, data);
            };
            ArrayAdapter.prototype.convertToOptions = function(data) {
              var self2 = this;
              var $existing = this.$element.find("option");
              var existingIds = $existing.map(function() {
                return self2.item($3(this)).id;
              }).get();
              var $options = [];
              function onlyItem(item2) {
                return function() {
                  return $3(this).val() == item2.id;
                };
              }
              for (var d = 0; d < data.length; d++) {
                var item = this._normalizeItem(data[d]);
                if (existingIds.indexOf(item.id) >= 0) {
                  var $existingOption = $existing.filter(onlyItem(item));
                  var existingData = this.item($existingOption);
                  var newData = $3.extend(true, {}, item, existingData);
                  var $newOption = this.option(newData);
                  $existingOption.replaceWith($newOption);
                  continue;
                }
                var $option = this.option(item);
                if (item.children) {
                  var $children = this.convertToOptions(item.children);
                  $option.append($children);
                }
                $options.push($option);
              }
              return $options;
            };
            return ArrayAdapter;
          });
          S22.define("select2/data/ajax", [
            "./array",
            "../utils",
            "jquery"
          ], function(ArrayAdapter, Utils, $3) {
            function AjaxAdapter($element, options) {
              this.ajaxOptions = this._applyDefaults(options.get("ajax"));
              if (this.ajaxOptions.processResults != null) {
                this.processResults = this.ajaxOptions.processResults;
              }
              AjaxAdapter.__super__.constructor.call(this, $element, options);
            }
            Utils.Extend(AjaxAdapter, ArrayAdapter);
            AjaxAdapter.prototype._applyDefaults = function(options) {
              var defaults = {
                data: function(params) {
                  return $3.extend({}, params, {
                    q: params.term
                  });
                },
                transport: function(params, success, failure) {
                  var $request = $3.ajax(params);
                  $request.then(success);
                  $request.fail(failure);
                  return $request;
                }
              };
              return $3.extend({}, defaults, options, true);
            };
            AjaxAdapter.prototype.processResults = function(results) {
              return results;
            };
            AjaxAdapter.prototype.query = function(params, callback) {
              var matches2 = [];
              var self2 = this;
              if (this._request != null) {
                if (typeof this._request.abort === "function") {
                  this._request.abort();
                }
                this._request = null;
              }
              var options = $3.extend({
                type: "GET"
              }, this.ajaxOptions);
              if (typeof options.url === "function") {
                options.url = options.url.call(this.$element, params);
              }
              if (typeof options.data === "function") {
                options.data = options.data.call(this.$element, params);
              }
              function request() {
                var $request = options.transport(options, function(data) {
                  var results = self2.processResults(data, params);
                  if (self2.options.get("debug") && window.console && console.error) {
                    if (!results || !results.results || !Array.isArray(results.results)) {
                      console.error(
                        "Select2: The AJAX results did not return an array in the `results` key of the response."
                      );
                    }
                  }
                  callback(results);
                }, function() {
                  if ("status" in $request && ($request.status === 0 || $request.status === "0")) {
                    return;
                  }
                  self2.trigger("results:message", {
                    message: "errorLoading"
                  });
                });
                self2._request = $request;
              }
              if (this.ajaxOptions.delay && params.term != null) {
                if (this._queryTimeout) {
                  window.clearTimeout(this._queryTimeout);
                }
                this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
              } else {
                request();
              }
            };
            return AjaxAdapter;
          });
          S22.define("select2/data/tags", [
            "jquery"
          ], function($3) {
            function Tags(decorated, $element, options) {
              var tags = options.get("tags");
              var createTag = options.get("createTag");
              if (createTag !== void 0) {
                this.createTag = createTag;
              }
              var insertTag = options.get("insertTag");
              if (insertTag !== void 0) {
                this.insertTag = insertTag;
              }
              decorated.call(this, $element, options);
              if (Array.isArray(tags)) {
                for (var t = 0; t < tags.length; t++) {
                  var tag = tags[t];
                  var item = this._normalizeItem(tag);
                  var $option = this.option(item);
                  this.$element.append($option);
                }
              }
            }
            Tags.prototype.query = function(decorated, params, callback) {
              var self2 = this;
              this._removeOldTags();
              if (params.term == null || params.page != null) {
                decorated.call(this, params, callback);
                return;
              }
              function wrapper(obj, child) {
                var data = obj.results;
                for (var i = 0; i < data.length; i++) {
                  var option = data[i];
                  var checkChildren = option.children != null && !wrapper({
                    results: option.children
                  }, true);
                  var optionText = (option.text || "").toUpperCase();
                  var paramsTerm = (params.term || "").toUpperCase();
                  var checkText = optionText === paramsTerm;
                  if (checkText || checkChildren) {
                    if (child) {
                      return false;
                    }
                    obj.data = data;
                    callback(obj);
                    return;
                  }
                }
                if (child) {
                  return true;
                }
                var tag = self2.createTag(params);
                if (tag != null) {
                  var $option = self2.option(tag);
                  $option.attr("data-select2-tag", "true");
                  self2.addOptions([$option]);
                  self2.insertTag(data, tag);
                }
                obj.results = data;
                callback(obj);
              }
              decorated.call(this, params, wrapper);
            };
            Tags.prototype.createTag = function(decorated, params) {
              if (params.term == null) {
                return null;
              }
              var term = params.term.trim();
              if (term === "") {
                return null;
              }
              return {
                id: term,
                text: term
              };
            };
            Tags.prototype.insertTag = function(_2, data, tag) {
              data.unshift(tag);
            };
            Tags.prototype._removeOldTags = function(_2) {
              var $options = this.$element.find("option[data-select2-tag]");
              $options.each(function() {
                if (this.selected) {
                  return;
                }
                $3(this).remove();
              });
            };
            return Tags;
          });
          S22.define("select2/data/tokenizer", [
            "jquery"
          ], function($3) {
            function Tokenizer2(decorated, $element, options) {
              var tokenizer2 = options.get("tokenizer");
              if (tokenizer2 !== void 0) {
                this.tokenizer = tokenizer2;
              }
              decorated.call(this, $element, options);
            }
            Tokenizer2.prototype.bind = function(decorated, container, $container) {
              decorated.call(this, container, $container);
              this.$search = container.dropdown.$search || container.selection.$search || $container.find(".select2-search__field");
            };
            Tokenizer2.prototype.query = function(decorated, params, callback) {
              var self2 = this;
              function createAndSelect(data) {
                var item = self2._normalizeItem(data);
                var $existingOptions = self2.$element.find("option").filter(function() {
                  return $3(this).val() === item.id;
                });
                if (!$existingOptions.length) {
                  var $option = self2.option(item);
                  $option.attr("data-select2-tag", true);
                  self2._removeOldTags();
                  self2.addOptions([$option]);
                }
                select(item);
              }
              function select(data) {
                self2.trigger("select", {
                  data
                });
              }
              params.term = params.term || "";
              var tokenData = this.tokenizer(params, this.options, createAndSelect);
              if (tokenData.term !== params.term) {
                if (this.$search.length) {
                  this.$search.val(tokenData.term);
                  this.$search.trigger("focus");
                }
                params.term = tokenData.term;
              }
              decorated.call(this, params, callback);
            };
            Tokenizer2.prototype.tokenizer = function(_2, params, options, callback) {
              var separators = options.get("tokenSeparators") || [];
              var term = params.term;
              var i = 0;
              var createTag = this.createTag || function(params2) {
                return {
                  id: params2.term,
                  text: params2.term
                };
              };
              while (i < term.length) {
                var termChar = term[i];
                if (separators.indexOf(termChar) === -1) {
                  i++;
                  continue;
                }
                var part = term.substr(0, i);
                var partParams = $3.extend({}, params, {
                  term: part
                });
                var data = createTag(partParams);
                if (data == null) {
                  i++;
                  continue;
                }
                callback(data);
                term = term.substr(i + 1) || "";
                i = 0;
              }
              return {
                term
              };
            };
            return Tokenizer2;
          });
          S22.define("select2/data/minimumInputLength", [], function() {
            function MinimumInputLength(decorated, $e, options) {
              this.minimumInputLength = options.get("minimumInputLength");
              decorated.call(this, $e, options);
            }
            MinimumInputLength.prototype.query = function(decorated, params, callback) {
              params.term = params.term || "";
              if (params.term.length < this.minimumInputLength) {
                this.trigger("results:message", {
                  message: "inputTooShort",
                  args: {
                    minimum: this.minimumInputLength,
                    input: params.term,
                    params
                  }
                });
                return;
              }
              decorated.call(this, params, callback);
            };
            return MinimumInputLength;
          });
          S22.define("select2/data/maximumInputLength", [], function() {
            function MaximumInputLength(decorated, $e, options) {
              this.maximumInputLength = options.get("maximumInputLength");
              decorated.call(this, $e, options);
            }
            MaximumInputLength.prototype.query = function(decorated, params, callback) {
              params.term = params.term || "";
              if (this.maximumInputLength > 0 && params.term.length > this.maximumInputLength) {
                this.trigger("results:message", {
                  message: "inputTooLong",
                  args: {
                    maximum: this.maximumInputLength,
                    input: params.term,
                    params
                  }
                });
                return;
              }
              decorated.call(this, params, callback);
            };
            return MaximumInputLength;
          });
          S22.define("select2/data/maximumSelectionLength", [], function() {
            function MaximumSelectionLength(decorated, $e, options) {
              this.maximumSelectionLength = options.get("maximumSelectionLength");
              decorated.call(this, $e, options);
            }
            MaximumSelectionLength.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("select", function() {
                self2._checkIfMaximumSelected();
              });
            };
            MaximumSelectionLength.prototype.query = function(decorated, params, callback) {
              var self2 = this;
              this._checkIfMaximumSelected(function() {
                decorated.call(self2, params, callback);
              });
            };
            MaximumSelectionLength.prototype._checkIfMaximumSelected = function(_2, successCallback) {
              var self2 = this;
              this.current(function(currentData) {
                var count = currentData != null ? currentData.length : 0;
                if (self2.maximumSelectionLength > 0 && count >= self2.maximumSelectionLength) {
                  self2.trigger("results:message", {
                    message: "maximumSelected",
                    args: {
                      maximum: self2.maximumSelectionLength
                    }
                  });
                  return;
                }
                if (successCallback) {
                  successCallback();
                }
              });
            };
            return MaximumSelectionLength;
          });
          S22.define("select2/dropdown", [
            "jquery",
            "./utils"
          ], function($3, Utils) {
            function Dropdown($element, options) {
              this.$element = $element;
              this.options = options;
              Dropdown.__super__.constructor.call(this);
            }
            Utils.Extend(Dropdown, Utils.Observable);
            Dropdown.prototype.render = function() {
              var $dropdown = $3(
                '<span class="select2-dropdown"><span class="select2-results"></span></span>'
              );
              $dropdown.attr("dir", this.options.get("dir"));
              this.$dropdown = $dropdown;
              return $dropdown;
            };
            Dropdown.prototype.bind = function() {
            };
            Dropdown.prototype.position = function($dropdown, $container) {
            };
            Dropdown.prototype.destroy = function() {
              this.$dropdown.remove();
            };
            return Dropdown;
          });
          S22.define("select2/dropdown/search", [
            "jquery"
          ], function($3) {
            function Search() {
            }
            Search.prototype.render = function(decorated) {
              var $rendered = decorated.call(this);
              var searchLabel = this.options.get("translations").get("search");
              var $search = $3(
                '<span class="select2-search select2-search--dropdown"><input class="select2-search__field" type="search" tabindex="-1" autocorrect="off" autocapitalize="none" spellcheck="false" role="searchbox" aria-autocomplete="list" /></span>'
              );
              this.$searchContainer = $search;
              this.$search = $search.find("input");
              this.$search.prop("autocomplete", this.options.get("autocomplete"));
              this.$search.attr("aria-label", searchLabel());
              $rendered.prepend($search);
              return $rendered;
            };
            Search.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              var resultsId = container.id + "-results";
              decorated.call(this, container, $container);
              this.$search.on("keydown", function(evt) {
                self2.trigger("keypress", evt);
                self2._keyUpPrevented = evt.isDefaultPrevented();
              });
              this.$search.on("input", function(evt) {
                $3(this).off("keyup");
              });
              this.$search.on("keyup input", function(evt) {
                self2.handleSearch(evt);
              });
              container.on("open", function() {
                self2.$search.attr("tabindex", 0);
                self2.$search.attr("aria-controls", resultsId);
                self2.$search.trigger("focus");
                window.setTimeout(function() {
                  self2.$search.trigger("focus");
                }, 0);
              });
              container.on("close", function() {
                self2.$search.attr("tabindex", -1);
                self2.$search.removeAttr("aria-controls");
                self2.$search.removeAttr("aria-activedescendant");
                self2.$search.val("");
                self2.$search.trigger("blur");
              });
              container.on("focus", function() {
                if (!container.isOpen()) {
                  self2.$search.trigger("focus");
                }
              });
              container.on("results:all", function(params) {
                if (params.query.term == null || params.query.term === "") {
                  var showSearch = self2.showSearch(params);
                  if (showSearch) {
                    self2.$searchContainer[0].classList.remove("select2-search--hide");
                  } else {
                    self2.$searchContainer[0].classList.add("select2-search--hide");
                  }
                }
              });
              container.on("results:focus", function(params) {
                if (params.data._resultId) {
                  self2.$search.attr("aria-activedescendant", params.data._resultId);
                } else {
                  self2.$search.removeAttr("aria-activedescendant");
                }
              });
            };
            Search.prototype.handleSearch = function(evt) {
              if (!this._keyUpPrevented) {
                var input = this.$search.val();
                this.trigger("query", {
                  term: input
                });
              }
              this._keyUpPrevented = false;
            };
            Search.prototype.showSearch = function(_2, params) {
              return true;
            };
            return Search;
          });
          S22.define("select2/dropdown/hidePlaceholder", [], function() {
            function HidePlaceholder(decorated, $element, options, dataAdapter) {
              this.placeholder = this.normalizePlaceholder(options.get("placeholder"));
              decorated.call(this, $element, options, dataAdapter);
            }
            HidePlaceholder.prototype.append = function(decorated, data) {
              data.results = this.removePlaceholder(data.results);
              decorated.call(this, data);
            };
            HidePlaceholder.prototype.normalizePlaceholder = function(_2, placeholder) {
              if (typeof placeholder === "string") {
                placeholder = {
                  id: "",
                  text: placeholder
                };
              }
              return placeholder;
            };
            HidePlaceholder.prototype.removePlaceholder = function(_2, data) {
              var modifiedData = data.slice(0);
              for (var d = data.length - 1; d >= 0; d--) {
                var item = data[d];
                if (this.placeholder.id === item.id) {
                  modifiedData.splice(d, 1);
                }
              }
              return modifiedData;
            };
            return HidePlaceholder;
          });
          S22.define("select2/dropdown/infiniteScroll", [
            "jquery"
          ], function($3) {
            function InfiniteScroll(decorated, $element, options, dataAdapter) {
              this.lastParams = {};
              decorated.call(this, $element, options, dataAdapter);
              this.$loadingMore = this.createLoadingMore();
              this.loading = false;
            }
            InfiniteScroll.prototype.append = function(decorated, data) {
              this.$loadingMore.remove();
              this.loading = false;
              decorated.call(this, data);
              if (this.showLoadingMore(data)) {
                this.$results.append(this.$loadingMore);
                this.loadMoreIfNeeded();
              }
            };
            InfiniteScroll.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("query", function(params) {
                self2.lastParams = params;
                self2.loading = true;
              });
              container.on("query:append", function(params) {
                self2.lastParams = params;
                self2.loading = true;
              });
              this.$results.on("scroll", this.loadMoreIfNeeded.bind(this));
            };
            InfiniteScroll.prototype.loadMoreIfNeeded = function() {
              var isLoadMoreVisible = $3.contains(
                document.documentElement,
                this.$loadingMore[0]
              );
              if (this.loading || !isLoadMoreVisible) {
                return;
              }
              var currentOffset = this.$results.offset().top + this.$results.outerHeight(false);
              var loadingMoreOffset = this.$loadingMore.offset().top + this.$loadingMore.outerHeight(false);
              if (currentOffset + 50 >= loadingMoreOffset) {
                this.loadMore();
              }
            };
            InfiniteScroll.prototype.loadMore = function() {
              this.loading = true;
              var params = $3.extend({}, { page: 1 }, this.lastParams);
              params.page++;
              this.trigger("query:append", params);
            };
            InfiniteScroll.prototype.showLoadingMore = function(_2, data) {
              return data.pagination && data.pagination.more;
            };
            InfiniteScroll.prototype.createLoadingMore = function() {
              var $option = $3(
                '<li class="select2-results__option select2-results__option--load-more"role="option" aria-disabled="true"></li>'
              );
              var message = this.options.get("translations").get("loadingMore");
              $option.html(message(this.lastParams));
              return $option;
            };
            return InfiniteScroll;
          });
          S22.define("select2/dropdown/attachBody", [
            "jquery",
            "../utils"
          ], function($3, Utils) {
            function AttachBody(decorated, $element, options) {
              this.$dropdownParent = $3(options.get("dropdownParent") || document.body);
              decorated.call(this, $element, options);
            }
            AttachBody.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("open", function() {
                self2._showDropdown();
                self2._attachPositioningHandler(container);
                self2._bindContainerResultHandlers(container);
              });
              container.on("close", function() {
                self2._hideDropdown();
                self2._detachPositioningHandler(container);
              });
              this.$dropdownContainer.on("mousedown", function(evt) {
                evt.stopPropagation();
              });
            };
            AttachBody.prototype.destroy = function(decorated) {
              decorated.call(this);
              this.$dropdownContainer.remove();
            };
            AttachBody.prototype.position = function(decorated, $dropdown, $container) {
              $dropdown.attr("class", $container.attr("class"));
              $dropdown[0].classList.remove("select2");
              $dropdown[0].classList.add("select2-container--open");
              $dropdown.css({
                position: "absolute",
                top: -999999
              });
              this.$container = $container;
            };
            AttachBody.prototype.render = function(decorated) {
              var $container = $3("<span></span>");
              var $dropdown = decorated.call(this);
              $container.append($dropdown);
              this.$dropdownContainer = $container;
              return $container;
            };
            AttachBody.prototype._hideDropdown = function(decorated) {
              this.$dropdownContainer.detach();
            };
            AttachBody.prototype._bindContainerResultHandlers = function(decorated, container) {
              if (this._containerResultsHandlersBound) {
                return;
              }
              var self2 = this;
              container.on("results:all", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              container.on("results:append", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              container.on("results:message", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              container.on("select", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              container.on("unselect", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              this._containerResultsHandlersBound = true;
            };
            AttachBody.prototype._attachPositioningHandler = function(decorated, container) {
              var self2 = this;
              var scrollEvent = "scroll.select2." + container.id;
              var resizeEvent = "resize.select2." + container.id;
              var orientationEvent = "orientationchange.select2." + container.id;
              var $watchers = this.$container.parents().filter(Utils.hasScroll);
              $watchers.each(function() {
                Utils.StoreData(this, "select2-scroll-position", {
                  x: $3(this).scrollLeft(),
                  y: $3(this).scrollTop()
                });
              });
              $watchers.on(scrollEvent, function(ev) {
                var position = Utils.GetData(this, "select2-scroll-position");
                $3(this).scrollTop(position.y);
              });
              $3(window).on(
                scrollEvent + " " + resizeEvent + " " + orientationEvent,
                function(e) {
                  self2._positionDropdown();
                  self2._resizeDropdown();
                }
              );
            };
            AttachBody.prototype._detachPositioningHandler = function(decorated, container) {
              var scrollEvent = "scroll.select2." + container.id;
              var resizeEvent = "resize.select2." + container.id;
              var orientationEvent = "orientationchange.select2." + container.id;
              var $watchers = this.$container.parents().filter(Utils.hasScroll);
              $watchers.off(scrollEvent);
              $3(window).off(scrollEvent + " " + resizeEvent + " " + orientationEvent);
            };
            AttachBody.prototype._positionDropdown = function() {
              var $window = $3(window);
              var isCurrentlyAbove = this.$dropdown[0].classList.contains("select2-dropdown--above");
              var isCurrentlyBelow = this.$dropdown[0].classList.contains("select2-dropdown--below");
              var newDirection = null;
              var offset = this.$container.offset();
              offset.bottom = offset.top + this.$container.outerHeight(false);
              var container = {
                height: this.$container.outerHeight(false)
              };
              container.top = offset.top;
              container.bottom = offset.top + container.height;
              var dropdown = {
                height: this.$dropdown.outerHeight(false)
              };
              var viewport = {
                top: $window.scrollTop(),
                bottom: $window.scrollTop() + $window.height()
              };
              var enoughRoomAbove = viewport.top < offset.top - dropdown.height;
              var enoughRoomBelow = viewport.bottom > offset.bottom + dropdown.height;
              var css = {
                left: offset.left,
                top: container.bottom
              };
              var $offsetParent = this.$dropdownParent;
              if ($offsetParent.css("position") === "static") {
                $offsetParent = $offsetParent.offsetParent();
              }
              var parentOffset = {
                top: 0,
                left: 0
              };
              if ($3.contains(document.body, $offsetParent[0]) || $offsetParent[0].isConnected) {
                parentOffset = $offsetParent.offset();
              }
              css.top -= parentOffset.top;
              css.left -= parentOffset.left;
              if (!isCurrentlyAbove && !isCurrentlyBelow) {
                newDirection = "below";
              }
              if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
                newDirection = "above";
              } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
                newDirection = "below";
              }
              if (newDirection == "above" || isCurrentlyAbove && newDirection !== "below") {
                css.top = container.top - parentOffset.top - dropdown.height;
              }
              if (newDirection != null) {
                this.$dropdown[0].classList.remove("select2-dropdown--below");
                this.$dropdown[0].classList.remove("select2-dropdown--above");
                this.$dropdown[0].classList.add("select2-dropdown--" + newDirection);
                this.$container[0].classList.remove("select2-container--below");
                this.$container[0].classList.remove("select2-container--above");
                this.$container[0].classList.add("select2-container--" + newDirection);
              }
              this.$dropdownContainer.css(css);
            };
            AttachBody.prototype._resizeDropdown = function() {
              var css = {
                width: this.$container.outerWidth(false) + "px"
              };
              if (this.options.get("dropdownAutoWidth")) {
                css.minWidth = css.width;
                css.position = "relative";
                css.width = "auto";
              }
              this.$dropdown.css(css);
            };
            AttachBody.prototype._showDropdown = function(decorated) {
              this.$dropdownContainer.appendTo(this.$dropdownParent);
              this._positionDropdown();
              this._resizeDropdown();
            };
            return AttachBody;
          });
          S22.define("select2/dropdown/minimumResultsForSearch", [], function() {
            function countResults(data) {
              var count = 0;
              for (var d = 0; d < data.length; d++) {
                var item = data[d];
                if (item.children) {
                  count += countResults(item.children);
                } else {
                  count++;
                }
              }
              return count;
            }
            function MinimumResultsForSearch(decorated, $element, options, dataAdapter) {
              this.minimumResultsForSearch = options.get("minimumResultsForSearch");
              if (this.minimumResultsForSearch < 0) {
                this.minimumResultsForSearch = Infinity;
              }
              decorated.call(this, $element, options, dataAdapter);
            }
            MinimumResultsForSearch.prototype.showSearch = function(decorated, params) {
              if (countResults(params.data.results) < this.minimumResultsForSearch) {
                return false;
              }
              return decorated.call(this, params);
            };
            return MinimumResultsForSearch;
          });
          S22.define("select2/dropdown/selectOnClose", [
            "../utils"
          ], function(Utils) {
            function SelectOnClose() {
            }
            SelectOnClose.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("close", function(params) {
                self2._handleSelectOnClose(params);
              });
            };
            SelectOnClose.prototype._handleSelectOnClose = function(_2, params) {
              if (params && params.originalSelect2Event != null) {
                var event = params.originalSelect2Event;
                if (event._type === "select" || event._type === "unselect") {
                  return;
                }
              }
              var $highlightedResults = this.getHighlightedResults();
              if ($highlightedResults.length < 1) {
                return;
              }
              var data = Utils.GetData($highlightedResults[0], "data");
              if (data.element != null && data.element.selected || data.element == null && data.selected) {
                return;
              }
              this.trigger("select", {
                data
              });
            };
            return SelectOnClose;
          });
          S22.define("select2/dropdown/closeOnSelect", [], function() {
            function CloseOnSelect() {
            }
            CloseOnSelect.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("select", function(evt) {
                self2._selectTriggered(evt);
              });
              container.on("unselect", function(evt) {
                self2._selectTriggered(evt);
              });
            };
            CloseOnSelect.prototype._selectTriggered = function(_2, evt) {
              var originalEvent = evt.originalEvent;
              if (originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey)) {
                return;
              }
              this.trigger("close", {
                originalEvent,
                originalSelect2Event: evt
              });
            };
            return CloseOnSelect;
          });
          S22.define("select2/dropdown/dropdownCss", [
            "../utils"
          ], function(Utils) {
            function DropdownCSS() {
            }
            DropdownCSS.prototype.render = function(decorated) {
              var $dropdown = decorated.call(this);
              var dropdownCssClass = this.options.get("dropdownCssClass") || "";
              if (dropdownCssClass.indexOf(":all:") !== -1) {
                dropdownCssClass = dropdownCssClass.replace(":all:", "");
                Utils.copyNonInternalCssClasses($dropdown[0], this.$element[0]);
              }
              $dropdown.addClass(dropdownCssClass);
              return $dropdown;
            };
            return DropdownCSS;
          });
          S22.define("select2/dropdown/tagsSearchHighlight", [
            "../utils"
          ], function(Utils) {
            function TagsSearchHighlight() {
            }
            TagsSearchHighlight.prototype.highlightFirstItem = function(decorated) {
              var $options = this.$results.find(
                ".select2-results__option--selectable:not(.select2-results__option--selected)"
              );
              if ($options.length > 0) {
                var $firstOption = $options.first();
                var data = Utils.GetData($firstOption[0], "data");
                var firstElement = data.element;
                if (firstElement && firstElement.getAttribute) {
                  if (firstElement.getAttribute("data-select2-tag") === "true") {
                    $firstOption.trigger("mouseenter");
                    return;
                  }
                }
              }
              decorated.call(this);
            };
            return TagsSearchHighlight;
          });
          S22.define("select2/i18n/en", [], function() {
            return {
              errorLoading: function() {
                return "The results could not be loaded.";
              },
              inputTooLong: function(args) {
                var overChars = args.input.length - args.maximum;
                var message = "Please delete " + overChars + " character";
                if (overChars != 1) {
                  message += "s";
                }
                return message;
              },
              inputTooShort: function(args) {
                var remainingChars = args.minimum - args.input.length;
                var message = "Please enter " + remainingChars + " or more characters";
                return message;
              },
              loadingMore: function() {
                return "Loading more results\u2026";
              },
              maximumSelected: function(args) {
                var message = "You can only select " + args.maximum + " item";
                if (args.maximum != 1) {
                  message += "s";
                }
                return message;
              },
              noResults: function() {
                return "No results found";
              },
              searching: function() {
                return "Searching\u2026";
              },
              removeAllItems: function() {
                return "Remove all items";
              },
              removeItem: function() {
                return "Remove item";
              },
              search: function() {
                return "Search";
              }
            };
          });
          S22.define("select2/defaults", [
            "jquery",
            "./results",
            "./selection/single",
            "./selection/multiple",
            "./selection/placeholder",
            "./selection/allowClear",
            "./selection/search",
            "./selection/selectionCss",
            "./selection/eventRelay",
            "./utils",
            "./translation",
            "./diacritics",
            "./data/select",
            "./data/array",
            "./data/ajax",
            "./data/tags",
            "./data/tokenizer",
            "./data/minimumInputLength",
            "./data/maximumInputLength",
            "./data/maximumSelectionLength",
            "./dropdown",
            "./dropdown/search",
            "./dropdown/hidePlaceholder",
            "./dropdown/infiniteScroll",
            "./dropdown/attachBody",
            "./dropdown/minimumResultsForSearch",
            "./dropdown/selectOnClose",
            "./dropdown/closeOnSelect",
            "./dropdown/dropdownCss",
            "./dropdown/tagsSearchHighlight",
            "./i18n/en"
          ], function($3, ResultsList, SingleSelection, MultipleSelection, Placeholder, AllowClear, SelectionSearch, SelectionCSS, EventRelay, Utils, Translation, DIACRITICS, SelectData, ArrayData, AjaxData, Tags, Tokenizer2, MinimumInputLength, MaximumInputLength, MaximumSelectionLength, Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll, AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect, DropdownCSS, TagsSearchHighlight, EnglishTranslation) {
            function Defaults() {
              this.reset();
            }
            Defaults.prototype.apply = function(options) {
              options = $3.extend(true, {}, this.defaults, options);
              if (options.dataAdapter == null) {
                if (options.ajax != null) {
                  options.dataAdapter = AjaxData;
                } else if (options.data != null) {
                  options.dataAdapter = ArrayData;
                } else {
                  options.dataAdapter = SelectData;
                }
                if (options.minimumInputLength > 0) {
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    MinimumInputLength
                  );
                }
                if (options.maximumInputLength > 0) {
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    MaximumInputLength
                  );
                }
                if (options.maximumSelectionLength > 0) {
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    MaximumSelectionLength
                  );
                }
                if (options.tags) {
                  options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
                }
                if (options.tokenSeparators != null || options.tokenizer != null) {
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    Tokenizer2
                  );
                }
              }
              if (options.resultsAdapter == null) {
                options.resultsAdapter = ResultsList;
                if (options.ajax != null) {
                  options.resultsAdapter = Utils.Decorate(
                    options.resultsAdapter,
                    InfiniteScroll
                  );
                }
                if (options.placeholder != null) {
                  options.resultsAdapter = Utils.Decorate(
                    options.resultsAdapter,
                    HidePlaceholder
                  );
                }
                if (options.selectOnClose) {
                  options.resultsAdapter = Utils.Decorate(
                    options.resultsAdapter,
                    SelectOnClose
                  );
                }
                if (options.tags) {
                  options.resultsAdapter = Utils.Decorate(
                    options.resultsAdapter,
                    TagsSearchHighlight
                  );
                }
              }
              if (options.dropdownAdapter == null) {
                if (options.multiple) {
                  options.dropdownAdapter = Dropdown;
                } else {
                  var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);
                  options.dropdownAdapter = SearchableDropdown;
                }
                if (options.minimumResultsForSearch !== 0) {
                  options.dropdownAdapter = Utils.Decorate(
                    options.dropdownAdapter,
                    MinimumResultsForSearch
                  );
                }
                if (options.closeOnSelect) {
                  options.dropdownAdapter = Utils.Decorate(
                    options.dropdownAdapter,
                    CloseOnSelect
                  );
                }
                if (options.dropdownCssClass != null) {
                  options.dropdownAdapter = Utils.Decorate(
                    options.dropdownAdapter,
                    DropdownCSS
                  );
                }
                options.dropdownAdapter = Utils.Decorate(
                  options.dropdownAdapter,
                  AttachBody
                );
              }
              if (options.selectionAdapter == null) {
                if (options.multiple) {
                  options.selectionAdapter = MultipleSelection;
                } else {
                  options.selectionAdapter = SingleSelection;
                }
                if (options.placeholder != null) {
                  options.selectionAdapter = Utils.Decorate(
                    options.selectionAdapter,
                    Placeholder
                  );
                }
                if (options.allowClear) {
                  options.selectionAdapter = Utils.Decorate(
                    options.selectionAdapter,
                    AllowClear
                  );
                }
                if (options.multiple) {
                  options.selectionAdapter = Utils.Decorate(
                    options.selectionAdapter,
                    SelectionSearch
                  );
                }
                if (options.selectionCssClass != null) {
                  options.selectionAdapter = Utils.Decorate(
                    options.selectionAdapter,
                    SelectionCSS
                  );
                }
                options.selectionAdapter = Utils.Decorate(
                  options.selectionAdapter,
                  EventRelay
                );
              }
              options.language = this._resolveLanguage(options.language);
              options.language.push("en");
              var uniqueLanguages = [];
              for (var l = 0; l < options.language.length; l++) {
                var language = options.language[l];
                if (uniqueLanguages.indexOf(language) === -1) {
                  uniqueLanguages.push(language);
                }
              }
              options.language = uniqueLanguages;
              options.translations = this._processTranslations(
                options.language,
                options.debug
              );
              return options;
            };
            Defaults.prototype.reset = function() {
              function stripDiacritics(text) {
                function match(a) {
                  return DIACRITICS[a] || a;
                }
                return text.replace(/[^\u0000-\u007E]/g, match);
              }
              function matcher(params, data) {
                if (params.term == null || params.term.trim() === "") {
                  return data;
                }
                if (data.children && data.children.length > 0) {
                  var match = $3.extend(true, {}, data);
                  for (var c = data.children.length - 1; c >= 0; c--) {
                    var child = data.children[c];
                    var matches2 = matcher(params, child);
                    if (matches2 == null) {
                      match.children.splice(c, 1);
                    }
                  }
                  if (match.children.length > 0) {
                    return match;
                  }
                  return matcher(params, match);
                }
                var original = stripDiacritics(data.text).toUpperCase();
                var term = stripDiacritics(params.term).toUpperCase();
                if (original.indexOf(term) > -1) {
                  return data;
                }
                return null;
              }
              this.defaults = {
                amdLanguageBase: "./i18n/",
                autocomplete: "off",
                closeOnSelect: true,
                debug: false,
                dropdownAutoWidth: false,
                escapeMarkup: Utils.escapeMarkup,
                language: {},
                matcher,
                minimumInputLength: 0,
                maximumInputLength: 0,
                maximumSelectionLength: 0,
                minimumResultsForSearch: 0,
                selectOnClose: false,
                scrollAfterSelect: false,
                sorter: function(data) {
                  return data;
                },
                templateResult: function(result) {
                  return result.text;
                },
                templateSelection: function(selection) {
                  return selection.text;
                },
                theme: "default",
                width: "resolve"
              };
            };
            Defaults.prototype.applyFromElement = function(options, $element) {
              var optionLanguage = options.language;
              var defaultLanguage = this.defaults.language;
              var elementLanguage = $element.prop("lang");
              var parentLanguage = $element.closest("[lang]").prop("lang");
              var languages = Array.prototype.concat.call(
                this._resolveLanguage(elementLanguage),
                this._resolveLanguage(optionLanguage),
                this._resolveLanguage(defaultLanguage),
                this._resolveLanguage(parentLanguage)
              );
              options.language = languages;
              return options;
            };
            Defaults.prototype._resolveLanguage = function(language) {
              if (!language) {
                return [];
              }
              if ($3.isEmptyObject(language)) {
                return [];
              }
              if ($3.isPlainObject(language)) {
                return [language];
              }
              var languages;
              if (!Array.isArray(language)) {
                languages = [language];
              } else {
                languages = language;
              }
              var resolvedLanguages = [];
              for (var l = 0; l < languages.length; l++) {
                resolvedLanguages.push(languages[l]);
                if (typeof languages[l] === "string" && languages[l].indexOf("-") > 0) {
                  var languageParts = languages[l].split("-");
                  var baseLanguage = languageParts[0];
                  resolvedLanguages.push(baseLanguage);
                }
              }
              return resolvedLanguages;
            };
            Defaults.prototype._processTranslations = function(languages, debug) {
              var translations = new Translation();
              for (var l = 0; l < languages.length; l++) {
                var languageData = new Translation();
                var language = languages[l];
                if (typeof language === "string") {
                  try {
                    languageData = Translation.loadPath(language);
                  } catch (e) {
                    try {
                      language = this.defaults.amdLanguageBase + language;
                      languageData = Translation.loadPath(language);
                    } catch (ex) {
                      if (debug && window.console && console.warn) {
                        console.warn(
                          'Select2: The language file for "' + language + '" could not be automatically loaded. A fallback will be used instead.'
                        );
                      }
                    }
                  }
                } else if ($3.isPlainObject(language)) {
                  languageData = new Translation(language);
                } else {
                  languageData = language;
                }
                translations.extend(languageData);
              }
              return translations;
            };
            Defaults.prototype.set = function(key, value) {
              var camelKey = $3.camelCase(key);
              var data = {};
              data[camelKey] = value;
              var convertedData = Utils._convertData(data);
              $3.extend(true, this.defaults, convertedData);
            };
            var defaults = new Defaults();
            return defaults;
          });
          S22.define("select2/options", [
            "jquery",
            "./defaults",
            "./utils"
          ], function($3, Defaults, Utils) {
            function Options(options, $element) {
              this.options = options;
              if ($element != null) {
                this.fromElement($element);
              }
              if ($element != null) {
                this.options = Defaults.applyFromElement(this.options, $element);
              }
              this.options = Defaults.apply(this.options);
            }
            Options.prototype.fromElement = function($e) {
              var excludedData = ["select2"];
              if (this.options.multiple == null) {
                this.options.multiple = $e.prop("multiple");
              }
              if (this.options.disabled == null) {
                this.options.disabled = $e.prop("disabled");
              }
              if (this.options.autocomplete == null && $e.prop("autocomplete")) {
                this.options.autocomplete = $e.prop("autocomplete");
              }
              if (this.options.dir == null) {
                if ($e.prop("dir")) {
                  this.options.dir = $e.prop("dir");
                } else if ($e.closest("[dir]").prop("dir")) {
                  this.options.dir = $e.closest("[dir]").prop("dir");
                } else {
                  this.options.dir = "ltr";
                }
              }
              $e.prop("disabled", this.options.disabled);
              $e.prop("multiple", this.options.multiple);
              if (Utils.GetData($e[0], "select2Tags")) {
                if (this.options.debug && window.console && console.warn) {
                  console.warn(
                    'Select2: The `data-select2-tags` attribute has been changed to use the `data-data` and `data-tags="true"` attributes and will be removed in future versions of Select2.'
                  );
                }
                Utils.StoreData($e[0], "data", Utils.GetData($e[0], "select2Tags"));
                Utils.StoreData($e[0], "tags", true);
              }
              if (Utils.GetData($e[0], "ajaxUrl")) {
                if (this.options.debug && window.console && console.warn) {
                  console.warn(
                    "Select2: The `data-ajax-url` attribute has been changed to `data-ajax--url` and support for the old attribute will be removed in future versions of Select2."
                  );
                }
                $e.attr("ajax--url", Utils.GetData($e[0], "ajaxUrl"));
                Utils.StoreData($e[0], "ajax-Url", Utils.GetData($e[0], "ajaxUrl"));
              }
              var dataset = {};
              function upperCaseLetter(_2, letter) {
                return letter.toUpperCase();
              }
              for (var attr = 0; attr < $e[0].attributes.length; attr++) {
                var attributeName = $e[0].attributes[attr].name;
                var prefix = "data-";
                if (attributeName.substr(0, prefix.length) == prefix) {
                  var dataName = attributeName.substring(prefix.length);
                  var dataValue = Utils.GetData($e[0], dataName);
                  var camelDataName = dataName.replace(/-([a-z])/g, upperCaseLetter);
                  dataset[camelDataName] = dataValue;
                }
              }
              if ($3.fn.jquery && $3.fn.jquery.substr(0, 2) == "1." && $e[0].dataset) {
                dataset = $3.extend(true, {}, $e[0].dataset, dataset);
              }
              var data = $3.extend(true, {}, Utils.GetData($e[0]), dataset);
              data = Utils._convertData(data);
              for (var key in data) {
                if (excludedData.indexOf(key) > -1) {
                  continue;
                }
                if ($3.isPlainObject(this.options[key])) {
                  $3.extend(this.options[key], data[key]);
                } else {
                  this.options[key] = data[key];
                }
              }
              return this;
            };
            Options.prototype.get = function(key) {
              return this.options[key];
            };
            Options.prototype.set = function(key, val) {
              this.options[key] = val;
            };
            return Options;
          });
          S22.define("select2/core", [
            "jquery",
            "./options",
            "./utils",
            "./keys"
          ], function($3, Options, Utils, KEYS) {
            var Select2 = function($element, options) {
              if (Utils.GetData($element[0], "select2") != null) {
                Utils.GetData($element[0], "select2").destroy();
              }
              this.$element = $element;
              this.id = this._generateId($element);
              options = options || {};
              this.options = new Options(options, $element);
              Select2.__super__.constructor.call(this);
              var tabindex = $element.attr("tabindex") || 0;
              Utils.StoreData($element[0], "old-tabindex", tabindex);
              $element.attr("tabindex", "-1");
              var DataAdapter = this.options.get("dataAdapter");
              this.dataAdapter = new DataAdapter($element, this.options);
              var $container = this.render();
              this._placeContainer($container);
              var SelectionAdapter = this.options.get("selectionAdapter");
              this.selection = new SelectionAdapter($element, this.options);
              this.$selection = this.selection.render();
              this.selection.position(this.$selection, $container);
              var DropdownAdapter = this.options.get("dropdownAdapter");
              this.dropdown = new DropdownAdapter($element, this.options);
              this.$dropdown = this.dropdown.render();
              this.dropdown.position(this.$dropdown, $container);
              var ResultsAdapter = this.options.get("resultsAdapter");
              this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
              this.$results = this.results.render();
              this.results.position(this.$results, this.$dropdown);
              var self2 = this;
              this._bindAdapters();
              this._registerDomEvents();
              this._registerDataEvents();
              this._registerSelectionEvents();
              this._registerDropdownEvents();
              this._registerResultsEvents();
              this._registerEvents();
              this.dataAdapter.current(function(initialData) {
                self2.trigger("selection:update", {
                  data: initialData
                });
              });
              $element[0].classList.add("select2-hidden-accessible");
              $element.attr("aria-hidden", "true");
              this._syncAttributes();
              Utils.StoreData($element[0], "select2", this);
              $element.data("select2", this);
            };
            Utils.Extend(Select2, Utils.Observable);
            Select2.prototype._generateId = function($element) {
              var id = "";
              if ($element.attr("id") != null) {
                id = $element.attr("id");
              } else if ($element.attr("name") != null) {
                id = $element.attr("name") + "-" + Utils.generateChars(2);
              } else {
                id = Utils.generateChars(4);
              }
              id = id.replace(/(:|\.|\[|\]|,)/g, "");
              id = "select2-" + id;
              return id;
            };
            Select2.prototype._placeContainer = function($container) {
              $container.insertAfter(this.$element);
              var width = this._resolveWidth(this.$element, this.options.get("width"));
              if (width != null) {
                $container.css("width", width);
              }
            };
            Select2.prototype._resolveWidth = function($element, method) {
              var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;
              if (method == "resolve") {
                var styleWidth = this._resolveWidth($element, "style");
                if (styleWidth != null) {
                  return styleWidth;
                }
                return this._resolveWidth($element, "element");
              }
              if (method == "element") {
                var elementWidth = $element.outerWidth(false);
                if (elementWidth <= 0) {
                  return "auto";
                }
                return elementWidth + "px";
              }
              if (method == "style") {
                var style = $element.attr("style");
                if (typeof style !== "string") {
                  return null;
                }
                var attrs = style.split(";");
                for (var i = 0, l = attrs.length; i < l; i = i + 1) {
                  var attr = attrs[i].replace(/\s/g, "");
                  var matches2 = attr.match(WIDTH);
                  if (matches2 !== null && matches2.length >= 1) {
                    return matches2[1];
                  }
                }
                return null;
              }
              if (method == "computedstyle") {
                var computedStyle = window.getComputedStyle($element[0]);
                return computedStyle.width;
              }
              return method;
            };
            Select2.prototype._bindAdapters = function() {
              this.dataAdapter.bind(this, this.$container);
              this.selection.bind(this, this.$container);
              this.dropdown.bind(this, this.$container);
              this.results.bind(this, this.$container);
            };
            Select2.prototype._registerDomEvents = function() {
              var self2 = this;
              this.$element.on("change.select2", function() {
                self2.dataAdapter.current(function(data) {
                  self2.trigger("selection:update", {
                    data
                  });
                });
              });
              this.$element.on("focus.select2", function(evt) {
                self2.trigger("focus", evt);
              });
              this._syncA = Utils.bind(this._syncAttributes, this);
              this._syncS = Utils.bind(this._syncSubtree, this);
              this._observer = new window.MutationObserver(function(mutations) {
                self2._syncA();
                self2._syncS(mutations);
              });
              this._observer.observe(this.$element[0], {
                attributes: true,
                childList: true,
                subtree: false
              });
            };
            Select2.prototype._registerDataEvents = function() {
              var self2 = this;
              this.dataAdapter.on("*", function(name, params) {
                self2.trigger(name, params);
              });
            };
            Select2.prototype._registerSelectionEvents = function() {
              var self2 = this;
              var nonRelayEvents = ["toggle", "focus"];
              this.selection.on("toggle", function() {
                self2.toggleDropdown();
              });
              this.selection.on("focus", function(params) {
                self2.focus(params);
              });
              this.selection.on("*", function(name, params) {
                if (nonRelayEvents.indexOf(name) !== -1) {
                  return;
                }
                self2.trigger(name, params);
              });
            };
            Select2.prototype._registerDropdownEvents = function() {
              var self2 = this;
              this.dropdown.on("*", function(name, params) {
                self2.trigger(name, params);
              });
            };
            Select2.prototype._registerResultsEvents = function() {
              var self2 = this;
              this.results.on("*", function(name, params) {
                self2.trigger(name, params);
              });
            };
            Select2.prototype._registerEvents = function() {
              var self2 = this;
              this.on("open", function() {
                self2.$container[0].classList.add("select2-container--open");
              });
              this.on("close", function() {
                self2.$container[0].classList.remove("select2-container--open");
              });
              this.on("enable", function() {
                self2.$container[0].classList.remove("select2-container--disabled");
              });
              this.on("disable", function() {
                self2.$container[0].classList.add("select2-container--disabled");
              });
              this.on("blur", function() {
                self2.$container[0].classList.remove("select2-container--focus");
              });
              this.on("query", function(params) {
                if (!self2.isOpen()) {
                  self2.trigger("open", {});
                }
                this.dataAdapter.query(params, function(data) {
                  self2.trigger("results:all", {
                    data,
                    query: params
                  });
                });
              });
              this.on("query:append", function(params) {
                this.dataAdapter.query(params, function(data) {
                  self2.trigger("results:append", {
                    data,
                    query: params
                  });
                });
              });
              this.on("keypress", function(evt) {
                var key = evt.which;
                if (self2.isOpen()) {
                  if (key === KEYS.ESC || key === KEYS.UP && evt.altKey) {
                    self2.close(evt);
                    evt.preventDefault();
                  } else if (key === KEYS.ENTER || key === KEYS.TAB) {
                    self2.trigger("results:select", {});
                    evt.preventDefault();
                  } else if (key === KEYS.SPACE && evt.ctrlKey) {
                    self2.trigger("results:toggle", {});
                    evt.preventDefault();
                  } else if (key === KEYS.UP) {
                    self2.trigger("results:previous", {});
                    evt.preventDefault();
                  } else if (key === KEYS.DOWN) {
                    self2.trigger("results:next", {});
                    evt.preventDefault();
                  }
                } else {
                  if (key === KEYS.ENTER || key === KEYS.SPACE || key === KEYS.DOWN && evt.altKey) {
                    self2.open();
                    evt.preventDefault();
                  }
                }
              });
            };
            Select2.prototype._syncAttributes = function() {
              this.options.set("disabled", this.$element.prop("disabled"));
              if (this.isDisabled()) {
                if (this.isOpen()) {
                  this.close();
                }
                this.trigger("disable", {});
              } else {
                this.trigger("enable", {});
              }
            };
            Select2.prototype._isChangeMutation = function(mutations) {
              var self2 = this;
              if (mutations.addedNodes && mutations.addedNodes.length > 0) {
                for (var n = 0; n < mutations.addedNodes.length; n++) {
                  var node = mutations.addedNodes[n];
                  if (node.selected) {
                    return true;
                  }
                }
              } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
                return true;
              } else if (Array.isArray(mutations)) {
                return mutations.some(function(mutation) {
                  return self2._isChangeMutation(mutation);
                });
              }
              return false;
            };
            Select2.prototype._syncSubtree = function(mutations) {
              var changed = this._isChangeMutation(mutations);
              var self2 = this;
              if (changed) {
                this.dataAdapter.current(function(currentData) {
                  self2.trigger("selection:update", {
                    data: currentData
                  });
                });
              }
            };
            Select2.prototype.trigger = function(name, args) {
              var actualTrigger = Select2.__super__.trigger;
              var preTriggerMap = {
                "open": "opening",
                "close": "closing",
                "select": "selecting",
                "unselect": "unselecting",
                "clear": "clearing"
              };
              if (args === void 0) {
                args = {};
              }
              if (name in preTriggerMap) {
                var preTriggerName = preTriggerMap[name];
                var preTriggerArgs = {
                  prevented: false,
                  name,
                  args
                };
                actualTrigger.call(this, preTriggerName, preTriggerArgs);
                if (preTriggerArgs.prevented) {
                  args.prevented = true;
                  return;
                }
              }
              actualTrigger.call(this, name, args);
            };
            Select2.prototype.toggleDropdown = function() {
              if (this.isDisabled()) {
                return;
              }
              if (this.isOpen()) {
                this.close();
              } else {
                this.open();
              }
            };
            Select2.prototype.open = function() {
              if (this.isOpen()) {
                return;
              }
              if (this.isDisabled()) {
                return;
              }
              this.trigger("query", {});
            };
            Select2.prototype.close = function(evt) {
              if (!this.isOpen()) {
                return;
              }
              this.trigger("close", { originalEvent: evt });
            };
            Select2.prototype.isEnabled = function() {
              return !this.isDisabled();
            };
            Select2.prototype.isDisabled = function() {
              return this.options.get("disabled");
            };
            Select2.prototype.isOpen = function() {
              return this.$container[0].classList.contains("select2-container--open");
            };
            Select2.prototype.hasFocus = function() {
              return this.$container[0].classList.contains("select2-container--focus");
            };
            Select2.prototype.focus = function(data) {
              if (this.hasFocus()) {
                return;
              }
              this.$container[0].classList.add("select2-container--focus");
              this.trigger("focus", {});
            };
            Select2.prototype.enable = function(args) {
              if (this.options.get("debug") && window.console && console.warn) {
                console.warn(
                  'Select2: The `select2("enable")` method has been deprecated and will be removed in later Select2 versions. Use $element.prop("disabled") instead.'
                );
              }
              if (args == null || args.length === 0) {
                args = [true];
              }
              var disabled = !args[0];
              this.$element.prop("disabled", disabled);
            };
            Select2.prototype.data = function() {
              if (this.options.get("debug") && arguments.length > 0 && window.console && console.warn) {
                console.warn(
                  'Select2: Data can no longer be set using `select2("data")`. You should consider setting the value instead using `$element.val()`.'
                );
              }
              var data = [];
              this.dataAdapter.current(function(currentData) {
                data = currentData;
              });
              return data;
            };
            Select2.prototype.val = function(args) {
              if (this.options.get("debug") && window.console && console.warn) {
                console.warn(
                  'Select2: The `select2("val")` method has been deprecated and will be removed in later Select2 versions. Use $element.val() instead.'
                );
              }
              if (args == null || args.length === 0) {
                return this.$element.val();
              }
              var newVal = args[0];
              if (Array.isArray(newVal)) {
                newVal = newVal.map(function(obj) {
                  return obj.toString();
                });
              }
              this.$element.val(newVal).trigger("input").trigger("change");
            };
            Select2.prototype.destroy = function() {
              Utils.RemoveData(this.$container[0]);
              this.$container.remove();
              this._observer.disconnect();
              this._observer = null;
              this._syncA = null;
              this._syncS = null;
              this.$element.off(".select2");
              this.$element.attr(
                "tabindex",
                Utils.GetData(this.$element[0], "old-tabindex")
              );
              this.$element[0].classList.remove("select2-hidden-accessible");
              this.$element.attr("aria-hidden", "false");
              Utils.RemoveData(this.$element[0]);
              this.$element.removeData("select2");
              this.dataAdapter.destroy();
              this.selection.destroy();
              this.dropdown.destroy();
              this.results.destroy();
              this.dataAdapter = null;
              this.selection = null;
              this.dropdown = null;
              this.results = null;
            };
            Select2.prototype.render = function() {
              var $container = $3(
                '<span class="select2 select2-container"><span class="selection"></span><span class="dropdown-wrapper" aria-hidden="true"></span></span>'
              );
              $container.attr("dir", this.options.get("dir"));
              this.$container = $container;
              this.$container[0].classList.add("select2-container--" + this.options.get("theme"));
              Utils.StoreData($container[0], "element", this.$element);
              return $container;
            };
            return Select2;
          });
          S22.define("jquery-mousewheel", [
            "jquery"
          ], function($3) {
            return $3;
          });
          S22.define("jquery.select2", [
            "jquery",
            "jquery-mousewheel",
            "./select2/core",
            "./select2/defaults",
            "./select2/utils"
          ], function($3, _2, Select2, Defaults, Utils) {
            if ($3.fn.select2 == null) {
              var thisMethods = ["open", "close", "destroy"];
              $3.fn.select2 = function(options) {
                options = options || {};
                if (typeof options === "object") {
                  this.each(function() {
                    var instanceOptions = $3.extend(true, {}, options);
                    var instance = new Select2($3(this), instanceOptions);
                  });
                  return this;
                } else if (typeof options === "string") {
                  var ret;
                  var args = Array.prototype.slice.call(arguments, 1);
                  this.each(function() {
                    var instance = Utils.GetData(this, "select2");
                    if (instance == null && window.console && console.error) {
                      console.error(
                        "The select2('" + options + "') method was called on an element that is not using Select2."
                      );
                    }
                    ret = instance[options].apply(instance, args);
                  });
                  if (thisMethods.indexOf(options) > -1) {
                    return this;
                  }
                  return ret;
                } else {
                  throw new Error("Invalid arguments for Select2: " + options);
                }
              };
            }
            if ($3.fn.select2.defaults == null) {
              $3.fn.select2.defaults = Defaults;
            }
            return Select2;
          });
          return {
            define: S22.define,
            require: S22.require
          };
        }();
        var select22 = S2.require("jquery.select2");
        jQuery4.fn.select2.amd = S2;
        return select22;
      });
    }
  });

  // node_modules/toastify-js/src/toastify.js
  var require_toastify = __commonJS({
    "node_modules/toastify-js/src/toastify.js"(exports, module) {
      (function(root, factory) {
        if (typeof module === "object" && module.exports) {
          module.exports = factory();
        } else {
          root.Toastify = factory();
        }
      })(exports, function(global2) {
        var Toastify2 = function(options) {
          return new Toastify2.lib.init(options);
        }, version2 = "1.12.0";
        Toastify2.defaults = {
          oldestFirst: true,
          text: "Toastify is awesome!",
          node: void 0,
          duration: 3e3,
          selector: void 0,
          callback: function() {
          },
          destination: void 0,
          newWindow: false,
          close: false,
          gravity: "toastify-top",
          positionLeft: false,
          position: "",
          backgroundColor: "",
          avatar: "",
          className: "",
          stopOnFocus: true,
          onClick: function() {
          },
          offset: { x: 0, y: 0 },
          escapeMarkup: true,
          ariaLive: "polite",
          style: { background: "" }
        };
        Toastify2.lib = Toastify2.prototype = {
          toastify: version2,
          constructor: Toastify2,
          // Initializing the object with required parameters
          init: function(options) {
            if (!options) {
              options = {};
            }
            this.options = {};
            this.toastElement = null;
            this.options.text = options.text || Toastify2.defaults.text;
            this.options.node = options.node || Toastify2.defaults.node;
            this.options.duration = options.duration === 0 ? 0 : options.duration || Toastify2.defaults.duration;
            this.options.selector = options.selector || Toastify2.defaults.selector;
            this.options.callback = options.callback || Toastify2.defaults.callback;
            this.options.destination = options.destination || Toastify2.defaults.destination;
            this.options.newWindow = options.newWindow || Toastify2.defaults.newWindow;
            this.options.close = options.close || Toastify2.defaults.close;
            this.options.gravity = options.gravity === "bottom" ? "toastify-bottom" : Toastify2.defaults.gravity;
            this.options.positionLeft = options.positionLeft || Toastify2.defaults.positionLeft;
            this.options.position = options.position || Toastify2.defaults.position;
            this.options.backgroundColor = options.backgroundColor || Toastify2.defaults.backgroundColor;
            this.options.avatar = options.avatar || Toastify2.defaults.avatar;
            this.options.className = options.className || Toastify2.defaults.className;
            this.options.stopOnFocus = options.stopOnFocus === void 0 ? Toastify2.defaults.stopOnFocus : options.stopOnFocus;
            this.options.onClick = options.onClick || Toastify2.defaults.onClick;
            this.options.offset = options.offset || Toastify2.defaults.offset;
            this.options.escapeMarkup = options.escapeMarkup !== void 0 ? options.escapeMarkup : Toastify2.defaults.escapeMarkup;
            this.options.ariaLive = options.ariaLive || Toastify2.defaults.ariaLive;
            this.options.style = options.style || Toastify2.defaults.style;
            if (options.backgroundColor) {
              this.options.style.background = options.backgroundColor;
            }
            return this;
          },
          // Building the DOM element
          buildToast: function() {
            if (!this.options) {
              throw "Toastify is not initialized";
            }
            var divElement = document.createElement("div");
            divElement.className = "toastify on " + this.options.className;
            if (!!this.options.position) {
              divElement.className += " toastify-" + this.options.position;
            } else {
              if (this.options.positionLeft === true) {
                divElement.className += " toastify-left";
                console.warn("Property `positionLeft` will be depreciated in further versions. Please use `position` instead.");
              } else {
                divElement.className += " toastify-right";
              }
            }
            divElement.className += " " + this.options.gravity;
            if (this.options.backgroundColor) {
              console.warn('DEPRECATION NOTICE: "backgroundColor" is being deprecated. Please use the "style.background" property.');
            }
            for (var property in this.options.style) {
              divElement.style[property] = this.options.style[property];
            }
            if (this.options.ariaLive) {
              divElement.setAttribute("aria-live", this.options.ariaLive);
            }
            if (this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE) {
              divElement.appendChild(this.options.node);
            } else {
              if (this.options.escapeMarkup) {
                divElement.innerText = this.options.text;
              } else {
                divElement.innerHTML = this.options.text;
              }
              if (this.options.avatar !== "") {
                var avatarElement = document.createElement("img");
                avatarElement.src = this.options.avatar;
                avatarElement.className = "toastify-avatar";
                if (this.options.position == "left" || this.options.positionLeft === true) {
                  divElement.appendChild(avatarElement);
                } else {
                  divElement.insertAdjacentElement("afterbegin", avatarElement);
                }
              }
            }
            if (this.options.close === true) {
              var closeElement = document.createElement("button");
              closeElement.type = "button";
              closeElement.setAttribute("aria-label", "Close");
              closeElement.className = "toast-close";
              closeElement.innerHTML = "&#10006;";
              closeElement.addEventListener(
                "click",
                function(event) {
                  event.stopPropagation();
                  this.removeElement(this.toastElement);
                  window.clearTimeout(this.toastElement.timeOutValue);
                }.bind(this)
              );
              var width = window.innerWidth > 0 ? window.innerWidth : screen.width;
              if ((this.options.position == "left" || this.options.positionLeft === true) && width > 360) {
                divElement.insertAdjacentElement("afterbegin", closeElement);
              } else {
                divElement.appendChild(closeElement);
              }
            }
            if (this.options.stopOnFocus && this.options.duration > 0) {
              var self2 = this;
              divElement.addEventListener(
                "mouseover",
                function(event) {
                  window.clearTimeout(divElement.timeOutValue);
                }
              );
              divElement.addEventListener(
                "mouseleave",
                function() {
                  divElement.timeOutValue = window.setTimeout(
                    function() {
                      self2.removeElement(divElement);
                    },
                    self2.options.duration
                  );
                }
              );
            }
            if (typeof this.options.destination !== "undefined") {
              divElement.addEventListener(
                "click",
                function(event) {
                  event.stopPropagation();
                  if (this.options.newWindow === true) {
                    window.open(this.options.destination, "_blank");
                  } else {
                    window.location = this.options.destination;
                  }
                }.bind(this)
              );
            }
            if (typeof this.options.onClick === "function" && typeof this.options.destination === "undefined") {
              divElement.addEventListener(
                "click",
                function(event) {
                  event.stopPropagation();
                  this.options.onClick();
                }.bind(this)
              );
            }
            if (typeof this.options.offset === "object") {
              var x = getAxisOffsetAValue("x", this.options);
              var y = getAxisOffsetAValue("y", this.options);
              var xOffset = this.options.position == "left" ? x : "-" + x;
              var yOffset = this.options.gravity == "toastify-top" ? y : "-" + y;
              divElement.style.transform = "translate(" + xOffset + "," + yOffset + ")";
            }
            return divElement;
          },
          // Displaying the toast
          showToast: function() {
            this.toastElement = this.buildToast();
            var rootElement;
            if (typeof this.options.selector === "string") {
              rootElement = document.getElementById(this.options.selector);
            } else if (this.options.selector instanceof HTMLElement || typeof ShadowRoot !== "undefined" && this.options.selector instanceof ShadowRoot) {
              rootElement = this.options.selector;
            } else {
              rootElement = document.body;
            }
            if (!rootElement) {
              throw "Root element is not defined";
            }
            var elementToInsert = Toastify2.defaults.oldestFirst ? rootElement.firstChild : rootElement.lastChild;
            rootElement.insertBefore(this.toastElement, elementToInsert);
            Toastify2.reposition();
            if (this.options.duration > 0) {
              this.toastElement.timeOutValue = window.setTimeout(
                function() {
                  this.removeElement(this.toastElement);
                }.bind(this),
                this.options.duration
              );
            }
            return this;
          },
          hideToast: function() {
            if (this.toastElement.timeOutValue) {
              clearTimeout(this.toastElement.timeOutValue);
            }
            this.removeElement(this.toastElement);
          },
          // Removing the element from the DOM
          removeElement: function(toastElement) {
            toastElement.className = toastElement.className.replace(" on", "");
            window.setTimeout(
              function() {
                if (this.options.node && this.options.node.parentNode) {
                  this.options.node.parentNode.removeChild(this.options.node);
                }
                if (toastElement.parentNode) {
                  toastElement.parentNode.removeChild(toastElement);
                }
                this.options.callback.call(toastElement);
                Toastify2.reposition();
              }.bind(this),
              400
            );
          }
        };
        Toastify2.reposition = function() {
          var topLeftOffsetSize = {
            top: 15,
            bottom: 15
          };
          var topRightOffsetSize = {
            top: 15,
            bottom: 15
          };
          var offsetSize = {
            top: 15,
            bottom: 15
          };
          var allToasts = document.getElementsByClassName("toastify");
          var classUsed;
          for (var i = 0; i < allToasts.length; i++) {
            if (containsClass(allToasts[i], "toastify-top") === true) {
              classUsed = "toastify-top";
            } else {
              classUsed = "toastify-bottom";
            }
            var height = allToasts[i].offsetHeight;
            classUsed = classUsed.substr(9, classUsed.length - 1);
            var offset = 15;
            var width = window.innerWidth > 0 ? window.innerWidth : screen.width;
            if (width <= 360) {
              allToasts[i].style[classUsed] = offsetSize[classUsed] + "px";
              offsetSize[classUsed] += height + offset;
            } else {
              if (containsClass(allToasts[i], "toastify-left") === true) {
                allToasts[i].style[classUsed] = topLeftOffsetSize[classUsed] + "px";
                topLeftOffsetSize[classUsed] += height + offset;
              } else {
                allToasts[i].style[classUsed] = topRightOffsetSize[classUsed] + "px";
                topRightOffsetSize[classUsed] += height + offset;
              }
            }
          }
          return this;
        };
        function getAxisOffsetAValue(axis, options) {
          if (options.offset[axis]) {
            if (isNaN(options.offset[axis])) {
              return options.offset[axis];
            } else {
              return options.offset[axis] + "px";
            }
          }
          return "0px";
        }
        function containsClass(elem, yourClass) {
          if (!elem || typeof yourClass !== "string") {
            return false;
          } else if (elem.className && elem.className.trim().split(/\s+/gi).indexOf(yourClass) > -1) {
            return true;
          } else {
            return false;
          }
        }
        Toastify2.lib.init.prototype = Toastify2.lib;
        return Toastify2;
      });
    }
  });

  // node_modules/flowbite/dist/flowbite.turbo.js
  var require_flowbite_turbo = __commonJS({
    "node_modules/flowbite/dist/flowbite.turbo.js"(exports, module) {
      (function webpackUniversalModuleDefinition(root, factory) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory();
        else if (typeof define === "function" && define.amd)
          define("Flowbite", [], factory);
        else if (typeof exports === "object")
          exports["Flowbite"] = factory();
        else
          root["Flowbite"] = factory();
      })(self, function() {
        return (
          /******/
          function() {
            "use strict";
            var __webpack_modules__ = {
              /***/
              853: (
                /***/
                function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
                  __webpack_require__2.r(__webpack_exports__2);
                  __webpack_require__2.d(__webpack_exports__2, {
                    "afterMain": function() {
                      return (
                        /* reexport */
                        afterMain
                      );
                    },
                    "afterRead": function() {
                      return (
                        /* reexport */
                        afterRead
                      );
                    },
                    "afterWrite": function() {
                      return (
                        /* reexport */
                        afterWrite
                      );
                    },
                    "applyStyles": function() {
                      return (
                        /* reexport */
                        modifiers_applyStyles
                      );
                    },
                    "arrow": function() {
                      return (
                        /* reexport */
                        modifiers_arrow
                      );
                    },
                    "auto": function() {
                      return (
                        /* reexport */
                        auto
                      );
                    },
                    "basePlacements": function() {
                      return (
                        /* reexport */
                        basePlacements
                      );
                    },
                    "beforeMain": function() {
                      return (
                        /* reexport */
                        beforeMain
                      );
                    },
                    "beforeRead": function() {
                      return (
                        /* reexport */
                        beforeRead
                      );
                    },
                    "beforeWrite": function() {
                      return (
                        /* reexport */
                        beforeWrite
                      );
                    },
                    "bottom": function() {
                      return (
                        /* reexport */
                        bottom
                      );
                    },
                    "clippingParents": function() {
                      return (
                        /* reexport */
                        clippingParents
                      );
                    },
                    "computeStyles": function() {
                      return (
                        /* reexport */
                        modifiers_computeStyles
                      );
                    },
                    "createPopper": function() {
                      return (
                        /* reexport */
                        popper_createPopper
                      );
                    },
                    "createPopperBase": function() {
                      return (
                        /* reexport */
                        createPopper
                      );
                    },
                    "createPopperLite": function() {
                      return (
                        /* reexport */
                        popper_lite_createPopper
                      );
                    },
                    "detectOverflow": function() {
                      return (
                        /* reexport */
                        detectOverflow
                      );
                    },
                    "end": function() {
                      return (
                        /* reexport */
                        end
                      );
                    },
                    "eventListeners": function() {
                      return (
                        /* reexport */
                        eventListeners
                      );
                    },
                    "flip": function() {
                      return (
                        /* reexport */
                        modifiers_flip
                      );
                    },
                    "hide": function() {
                      return (
                        /* reexport */
                        modifiers_hide
                      );
                    },
                    "left": function() {
                      return (
                        /* reexport */
                        left
                      );
                    },
                    "main": function() {
                      return (
                        /* reexport */
                        main
                      );
                    },
                    "modifierPhases": function() {
                      return (
                        /* reexport */
                        modifierPhases
                      );
                    },
                    "offset": function() {
                      return (
                        /* reexport */
                        modifiers_offset
                      );
                    },
                    "placements": function() {
                      return (
                        /* reexport */
                        enums_placements
                      );
                    },
                    "popper": function() {
                      return (
                        /* reexport */
                        popper
                      );
                    },
                    "popperGenerator": function() {
                      return (
                        /* reexport */
                        popperGenerator
                      );
                    },
                    "popperOffsets": function() {
                      return (
                        /* reexport */
                        modifiers_popperOffsets
                      );
                    },
                    "preventOverflow": function() {
                      return (
                        /* reexport */
                        modifiers_preventOverflow
                      );
                    },
                    "read": function() {
                      return (
                        /* reexport */
                        read
                      );
                    },
                    "reference": function() {
                      return (
                        /* reexport */
                        reference
                      );
                    },
                    "right": function() {
                      return (
                        /* reexport */
                        right
                      );
                    },
                    "start": function() {
                      return (
                        /* reexport */
                        start2
                      );
                    },
                    "top": function() {
                      return (
                        /* reexport */
                        enums_top
                      );
                    },
                    "variationPlacements": function() {
                      return (
                        /* reexport */
                        variationPlacements
                      );
                    },
                    "viewport": function() {
                      return (
                        /* reexport */
                        viewport
                      );
                    },
                    "write": function() {
                      return (
                        /* reexport */
                        write
                      );
                    }
                  });
                  ;
                  var enums_top = "top";
                  var bottom = "bottom";
                  var right = "right";
                  var left = "left";
                  var auto = "auto";
                  var basePlacements = [enums_top, bottom, right, left];
                  var start2 = "start";
                  var end = "end";
                  var clippingParents = "clippingParents";
                  var viewport = "viewport";
                  var popper = "popper";
                  var reference = "reference";
                  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
                    return acc.concat([placement + "-" + start2, placement + "-" + end]);
                  }, []);
                  var enums_placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
                    return acc.concat([placement, placement + "-" + start2, placement + "-" + end]);
                  }, []);
                  var beforeRead = "beforeRead";
                  var read = "read";
                  var afterRead = "afterRead";
                  var beforeMain = "beforeMain";
                  var main = "main";
                  var afterMain = "afterMain";
                  var beforeWrite = "beforeWrite";
                  var write = "write";
                  var afterWrite = "afterWrite";
                  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
                  ;
                  function getNodeName(element) {
                    return element ? (element.nodeName || "").toLowerCase() : null;
                  }
                  ;
                  function getWindow(node) {
                    if (node == null) {
                      return window;
                    }
                    if (node.toString() !== "[object Window]") {
                      var ownerDocument = node.ownerDocument;
                      return ownerDocument ? ownerDocument.defaultView || window : window;
                    }
                    return node;
                  }
                  ;
                  function isElement(node) {
                    var OwnElement = getWindow(node).Element;
                    return node instanceof OwnElement || node instanceof Element;
                  }
                  function isHTMLElement(node) {
                    var OwnElement = getWindow(node).HTMLElement;
                    return node instanceof OwnElement || node instanceof HTMLElement;
                  }
                  function isShadowRoot(node) {
                    if (typeof ShadowRoot === "undefined") {
                      return false;
                    }
                    var OwnElement = getWindow(node).ShadowRoot;
                    return node instanceof OwnElement || node instanceof ShadowRoot;
                  }
                  ;
                  function applyStyles(_ref) {
                    var state = _ref.state;
                    Object.keys(state.elements).forEach(function(name) {
                      var style = state.styles[name] || {};
                      var attributes = state.attributes[name] || {};
                      var element = state.elements[name];
                      if (!isHTMLElement(element) || !getNodeName(element)) {
                        return;
                      }
                      Object.assign(element.style, style);
                      Object.keys(attributes).forEach(function(name2) {
                        var value = attributes[name2];
                        if (value === false) {
                          element.removeAttribute(name2);
                        } else {
                          element.setAttribute(name2, value === true ? "" : value);
                        }
                      });
                    });
                  }
                  function effect2(_ref2) {
                    var state = _ref2.state;
                    var initialStyles = {
                      popper: {
                        position: state.options.strategy,
                        left: "0",
                        top: "0",
                        margin: "0"
                      },
                      arrow: {
                        position: "absolute"
                      },
                      reference: {}
                    };
                    Object.assign(state.elements.popper.style, initialStyles.popper);
                    state.styles = initialStyles;
                    if (state.elements.arrow) {
                      Object.assign(state.elements.arrow.style, initialStyles.arrow);
                    }
                    return function() {
                      Object.keys(state.elements).forEach(function(name) {
                        var element = state.elements[name];
                        var attributes = state.attributes[name] || {};
                        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
                        var style = styleProperties.reduce(function(style2, property) {
                          style2[property] = "";
                          return style2;
                        }, {});
                        if (!isHTMLElement(element) || !getNodeName(element)) {
                          return;
                        }
                        Object.assign(element.style, style);
                        Object.keys(attributes).forEach(function(attribute) {
                          element.removeAttribute(attribute);
                        });
                      });
                    };
                  }
                  var modifiers_applyStyles = {
                    name: "applyStyles",
                    enabled: true,
                    phase: "write",
                    fn: applyStyles,
                    effect: effect2,
                    requires: ["computeStyles"]
                  };
                  ;
                  function getBasePlacement(placement) {
                    return placement.split("-")[0];
                  }
                  ;
                  var math_max = Math.max;
                  var math_min = Math.min;
                  var round = Math.round;
                  ;
                  function getUAString() {
                    var uaData = navigator.userAgentData;
                    if (uaData != null && uaData.brands) {
                      return uaData.brands.map(function(item) {
                        return item.brand + "/" + item.version;
                      }).join(" ");
                    }
                    return navigator.userAgent;
                  }
                  ;
                  function isLayoutViewport() {
                    return !/^((?!chrome|android).)*safari/i.test(getUAString());
                  }
                  ;
                  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
                    if (includeScale === void 0) {
                      includeScale = false;
                    }
                    if (isFixedStrategy === void 0) {
                      isFixedStrategy = false;
                    }
                    var clientRect = element.getBoundingClientRect();
                    var scaleX = 1;
                    var scaleY = 1;
                    if (includeScale && isHTMLElement(element)) {
                      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
                      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
                    }
                    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
                    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
                    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
                    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
                    var width = clientRect.width / scaleX;
                    var height = clientRect.height / scaleY;
                    return {
                      width,
                      height,
                      top: y,
                      right: x + width,
                      bottom: y + height,
                      left: x,
                      x,
                      y
                    };
                  }
                  ;
                  function getLayoutRect(element) {
                    var clientRect = getBoundingClientRect(element);
                    var width = element.offsetWidth;
                    var height = element.offsetHeight;
                    if (Math.abs(clientRect.width - width) <= 1) {
                      width = clientRect.width;
                    }
                    if (Math.abs(clientRect.height - height) <= 1) {
                      height = clientRect.height;
                    }
                    return {
                      x: element.offsetLeft,
                      y: element.offsetTop,
                      width,
                      height
                    };
                  }
                  ;
                  function contains(parent, child) {
                    var rootNode = child.getRootNode && child.getRootNode();
                    if (parent.contains(child)) {
                      return true;
                    } else if (rootNode && isShadowRoot(rootNode)) {
                      var next = child;
                      do {
                        if (next && parent.isSameNode(next)) {
                          return true;
                        }
                        next = next.parentNode || next.host;
                      } while (next);
                    }
                    return false;
                  }
                  ;
                  function getComputedStyle2(element) {
                    return getWindow(element).getComputedStyle(element);
                  }
                  ;
                  function isTableElement(element) {
                    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
                  }
                  ;
                  function getDocumentElement(element) {
                    return ((isElement(element) ? element.ownerDocument : (
                      // $FlowFixMe[prop-missing]
                      element.document
                    )) || window.document).documentElement;
                  }
                  ;
                  function getParentNode(element) {
                    if (getNodeName(element) === "html") {
                      return element;
                    }
                    return (
                      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
                      // $FlowFixMe[incompatible-return]
                      // $FlowFixMe[prop-missing]
                      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
                      element.parentNode || // DOM Element detected
                      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
                      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
                      getDocumentElement(element)
                    );
                  }
                  ;
                  function getTrueOffsetParent(element) {
                    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
                    getComputedStyle2(element).position === "fixed") {
                      return null;
                    }
                    return element.offsetParent;
                  }
                  function getContainingBlock(element) {
                    var isFirefox2 = /firefox/i.test(getUAString());
                    var isIE = /Trident/i.test(getUAString());
                    if (isIE && isHTMLElement(element)) {
                      var elementCss = getComputedStyle2(element);
                      if (elementCss.position === "fixed") {
                        return null;
                      }
                    }
                    var currentNode = getParentNode(element);
                    if (isShadowRoot(currentNode)) {
                      currentNode = currentNode.host;
                    }
                    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
                      var css = getComputedStyle2(currentNode);
                      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox2 && css.willChange === "filter" || isFirefox2 && css.filter && css.filter !== "none") {
                        return currentNode;
                      } else {
                        currentNode = currentNode.parentNode;
                      }
                    }
                    return null;
                  }
                  function getOffsetParent(element) {
                    var window2 = getWindow(element);
                    var offsetParent = getTrueOffsetParent(element);
                    while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
                      offsetParent = getTrueOffsetParent(offsetParent);
                    }
                    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
                      return window2;
                    }
                    return offsetParent || getContainingBlock(element) || window2;
                  }
                  ;
                  function getMainAxisFromPlacement(placement) {
                    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
                  }
                  ;
                  function within(min, value, max) {
                    return math_max(min, math_min(value, max));
                  }
                  function withinMaxClamp(min, value, max) {
                    var v = within(min, value, max);
                    return v > max ? max : v;
                  }
                  ;
                  function getFreshSideObject() {
                    return {
                      top: 0,
                      right: 0,
                      bottom: 0,
                      left: 0
                    };
                  }
                  ;
                  function mergePaddingObject(paddingObject) {
                    return Object.assign({}, getFreshSideObject(), paddingObject);
                  }
                  ;
                  function expandToHashMap(value, keys2) {
                    return keys2.reduce(function(hashMap, key) {
                      hashMap[key] = value;
                      return hashMap;
                    }, {});
                  }
                  ;
                  var toPaddingObject = function toPaddingObject2(padding, state) {
                    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
                      placement: state.placement
                    })) : padding;
                    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
                  };
                  function arrow(_ref) {
                    var _state$modifiersData$;
                    var state = _ref.state, name = _ref.name, options = _ref.options;
                    var arrowElement = state.elements.arrow;
                    var popperOffsets2 = state.modifiersData.popperOffsets;
                    var basePlacement = getBasePlacement(state.placement);
                    var axis = getMainAxisFromPlacement(basePlacement);
                    var isVertical = [left, right].indexOf(basePlacement) >= 0;
                    var len = isVertical ? "height" : "width";
                    if (!arrowElement || !popperOffsets2) {
                      return;
                    }
                    var paddingObject = toPaddingObject(options.padding, state);
                    var arrowRect = getLayoutRect(arrowElement);
                    var minProp = axis === "y" ? enums_top : left;
                    var maxProp = axis === "y" ? bottom : right;
                    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
                    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
                    var arrowOffsetParent = getOffsetParent(arrowElement);
                    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
                    var centerToReference = endDiff / 2 - startDiff / 2;
                    var min = paddingObject[minProp];
                    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
                    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
                    var offset2 = within(min, center, max);
                    var axisProp = axis;
                    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
                  }
                  function arrow_effect(_ref2) {
                    var state = _ref2.state, options = _ref2.options;
                    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
                    if (arrowElement == null) {
                      return;
                    }
                    if (typeof arrowElement === "string") {
                      arrowElement = state.elements.popper.querySelector(arrowElement);
                      if (!arrowElement) {
                        return;
                      }
                    }
                    if (false) {
                    }
                    if (!contains(state.elements.popper, arrowElement)) {
                      if (false) {
                      }
                      return;
                    }
                    state.elements.arrow = arrowElement;
                  }
                  var modifiers_arrow = {
                    name: "arrow",
                    enabled: true,
                    phase: "main",
                    fn: arrow,
                    effect: arrow_effect,
                    requires: ["popperOffsets"],
                    requiresIfExists: ["preventOverflow"]
                  };
                  ;
                  function getVariation(placement) {
                    return placement.split("-")[1];
                  }
                  ;
                  var unsetSides = {
                    top: "auto",
                    right: "auto",
                    bottom: "auto",
                    left: "auto"
                  };
                  function roundOffsetsByDPR(_ref) {
                    var x = _ref.x, y = _ref.y;
                    var win = window;
                    var dpr = win.devicePixelRatio || 1;
                    return {
                      x: round(x * dpr) / dpr || 0,
                      y: round(y * dpr) / dpr || 0
                    };
                  }
                  function mapToStyles(_ref2) {
                    var _Object$assign2;
                    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
                    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
                    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
                      x,
                      y
                    }) : {
                      x,
                      y
                    };
                    x = _ref3.x;
                    y = _ref3.y;
                    var hasX = offsets.hasOwnProperty("x");
                    var hasY = offsets.hasOwnProperty("y");
                    var sideX = left;
                    var sideY = enums_top;
                    var win = window;
                    if (adaptive) {
                      var offsetParent = getOffsetParent(popper2);
                      var heightProp = "clientHeight";
                      var widthProp = "clientWidth";
                      if (offsetParent === getWindow(popper2)) {
                        offsetParent = getDocumentElement(popper2);
                        if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
                          heightProp = "scrollHeight";
                          widthProp = "scrollWidth";
                        }
                      }
                      offsetParent = offsetParent;
                      if (placement === enums_top || (placement === left || placement === right) && variation === end) {
                        sideY = bottom;
                        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
                          // $FlowFixMe[prop-missing]
                          offsetParent[heightProp]
                        );
                        y -= offsetY - popperRect.height;
                        y *= gpuAcceleration ? 1 : -1;
                      }
                      if (placement === left || (placement === enums_top || placement === bottom) && variation === end) {
                        sideX = right;
                        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
                          // $FlowFixMe[prop-missing]
                          offsetParent[widthProp]
                        );
                        x -= offsetX - popperRect.width;
                        x *= gpuAcceleration ? 1 : -1;
                      }
                    }
                    var commonStyles = Object.assign({
                      position
                    }, adaptive && unsetSides);
                    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
                      x,
                      y
                    }) : {
                      x,
                      y
                    };
                    x = _ref4.x;
                    y = _ref4.y;
                    if (gpuAcceleration) {
                      var _Object$assign;
                      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
                    }
                    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
                  }
                  function computeStyles(_ref5) {
                    var state = _ref5.state, options = _ref5.options;
                    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
                    if (false) {
                      var transitionProperty;
                    }
                    var commonStyles = {
                      placement: getBasePlacement(state.placement),
                      variation: getVariation(state.placement),
                      popper: state.elements.popper,
                      popperRect: state.rects.popper,
                      gpuAcceleration,
                      isFixed: state.options.strategy === "fixed"
                    };
                    if (state.modifiersData.popperOffsets != null) {
                      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
                        offsets: state.modifiersData.popperOffsets,
                        position: state.options.strategy,
                        adaptive,
                        roundOffsets
                      })));
                    }
                    if (state.modifiersData.arrow != null) {
                      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
                        offsets: state.modifiersData.arrow,
                        position: "absolute",
                        adaptive: false,
                        roundOffsets
                      })));
                    }
                    state.attributes.popper = Object.assign({}, state.attributes.popper, {
                      "data-popper-placement": state.placement
                    });
                  }
                  var modifiers_computeStyles = {
                    name: "computeStyles",
                    enabled: true,
                    phase: "beforeWrite",
                    fn: computeStyles,
                    data: {}
                  };
                  ;
                  var passive = {
                    passive: true
                  };
                  function eventListeners_effect(_ref) {
                    var state = _ref.state, instance = _ref.instance, options = _ref.options;
                    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
                    var window2 = getWindow(state.elements.popper);
                    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
                    if (scroll) {
                      scrollParents.forEach(function(scrollParent) {
                        scrollParent.addEventListener("scroll", instance.update, passive);
                      });
                    }
                    if (resize) {
                      window2.addEventListener("resize", instance.update, passive);
                    }
                    return function() {
                      if (scroll) {
                        scrollParents.forEach(function(scrollParent) {
                          scrollParent.removeEventListener("scroll", instance.update, passive);
                        });
                      }
                      if (resize) {
                        window2.removeEventListener("resize", instance.update, passive);
                      }
                    };
                  }
                  var eventListeners = {
                    name: "eventListeners",
                    enabled: true,
                    phase: "write",
                    fn: function fn() {
                    },
                    effect: eventListeners_effect,
                    data: {}
                  };
                  ;
                  var hash = {
                    left: "right",
                    right: "left",
                    bottom: "top",
                    top: "bottom"
                  };
                  function getOppositePlacement(placement) {
                    return placement.replace(/left|right|bottom|top/g, function(matched) {
                      return hash[matched];
                    });
                  }
                  ;
                  var getOppositeVariationPlacement_hash = {
                    start: "end",
                    end: "start"
                  };
                  function getOppositeVariationPlacement(placement) {
                    return placement.replace(/start|end/g, function(matched) {
                      return getOppositeVariationPlacement_hash[matched];
                    });
                  }
                  ;
                  function getWindowScroll(node) {
                    var win = getWindow(node);
                    var scrollLeft = win.pageXOffset;
                    var scrollTop = win.pageYOffset;
                    return {
                      scrollLeft,
                      scrollTop
                    };
                  }
                  ;
                  function getWindowScrollBarX(element) {
                    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
                  }
                  ;
                  function getViewportRect(element, strategy) {
                    var win = getWindow(element);
                    var html = getDocumentElement(element);
                    var visualViewport = win.visualViewport;
                    var width = html.clientWidth;
                    var height = html.clientHeight;
                    var x = 0;
                    var y = 0;
                    if (visualViewport) {
                      width = visualViewport.width;
                      height = visualViewport.height;
                      var layoutViewport = isLayoutViewport();
                      if (layoutViewport || !layoutViewport && strategy === "fixed") {
                        x = visualViewport.offsetLeft;
                        y = visualViewport.offsetTop;
                      }
                    }
                    return {
                      width,
                      height,
                      x: x + getWindowScrollBarX(element),
                      y
                    };
                  }
                  ;
                  function getDocumentRect(element) {
                    var _element$ownerDocumen;
                    var html = getDocumentElement(element);
                    var winScroll = getWindowScroll(element);
                    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
                    var width = math_max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
                    var height = math_max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
                    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
                    var y = -winScroll.scrollTop;
                    if (getComputedStyle2(body || html).direction === "rtl") {
                      x += math_max(html.clientWidth, body ? body.clientWidth : 0) - width;
                    }
                    return {
                      width,
                      height,
                      x,
                      y
                    };
                  }
                  ;
                  function isScrollParent(element) {
                    var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
                    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
                  }
                  ;
                  function getScrollParent(node) {
                    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
                      return node.ownerDocument.body;
                    }
                    if (isHTMLElement(node) && isScrollParent(node)) {
                      return node;
                    }
                    return getScrollParent(getParentNode(node));
                  }
                  ;
                  function listScrollParents(element, list) {
                    var _element$ownerDocumen;
                    if (list === void 0) {
                      list = [];
                    }
                    var scrollParent = getScrollParent(element);
                    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
                    var win = getWindow(scrollParent);
                    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
                    var updatedList = list.concat(target);
                    return isBody ? updatedList : (
                      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
                      updatedList.concat(listScrollParents(getParentNode(target)))
                    );
                  }
                  ;
                  function rectToClientRect(rect) {
                    return Object.assign({}, rect, {
                      left: rect.x,
                      top: rect.y,
                      right: rect.x + rect.width,
                      bottom: rect.y + rect.height
                    });
                  }
                  ;
                  function getInnerBoundingClientRect(element, strategy) {
                    var rect = getBoundingClientRect(element, false, strategy === "fixed");
                    rect.top = rect.top + element.clientTop;
                    rect.left = rect.left + element.clientLeft;
                    rect.bottom = rect.top + element.clientHeight;
                    rect.right = rect.left + element.clientWidth;
                    rect.width = element.clientWidth;
                    rect.height = element.clientHeight;
                    rect.x = rect.left;
                    rect.y = rect.top;
                    return rect;
                  }
                  function getClientRectFromMixedType(element, clippingParent, strategy) {
                    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
                  }
                  function getClippingParents(element) {
                    var clippingParents2 = listScrollParents(getParentNode(element));
                    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
                    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
                    if (!isElement(clipperElement)) {
                      return [];
                    }
                    return clippingParents2.filter(function(clippingParent) {
                      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
                    });
                  }
                  function getClippingRect(element, boundary, rootBoundary, strategy) {
                    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
                    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
                    var firstClippingParent = clippingParents2[0];
                    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
                      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
                      accRect.top = math_max(rect.top, accRect.top);
                      accRect.right = math_min(rect.right, accRect.right);
                      accRect.bottom = math_min(rect.bottom, accRect.bottom);
                      accRect.left = math_max(rect.left, accRect.left);
                      return accRect;
                    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
                    clippingRect.width = clippingRect.right - clippingRect.left;
                    clippingRect.height = clippingRect.bottom - clippingRect.top;
                    clippingRect.x = clippingRect.left;
                    clippingRect.y = clippingRect.top;
                    return clippingRect;
                  }
                  ;
                  function computeOffsets(_ref) {
                    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
                    var basePlacement = placement ? getBasePlacement(placement) : null;
                    var variation = placement ? getVariation(placement) : null;
                    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
                    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
                    var offsets;
                    switch (basePlacement) {
                      case enums_top:
                        offsets = {
                          x: commonX,
                          y: reference2.y - element.height
                        };
                        break;
                      case bottom:
                        offsets = {
                          x: commonX,
                          y: reference2.y + reference2.height
                        };
                        break;
                      case right:
                        offsets = {
                          x: reference2.x + reference2.width,
                          y: commonY
                        };
                        break;
                      case left:
                        offsets = {
                          x: reference2.x - element.width,
                          y: commonY
                        };
                        break;
                      default:
                        offsets = {
                          x: reference2.x,
                          y: reference2.y
                        };
                    }
                    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
                    if (mainAxis != null) {
                      var len = mainAxis === "y" ? "height" : "width";
                      switch (variation) {
                        case start2:
                          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
                          break;
                        case end:
                          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
                          break;
                        default:
                      }
                    }
                    return offsets;
                  }
                  ;
                  function detectOverflow(state, options) {
                    if (options === void 0) {
                      options = {};
                    }
                    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
                    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
                    var altContext = elementContext === popper ? reference : popper;
                    var popperRect = state.rects.popper;
                    var element = state.elements[altBoundary ? altContext : elementContext];
                    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
                    var referenceClientRect = getBoundingClientRect(state.elements.reference);
                    var popperOffsets2 = computeOffsets({
                      reference: referenceClientRect,
                      element: popperRect,
                      strategy: "absolute",
                      placement
                    });
                    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
                    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
                    var overflowOffsets = {
                      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
                      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
                      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
                      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
                    };
                    var offsetData = state.modifiersData.offset;
                    if (elementContext === popper && offsetData) {
                      var offset2 = offsetData[placement];
                      Object.keys(overflowOffsets).forEach(function(key) {
                        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
                        var axis = [enums_top, bottom].indexOf(key) >= 0 ? "y" : "x";
                        overflowOffsets[key] += offset2[axis] * multiply;
                      });
                    }
                    return overflowOffsets;
                  }
                  ;
                  function computeAutoPlacement(state, options) {
                    if (options === void 0) {
                      options = {};
                    }
                    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? enums_placements : _options$allowedAutoP;
                    var variation = getVariation(placement);
                    var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
                      return getVariation(placement2) === variation;
                    }) : basePlacements;
                    var allowedPlacements = placements.filter(function(placement2) {
                      return allowedAutoPlacements.indexOf(placement2) >= 0;
                    });
                    if (allowedPlacements.length === 0) {
                      allowedPlacements = placements;
                      if (false) {
                      }
                    }
                    var overflows = allowedPlacements.reduce(function(acc, placement2) {
                      acc[placement2] = detectOverflow(state, {
                        placement: placement2,
                        boundary,
                        rootBoundary,
                        padding
                      })[getBasePlacement(placement2)];
                      return acc;
                    }, {});
                    return Object.keys(overflows).sort(function(a, b) {
                      return overflows[a] - overflows[b];
                    });
                  }
                  ;
                  function getExpandedFallbackPlacements(placement) {
                    if (getBasePlacement(placement) === auto) {
                      return [];
                    }
                    var oppositePlacement = getOppositePlacement(placement);
                    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
                  }
                  function flip(_ref) {
                    var state = _ref.state, options = _ref.options, name = _ref.name;
                    if (state.modifiersData[name]._skip) {
                      return;
                    }
                    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
                    var preferredPlacement = state.options.placement;
                    var basePlacement = getBasePlacement(preferredPlacement);
                    var isBasePlacement = basePlacement === preferredPlacement;
                    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
                    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
                      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
                        placement: placement2,
                        boundary,
                        rootBoundary,
                        padding,
                        flipVariations,
                        allowedAutoPlacements
                      }) : placement2);
                    }, []);
                    var referenceRect = state.rects.reference;
                    var popperRect = state.rects.popper;
                    var checksMap = /* @__PURE__ */ new Map();
                    var makeFallbackChecks = true;
                    var firstFittingPlacement = placements[0];
                    for (var i = 0; i < placements.length; i++) {
                      var placement = placements[i];
                      var _basePlacement = getBasePlacement(placement);
                      var isStartVariation = getVariation(placement) === start2;
                      var isVertical = [enums_top, bottom].indexOf(_basePlacement) >= 0;
                      var len = isVertical ? "width" : "height";
                      var overflow = detectOverflow(state, {
                        placement,
                        boundary,
                        rootBoundary,
                        altBoundary,
                        padding
                      });
                      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : enums_top;
                      if (referenceRect[len] > popperRect[len]) {
                        mainVariationSide = getOppositePlacement(mainVariationSide);
                      }
                      var altVariationSide = getOppositePlacement(mainVariationSide);
                      var checks = [];
                      if (checkMainAxis) {
                        checks.push(overflow[_basePlacement] <= 0);
                      }
                      if (checkAltAxis) {
                        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
                      }
                      if (checks.every(function(check) {
                        return check;
                      })) {
                        firstFittingPlacement = placement;
                        makeFallbackChecks = false;
                        break;
                      }
                      checksMap.set(placement, checks);
                    }
                    if (makeFallbackChecks) {
                      var numberOfChecks = flipVariations ? 3 : 1;
                      var _loop = function _loop2(_i2) {
                        var fittingPlacement = placements.find(function(placement2) {
                          var checks2 = checksMap.get(placement2);
                          if (checks2) {
                            return checks2.slice(0, _i2).every(function(check) {
                              return check;
                            });
                          }
                        });
                        if (fittingPlacement) {
                          firstFittingPlacement = fittingPlacement;
                          return "break";
                        }
                      };
                      for (var _i = numberOfChecks; _i > 0; _i--) {
                        var _ret = _loop(_i);
                        if (_ret === "break")
                          break;
                      }
                    }
                    if (state.placement !== firstFittingPlacement) {
                      state.modifiersData[name]._skip = true;
                      state.placement = firstFittingPlacement;
                      state.reset = true;
                    }
                  }
                  var modifiers_flip = {
                    name: "flip",
                    enabled: true,
                    phase: "main",
                    fn: flip,
                    requiresIfExists: ["offset"],
                    data: {
                      _skip: false
                    }
                  };
                  ;
                  function getSideOffsets(overflow, rect, preventedOffsets) {
                    if (preventedOffsets === void 0) {
                      preventedOffsets = {
                        x: 0,
                        y: 0
                      };
                    }
                    return {
                      top: overflow.top - rect.height - preventedOffsets.y,
                      right: overflow.right - rect.width + preventedOffsets.x,
                      bottom: overflow.bottom - rect.height + preventedOffsets.y,
                      left: overflow.left - rect.width - preventedOffsets.x
                    };
                  }
                  function isAnySideFullyClipped(overflow) {
                    return [enums_top, right, bottom, left].some(function(side) {
                      return overflow[side] >= 0;
                    });
                  }
                  function hide(_ref) {
                    var state = _ref.state, name = _ref.name;
                    var referenceRect = state.rects.reference;
                    var popperRect = state.rects.popper;
                    var preventedOffsets = state.modifiersData.preventOverflow;
                    var referenceOverflow = detectOverflow(state, {
                      elementContext: "reference"
                    });
                    var popperAltOverflow = detectOverflow(state, {
                      altBoundary: true
                    });
                    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
                    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
                    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
                    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
                    state.modifiersData[name] = {
                      referenceClippingOffsets,
                      popperEscapeOffsets,
                      isReferenceHidden,
                      hasPopperEscaped
                    };
                    state.attributes.popper = Object.assign({}, state.attributes.popper, {
                      "data-popper-reference-hidden": isReferenceHidden,
                      "data-popper-escaped": hasPopperEscaped
                    });
                  }
                  var modifiers_hide = {
                    name: "hide",
                    enabled: true,
                    phase: "main",
                    requiresIfExists: ["preventOverflow"],
                    fn: hide
                  };
                  ;
                  function distanceAndSkiddingToXY(placement, rects, offset2) {
                    var basePlacement = getBasePlacement(placement);
                    var invertDistance = [left, enums_top].indexOf(basePlacement) >= 0 ? -1 : 1;
                    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
                      placement
                    })) : offset2, skidding = _ref[0], distance = _ref[1];
                    skidding = skidding || 0;
                    distance = (distance || 0) * invertDistance;
                    return [left, right].indexOf(basePlacement) >= 0 ? {
                      x: distance,
                      y: skidding
                    } : {
                      x: skidding,
                      y: distance
                    };
                  }
                  function offset(_ref2) {
                    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
                    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
                    var data = enums_placements.reduce(function(acc, placement) {
                      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
                      return acc;
                    }, {});
                    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
                    if (state.modifiersData.popperOffsets != null) {
                      state.modifiersData.popperOffsets.x += x;
                      state.modifiersData.popperOffsets.y += y;
                    }
                    state.modifiersData[name] = data;
                  }
                  var modifiers_offset = {
                    name: "offset",
                    enabled: true,
                    phase: "main",
                    requires: ["popperOffsets"],
                    fn: offset
                  };
                  ;
                  function popperOffsets(_ref) {
                    var state = _ref.state, name = _ref.name;
                    state.modifiersData[name] = computeOffsets({
                      reference: state.rects.reference,
                      element: state.rects.popper,
                      strategy: "absolute",
                      placement: state.placement
                    });
                  }
                  var modifiers_popperOffsets = {
                    name: "popperOffsets",
                    enabled: true,
                    phase: "read",
                    fn: popperOffsets,
                    data: {}
                  };
                  ;
                  function getAltAxis(axis) {
                    return axis === "x" ? "y" : "x";
                  }
                  ;
                  function preventOverflow(_ref) {
                    var state = _ref.state, options = _ref.options, name = _ref.name;
                    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
                    var overflow = detectOverflow(state, {
                      boundary,
                      rootBoundary,
                      padding,
                      altBoundary
                    });
                    var basePlacement = getBasePlacement(state.placement);
                    var variation = getVariation(state.placement);
                    var isBasePlacement = !variation;
                    var mainAxis = getMainAxisFromPlacement(basePlacement);
                    var altAxis = getAltAxis(mainAxis);
                    var popperOffsets2 = state.modifiersData.popperOffsets;
                    var referenceRect = state.rects.reference;
                    var popperRect = state.rects.popper;
                    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
                      placement: state.placement
                    })) : tetherOffset;
                    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
                      mainAxis: tetherOffsetValue,
                      altAxis: tetherOffsetValue
                    } : Object.assign({
                      mainAxis: 0,
                      altAxis: 0
                    }, tetherOffsetValue);
                    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
                    var data = {
                      x: 0,
                      y: 0
                    };
                    if (!popperOffsets2) {
                      return;
                    }
                    if (checkMainAxis) {
                      var _offsetModifierState$;
                      var mainSide = mainAxis === "y" ? enums_top : left;
                      var altSide = mainAxis === "y" ? bottom : right;
                      var len = mainAxis === "y" ? "height" : "width";
                      var offset2 = popperOffsets2[mainAxis];
                      var min = offset2 + overflow[mainSide];
                      var max = offset2 - overflow[altSide];
                      var additive = tether ? -popperRect[len] / 2 : 0;
                      var minLen = variation === start2 ? referenceRect[len] : popperRect[len];
                      var maxLen = variation === start2 ? -popperRect[len] : -referenceRect[len];
                      var arrowElement = state.elements.arrow;
                      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
                        width: 0,
                        height: 0
                      };
                      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
                      var arrowPaddingMin = arrowPaddingObject[mainSide];
                      var arrowPaddingMax = arrowPaddingObject[altSide];
                      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
                      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
                      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
                      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
                      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
                      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
                      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
                      var tetherMax = offset2 + maxOffset - offsetModifierValue;
                      var preventedOffset = within(tether ? math_min(min, tetherMin) : min, offset2, tether ? math_max(max, tetherMax) : max);
                      popperOffsets2[mainAxis] = preventedOffset;
                      data[mainAxis] = preventedOffset - offset2;
                    }
                    if (checkAltAxis) {
                      var _offsetModifierState$2;
                      var _mainSide = mainAxis === "x" ? enums_top : left;
                      var _altSide = mainAxis === "x" ? bottom : right;
                      var _offset = popperOffsets2[altAxis];
                      var _len = altAxis === "y" ? "height" : "width";
                      var _min = _offset + overflow[_mainSide];
                      var _max = _offset - overflow[_altSide];
                      var isOriginSide = [enums_top, left].indexOf(basePlacement) !== -1;
                      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
                      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
                      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
                      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
                      popperOffsets2[altAxis] = _preventedOffset;
                      data[altAxis] = _preventedOffset - _offset;
                    }
                    state.modifiersData[name] = data;
                  }
                  var modifiers_preventOverflow = {
                    name: "preventOverflow",
                    enabled: true,
                    phase: "main",
                    fn: preventOverflow,
                    requiresIfExists: ["offset"]
                  };
                  ;
                  ;
                  function getHTMLElementScroll(element) {
                    return {
                      scrollLeft: element.scrollLeft,
                      scrollTop: element.scrollTop
                    };
                  }
                  ;
                  function getNodeScroll(node) {
                    if (node === getWindow(node) || !isHTMLElement(node)) {
                      return getWindowScroll(node);
                    } else {
                      return getHTMLElementScroll(node);
                    }
                  }
                  ;
                  function isElementScaled(element) {
                    var rect = element.getBoundingClientRect();
                    var scaleX = round(rect.width) / element.offsetWidth || 1;
                    var scaleY = round(rect.height) / element.offsetHeight || 1;
                    return scaleX !== 1 || scaleY !== 1;
                  }
                  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
                    if (isFixed === void 0) {
                      isFixed = false;
                    }
                    var isOffsetParentAnElement = isHTMLElement(offsetParent);
                    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
                    var documentElement = getDocumentElement(offsetParent);
                    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
                    var scroll = {
                      scrollLeft: 0,
                      scrollTop: 0
                    };
                    var offsets = {
                      x: 0,
                      y: 0
                    };
                    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
                      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
                      isScrollParent(documentElement)) {
                        scroll = getNodeScroll(offsetParent);
                      }
                      if (isHTMLElement(offsetParent)) {
                        offsets = getBoundingClientRect(offsetParent, true);
                        offsets.x += offsetParent.clientLeft;
                        offsets.y += offsetParent.clientTop;
                      } else if (documentElement) {
                        offsets.x = getWindowScrollBarX(documentElement);
                      }
                    }
                    return {
                      x: rect.left + scroll.scrollLeft - offsets.x,
                      y: rect.top + scroll.scrollTop - offsets.y,
                      width: rect.width,
                      height: rect.height
                    };
                  }
                  ;
                  function order(modifiers) {
                    var map2 = /* @__PURE__ */ new Map();
                    var visited = /* @__PURE__ */ new Set();
                    var result = [];
                    modifiers.forEach(function(modifier) {
                      map2.set(modifier.name, modifier);
                    });
                    function sort(modifier) {
                      visited.add(modifier.name);
                      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
                      requires.forEach(function(dep) {
                        if (!visited.has(dep)) {
                          var depModifier = map2.get(dep);
                          if (depModifier) {
                            sort(depModifier);
                          }
                        }
                      });
                      result.push(modifier);
                    }
                    modifiers.forEach(function(modifier) {
                      if (!visited.has(modifier.name)) {
                        sort(modifier);
                      }
                    });
                    return result;
                  }
                  function orderModifiers(modifiers) {
                    var orderedModifiers = order(modifiers);
                    return modifierPhases.reduce(function(acc, phase) {
                      return acc.concat(orderedModifiers.filter(function(modifier) {
                        return modifier.phase === phase;
                      }));
                    }, []);
                  }
                  ;
                  function debounce3(fn) {
                    var pending;
                    return function() {
                      if (!pending) {
                        pending = new Promise(function(resolve2) {
                          Promise.resolve().then(function() {
                            pending = void 0;
                            resolve2(fn());
                          });
                        });
                      }
                      return pending;
                    };
                  }
                  ;
                  function mergeByName(modifiers) {
                    var merged = modifiers.reduce(function(merged2, current) {
                      var existing = merged2[current.name];
                      merged2[current.name] = existing ? Object.assign({}, existing, current, {
                        options: Object.assign({}, existing.options, current.options),
                        data: Object.assign({}, existing.data, current.data)
                      }) : current;
                      return merged2;
                    }, {});
                    return Object.keys(merged).map(function(key) {
                      return merged[key];
                    });
                  }
                  ;
                  var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
                  var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
                  var DEFAULT_OPTIONS = {
                    placement: "bottom",
                    modifiers: [],
                    strategy: "absolute"
                  };
                  function areValidElements() {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }
                    return !args.some(function(element) {
                      return !(element && typeof element.getBoundingClientRect === "function");
                    });
                  }
                  function popperGenerator(generatorOptions) {
                    if (generatorOptions === void 0) {
                      generatorOptions = {};
                    }
                    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
                    return function createPopper2(reference2, popper2, options) {
                      if (options === void 0) {
                        options = defaultOptions2;
                      }
                      var state = {
                        placement: "bottom",
                        orderedModifiers: [],
                        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
                        modifiersData: {},
                        elements: {
                          reference: reference2,
                          popper: popper2
                        },
                        attributes: {},
                        styles: {}
                      };
                      var effectCleanupFns = [];
                      var isDestroyed = false;
                      var instance = {
                        state,
                        setOptions: function setOptions(setOptionsAction) {
                          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
                          cleanupModifierEffects();
                          state.options = Object.assign({}, defaultOptions2, state.options, options2);
                          state.scrollParents = {
                            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
                            popper: listScrollParents(popper2)
                          };
                          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
                          state.orderedModifiers = orderedModifiers.filter(function(m) {
                            return m.enabled;
                          });
                          if (false) {
                            var _getComputedStyle, marginTop, marginRight, marginBottom, marginLeft, flipModifier, modifiers;
                          }
                          runModifierEffects();
                          return instance.update();
                        },
                        // Sync update  it will always be executed, even if not necessary. This
                        // is useful for low frequency updates where sync behavior simplifies the
                        // logic.
                        // For high frequency updates (e.g. `resize` and `scroll` events), always
                        // prefer the async Popper#update method
                        forceUpdate: function forceUpdate() {
                          if (isDestroyed) {
                            return;
                          }
                          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
                          if (!areValidElements(reference3, popper3)) {
                            if (false) {
                            }
                            return;
                          }
                          state.rects = {
                            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
                            popper: getLayoutRect(popper3)
                          };
                          state.reset = false;
                          state.placement = state.options.placement;
                          state.orderedModifiers.forEach(function(modifier) {
                            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                          });
                          var __debug_loops__ = 0;
                          for (var index = 0; index < state.orderedModifiers.length; index++) {
                            if (false) {
                            }
                            if (state.reset === true) {
                              state.reset = false;
                              index = -1;
                              continue;
                            }
                            var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                            if (typeof fn === "function") {
                              state = fn({
                                state,
                                options: _options,
                                name,
                                instance
                              }) || state;
                            }
                          }
                        },
                        // Async and optimistically optimized update  it will not be executed if
                        // not necessary (debounced to run at most once-per-tick)
                        update: debounce3(function() {
                          return new Promise(function(resolve2) {
                            instance.forceUpdate();
                            resolve2(state);
                          });
                        }),
                        destroy: function destroy() {
                          cleanupModifierEffects();
                          isDestroyed = true;
                        }
                      };
                      if (!areValidElements(reference2, popper2)) {
                        if (false) {
                        }
                        return instance;
                      }
                      instance.setOptions(options).then(function(state2) {
                        if (!isDestroyed && options.onFirstUpdate) {
                          options.onFirstUpdate(state2);
                        }
                      });
                      function runModifierEffects() {
                        state.orderedModifiers.forEach(function(_ref3) {
                          var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect3 = _ref3.effect;
                          if (typeof effect3 === "function") {
                            var cleanupFn = effect3({
                              state,
                              name,
                              instance,
                              options: options2
                            });
                            var noopFn = function noopFn2() {
                            };
                            effectCleanupFns.push(cleanupFn || noopFn);
                          }
                        });
                      }
                      function cleanupModifierEffects() {
                        effectCleanupFns.forEach(function(fn) {
                          return fn();
                        });
                        effectCleanupFns = [];
                      }
                      return instance;
                    };
                  }
                  var createPopper = /* @__PURE__ */ popperGenerator();
                  ;
                  var defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles, modifiers_offset, modifiers_flip, modifiers_preventOverflow, modifiers_arrow, modifiers_hide];
                  var popper_createPopper = /* @__PURE__ */ popperGenerator({
                    defaultModifiers
                  });
                  ;
                  var popper_lite_defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles];
                  var popper_lite_createPopper = /* @__PURE__ */ popperGenerator({
                    defaultModifiers: popper_lite_defaultModifiers
                  });
                  ;
                }
              ),
              /***/
              554: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  function _arrayLikeToArray(r, a) {
                    (null == a || a > r.length) && (a = r.length);
                    for (var e = 0, n = Array(a); e < a; e++)
                      n[e] = r[e];
                    return n;
                  }
                  function _arrayWithHoles(r) {
                    if (Array.isArray(r))
                      return r;
                  }
                  function _arrayWithoutHoles(r) {
                    if (Array.isArray(r))
                      return _arrayLikeToArray(r);
                  }
                  function _assertThisInitialized(e) {
                    if (void 0 === e)
                      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e;
                  }
                  function _callSuper(t, o, e) {
                    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
                  }
                  function _classCallCheck(a, n) {
                    if (!(a instanceof n))
                      throw new TypeError("Cannot call a class as a function");
                  }
                  function _defineProperties(e, r) {
                    for (var t = 0; t < r.length; t++) {
                      var o = r[t];
                      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
                    }
                  }
                  function _createClass(e, r, t) {
                    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
                      writable: false
                    }), e;
                  }
                  function _get() {
                    return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
                      var p2 = _superPropBase(e, t);
                      if (p2) {
                        var n = Object.getOwnPropertyDescriptor(p2, t);
                        return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
                      }
                    }, _get.apply(null, arguments);
                  }
                  function _getPrototypeOf(t) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
                      return t2.__proto__ || Object.getPrototypeOf(t2);
                    }, _getPrototypeOf(t);
                  }
                  function _inherits(t, e) {
                    if ("function" != typeof e && null !== e)
                      throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                      constructor: {
                        value: t,
                        writable: true,
                        configurable: true
                      }
                    }), Object.defineProperty(t, "prototype", {
                      writable: false
                    }), e && _setPrototypeOf(t, e);
                  }
                  function _isNativeReflectConstruct() {
                    try {
                      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                      }));
                    } catch (t2) {
                    }
                    return (_isNativeReflectConstruct = function() {
                      return !!t;
                    })();
                  }
                  function _iterableToArray(r) {
                    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"])
                      return Array.from(r);
                  }
                  function _iterableToArrayLimit(r, l) {
                    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
                    if (null != t) {
                      var e, n, i, u, a = [], f = true, o = false;
                      try {
                        if (i = (t = t.call(r)).next, 0 === l) {
                          if (Object(t) !== t)
                            return;
                          f = false;
                        } else
                          for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true)
                            ;
                      } catch (r2) {
                        o = true, n = r2;
                      } finally {
                        try {
                          if (!f && null != t.return && (u = t.return(), Object(u) !== u))
                            return;
                        } finally {
                          if (o)
                            throw n;
                        }
                      }
                      return a;
                    }
                  }
                  function _nonIterableRest() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                  }
                  function _nonIterableSpread() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                  }
                  function _possibleConstructorReturn(t, e) {
                    if (e && ("object" == typeof e || "function" == typeof e))
                      return e;
                    if (void 0 !== e)
                      throw new TypeError("Derived constructors may only return object or undefined");
                    return _assertThisInitialized(t);
                  }
                  function _setPrototypeOf(t, e) {
                    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
                      return t2.__proto__ = e2, t2;
                    }, _setPrototypeOf(t, e);
                  }
                  function _slicedToArray(r, e) {
                    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
                  }
                  function _superPropBase(t, o) {
                    for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); )
                      ;
                    return t;
                  }
                  function _toConsumableArray(r) {
                    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
                  }
                  function _toPrimitive(t, r) {
                    if ("object" != typeof t || !t)
                      return t;
                    var e = t[Symbol.toPrimitive];
                    if (void 0 !== e) {
                      var i = e.call(t, r || "default");
                      if ("object" != typeof i)
                        return i;
                      throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return ("string" === r ? String : Number)(t);
                  }
                  function _toPropertyKey(t) {
                    var i = _toPrimitive(t, "string");
                    return "symbol" == typeof i ? i : i + "";
                  }
                  function _typeof(o) {
                    "@babel/helpers - typeof";
                    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
                      return typeof o2;
                    } : function(o2) {
                      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
                    }, _typeof(o);
                  }
                  function _unsupportedIterableToArray(r, a) {
                    if (r) {
                      if ("string" == typeof r)
                        return _arrayLikeToArray(r, a);
                      var t = {}.toString.call(r).slice(8, -1);
                      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
                    }
                  }
                  function hasProperty2(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                  }
                  function lastItemOf(arr) {
                    return arr[arr.length - 1];
                  }
                  function pushUnique(arr) {
                    for (var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                      items[_key - 1] = arguments[_key];
                    }
                    items.forEach(function(item) {
                      if (arr.includes(item)) {
                        return;
                      }
                      arr.push(item);
                    });
                    return arr;
                  }
                  function stringToArray(str, separator) {
                    return str ? str.split(separator) : [];
                  }
                  function isInRange(testVal, min, max) {
                    var minOK = min === void 0 || testVal >= min;
                    var maxOK = max === void 0 || testVal <= max;
                    return minOK && maxOK;
                  }
                  function limitToRange(val, min, max) {
                    if (val < min) {
                      return min;
                    }
                    if (val > max) {
                      return max;
                    }
                    return val;
                  }
                  function createTagRepeat(tagName, repeat) {
                    var attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                    var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
                    var html = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "";
                    var openTagSrc = Object.keys(attributes).reduce(function(src, attr) {
                      var val = attributes[attr];
                      if (typeof val === "function") {
                        val = val(index);
                      }
                      return "".concat(src, " ").concat(attr, '="').concat(val, '"');
                    }, tagName);
                    html += "<".concat(openTagSrc, "></").concat(tagName, ">");
                    var next = index + 1;
                    return next < repeat ? createTagRepeat(tagName, repeat, attributes, next, html) : html;
                  }
                  function optimizeTemplateHTML(html) {
                    return html.replace(/>\s+/g, ">").replace(/\s+</, "<");
                  }
                  function stripTime(timeValue) {
                    return new Date(timeValue).setHours(0, 0, 0, 0);
                  }
                  function today() {
                    return (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0);
                  }
                  function dateValue() {
                    switch (arguments.length) {
                      case 0:
                        return today();
                      case 1:
                        return stripTime(arguments.length <= 0 ? void 0 : arguments[0]);
                    }
                    var newDate = /* @__PURE__ */ new Date(0);
                    newDate.setFullYear.apply(newDate, arguments);
                    return newDate.setHours(0, 0, 0, 0);
                  }
                  function addDays(date, amount) {
                    var newDate = new Date(date);
                    return newDate.setDate(newDate.getDate() + amount);
                  }
                  function addWeeks(date, amount) {
                    return addDays(date, amount * 7);
                  }
                  function addMonths(date, amount) {
                    var newDate = new Date(date);
                    var monthsToSet = newDate.getMonth() + amount;
                    var expectedMonth = monthsToSet % 12;
                    if (expectedMonth < 0) {
                      expectedMonth += 12;
                    }
                    var time = newDate.setMonth(monthsToSet);
                    return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time;
                  }
                  function addYears(date, amount) {
                    var newDate = new Date(date);
                    var expectedMonth = newDate.getMonth();
                    var time = newDate.setFullYear(newDate.getFullYear() + amount);
                    return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time;
                  }
                  function dayDiff(day, from) {
                    return (day - from + 7) % 7;
                  }
                  function dayOfTheWeekOf(baseDate, dayOfWeek) {
                    var weekStart = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                    var baseDay = new Date(baseDate).getDay();
                    return addDays(baseDate, dayDiff(dayOfWeek, weekStart) - dayDiff(baseDay, weekStart));
                  }
                  function getWeek(date) {
                    var thuOfTheWeek = dayOfTheWeekOf(date, 4, 1);
                    var firstThu = dayOfTheWeekOf(new Date(thuOfTheWeek).setMonth(0, 4), 4, 1);
                    return Math.round((thuOfTheWeek - firstThu) / 6048e5) + 1;
                  }
                  function startOfYearPeriod(date, years) {
                    var year = new Date(date).getFullYear();
                    return Math.floor(year / years) * years;
                  }
                  var reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;
                  var reNonDateParts = /[\s!-/:-@[-`{-~]+/;
                  var knownFormats = {};
                  var parseFns = {
                    y: function y(date, year) {
                      return new Date(date).setFullYear(parseInt(year, 10));
                    },
                    m: function m(date, month, locale) {
                      var newDate = new Date(date);
                      var monthIndex = parseInt(month, 10) - 1;
                      if (isNaN(monthIndex)) {
                        if (!month) {
                          return NaN;
                        }
                        var monthName = month.toLowerCase();
                        var compareNames = function compareNames2(name) {
                          return name.toLowerCase().startsWith(monthName);
                        };
                        monthIndex = locale.monthsShort.findIndex(compareNames);
                        if (monthIndex < 0) {
                          monthIndex = locale.months.findIndex(compareNames);
                        }
                        if (monthIndex < 0) {
                          return NaN;
                        }
                      }
                      newDate.setMonth(monthIndex);
                      return newDate.getMonth() !== normalizeMonth(monthIndex) ? newDate.setDate(0) : newDate.getTime();
                    },
                    d: function d(date, day) {
                      return new Date(date).setDate(parseInt(day, 10));
                    }
                  };
                  var formatFns = {
                    d: function d(date) {
                      return date.getDate();
                    },
                    dd: function dd(date) {
                      return padZero(date.getDate(), 2);
                    },
                    D: function D(date, locale) {
                      return locale.daysShort[date.getDay()];
                    },
                    DD: function DD(date, locale) {
                      return locale.days[date.getDay()];
                    },
                    m: function m(date) {
                      return date.getMonth() + 1;
                    },
                    mm: function mm(date) {
                      return padZero(date.getMonth() + 1, 2);
                    },
                    M: function M(date, locale) {
                      return locale.monthsShort[date.getMonth()];
                    },
                    MM: function MM(date, locale) {
                      return locale.months[date.getMonth()];
                    },
                    y: function y(date) {
                      return date.getFullYear();
                    },
                    yy: function yy(date) {
                      return padZero(date.getFullYear(), 2).slice(-2);
                    },
                    yyyy: function yyyy(date) {
                      return padZero(date.getFullYear(), 4);
                    }
                  };
                  function normalizeMonth(monthIndex) {
                    return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);
                  }
                  function padZero(num, length) {
                    return num.toString().padStart(length, "0");
                  }
                  function parseFormatString(format) {
                    if (typeof format !== "string") {
                      throw new Error("Invalid date format.");
                    }
                    if (format in knownFormats) {
                      return knownFormats[format];
                    }
                    var separators = format.split(reFormatTokens);
                    var parts = format.match(new RegExp(reFormatTokens, "g"));
                    if (separators.length === 0 || !parts) {
                      throw new Error("Invalid date format.");
                    }
                    var partFormatters = parts.map(function(token) {
                      return formatFns[token];
                    });
                    var partParserKeys = Object.keys(parseFns).reduce(function(keys2, key) {
                      var token = parts.find(function(part) {
                        return part[0] !== "D" && part[0].toLowerCase() === key;
                      });
                      if (token) {
                        keys2.push(key);
                      }
                      return keys2;
                    }, []);
                    return knownFormats[format] = {
                      parser: function parser(dateStr, locale) {
                        var dateParts = dateStr.split(reNonDateParts).reduce(function(dtParts, part, index) {
                          if (part.length > 0 && parts[index]) {
                            var token = parts[index][0];
                            if (token === "M") {
                              dtParts.m = part;
                            } else if (token !== "D") {
                              dtParts[token] = part;
                            }
                          }
                          return dtParts;
                        }, {});
                        return partParserKeys.reduce(function(origDate, key) {
                          var newDate = parseFns[key](origDate, dateParts[key], locale);
                          return isNaN(newDate) ? origDate : newDate;
                        }, today());
                      },
                      formatter: function formatter(date, locale) {
                        var dateStr = partFormatters.reduce(function(str, fn, index) {
                          return str += "".concat(separators[index]).concat(fn(date, locale));
                        }, "");
                        return dateStr += lastItemOf(separators);
                      }
                    };
                  }
                  function parseDate(dateStr, format, locale) {
                    if (dateStr instanceof Date || typeof dateStr === "number") {
                      var date = stripTime(dateStr);
                      return isNaN(date) ? void 0 : date;
                    }
                    if (!dateStr) {
                      return void 0;
                    }
                    if (dateStr === "today") {
                      return today();
                    }
                    if (format && format.toValue) {
                      var _date = format.toValue(dateStr, format, locale);
                      return isNaN(_date) ? void 0 : stripTime(_date);
                    }
                    return parseFormatString(format).parser(dateStr, locale);
                  }
                  function formatDate(date, format, locale) {
                    if (isNaN(date) || !date && date !== 0) {
                      return "";
                    }
                    var dateObj = typeof date === "number" ? new Date(date) : date;
                    if (format.toDisplay) {
                      return format.toDisplay(dateObj, format, locale);
                    }
                    return parseFormatString(format).formatter(dateObj, locale);
                  }
                  var listenerRegistry = /* @__PURE__ */ new WeakMap();
                  var _EventTarget$prototyp = EventTarget.prototype, addEventListener3 = _EventTarget$prototyp.addEventListener, removeEventListener3 = _EventTarget$prototyp.removeEventListener;
                  function registerListeners(keyObj, listeners) {
                    var registered = listenerRegistry.get(keyObj);
                    if (!registered) {
                      registered = [];
                      listenerRegistry.set(keyObj, registered);
                    }
                    listeners.forEach(function(listener) {
                      addEventListener3.call.apply(addEventListener3, _toConsumableArray(listener));
                      registered.push(listener);
                    });
                  }
                  function unregisterListeners(keyObj) {
                    var listeners = listenerRegistry.get(keyObj);
                    if (!listeners) {
                      return;
                    }
                    listeners.forEach(function(listener) {
                      removeEventListener3.call.apply(removeEventListener3, _toConsumableArray(listener));
                    });
                    listenerRegistry["delete"](keyObj);
                  }
                  if (!Event.prototype.composedPath) {
                    var getComposedPath = function getComposedPath2(node) {
                      var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                      path.push(node);
                      var parent;
                      if (node.parentNode) {
                        parent = node.parentNode;
                      } else if (node.host) {
                        parent = node.host;
                      } else if (node.defaultView) {
                        parent = node.defaultView;
                      }
                      return parent ? getComposedPath2(parent, path) : path;
                    };
                    Event.prototype.composedPath = function() {
                      return getComposedPath(this.target);
                    };
                  }
                  function findFromPath(path, criteria, currentTarget) {
                    var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
                    var el = path[index];
                    if (criteria(el)) {
                      return el;
                    } else if (el === currentTarget || !el.parentElement) {
                      return;
                    }
                    return findFromPath(path, criteria, currentTarget, index + 1);
                  }
                  function findElementInEventPath(ev, selector) {
                    var criteria = typeof selector === "function" ? selector : function(el) {
                      return el.matches(selector);
                    };
                    return findFromPath(ev.composedPath(), criteria, ev.currentTarget);
                  }
                  var locales = {
                    en: {
                      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                      daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                      daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
                      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                      monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                      today: "Today",
                      clear: "Clear",
                      titleFormat: "MM y"
                    }
                  };
                  var defaultOptions2 = {
                    autohide: false,
                    beforeShowDay: null,
                    beforeShowDecade: null,
                    beforeShowMonth: null,
                    beforeShowYear: null,
                    calendarWeeks: false,
                    clearBtn: false,
                    dateDelimiter: ",",
                    datesDisabled: [],
                    daysOfWeekDisabled: [],
                    daysOfWeekHighlighted: [],
                    defaultViewDate: void 0,
                    // placeholder, defaults to today() by the program
                    disableTouchKeyboard: false,
                    format: "mm/dd/yyyy",
                    language: "en",
                    maxDate: null,
                    maxNumberOfDates: 1,
                    maxView: 3,
                    minDate: null,
                    nextArrow: '<svg class="w-4 h-4 rtl:rotate-180 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 10"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 5h12m0 0L9 1m4 4L9 9"/></svg>',
                    orientation: "auto",
                    pickLevel: 0,
                    prevArrow: '<svg class="w-4 h-4 rtl:rotate-180 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 10"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5H1m0 0 4 4M1 5l4-4"/></svg>',
                    showDaysOfWeek: true,
                    showOnClick: true,
                    showOnFocus: true,
                    startView: 0,
                    title: "",
                    todayBtn: false,
                    todayBtnMode: 0,
                    todayHighlight: false,
                    updateOnBlur: true,
                    weekStart: 0
                  };
                  var range2 = document.createRange();
                  function parseHTML(html) {
                    return range2.createContextualFragment(html);
                  }
                  function hideElement(el) {
                    if (el.style.display === "none") {
                      return;
                    }
                    if (el.style.display) {
                      el.dataset.styleDisplay = el.style.display;
                    }
                    el.style.display = "none";
                  }
                  function showElement(el) {
                    if (el.style.display !== "none") {
                      return;
                    }
                    if (el.dataset.styleDisplay) {
                      el.style.display = el.dataset.styleDisplay;
                      delete el.dataset.styleDisplay;
                    } else {
                      el.style.display = "";
                    }
                  }
                  function emptyChildNodes(el) {
                    if (el.firstChild) {
                      el.removeChild(el.firstChild);
                      emptyChildNodes(el);
                    }
                  }
                  function replaceChildNodes(el, newChildNodes) {
                    emptyChildNodes(el);
                    if (newChildNodes instanceof DocumentFragment) {
                      el.appendChild(newChildNodes);
                    } else if (typeof newChildNodes === "string") {
                      el.appendChild(parseHTML(newChildNodes));
                    } else if (typeof newChildNodes.forEach === "function") {
                      newChildNodes.forEach(function(node) {
                        el.appendChild(node);
                      });
                    }
                  }
                  var defaultLang = defaultOptions2.language, defaultFormat = defaultOptions2.format, defaultWeekStart = defaultOptions2.weekStart;
                  function sanitizeDOW(dow, day) {
                    return dow.length < 6 && day >= 0 && day < 7 ? pushUnique(dow, day) : dow;
                  }
                  function calcEndOfWeek(startOfWeek) {
                    return (startOfWeek + 6) % 7;
                  }
                  function validateDate(value, format, locale, origValue) {
                    var date = parseDate(value, format, locale);
                    return date !== void 0 ? date : origValue;
                  }
                  function validateViewId(value, origValue) {
                    var max = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3;
                    var viewId = parseInt(value, 10);
                    return viewId >= 0 && viewId <= max ? viewId : origValue;
                  }
                  function processOptions(options, datepicker) {
                    var inOpts = Object.assign({}, options);
                    var config = {};
                    var locales2 = datepicker.constructor.locales;
                    var _ref = datepicker.config || {}, format = _ref.format, language = _ref.language, locale = _ref.locale, maxDate = _ref.maxDate, maxView = _ref.maxView, minDate = _ref.minDate, pickLevel = _ref.pickLevel, startView = _ref.startView, weekStart = _ref.weekStart;
                    if (inOpts.language) {
                      var lang;
                      if (inOpts.language !== language) {
                        if (locales2[inOpts.language]) {
                          lang = inOpts.language;
                        } else {
                          lang = inOpts.language.split("-")[0];
                          if (locales2[lang] === void 0) {
                            lang = false;
                          }
                        }
                      }
                      delete inOpts.language;
                      if (lang) {
                        language = config.language = lang;
                        var origLocale = locale || locales2[defaultLang];
                        locale = Object.assign({
                          format: defaultFormat,
                          weekStart: defaultWeekStart
                        }, locales2[defaultLang]);
                        if (language !== defaultLang) {
                          Object.assign(locale, locales2[language]);
                        }
                        config.locale = locale;
                        if (format === origLocale.format) {
                          format = config.format = locale.format;
                        }
                        if (weekStart === origLocale.weekStart) {
                          weekStart = config.weekStart = locale.weekStart;
                          config.weekEnd = calcEndOfWeek(locale.weekStart);
                        }
                      }
                    }
                    if (inOpts.format) {
                      var hasToDisplay = typeof inOpts.format.toDisplay === "function";
                      var hasToValue = typeof inOpts.format.toValue === "function";
                      var validFormatString = reFormatTokens.test(inOpts.format);
                      if (hasToDisplay && hasToValue || validFormatString) {
                        format = config.format = inOpts.format;
                      }
                      delete inOpts.format;
                    }
                    var minDt = minDate;
                    var maxDt = maxDate;
                    if (inOpts.minDate !== void 0) {
                      minDt = inOpts.minDate === null ? dateValue(0, 0, 1) : validateDate(inOpts.minDate, format, locale, minDt);
                      delete inOpts.minDate;
                    }
                    if (inOpts.maxDate !== void 0) {
                      maxDt = inOpts.maxDate === null ? void 0 : validateDate(inOpts.maxDate, format, locale, maxDt);
                      delete inOpts.maxDate;
                    }
                    if (maxDt < minDt) {
                      minDate = config.minDate = maxDt;
                      maxDate = config.maxDate = minDt;
                    } else {
                      if (minDate !== minDt) {
                        minDate = config.minDate = minDt;
                      }
                      if (maxDate !== maxDt) {
                        maxDate = config.maxDate = maxDt;
                      }
                    }
                    if (inOpts.datesDisabled) {
                      config.datesDisabled = inOpts.datesDisabled.reduce(function(dates, dt) {
                        var date = parseDate(dt, format, locale);
                        return date !== void 0 ? pushUnique(dates, date) : dates;
                      }, []);
                      delete inOpts.datesDisabled;
                    }
                    if (inOpts.defaultViewDate !== void 0) {
                      var viewDate = parseDate(inOpts.defaultViewDate, format, locale);
                      if (viewDate !== void 0) {
                        config.defaultViewDate = viewDate;
                      }
                      delete inOpts.defaultViewDate;
                    }
                    if (inOpts.weekStart !== void 0) {
                      var wkStart = Number(inOpts.weekStart) % 7;
                      if (!isNaN(wkStart)) {
                        weekStart = config.weekStart = wkStart;
                        config.weekEnd = calcEndOfWeek(wkStart);
                      }
                      delete inOpts.weekStart;
                    }
                    if (inOpts.daysOfWeekDisabled) {
                      config.daysOfWeekDisabled = inOpts.daysOfWeekDisabled.reduce(sanitizeDOW, []);
                      delete inOpts.daysOfWeekDisabled;
                    }
                    if (inOpts.daysOfWeekHighlighted) {
                      config.daysOfWeekHighlighted = inOpts.daysOfWeekHighlighted.reduce(sanitizeDOW, []);
                      delete inOpts.daysOfWeekHighlighted;
                    }
                    if (inOpts.maxNumberOfDates !== void 0) {
                      var maxNumberOfDates = parseInt(inOpts.maxNumberOfDates, 10);
                      if (maxNumberOfDates >= 0) {
                        config.maxNumberOfDates = maxNumberOfDates;
                        config.multidate = maxNumberOfDates !== 1;
                      }
                      delete inOpts.maxNumberOfDates;
                    }
                    if (inOpts.dateDelimiter) {
                      config.dateDelimiter = String(inOpts.dateDelimiter);
                      delete inOpts.dateDelimiter;
                    }
                    var newPickLevel = pickLevel;
                    if (inOpts.pickLevel !== void 0) {
                      newPickLevel = validateViewId(inOpts.pickLevel, 2);
                      delete inOpts.pickLevel;
                    }
                    if (newPickLevel !== pickLevel) {
                      pickLevel = config.pickLevel = newPickLevel;
                    }
                    var newMaxView = maxView;
                    if (inOpts.maxView !== void 0) {
                      newMaxView = validateViewId(inOpts.maxView, maxView);
                      delete inOpts.maxView;
                    }
                    newMaxView = pickLevel > newMaxView ? pickLevel : newMaxView;
                    if (newMaxView !== maxView) {
                      maxView = config.maxView = newMaxView;
                    }
                    var newStartView = startView;
                    if (inOpts.startView !== void 0) {
                      newStartView = validateViewId(inOpts.startView, newStartView);
                      delete inOpts.startView;
                    }
                    if (newStartView < pickLevel) {
                      newStartView = pickLevel;
                    } else if (newStartView > maxView) {
                      newStartView = maxView;
                    }
                    if (newStartView !== startView) {
                      config.startView = newStartView;
                    }
                    if (inOpts.prevArrow) {
                      var prevArrow = parseHTML(inOpts.prevArrow);
                      if (prevArrow.childNodes.length > 0) {
                        config.prevArrow = prevArrow.childNodes;
                      }
                      delete inOpts.prevArrow;
                    }
                    if (inOpts.nextArrow) {
                      var nextArrow = parseHTML(inOpts.nextArrow);
                      if (nextArrow.childNodes.length > 0) {
                        config.nextArrow = nextArrow.childNodes;
                      }
                      delete inOpts.nextArrow;
                    }
                    if (inOpts.disableTouchKeyboard !== void 0) {
                      config.disableTouchKeyboard = "ontouchstart" in document && !!inOpts.disableTouchKeyboard;
                      delete inOpts.disableTouchKeyboard;
                    }
                    if (inOpts.orientation) {
                      var orientation = inOpts.orientation.toLowerCase().split(/\s+/g);
                      config.orientation = {
                        x: orientation.find(function(x) {
                          return x === "left" || x === "right";
                        }) || "auto",
                        y: orientation.find(function(y) {
                          return y === "top" || y === "bottom";
                        }) || "auto"
                      };
                      delete inOpts.orientation;
                    }
                    if (inOpts.todayBtnMode !== void 0) {
                      switch (inOpts.todayBtnMode) {
                        case 0:
                        case 1:
                          config.todayBtnMode = inOpts.todayBtnMode;
                      }
                      delete inOpts.todayBtnMode;
                    }
                    Object.keys(inOpts).forEach(function(key) {
                      if (inOpts[key] !== void 0 && hasProperty2(defaultOptions2, key)) {
                        config[key] = inOpts[key];
                      }
                    });
                    return config;
                  }
                  var pickerTemplate = optimizeTemplateHTML('<div class="datepicker hidden">\n  <div class="datepicker-picker inline-block rounded-lg bg-white dark:bg-gray-700 shadow-lg p-4">\n    <div class="datepicker-header">\n      <div class="datepicker-title bg-white dark:bg-gray-700 dark:text-white px-2 py-3 text-center font-semibold"></div>\n      <div class="datepicker-controls flex justify-between mb-2">\n        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 prev-btn"></button>\n        <button type="button" class="text-sm rounded-lg text-gray-900 dark:text-white bg-white dark:bg-gray-700 font-semibold py-2.5 px-5 hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-200 view-switch"></button>\n        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 next-btn"></button>\n      </div>\n    </div>\n    <div class="datepicker-main p-1"></div>\n    <div class="datepicker-footer">\n      <div class="datepicker-controls flex space-x-2 rtl:space-x-reverse mt-2">\n        <button type="button" class="%buttonClass% today-btn text-white bg-blue-700 !bg-primary-700 dark:bg-blue-600 dark:!bg-primary-600 hover:bg-blue-800 hover:!bg-primary-800 dark:hover:bg-blue-700 dark:hover:!bg-primary-700 focus:ring-4 focus:ring-blue-300 focus:!ring-primary-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>\n        <button type="button" class="%buttonClass% clear-btn text-gray-900 dark:text-white bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-600 focus:ring-4 focus:ring-blue-300 focus:!ring-primary-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>\n      </div>\n    </div>\n  </div>\n</div>');
                  var daysTemplate = optimizeTemplateHTML('<div class="days">\n  <div class="days-of-week grid grid-cols-7 mb-1">'.concat(createTagRepeat("span", 7, {
                    "class": "dow block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm"
                  }), '</div>\n  <div class="datepicker-grid w-64 grid grid-cols-7">').concat(createTagRepeat("span", 42, {
                    "class": "block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400"
                  }), "</div>\n</div>"));
                  var calendarWeeksTemplate = optimizeTemplateHTML('<div class="calendar-weeks">\n  <div class="days-of-week flex"><span class="dow h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400"></span></div>\n  <div class="weeks">'.concat(createTagRepeat("span", 6, {
                    "class": "week block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm"
                  }), "</div>\n</div>"));
                  var View2 = /* @__PURE__ */ function() {
                    function View3(picker, config) {
                      _classCallCheck(this, View3);
                      Object.assign(this, config, {
                        picker,
                        element: parseHTML('<div class="datepicker-view flex"></div>').firstChild,
                        selected: []
                      });
                      this.init(this.picker.datepicker.config);
                    }
                    return _createClass(View3, [{
                      key: "init",
                      value: function init(options) {
                        if (options.pickLevel !== void 0) {
                          this.isMinView = this.id === options.pickLevel;
                        }
                        this.setOptions(options);
                        this.updateFocus();
                        this.updateSelection();
                      }
                      // Execute beforeShow() callback and apply the result to the element
                      // args:
                      // - current - current value on the iteration on view rendering
                      // - timeValue - time value of the date to pass to beforeShow()
                    }, {
                      key: "performBeforeHook",
                      value: function performBeforeHook(el, current, timeValue) {
                        var result = this.beforeShow(new Date(timeValue));
                        switch (_typeof(result)) {
                          case "boolean":
                            result = {
                              enabled: result
                            };
                            break;
                          case "string":
                            result = {
                              classes: result
                            };
                        }
                        if (result) {
                          if (result.enabled === false) {
                            el.classList.add("disabled");
                            pushUnique(this.disabled, current);
                          }
                          if (result.classes) {
                            var _el$classList;
                            var extraClasses = result.classes.split(/\s+/);
                            (_el$classList = el.classList).add.apply(_el$classList, _toConsumableArray(extraClasses));
                            if (extraClasses.includes("disabled")) {
                              pushUnique(this.disabled, current);
                            }
                          }
                          if (result.content) {
                            replaceChildNodes(el, result.content);
                          }
                        }
                      }
                    }]);
                  }();
                  var DaysView = /* @__PURE__ */ function(_View) {
                    function DaysView2(picker) {
                      _classCallCheck(this, DaysView2);
                      return _callSuper(this, DaysView2, [picker, {
                        id: 0,
                        name: "days",
                        cellClass: "day"
                      }]);
                    }
                    _inherits(DaysView2, _View);
                    return _createClass(DaysView2, [{
                      key: "init",
                      value: function init(options) {
                        var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                        if (onConstruction) {
                          var inner = parseHTML(daysTemplate).firstChild;
                          this.dow = inner.firstChild;
                          this.grid = inner.lastChild;
                          this.element.appendChild(inner);
                        }
                        _get(_getPrototypeOf(DaysView2.prototype), "init", this).call(this, options);
                      }
                    }, {
                      key: "setOptions",
                      value: function setOptions(options) {
                        var _this = this;
                        var updateDOW;
                        if (hasProperty2(options, "minDate")) {
                          this.minDate = options.minDate;
                        }
                        if (hasProperty2(options, "maxDate")) {
                          this.maxDate = options.maxDate;
                        }
                        if (options.datesDisabled) {
                          this.datesDisabled = options.datesDisabled;
                        }
                        if (options.daysOfWeekDisabled) {
                          this.daysOfWeekDisabled = options.daysOfWeekDisabled;
                          updateDOW = true;
                        }
                        if (options.daysOfWeekHighlighted) {
                          this.daysOfWeekHighlighted = options.daysOfWeekHighlighted;
                        }
                        if (options.todayHighlight !== void 0) {
                          this.todayHighlight = options.todayHighlight;
                        }
                        if (options.weekStart !== void 0) {
                          this.weekStart = options.weekStart;
                          this.weekEnd = options.weekEnd;
                          updateDOW = true;
                        }
                        if (options.locale) {
                          var locale = this.locale = options.locale;
                          this.dayNames = locale.daysMin;
                          this.switchLabelFormat = locale.titleFormat;
                          updateDOW = true;
                        }
                        if (options.beforeShowDay !== void 0) {
                          this.beforeShow = typeof options.beforeShowDay === "function" ? options.beforeShowDay : void 0;
                        }
                        if (options.calendarWeeks !== void 0) {
                          if (options.calendarWeeks && !this.calendarWeeks) {
                            var weeksElem = parseHTML(calendarWeeksTemplate).firstChild;
                            this.calendarWeeks = {
                              element: weeksElem,
                              dow: weeksElem.firstChild,
                              weeks: weeksElem.lastChild
                            };
                            this.element.insertBefore(weeksElem, this.element.firstChild);
                          } else if (this.calendarWeeks && !options.calendarWeeks) {
                            this.element.removeChild(this.calendarWeeks.element);
                            this.calendarWeeks = null;
                          }
                        }
                        if (options.showDaysOfWeek !== void 0) {
                          if (options.showDaysOfWeek) {
                            showElement(this.dow);
                            if (this.calendarWeeks) {
                              showElement(this.calendarWeeks.dow);
                            }
                          } else {
                            hideElement(this.dow);
                            if (this.calendarWeeks) {
                              hideElement(this.calendarWeeks.dow);
                            }
                          }
                        }
                        if (updateDOW) {
                          Array.from(this.dow.children).forEach(function(el, index) {
                            var dow = (_this.weekStart + index) % 7;
                            el.textContent = _this.dayNames[dow];
                            el.className = _this.daysOfWeekDisabled.includes(dow) ? "dow disabled text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400 cursor-not-allowed" : "dow text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400";
                          });
                        }
                      }
                      // Apply update on the focused date to view's settings
                    }, {
                      key: "updateFocus",
                      value: function updateFocus() {
                        var viewDate = new Date(this.picker.viewDate);
                        var viewYear = viewDate.getFullYear();
                        var viewMonth = viewDate.getMonth();
                        var firstOfMonth = dateValue(viewYear, viewMonth, 1);
                        var start2 = dayOfTheWeekOf(firstOfMonth, this.weekStart, this.weekStart);
                        this.first = firstOfMonth;
                        this.last = dateValue(viewYear, viewMonth + 1, 0);
                        this.start = start2;
                        this.focused = this.picker.viewDate;
                      }
                      // Apply update on the selected dates to view's settings
                    }, {
                      key: "updateSelection",
                      value: function updateSelection() {
                        var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
                        this.selected = dates;
                        if (rangepicker) {
                          this.range = rangepicker.dates;
                        }
                      }
                      // Update the entire view UI
                    }, {
                      key: "render",
                      value: function render2() {
                        var _this2 = this;
                        this.today = this.todayHighlight ? today() : void 0;
                        this.disabled = _toConsumableArray(this.datesDisabled);
                        var switchLabel = formatDate(this.focused, this.switchLabelFormat, this.locale);
                        this.picker.setViewSwitchLabel(switchLabel);
                        this.picker.setPrevBtnDisabled(this.first <= this.minDate);
                        this.picker.setNextBtnDisabled(this.last >= this.maxDate);
                        if (this.calendarWeeks) {
                          var startOfWeek = dayOfTheWeekOf(this.first, 1, 1);
                          Array.from(this.calendarWeeks.weeks.children).forEach(function(el, index) {
                            el.textContent = getWeek(addWeeks(startOfWeek, index));
                          });
                        }
                        Array.from(this.grid.children).forEach(function(el, index) {
                          var classList = el.classList;
                          var current = addDays(_this2.start, index);
                          var date = new Date(current);
                          var day = date.getDay();
                          el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this2.cellClass);
                          el.dataset.date = current;
                          el.textContent = date.getDate();
                          if (current < _this2.first) {
                            classList.add("prev", "text-gray-500", "dark:text-white");
                          } else if (current > _this2.last) {
                            classList.add("next", "text-gray-500", "dark:text-white");
                          }
                          if (_this2.today === current) {
                            classList.add("today", "bg-gray-100", "dark:bg-gray-600");
                          }
                          if (current < _this2.minDate || current > _this2.maxDate || _this2.disabled.includes(current)) {
                            classList.add("disabled", "cursor-not-allowed", "text-gray-400", "dark:text-gray-500");
                            classList.remove("hover:bg-gray-100", "dark:hover:bg-gray-600", "text-gray-900", "dark:text-white", "cursor-pointer");
                          }
                          if (_this2.daysOfWeekDisabled.includes(day)) {
                            classList.add("disabled", "cursor-not-allowed", "text-gray-400", "dark:text-gray-500");
                            classList.remove("hover:bg-gray-100", "dark:hover:bg-gray-600", "text-gray-900", "dark:text-white", "cursor-pointer");
                            pushUnique(_this2.disabled, current);
                          }
                          if (_this2.daysOfWeekHighlighted.includes(day)) {
                            classList.add("highlighted");
                          }
                          if (_this2.range) {
                            var _this2$range = _slicedToArray(_this2.range, 2), rangeStart = _this2$range[0], rangeEnd = _this2$range[1];
                            if (current > rangeStart && current < rangeEnd) {
                              classList.add("range", "bg-gray-200", "dark:bg-gray-600");
                              classList.remove("rounded-lg", "rounded-l-lg", "rounded-r-lg");
                            }
                            if (current === rangeStart) {
                              classList.add("range-start", "bg-gray-100", "dark:bg-gray-600", "rounded-l-lg");
                              classList.remove("rounded-lg", "rounded-r-lg");
                            }
                            if (current === rangeEnd) {
                              classList.add("range-end", "bg-gray-100", "dark:bg-gray-600", "rounded-r-lg");
                              classList.remove("rounded-lg", "rounded-l-lg");
                            }
                          }
                          if (_this2.selected.includes(current)) {
                            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
                            classList.remove("text-gray-900", "text-gray-500", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600", "dark:bg-gray-600", "bg-gray-100", "bg-gray-200");
                          }
                          if (current === _this2.focused) {
                            classList.add("focused");
                          }
                          if (_this2.beforeShow) {
                            _this2.performBeforeHook(el, current, current);
                          }
                        });
                      }
                      // Update the view UI by applying the changes of selected and focused items
                    }, {
                      key: "refresh",
                      value: function refresh() {
                        var _this3 = this;
                        var _ref = this.range || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
                        this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el) {
                          el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white", "focused");
                          el.classList.add("text-gray-900", "rounded-lg", "dark:text-white");
                        });
                        Array.from(this.grid.children).forEach(function(el) {
                          var current = Number(el.dataset.date);
                          var classList = el.classList;
                          classList.remove("bg-gray-200", "dark:bg-gray-600", "rounded-l-lg", "rounded-r-lg");
                          if (current > rangeStart && current < rangeEnd) {
                            classList.add("range", "bg-gray-200", "dark:bg-gray-600");
                            classList.remove("rounded-lg");
                          }
                          if (current === rangeStart) {
                            classList.add("range-start", "bg-gray-200", "dark:bg-gray-600", "rounded-l-lg");
                            classList.remove("rounded-lg");
                          }
                          if (current === rangeEnd) {
                            classList.add("range-end", "bg-gray-200", "dark:bg-gray-600", "rounded-r-lg");
                            classList.remove("rounded-lg");
                          }
                          if (_this3.selected.includes(current)) {
                            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
                            classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600", "bg-gray-100", "bg-gray-200", "dark:bg-gray-600");
                          }
                          if (current === _this3.focused) {
                            classList.add("focused");
                          }
                        });
                      }
                      // Update the view UI by applying the change of focused item
                    }, {
                      key: "refreshFocus",
                      value: function refreshFocus() {
                        var index = Math.round((this.focused - this.start) / 864e5);
                        this.grid.querySelectorAll(".focused").forEach(function(el) {
                          el.classList.remove("focused");
                        });
                        this.grid.children[index].classList.add("focused");
                      }
                    }]);
                  }(View2);
                  function computeMonthRange(range3, thisYear) {
                    if (!range3 || !range3[0] || !range3[1]) {
                      return;
                    }
                    var _range2 = _slicedToArray(range3, 2), _range$ = _slicedToArray(_range2[0], 2), startY = _range$[0], startM = _range$[1], _range$2 = _slicedToArray(_range2[1], 2), endY = _range$2[0], endM = _range$2[1];
                    if (startY > thisYear || endY < thisYear) {
                      return;
                    }
                    return [startY === thisYear ? startM : -1, endY === thisYear ? endM : 12];
                  }
                  var MonthsView = /* @__PURE__ */ function(_View) {
                    function MonthsView2(picker) {
                      _classCallCheck(this, MonthsView2);
                      return _callSuper(this, MonthsView2, [picker, {
                        id: 1,
                        name: "months",
                        cellClass: "month"
                      }]);
                    }
                    _inherits(MonthsView2, _View);
                    return _createClass(MonthsView2, [{
                      key: "init",
                      value: function init(options) {
                        var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                        if (onConstruction) {
                          this.grid = this.element;
                          this.element.classList.add("months", "datepicker-grid", "w-64", "grid", "grid-cols-4");
                          this.grid.appendChild(parseHTML(createTagRepeat("span", 12, {
                            "data-month": function dataMonth(ix) {
                              return ix;
                            }
                          })));
                        }
                        _get(_getPrototypeOf(MonthsView2.prototype), "init", this).call(this, options);
                      }
                    }, {
                      key: "setOptions",
                      value: function setOptions(options) {
                        if (options.locale) {
                          this.monthNames = options.locale.monthsShort;
                        }
                        if (hasProperty2(options, "minDate")) {
                          if (options.minDate === void 0) {
                            this.minYear = this.minMonth = this.minDate = void 0;
                          } else {
                            var minDateObj = new Date(options.minDate);
                            this.minYear = minDateObj.getFullYear();
                            this.minMonth = minDateObj.getMonth();
                            this.minDate = minDateObj.setDate(1);
                          }
                        }
                        if (hasProperty2(options, "maxDate")) {
                          if (options.maxDate === void 0) {
                            this.maxYear = this.maxMonth = this.maxDate = void 0;
                          } else {
                            var maxDateObj = new Date(options.maxDate);
                            this.maxYear = maxDateObj.getFullYear();
                            this.maxMonth = maxDateObj.getMonth();
                            this.maxDate = dateValue(this.maxYear, this.maxMonth + 1, 0);
                          }
                        }
                        if (options.beforeShowMonth !== void 0) {
                          this.beforeShow = typeof options.beforeShowMonth === "function" ? options.beforeShowMonth : void 0;
                        }
                      }
                      // Update view's settings to reflect the viewDate set on the picker
                    }, {
                      key: "updateFocus",
                      value: function updateFocus() {
                        var viewDate = new Date(this.picker.viewDate);
                        this.year = viewDate.getFullYear();
                        this.focused = viewDate.getMonth();
                      }
                      // Update view's settings to reflect the selected dates
                    }, {
                      key: "updateSelection",
                      value: function updateSelection() {
                        var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
                        this.selected = dates.reduce(function(selected, timeValue) {
                          var date = new Date(timeValue);
                          var year = date.getFullYear();
                          var month = date.getMonth();
                          if (selected[year] === void 0) {
                            selected[year] = [month];
                          } else {
                            pushUnique(selected[year], month);
                          }
                          return selected;
                        }, {});
                        if (rangepicker && rangepicker.dates) {
                          this.range = rangepicker.dates.map(function(timeValue) {
                            var date = new Date(timeValue);
                            return isNaN(date) ? void 0 : [date.getFullYear(), date.getMonth()];
                          });
                        }
                      }
                      // Update the entire view UI
                    }, {
                      key: "render",
                      value: function render2() {
                        var _this = this;
                        this.disabled = [];
                        this.picker.setViewSwitchLabel(this.year);
                        this.picker.setPrevBtnDisabled(this.year <= this.minYear);
                        this.picker.setNextBtnDisabled(this.year >= this.maxYear);
                        var selected = this.selected[this.year] || [];
                        var yrOutOfRange = this.year < this.minYear || this.year > this.maxYear;
                        var isMinYear = this.year === this.minYear;
                        var isMaxYear = this.year === this.maxYear;
                        var range3 = computeMonthRange(this.range, this.year);
                        Array.from(this.grid.children).forEach(function(el, index) {
                          var classList = el.classList;
                          var date = dateValue(_this.year, index, 1);
                          el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this.cellClass);
                          if (_this.isMinView) {
                            el.dataset.date = date;
                          }
                          el.textContent = _this.monthNames[index];
                          if (yrOutOfRange || isMinYear && index < _this.minMonth || isMaxYear && index > _this.maxMonth) {
                            classList.add("disabled");
                          }
                          if (range3) {
                            var _range2 = _slicedToArray(range3, 2), rangeStart = _range2[0], rangeEnd = _range2[1];
                            if (index > rangeStart && index < rangeEnd) {
                              classList.add("range");
                            }
                            if (index === rangeStart) {
                              classList.add("range-start");
                            }
                            if (index === rangeEnd) {
                              classList.add("range-end");
                            }
                          }
                          if (selected.includes(index)) {
                            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
                            classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
                          }
                          if (index === _this.focused) {
                            classList.add("focused");
                          }
                          if (_this.beforeShow) {
                            _this.performBeforeHook(el, index, date);
                          }
                        });
                      }
                      // Update the view UI by applying the changes of selected and focused items
                    }, {
                      key: "refresh",
                      value: function refresh() {
                        var _this2 = this;
                        var selected = this.selected[this.year] || [];
                        var _ref = computeMonthRange(this.range, this.year) || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
                        this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el) {
                          el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "dark:bg-blue-600", "dark:!bg-primary-700", "dark:text-white", "text-white", "focused");
                          el.classList.add("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
                        });
                        Array.from(this.grid.children).forEach(function(el, index) {
                          var classList = el.classList;
                          if (index > rangeStart && index < rangeEnd) {
                            classList.add("range");
                          }
                          if (index === rangeStart) {
                            classList.add("range-start");
                          }
                          if (index === rangeEnd) {
                            classList.add("range-end");
                          }
                          if (selected.includes(index)) {
                            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
                            classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
                          }
                          if (index === _this2.focused) {
                            classList.add("focused");
                          }
                        });
                      }
                      // Update the view UI by applying the change of focused item
                    }, {
                      key: "refreshFocus",
                      value: function refreshFocus() {
                        this.grid.querySelectorAll(".focused").forEach(function(el) {
                          el.classList.remove("focused");
                        });
                        this.grid.children[this.focused].classList.add("focused");
                      }
                    }]);
                  }(View2);
                  function toTitleCase(word) {
                    return _toConsumableArray(word).reduce(function(str, ch, ix) {
                      return str += ix ? ch : ch.toUpperCase();
                    }, "");
                  }
                  var YearsView = /* @__PURE__ */ function(_View) {
                    function YearsView2(picker, config) {
                      _classCallCheck(this, YearsView2);
                      return _callSuper(this, YearsView2, [picker, config]);
                    }
                    _inherits(YearsView2, _View);
                    return _createClass(YearsView2, [{
                      key: "init",
                      value: function init(options) {
                        var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                        if (onConstruction) {
                          this.navStep = this.step * 10;
                          this.beforeShowOption = "beforeShow".concat(toTitleCase(this.cellClass));
                          this.grid = this.element;
                          this.element.classList.add(this.name, "datepicker-grid", "w-64", "grid", "grid-cols-4");
                          this.grid.appendChild(parseHTML(createTagRepeat("span", 12)));
                        }
                        _get(_getPrototypeOf(YearsView2.prototype), "init", this).call(this, options);
                      }
                    }, {
                      key: "setOptions",
                      value: function setOptions(options) {
                        if (hasProperty2(options, "minDate")) {
                          if (options.minDate === void 0) {
                            this.minYear = this.minDate = void 0;
                          } else {
                            this.minYear = startOfYearPeriod(options.minDate, this.step);
                            this.minDate = dateValue(this.minYear, 0, 1);
                          }
                        }
                        if (hasProperty2(options, "maxDate")) {
                          if (options.maxDate === void 0) {
                            this.maxYear = this.maxDate = void 0;
                          } else {
                            this.maxYear = startOfYearPeriod(options.maxDate, this.step);
                            this.maxDate = dateValue(this.maxYear, 11, 31);
                          }
                        }
                        if (options[this.beforeShowOption] !== void 0) {
                          var beforeShow = options[this.beforeShowOption];
                          this.beforeShow = typeof beforeShow === "function" ? beforeShow : void 0;
                        }
                      }
                      // Update view's settings to reflect the viewDate set on the picker
                    }, {
                      key: "updateFocus",
                      value: function updateFocus() {
                        var viewDate = new Date(this.picker.viewDate);
                        var first = startOfYearPeriod(viewDate, this.navStep);
                        var last2 = first + 9 * this.step;
                        this.first = first;
                        this.last = last2;
                        this.start = first - this.step;
                        this.focused = startOfYearPeriod(viewDate, this.step);
                      }
                      // Update view's settings to reflect the selected dates
                    }, {
                      key: "updateSelection",
                      value: function updateSelection() {
                        var _this = this;
                        var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
                        this.selected = dates.reduce(function(years, timeValue) {
                          return pushUnique(years, startOfYearPeriod(timeValue, _this.step));
                        }, []);
                        if (rangepicker && rangepicker.dates) {
                          this.range = rangepicker.dates.map(function(timeValue) {
                            if (timeValue !== void 0) {
                              return startOfYearPeriod(timeValue, _this.step);
                            }
                          });
                        }
                      }
                      // Update the entire view UI
                    }, {
                      key: "render",
                      value: function render2() {
                        var _this2 = this;
                        this.disabled = [];
                        this.picker.setViewSwitchLabel("".concat(this.first, "-").concat(this.last));
                        this.picker.setPrevBtnDisabled(this.first <= this.minYear);
                        this.picker.setNextBtnDisabled(this.last >= this.maxYear);
                        Array.from(this.grid.children).forEach(function(el, index) {
                          var classList = el.classList;
                          var current = _this2.start + index * _this2.step;
                          var date = dateValue(current, 0, 1);
                          el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this2.cellClass);
                          if (_this2.isMinView) {
                            el.dataset.date = date;
                          }
                          el.textContent = el.dataset.year = current;
                          if (index === 0) {
                            classList.add("prev");
                          } else if (index === 11) {
                            classList.add("next");
                          }
                          if (current < _this2.minYear || current > _this2.maxYear) {
                            classList.add("disabled");
                          }
                          if (_this2.range) {
                            var _this2$range = _slicedToArray(_this2.range, 2), rangeStart = _this2$range[0], rangeEnd = _this2$range[1];
                            if (current > rangeStart && current < rangeEnd) {
                              classList.add("range");
                            }
                            if (current === rangeStart) {
                              classList.add("range-start");
                            }
                            if (current === rangeEnd) {
                              classList.add("range-end");
                            }
                          }
                          if (_this2.selected.includes(current)) {
                            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
                            classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
                          }
                          if (current === _this2.focused) {
                            classList.add("focused");
                          }
                          if (_this2.beforeShow) {
                            _this2.performBeforeHook(el, current, date);
                          }
                        });
                      }
                      // Update the view UI by applying the changes of selected and focused items
                    }, {
                      key: "refresh",
                      value: function refresh() {
                        var _this3 = this;
                        var _ref = this.range || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
                        this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(function(el) {
                          el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark!bg-primary-600", "dark:text-white", "focused");
                        });
                        Array.from(this.grid.children).forEach(function(el) {
                          var current = Number(el.textContent);
                          var classList = el.classList;
                          if (current > rangeStart && current < rangeEnd) {
                            classList.add("range");
                          }
                          if (current === rangeStart) {
                            classList.add("range-start");
                          }
                          if (current === rangeEnd) {
                            classList.add("range-end");
                          }
                          if (_this3.selected.includes(current)) {
                            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
                            classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
                          }
                          if (current === _this3.focused) {
                            classList.add("focused");
                          }
                        });
                      }
                      // Update the view UI by applying the change of focused item
                    }, {
                      key: "refreshFocus",
                      value: function refreshFocus() {
                        var index = Math.round((this.focused - this.start) / this.step);
                        this.grid.querySelectorAll(".focused").forEach(function(el) {
                          el.classList.remove("focused");
                        });
                        this.grid.children[index].classList.add("focused");
                      }
                    }]);
                  }(View2);
                  function triggerDatepickerEvent(datepicker, type) {
                    var detail = {
                      date: datepicker.getDate(),
                      viewDate: new Date(datepicker.picker.viewDate),
                      viewId: datepicker.picker.currentView.id,
                      datepicker
                    };
                    datepicker.element.dispatchEvent(new CustomEvent(type, {
                      detail
                    }));
                  }
                  function goToPrevOrNext(datepicker, direction) {
                    var _datepicker$config = datepicker.config, minDate = _datepicker$config.minDate, maxDate = _datepicker$config.maxDate;
                    var _datepicker$picker = datepicker.picker, currentView = _datepicker$picker.currentView, viewDate = _datepicker$picker.viewDate;
                    var newViewDate;
                    switch (currentView.id) {
                      case 0:
                        newViewDate = addMonths(viewDate, direction);
                        break;
                      case 1:
                        newViewDate = addYears(viewDate, direction);
                        break;
                      default:
                        newViewDate = addYears(viewDate, direction * currentView.navStep);
                    }
                    newViewDate = limitToRange(newViewDate, minDate, maxDate);
                    datepicker.picker.changeFocus(newViewDate).render();
                  }
                  function switchView(datepicker) {
                    var viewId = datepicker.picker.currentView.id;
                    if (viewId === datepicker.config.maxView) {
                      return;
                    }
                    datepicker.picker.changeView(viewId + 1).render();
                  }
                  function unfocus(datepicker) {
                    if (datepicker.config.updateOnBlur) {
                      datepicker.update({
                        autohide: true
                      });
                    } else {
                      datepicker.refresh("input");
                      datepicker.hide();
                    }
                  }
                  function goToSelectedMonthOrYear(datepicker, selection) {
                    var picker = datepicker.picker;
                    var viewDate = new Date(picker.viewDate);
                    var viewId = picker.currentView.id;
                    var newDate = viewId === 1 ? addMonths(viewDate, selection - viewDate.getMonth()) : addYears(viewDate, selection - viewDate.getFullYear());
                    picker.changeFocus(newDate).changeView(viewId - 1).render();
                  }
                  function onClickTodayBtn(datepicker) {
                    var picker = datepicker.picker;
                    var currentDate = today();
                    if (datepicker.config.todayBtnMode === 1) {
                      if (datepicker.config.autohide) {
                        datepicker.setDate(currentDate);
                        return;
                      }
                      datepicker.setDate(currentDate, {
                        render: false
                      });
                      picker.update();
                    }
                    if (picker.viewDate !== currentDate) {
                      picker.changeFocus(currentDate);
                    }
                    picker.changeView(0).render();
                  }
                  function onClickClearBtn(datepicker) {
                    datepicker.setDate({
                      clear: true
                    });
                  }
                  function onClickViewSwitch(datepicker) {
                    switchView(datepicker);
                  }
                  function onClickPrevBtn(datepicker) {
                    goToPrevOrNext(datepicker, -1);
                  }
                  function onClickNextBtn(datepicker) {
                    goToPrevOrNext(datepicker, 1);
                  }
                  function onClickView(datepicker, ev) {
                    var target = findElementInEventPath(ev, ".datepicker-cell");
                    if (!target || target.classList.contains("disabled")) {
                      return;
                    }
                    var _datepicker$picker$cu = datepicker.picker.currentView, id = _datepicker$picker$cu.id, isMinView = _datepicker$picker$cu.isMinView;
                    if (isMinView) {
                      datepicker.setDate(Number(target.dataset.date));
                    } else if (id === 1) {
                      goToSelectedMonthOrYear(datepicker, Number(target.dataset.month));
                    } else {
                      goToSelectedMonthOrYear(datepicker, Number(target.dataset.year));
                    }
                  }
                  function onClickPicker(datepicker) {
                    if (!datepicker.inline && !datepicker.config.disableTouchKeyboard) {
                      datepicker.inputField.focus();
                    }
                  }
                  function processPickerOptions(picker, options) {
                    if (options.title !== void 0) {
                      if (options.title) {
                        picker.controls.title.textContent = options.title;
                        showElement(picker.controls.title);
                      } else {
                        picker.controls.title.textContent = "";
                        hideElement(picker.controls.title);
                      }
                    }
                    if (options.prevArrow) {
                      var prevBtn = picker.controls.prevBtn;
                      emptyChildNodes(prevBtn);
                      options.prevArrow.forEach(function(node) {
                        prevBtn.appendChild(node.cloneNode(true));
                      });
                    }
                    if (options.nextArrow) {
                      var nextBtn = picker.controls.nextBtn;
                      emptyChildNodes(nextBtn);
                      options.nextArrow.forEach(function(node) {
                        nextBtn.appendChild(node.cloneNode(true));
                      });
                    }
                    if (options.locale) {
                      picker.controls.todayBtn.textContent = options.locale.today;
                      picker.controls.clearBtn.textContent = options.locale.clear;
                    }
                    if (options.todayBtn !== void 0) {
                      if (options.todayBtn) {
                        showElement(picker.controls.todayBtn);
                      } else {
                        hideElement(picker.controls.todayBtn);
                      }
                    }
                    if (hasProperty2(options, "minDate") || hasProperty2(options, "maxDate")) {
                      var _picker$datepicker$co = picker.datepicker.config, minDate = _picker$datepicker$co.minDate, maxDate = _picker$datepicker$co.maxDate;
                      picker.controls.todayBtn.disabled = !isInRange(today(), minDate, maxDate);
                    }
                    if (options.clearBtn !== void 0) {
                      if (options.clearBtn) {
                        showElement(picker.controls.clearBtn);
                      } else {
                        hideElement(picker.controls.clearBtn);
                      }
                    }
                  }
                  function computeResetViewDate(datepicker) {
                    var dates = datepicker.dates, config = datepicker.config;
                    var viewDate = dates.length > 0 ? lastItemOf(dates) : config.defaultViewDate;
                    return limitToRange(viewDate, config.minDate, config.maxDate);
                  }
                  function setViewDate(picker, newDate) {
                    var oldViewDate = new Date(picker.viewDate);
                    var newViewDate = new Date(newDate);
                    var _picker$currentView = picker.currentView, id = _picker$currentView.id, year = _picker$currentView.year, first = _picker$currentView.first, last2 = _picker$currentView.last;
                    var viewYear = newViewDate.getFullYear();
                    picker.viewDate = newDate;
                    if (viewYear !== oldViewDate.getFullYear()) {
                      triggerDatepickerEvent(picker.datepicker, "changeYear");
                    }
                    if (newViewDate.getMonth() !== oldViewDate.getMonth()) {
                      triggerDatepickerEvent(picker.datepicker, "changeMonth");
                    }
                    switch (id) {
                      case 0:
                        return newDate < first || newDate > last2;
                      case 1:
                        return viewYear !== year;
                      default:
                        return viewYear < first || viewYear > last2;
                    }
                  }
                  function getTextDirection(el) {
                    return window.getComputedStyle(el).direction;
                  }
                  var Picker = /* @__PURE__ */ function() {
                    function Picker2(datepicker) {
                      _classCallCheck(this, Picker2);
                      this.datepicker = datepicker;
                      var template = pickerTemplate.replace(/%buttonClass%/g, datepicker.config.buttonClass);
                      var element = this.element = parseHTML(template).firstChild;
                      var _element$firstChild$c = _slicedToArray(element.firstChild.children, 3), header = _element$firstChild$c[0], main = _element$firstChild$c[1], footer = _element$firstChild$c[2];
                      var title = header.firstElementChild;
                      var _header$lastElementCh = _slicedToArray(header.lastElementChild.children, 3), prevBtn = _header$lastElementCh[0], viewSwitch = _header$lastElementCh[1], nextBtn = _header$lastElementCh[2];
                      var _footer$firstChild$ch = _slicedToArray(footer.firstChild.children, 2), todayBtn = _footer$firstChild$ch[0], clearBtn = _footer$firstChild$ch[1];
                      var controls = {
                        title,
                        prevBtn,
                        viewSwitch,
                        nextBtn,
                        todayBtn,
                        clearBtn
                      };
                      this.main = main;
                      this.controls = controls;
                      var elementClass = datepicker.inline ? "inline" : "dropdown";
                      element.classList.add("datepicker-".concat(elementClass));
                      elementClass === "dropdown" ? element.classList.add("dropdown", "absolute", "top-0", "left-0", "z-50", "pt-2") : null;
                      processPickerOptions(this, datepicker.config);
                      this.viewDate = computeResetViewDate(datepicker);
                      registerListeners(datepicker, [[element, "click", onClickPicker.bind(null, datepicker), {
                        capture: true
                      }], [main, "click", onClickView.bind(null, datepicker)], [controls.viewSwitch, "click", onClickViewSwitch.bind(null, datepicker)], [controls.prevBtn, "click", onClickPrevBtn.bind(null, datepicker)], [controls.nextBtn, "click", onClickNextBtn.bind(null, datepicker)], [controls.todayBtn, "click", onClickTodayBtn.bind(null, datepicker)], [controls.clearBtn, "click", onClickClearBtn.bind(null, datepicker)]]);
                      this.views = [new DaysView(this), new MonthsView(this), new YearsView(this, {
                        id: 2,
                        name: "years",
                        cellClass: "year",
                        step: 1
                      }), new YearsView(this, {
                        id: 3,
                        name: "decades",
                        cellClass: "decade",
                        step: 10
                      })];
                      this.currentView = this.views[datepicker.config.startView];
                      this.currentView.render();
                      this.main.appendChild(this.currentView.element);
                      datepicker.config.container.appendChild(this.element);
                    }
                    return _createClass(Picker2, [{
                      key: "setOptions",
                      value: function setOptions(options) {
                        processPickerOptions(this, options);
                        this.views.forEach(function(view) {
                          view.init(options, false);
                        });
                        this.currentView.render();
                      }
                    }, {
                      key: "detach",
                      value: function detach() {
                        this.datepicker.config.container.removeChild(this.element);
                      }
                    }, {
                      key: "show",
                      value: function show() {
                        if (this.active) {
                          return;
                        }
                        this.element.classList.add("active", "block");
                        this.element.classList.remove("hidden");
                        this.active = true;
                        var datepicker = this.datepicker;
                        if (!datepicker.inline) {
                          var inputDirection = getTextDirection(datepicker.inputField);
                          if (inputDirection !== getTextDirection(datepicker.config.container)) {
                            this.element.dir = inputDirection;
                          } else if (this.element.dir) {
                            this.element.removeAttribute("dir");
                          }
                          this.place();
                          if (datepicker.config.disableTouchKeyboard) {
                            datepicker.inputField.blur();
                          }
                        }
                        triggerDatepickerEvent(datepicker, "show");
                      }
                    }, {
                      key: "hide",
                      value: function hide() {
                        if (!this.active) {
                          return;
                        }
                        this.datepicker.exitEditMode();
                        this.element.classList.remove("active", "block");
                        this.element.classList.add("active", "block", "hidden");
                        this.active = false;
                        triggerDatepickerEvent(this.datepicker, "hide");
                      }
                    }, {
                      key: "place",
                      value: function place() {
                        var _this$element = this.element, classList = _this$element.classList, style = _this$element.style;
                        var _this$datepicker = this.datepicker, config = _this$datepicker.config, inputField = _this$datepicker.inputField;
                        var container = config.container;
                        var _this$element$getBoun = this.element.getBoundingClientRect(), calendarWidth = _this$element$getBoun.width, calendarHeight = _this$element$getBoun.height;
                        var _container$getBoundin = container.getBoundingClientRect(), containerLeft = _container$getBoundin.left, containerTop = _container$getBoundin.top, containerWidth = _container$getBoundin.width;
                        var _inputField$getBoundi = inputField.getBoundingClientRect(), inputLeft = _inputField$getBoundi.left, inputTop = _inputField$getBoundi.top, inputWidth = _inputField$getBoundi.width, inputHeight = _inputField$getBoundi.height;
                        var _config$orientation = config.orientation, orientX = _config$orientation.x, orientY = _config$orientation.y;
                        var scrollTop;
                        var left;
                        var top;
                        if (container === document.body) {
                          scrollTop = window.scrollY;
                          left = inputLeft + window.scrollX;
                          top = inputTop + scrollTop;
                        } else {
                          scrollTop = container.scrollTop;
                          left = inputLeft - containerLeft;
                          top = inputTop - containerTop + scrollTop;
                        }
                        if (orientX === "auto") {
                          if (left < 0) {
                            orientX = "left";
                            left = 10;
                          } else if (left + calendarWidth > containerWidth) {
                            orientX = "right";
                          } else {
                            orientX = getTextDirection(inputField) === "rtl" ? "right" : "left";
                          }
                        }
                        if (orientX === "right") {
                          left -= calendarWidth - inputWidth;
                        }
                        if (orientY === "auto") {
                          orientY = top - calendarHeight < scrollTop ? "bottom" : "top";
                        }
                        if (orientY === "top") {
                          top -= calendarHeight;
                        } else {
                          top += inputHeight;
                        }
                        classList.remove("datepicker-orient-top", "datepicker-orient-bottom", "datepicker-orient-right", "datepicker-orient-left");
                        classList.add("datepicker-orient-".concat(orientY), "datepicker-orient-".concat(orientX));
                        style.top = top ? "".concat(top, "px") : top;
                        style.left = left ? "".concat(left, "px") : left;
                      }
                    }, {
                      key: "setViewSwitchLabel",
                      value: function setViewSwitchLabel(labelText) {
                        this.controls.viewSwitch.textContent = labelText;
                      }
                    }, {
                      key: "setPrevBtnDisabled",
                      value: function setPrevBtnDisabled(disabled) {
                        this.controls.prevBtn.disabled = disabled;
                      }
                    }, {
                      key: "setNextBtnDisabled",
                      value: function setNextBtnDisabled(disabled) {
                        this.controls.nextBtn.disabled = disabled;
                      }
                    }, {
                      key: "changeView",
                      value: function changeView(viewId) {
                        var oldView = this.currentView;
                        var newView = this.views[viewId];
                        if (newView.id !== oldView.id) {
                          this.currentView = newView;
                          this._renderMethod = "render";
                          triggerDatepickerEvent(this.datepicker, "changeView");
                          this.main.replaceChild(newView.element, oldView.element);
                        }
                        return this;
                      }
                      // Change the focused date (view date)
                    }, {
                      key: "changeFocus",
                      value: function changeFocus(newViewDate) {
                        this._renderMethod = setViewDate(this, newViewDate) ? "render" : "refreshFocus";
                        this.views.forEach(function(view) {
                          view.updateFocus();
                        });
                        return this;
                      }
                      // Apply the change of the selected dates
                    }, {
                      key: "update",
                      value: function update() {
                        var newViewDate = computeResetViewDate(this.datepicker);
                        this._renderMethod = setViewDate(this, newViewDate) ? "render" : "refresh";
                        this.views.forEach(function(view) {
                          view.updateFocus();
                          view.updateSelection();
                        });
                        return this;
                      }
                      // Refresh the picker UI
                    }, {
                      key: "render",
                      value: function render2() {
                        var quickRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                        var renderMethod = quickRender && this._renderMethod || "render";
                        delete this._renderMethod;
                        this.currentView[renderMethod]();
                      }
                    }]);
                  }();
                  function findNextAvailableOne(date, addFn, increase, testFn, min, max) {
                    if (!isInRange(date, min, max)) {
                      return;
                    }
                    if (testFn(date)) {
                      var newDate = addFn(date, increase);
                      return findNextAvailableOne(newDate, addFn, increase, testFn, min, max);
                    }
                    return date;
                  }
                  function moveByArrowKey(datepicker, ev, direction, vertical) {
                    var picker = datepicker.picker;
                    var currentView = picker.currentView;
                    var step = currentView.step || 1;
                    var viewDate = picker.viewDate;
                    var addFn;
                    var testFn;
                    switch (currentView.id) {
                      case 0:
                        if (vertical) {
                          viewDate = addDays(viewDate, direction * 7);
                        } else if (ev.ctrlKey || ev.metaKey) {
                          viewDate = addYears(viewDate, direction);
                        } else {
                          viewDate = addDays(viewDate, direction);
                        }
                        addFn = addDays;
                        testFn = function testFn2(date) {
                          return currentView.disabled.includes(date);
                        };
                        break;
                      case 1:
                        viewDate = addMonths(viewDate, vertical ? direction * 4 : direction);
                        addFn = addMonths;
                        testFn = function testFn2(date) {
                          var dt = new Date(date);
                          var year = currentView.year, disabled = currentView.disabled;
                          return dt.getFullYear() === year && disabled.includes(dt.getMonth());
                        };
                        break;
                      default:
                        viewDate = addYears(viewDate, direction * (vertical ? 4 : 1) * step);
                        addFn = addYears;
                        testFn = function testFn2(date) {
                          return currentView.disabled.includes(startOfYearPeriod(date, step));
                        };
                    }
                    viewDate = findNextAvailableOne(viewDate, addFn, direction < 0 ? -step : step, testFn, currentView.minDate, currentView.maxDate);
                    if (viewDate !== void 0) {
                      picker.changeFocus(viewDate).render();
                    }
                  }
                  function onKeydown(datepicker, ev) {
                    if (ev.key === "Tab") {
                      unfocus(datepicker);
                      return;
                    }
                    var picker = datepicker.picker;
                    var _picker$currentView = picker.currentView, id = _picker$currentView.id, isMinView = _picker$currentView.isMinView;
                    if (!picker.active) {
                      switch (ev.key) {
                        case "ArrowDown":
                        case "Escape":
                          picker.show();
                          break;
                        case "Enter":
                          datepicker.update();
                          break;
                        default:
                          return;
                      }
                    } else if (datepicker.editMode) {
                      switch (ev.key) {
                        case "Escape":
                          picker.hide();
                          break;
                        case "Enter":
                          datepicker.exitEditMode({
                            update: true,
                            autohide: datepicker.config.autohide
                          });
                          break;
                        default:
                          return;
                      }
                    } else {
                      switch (ev.key) {
                        case "Escape":
                          picker.hide();
                          break;
                        case "ArrowLeft":
                          if (ev.ctrlKey || ev.metaKey) {
                            goToPrevOrNext(datepicker, -1);
                          } else if (ev.shiftKey) {
                            datepicker.enterEditMode();
                            return;
                          } else {
                            moveByArrowKey(datepicker, ev, -1, false);
                          }
                          break;
                        case "ArrowRight":
                          if (ev.ctrlKey || ev.metaKey) {
                            goToPrevOrNext(datepicker, 1);
                          } else if (ev.shiftKey) {
                            datepicker.enterEditMode();
                            return;
                          } else {
                            moveByArrowKey(datepicker, ev, 1, false);
                          }
                          break;
                        case "ArrowUp":
                          if (ev.ctrlKey || ev.metaKey) {
                            switchView(datepicker);
                          } else if (ev.shiftKey) {
                            datepicker.enterEditMode();
                            return;
                          } else {
                            moveByArrowKey(datepicker, ev, -1, true);
                          }
                          break;
                        case "ArrowDown":
                          if (ev.shiftKey && !ev.ctrlKey && !ev.metaKey) {
                            datepicker.enterEditMode();
                            return;
                          }
                          moveByArrowKey(datepicker, ev, 1, true);
                          break;
                        case "Enter":
                          if (isMinView) {
                            datepicker.setDate(picker.viewDate);
                          } else {
                            picker.changeView(id - 1).render();
                          }
                          break;
                        case "Backspace":
                        case "Delete":
                          datepicker.enterEditMode();
                          return;
                        default:
                          if (ev.key.length === 1 && !ev.ctrlKey && !ev.metaKey) {
                            datepicker.enterEditMode();
                          }
                          return;
                      }
                    }
                    ev.preventDefault();
                    ev.stopPropagation();
                  }
                  function onFocus(datepicker) {
                    if (datepicker.config.showOnFocus && !datepicker._showing) {
                      datepicker.show();
                    }
                  }
                  function onMousedown(datepicker, ev) {
                    var el = ev.target;
                    if (datepicker.picker.active || datepicker.config.showOnClick) {
                      el._active = el === document.activeElement;
                      el._clicking = setTimeout(function() {
                        delete el._active;
                        delete el._clicking;
                      }, 2e3);
                    }
                  }
                  function onClickInput(datepicker, ev) {
                    var el = ev.target;
                    if (!el._clicking) {
                      return;
                    }
                    clearTimeout(el._clicking);
                    delete el._clicking;
                    if (el._active) {
                      datepicker.enterEditMode();
                    }
                    delete el._active;
                    if (datepicker.config.showOnClick) {
                      datepicker.show();
                    }
                  }
                  function onPaste(datepicker, ev) {
                    if (ev.clipboardData.types.includes("text/plain")) {
                      datepicker.enterEditMode();
                    }
                  }
                  function onClickOutside(datepicker, ev) {
                    var element = datepicker.element;
                    if (element !== document.activeElement) {
                      return;
                    }
                    var pickerElem = datepicker.picker.element;
                    if (findElementInEventPath(ev, function(el) {
                      return el === element || el === pickerElem;
                    })) {
                      return;
                    }
                    unfocus(datepicker);
                  }
                  function stringifyDates(dates, config) {
                    return dates.map(function(dt) {
                      return formatDate(dt, config.format, config.locale);
                    }).join(config.dateDelimiter);
                  }
                  function processInputDates(datepicker, inputDates) {
                    var clear2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                    var config = datepicker.config, origDates = datepicker.dates, rangepicker = datepicker.rangepicker;
                    if (inputDates.length === 0) {
                      return clear2 ? [] : void 0;
                    }
                    var rangeEnd = rangepicker && datepicker === rangepicker.datepickers[1];
                    var newDates = inputDates.reduce(function(dates, dt) {
                      var date = parseDate(dt, config.format, config.locale);
                      if (date === void 0) {
                        return dates;
                      }
                      if (config.pickLevel > 0) {
                        var _dt = new Date(date);
                        if (config.pickLevel === 1) {
                          date = rangeEnd ? _dt.setMonth(_dt.getMonth() + 1, 0) : _dt.setDate(1);
                        } else {
                          date = rangeEnd ? _dt.setFullYear(_dt.getFullYear() + 1, 0, 0) : _dt.setMonth(0, 1);
                        }
                      }
                      if (isInRange(date, config.minDate, config.maxDate) && !dates.includes(date) && !config.datesDisabled.includes(date) && !config.daysOfWeekDisabled.includes(new Date(date).getDay())) {
                        dates.push(date);
                      }
                      return dates;
                    }, []);
                    if (newDates.length === 0) {
                      return;
                    }
                    if (config.multidate && !clear2) {
                      newDates = newDates.reduce(function(dates, date) {
                        if (!origDates.includes(date)) {
                          dates.push(date);
                        }
                        return dates;
                      }, origDates.filter(function(date) {
                        return !newDates.includes(date);
                      }));
                    }
                    return config.maxNumberOfDates && newDates.length > config.maxNumberOfDates ? newDates.slice(config.maxNumberOfDates * -1) : newDates;
                  }
                  function refreshUI(datepicker) {
                    var mode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
                    var quickRender = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
                    var config = datepicker.config, picker = datepicker.picker, inputField = datepicker.inputField;
                    if (mode & 2) {
                      var newView = picker.active ? config.pickLevel : config.startView;
                      picker.update().changeView(newView).render(quickRender);
                    }
                    if (mode & 1 && inputField) {
                      inputField.value = stringifyDates(datepicker.dates, config);
                    }
                  }
                  function _setDate(datepicker, inputDates, options) {
                    var clear2 = options.clear, render2 = options.render, autohide = options.autohide;
                    if (render2 === void 0) {
                      render2 = true;
                    }
                    if (!render2) {
                      autohide = false;
                    } else if (autohide === void 0) {
                      autohide = datepicker.config.autohide;
                    }
                    var newDates = processInputDates(datepicker, inputDates, clear2);
                    if (!newDates) {
                      return;
                    }
                    if (newDates.toString() !== datepicker.dates.toString()) {
                      datepicker.dates = newDates;
                      refreshUI(datepicker, render2 ? 3 : 1);
                      triggerDatepickerEvent(datepicker, "changeDate");
                    } else {
                      refreshUI(datepicker, 1);
                    }
                    if (autohide) {
                      datepicker.hide();
                    }
                  }
                  var Datepicker = /* @__PURE__ */ function() {
                    function Datepicker2(element) {
                      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                      var rangepicker = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
                      _classCallCheck(this, Datepicker2);
                      element.datepicker = this;
                      this.element = element;
                      var config = this.config = Object.assign({
                        buttonClass: options.buttonClass && String(options.buttonClass) || "button",
                        container: document.body,
                        defaultViewDate: today(),
                        maxDate: void 0,
                        minDate: void 0
                      }, processOptions(defaultOptions2, this));
                      this._options = options;
                      Object.assign(config, processOptions(options, this));
                      var inline = this.inline = element.tagName !== "INPUT";
                      var inputField;
                      var initialDates;
                      if (inline) {
                        config.container = element;
                        initialDates = stringToArray(element.dataset.date, config.dateDelimiter);
                        delete element.dataset.date;
                      } else {
                        var container = options.container ? document.querySelector(options.container) : null;
                        if (container) {
                          config.container = container;
                        }
                        inputField = this.inputField = element;
                        inputField.classList.add("datepicker-input");
                        initialDates = stringToArray(inputField.value, config.dateDelimiter);
                      }
                      if (rangepicker) {
                        var index = rangepicker.inputs.indexOf(inputField);
                        var datepickers = rangepicker.datepickers;
                        if (index < 0 || index > 1 || !Array.isArray(datepickers)) {
                          throw Error("Invalid rangepicker object.");
                        }
                        datepickers[index] = this;
                        Object.defineProperty(this, "rangepicker", {
                          get: function get2() {
                            return rangepicker;
                          }
                        });
                      }
                      this.dates = [];
                      var inputDateValues = processInputDates(this, initialDates);
                      if (inputDateValues && inputDateValues.length > 0) {
                        this.dates = inputDateValues;
                      }
                      if (inputField) {
                        inputField.value = stringifyDates(this.dates, config);
                      }
                      var picker = this.picker = new Picker(this);
                      if (inline) {
                        this.show();
                      } else {
                        var onMousedownDocument = onClickOutside.bind(null, this);
                        var listeners = [[inputField, "keydown", onKeydown.bind(null, this)], [inputField, "focus", onFocus.bind(null, this)], [inputField, "mousedown", onMousedown.bind(null, this)], [inputField, "click", onClickInput.bind(null, this)], [inputField, "paste", onPaste.bind(null, this)], [document, "mousedown", onMousedownDocument], [document, "touchstart", onMousedownDocument], [window, "resize", picker.place.bind(picker)]];
                        registerListeners(this, listeners);
                      }
                    }
                    return _createClass(Datepicker2, [{
                      key: "active",
                      get: (
                        /**
                         * @type {Boolean} - Whether the picker element is shown. `true` whne shown
                         */
                        function get2() {
                          return !!(this.picker && this.picker.active);
                        }
                      )
                      /**
                       * @type {HTMLDivElement} - DOM object of picker element
                       */
                    }, {
                      key: "pickerElement",
                      get: function get2() {
                        return this.picker ? this.picker.element : void 0;
                      }
                      /**
                       * Set new values to the config options
                       * @param {Object} options - config options to update
                       */
                    }, {
                      key: "setOptions",
                      value: function setOptions(options) {
                        var picker = this.picker;
                        var newOptions = processOptions(options, this);
                        Object.assign(this._options, options);
                        Object.assign(this.config, newOptions);
                        picker.setOptions(newOptions);
                        refreshUI(this, 3);
                      }
                      /**
                       * Show the picker element
                       */
                    }, {
                      key: "show",
                      value: function show() {
                        if (this.inputField) {
                          if (this.inputField.disabled) {
                            return;
                          }
                          if (this.inputField !== document.activeElement) {
                            this._showing = true;
                            this.inputField.focus();
                            delete this._showing;
                          }
                        }
                        this.picker.show();
                      }
                      /**
                       * Hide the picker element
                       * Not available on inline picker
                       */
                    }, {
                      key: "hide",
                      value: function hide() {
                        if (this.inline) {
                          return;
                        }
                        this.picker.hide();
                        this.picker.update().changeView(this.config.startView).render();
                      }
                      /**
                       * Destroy the Datepicker instance
                       * @return {Detepicker} - the instance destroyed
                       */
                    }, {
                      key: "destroy",
                      value: function destroy() {
                        this.hide();
                        unregisterListeners(this);
                        this.picker.detach();
                        if (!this.inline) {
                          this.inputField.classList.remove("datepicker-input");
                        }
                        delete this.element.datepicker;
                        return this;
                      }
                      /**
                       * Get the selected date(s)
                       *
                       * The method returns a Date object of selected date by default, and returns
                       * an array of selected dates in multidate mode. If format string is passed,
                       * it returns date string(s) formatted in given format.
                       *
                       * @param  {String} [format] - Format string to stringify the date(s)
                       * @return {Date|String|Date[]|String[]} - selected date(s), or if none is
                       * selected, empty array in multidate mode and untitled in sigledate mode
                       */
                    }, {
                      key: "getDate",
                      value: function getDate() {
                        var _this = this;
                        var format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
                        var callback = format ? function(date) {
                          return formatDate(date, format, _this.config.locale);
                        } : function(date) {
                          return new Date(date);
                        };
                        if (this.config.multidate) {
                          return this.dates.map(callback);
                        }
                        if (this.dates.length > 0) {
                          return callback(this.dates[0]);
                        }
                      }
                      /**
                       * Set selected date(s)
                       *
                       * In multidate mode, you can pass multiple dates as a series of arguments
                       * or an array. (Since each date is parsed individually, the type of the
                       * dates doesn't have to be the same.)
                       * The given dates are used to toggle the select status of each date. The
                       * number of selected dates is kept from exceeding the length set to
                       * maxNumberOfDates.
                       *
                       * With clear: true option, the method can be used to clear the selection
                       * and to replace the selection instead of toggling in multidate mode.
                       * If the option is passed with no date arguments or an empty dates array,
                       * it works as "clear" (clear the selection then set nothing), and if the
                       * option is passed with new dates to select, it works as "replace" (clear
                       * the selection then set the given dates)
                       *
                       * When render: false option is used, the method omits re-rendering the
                       * picker element. In this case, you need to call refresh() method later in
                       * order for the picker element to reflect the changes. The input field is
                       * refreshed always regardless of this option.
                       *
                       * When invalid (unparsable, repeated, disabled or out-of-range) dates are
                       * passed, the method ignores them and applies only valid ones. In the case
                       * that all the given dates are invalid, which is distinguished from passing
                       * no dates, the method considers it as an error and leaves the selection
                       * untouched.
                       *
                       * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date
                       * objects, time values or mix of those for new selection
                       * @param {Object} [options] - function options
                       * - clear: {boolean} - Whether to clear the existing selection
                       *     defualt: false
                       * - render: {boolean} - Whether to re-render the picker element
                       *     default: true
                       * - autohide: {boolean} - Whether to hide the picker element after re-render
                       *     Ignored when used with render: false
                       *     default: config.autohide
                       */
                    }, {
                      key: "setDate",
                      value: function setDate() {
                        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                          args[_key] = arguments[_key];
                        }
                        var dates = [].concat(args);
                        var opts = {};
                        var lastArg = lastItemOf(args);
                        if (_typeof(lastArg) === "object" && !Array.isArray(lastArg) && !(lastArg instanceof Date) && lastArg) {
                          Object.assign(opts, dates.pop());
                        }
                        var inputDates = Array.isArray(dates[0]) ? dates[0] : dates;
                        _setDate(this, inputDates, opts);
                      }
                      /**
                       * Update the selected date(s) with input field's value
                       * Not available on inline picker
                       *
                       * The input field will be refreshed with properly formatted date string.
                       *
                       * @param  {Object} [options] - function options
                       * - autohide: {boolean} - whether to hide the picker element after refresh
                       *     default: false
                       */
                    }, {
                      key: "update",
                      value: function update() {
                        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
                        if (this.inline) {
                          return;
                        }
                        var opts = {
                          clear: true,
                          autohide: !!(options && options.autohide)
                        };
                        var inputDates = stringToArray(this.inputField.value, this.config.dateDelimiter);
                        _setDate(this, inputDates, opts);
                      }
                      /**
                       * Refresh the picker element and the associated input field
                       * @param {String} [target] - target item when refreshing one item only
                       * 'picker' or 'input'
                       * @param {Boolean} [forceRender] - whether to re-render the picker element
                       * regardless of its state instead of optimized refresh
                       */
                    }, {
                      key: "refresh",
                      value: function refresh() {
                        var target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
                        var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                        if (target && typeof target !== "string") {
                          forceRender = target;
                          target = void 0;
                        }
                        var mode;
                        if (target === "picker") {
                          mode = 2;
                        } else if (target === "input") {
                          mode = 1;
                        } else {
                          mode = 3;
                        }
                        refreshUI(this, mode, !forceRender);
                      }
                      /**
                       * Enter edit mode
                       * Not available on inline picker or when the picker element is hidden
                       */
                    }, {
                      key: "enterEditMode",
                      value: function enterEditMode() {
                        if (this.inline || !this.picker.active || this.editMode) {
                          return;
                        }
                        this.editMode = true;
                        this.inputField.classList.add("in-edit", "border-blue-700", "!border-primary-700");
                      }
                      /**
                       * Exit from edit mode
                       * Not available on inline picker
                       * @param  {Object} [options] - function options
                       * - update: {boolean} - whether to call update() after exiting
                       *     If false, input field is revert to the existing selection
                       *     default: false
                       */
                    }, {
                      key: "exitEditMode",
                      value: function exitEditMode() {
                        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
                        if (this.inline || !this.editMode) {
                          return;
                        }
                        var opts = Object.assign({
                          update: false
                        }, options);
                        delete this.editMode;
                        this.inputField.classList.remove("in-edit", "border-blue-700", "!border-primary-700");
                        if (opts.update) {
                          this.update(opts);
                        }
                      }
                    }], [{
                      key: "formatDate",
                      value: function formatDate$1(date, format, lang) {
                        return formatDate(date, format, lang && locales[lang] || locales.en);
                      }
                      /**
                       * Parse date string
                       * @param  {String|Date|Number} dateStr - date string, Date object or time
                       * value to parse
                       * @param  {String|Object} format - format string or object that contains
                       * toValue() custom parser, whose signature is
                       * - args:
                       *   - dateStr: {String|Date|Number} - the dateStr passed to the method
                       *   - format: {Object} - the format object passed to the method
                       *   - locale: {Object} - locale for the language specified by `lang`
                       * - return:
                       *     {Date|Number} parsed date or its time value
                       * @param  {String} [lang=en] - language code for the locale to use
                       * @return {Number} time value of parsed date
                       */
                    }, {
                      key: "parseDate",
                      value: function parseDate$1(dateStr, format, lang) {
                        return parseDate(dateStr, format, lang && locales[lang] || locales.en);
                      }
                      /**
                       * @type {Object} - Installed locales in `[languageCode]: localeObject` format
                       * en`:_English (US)_ is pre-installed.
                       */
                    }, {
                      key: "locales",
                      get: function get2() {
                        return locales;
                      }
                    }]);
                  }();
                  function filterOptions(options) {
                    var newOpts = Object.assign({}, options);
                    delete newOpts.inputs;
                    delete newOpts.allowOneSidedRange;
                    delete newOpts.maxNumberOfDates;
                    return newOpts;
                  }
                  function setupDatepicker(rangepicker, changeDateListener, el, options) {
                    registerListeners(rangepicker, [[el, "changeDate", changeDateListener]]);
                    new Datepicker(el, options, rangepicker);
                  }
                  function onChangeDate(rangepicker, ev) {
                    if (rangepicker._updating) {
                      return;
                    }
                    rangepicker._updating = true;
                    var target = ev.target;
                    if (target.datepicker === void 0) {
                      return;
                    }
                    var datepickers = rangepicker.datepickers;
                    var setDateOptions = {
                      render: false
                    };
                    var changedSide = rangepicker.inputs.indexOf(target);
                    var otherSide = changedSide === 0 ? 1 : 0;
                    var changedDate = datepickers[changedSide].dates[0];
                    var otherDate = datepickers[otherSide].dates[0];
                    if (changedDate !== void 0 && otherDate !== void 0) {
                      if (changedSide === 0 && changedDate > otherDate) {
                        datepickers[0].setDate(otherDate, setDateOptions);
                        datepickers[1].setDate(changedDate, setDateOptions);
                      } else if (changedSide === 1 && changedDate < otherDate) {
                        datepickers[0].setDate(changedDate, setDateOptions);
                        datepickers[1].setDate(otherDate, setDateOptions);
                      }
                    } else if (!rangepicker.allowOneSidedRange) {
                      if (changedDate !== void 0 || otherDate !== void 0) {
                        setDateOptions.clear = true;
                        datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);
                      }
                    }
                    datepickers[0].picker.update().render();
                    datepickers[1].picker.update().render();
                    delete rangepicker._updating;
                  }
                  var DateRangePicker = /* @__PURE__ */ function() {
                    function DateRangePicker2(element) {
                      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                      _classCallCheck(this, DateRangePicker2);
                      var inputs = Array.isArray(options.inputs) ? options.inputs : Array.from(element.querySelectorAll("input"));
                      if (inputs.length < 2) {
                        return;
                      }
                      element.rangepicker = this;
                      this.element = element;
                      this.inputs = inputs.slice(0, 2);
                      this.allowOneSidedRange = !!options.allowOneSidedRange;
                      var changeDateListener = onChangeDate.bind(null, this);
                      var cleanOptions = filterOptions(options);
                      var datepickers = [];
                      Object.defineProperty(this, "datepickers", {
                        get: function get2() {
                          return datepickers;
                        }
                      });
                      setupDatepicker(this, changeDateListener, this.inputs[0], cleanOptions);
                      setupDatepicker(this, changeDateListener, this.inputs[1], cleanOptions);
                      Object.freeze(datepickers);
                      if (datepickers[0].dates.length > 0) {
                        onChangeDate(this, {
                          target: this.inputs[0]
                        });
                      } else if (datepickers[1].dates.length > 0) {
                        onChangeDate(this, {
                          target: this.inputs[1]
                        });
                      }
                    }
                    return _createClass(DateRangePicker2, [{
                      key: "dates",
                      get: function get2() {
                        return this.datepickers.length === 2 ? [this.datepickers[0].dates[0], this.datepickers[1].dates[0]] : void 0;
                      }
                      /**
                       * Set new values to the config options
                       * @param {Object} options - config options to update
                       */
                    }, {
                      key: "setOptions",
                      value: function setOptions(options) {
                        this.allowOneSidedRange = !!options.allowOneSidedRange;
                        var cleanOptions = filterOptions(options);
                        this.datepickers[0].setOptions(cleanOptions);
                        this.datepickers[1].setOptions(cleanOptions);
                      }
                      /**
                       * Destroy the DateRangePicker instance
                       * @return {DateRangePicker} - the instance destroyed
                       */
                    }, {
                      key: "destroy",
                      value: function destroy() {
                        this.datepickers[0].destroy();
                        this.datepickers[1].destroy();
                        unregisterListeners(this);
                        delete this.element.rangepicker;
                      }
                      /**
                       * Get the start and end dates of the date range
                       *
                       * The method returns Date objects by default. If format string is passed,
                       * it returns date strings formatted in given format.
                       * The result array always contains 2 items (start date/end date) and
                       * undefined is used for unselected side. (e.g. If none is selected,
                       * the result will be [undefined, undefined]. If only the end date is set
                       * when allowOneSidedRange config option is true, [undefined, endDate] will
                       * be returned.)
                       *
                       * @param  {String} [format] - Format string to stringify the dates
                       * @return {Array} - Start and end dates
                       */
                    }, {
                      key: "getDates",
                      value: function getDates() {
                        var _this = this;
                        var format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
                        var callback = format ? function(date) {
                          return formatDate(date, format, _this.datepickers[0].config.locale);
                        } : function(date) {
                          return new Date(date);
                        };
                        return this.dates.map(function(date) {
                          return date === void 0 ? date : callback(date);
                        });
                      }
                      /**
                       * Set the start and end dates of the date range
                       *
                       * The method calls datepicker.setDate() internally using each of the
                       * arguments in startend order.
                       *
                       * When a clear: true option object is passed instead of a date, the method
                       * clears the date.
                       *
                       * If an invalid date, the same date as the current one or an option object
                       * without clear: true is passed, the method considers that argument as an
                       * "ineffective" argument because calling datepicker.setDate() with those
                       * values makes no changes to the date selection.
                       *
                       * When the allowOneSidedRange config option is false, passing {clear: true}
                       * to clear the range works only when it is done to the last effective
                       * argument (in other words, passed to rangeEnd or to rangeStart along with
                       * ineffective rangeEnd). This is because when the date range is changed,
                       * it gets normalized based on the last change at the end of the changing
                       * process.
                       *
                       * @param {Date|Number|String|Object} rangeStart - Start date of the range
                       * or {clear: true} to clear the date
                       * @param {Date|Number|String|Object} rangeEnd - End date of the range
                       * or {clear: true} to clear the date
                       */
                    }, {
                      key: "setDates",
                      value: function setDates(rangeStart, rangeEnd) {
                        var _this$datepickers = _slicedToArray(this.datepickers, 2), datepicker0 = _this$datepickers[0], datepicker1 = _this$datepickers[1];
                        var origDates = this.dates;
                        this._updating = true;
                        datepicker0.setDate(rangeStart);
                        datepicker1.setDate(rangeEnd);
                        delete this._updating;
                        if (datepicker1.dates[0] !== origDates[1]) {
                          onChangeDate(this, {
                            target: this.inputs[1]
                          });
                        } else if (datepicker0.dates[0] !== origDates[0]) {
                          onChangeDate(this, {
                            target: this.inputs[0]
                          });
                        }
                      }
                    }]);
                  }();
                  exports2.DateRangePicker = DateRangePicker;
                  exports2.Datepicker = Datepicker;
                }
              ),
              /***/
              902: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __assign = this && this.__assign || function() {
                    __assign = Object.assign || function(t) {
                      for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p2 in s)
                          if (Object.prototype.hasOwnProperty.call(s, p2))
                            t[p2] = s[p2];
                      }
                      return t;
                    };
                    return __assign.apply(this, arguments);
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.initAccordions = void 0;
                  var instances_1 = __webpack_require__2(423);
                  var Default = {
                    alwaysOpen: false,
                    activeClasses: "bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white",
                    inactiveClasses: "text-gray-500 dark:text-gray-400",
                    onOpen: function() {
                    },
                    onClose: function() {
                    },
                    onToggle: function() {
                    }
                  };
                  var DefaultInstanceOptions = {
                    id: null,
                    override: true
                  };
                  var Accordion = (
                    /** @class */
                    function() {
                      function Accordion2(accordionEl, items, options, instanceOptions) {
                        if (accordionEl === void 0) {
                          accordionEl = null;
                        }
                        if (items === void 0) {
                          items = [];
                        }
                        if (options === void 0) {
                          options = Default;
                        }
                        if (instanceOptions === void 0) {
                          instanceOptions = DefaultInstanceOptions;
                        }
                        this._instanceId = instanceOptions.id ? instanceOptions.id : accordionEl.id;
                        this._accordionEl = accordionEl;
                        this._items = items;
                        this._options = __assign(__assign({}, Default), options);
                        this._initialized = false;
                        this.init();
                        instances_1.default.addInstance("Accordion", this, this._instanceId, instanceOptions.override);
                      }
                      Accordion2.prototype.init = function() {
                        var _this = this;
                        if (this._items.length && !this._initialized) {
                          this._items.forEach(function(item) {
                            if (item.active) {
                              _this.open(item.id);
                            }
                            var clickHandler = function() {
                              _this.toggle(item.id);
                            };
                            item.triggerEl.addEventListener("click", clickHandler);
                            item.clickHandler = clickHandler;
                          });
                          this._initialized = true;
                        }
                      };
                      Accordion2.prototype.destroy = function() {
                        if (this._items.length && this._initialized) {
                          this._items.forEach(function(item) {
                            item.triggerEl.removeEventListener("click", item.clickHandler);
                            delete item.clickHandler;
                          });
                          this._initialized = false;
                        }
                      };
                      Accordion2.prototype.removeInstance = function() {
                        instances_1.default.removeInstance("Accordion", this._instanceId);
                      };
                      Accordion2.prototype.destroyAndRemoveInstance = function() {
                        this.destroy();
                        this.removeInstance();
                      };
                      Accordion2.prototype.getItem = function(id) {
                        return this._items.filter(function(item) {
                          return item.id === id;
                        })[0];
                      };
                      Accordion2.prototype.open = function(id) {
                        var _a, _b;
                        var _this = this;
                        var item = this.getItem(id);
                        if (!this._options.alwaysOpen) {
                          this._items.map(function(i) {
                            var _a2, _b2;
                            if (i !== item) {
                              (_a2 = i.triggerEl.classList).remove.apply(_a2, _this._options.activeClasses.split(" "));
                              (_b2 = i.triggerEl.classList).add.apply(_b2, _this._options.inactiveClasses.split(" "));
                              i.targetEl.classList.add("hidden");
                              i.triggerEl.setAttribute("aria-expanded", "false");
                              i.active = false;
                              if (i.iconEl) {
                                i.iconEl.classList.add("rotate-180");
                              }
                            }
                          });
                        }
                        (_a = item.triggerEl.classList).add.apply(_a, this._options.activeClasses.split(" "));
                        (_b = item.triggerEl.classList).remove.apply(_b, this._options.inactiveClasses.split(" "));
                        item.triggerEl.setAttribute("aria-expanded", "true");
                        item.targetEl.classList.remove("hidden");
                        item.active = true;
                        if (item.iconEl) {
                          item.iconEl.classList.remove("rotate-180");
                        }
                        this._options.onOpen(this, item);
                      };
                      Accordion2.prototype.toggle = function(id) {
                        var item = this.getItem(id);
                        if (item.active) {
                          this.close(id);
                        } else {
                          this.open(id);
                        }
                        this._options.onToggle(this, item);
                      };
                      Accordion2.prototype.close = function(id) {
                        var _a, _b;
                        var item = this.getItem(id);
                        (_a = item.triggerEl.classList).remove.apply(_a, this._options.activeClasses.split(" "));
                        (_b = item.triggerEl.classList).add.apply(_b, this._options.inactiveClasses.split(" "));
                        item.targetEl.classList.add("hidden");
                        item.triggerEl.setAttribute("aria-expanded", "false");
                        item.active = false;
                        if (item.iconEl) {
                          item.iconEl.classList.add("rotate-180");
                        }
                        this._options.onClose(this, item);
                      };
                      Accordion2.prototype.updateOnOpen = function(callback) {
                        this._options.onOpen = callback;
                      };
                      Accordion2.prototype.updateOnClose = function(callback) {
                        this._options.onClose = callback;
                      };
                      Accordion2.prototype.updateOnToggle = function(callback) {
                        this._options.onToggle = callback;
                      };
                      return Accordion2;
                    }()
                  );
                  function initAccordions() {
                    document.querySelectorAll("[data-accordion]").forEach(function($accordionEl) {
                      var alwaysOpen = $accordionEl.getAttribute("data-accordion");
                      var activeClasses = $accordionEl.getAttribute("data-active-classes");
                      var inactiveClasses = $accordionEl.getAttribute("data-inactive-classes");
                      var items = [];
                      $accordionEl.querySelectorAll("[data-accordion-target]").forEach(function($triggerEl) {
                        if ($triggerEl.closest("[data-accordion]") === $accordionEl) {
                          var item = {
                            id: $triggerEl.getAttribute("data-accordion-target"),
                            triggerEl: $triggerEl,
                            targetEl: document.querySelector($triggerEl.getAttribute("data-accordion-target")),
                            iconEl: $triggerEl.querySelector("[data-accordion-icon]"),
                            active: $triggerEl.getAttribute("aria-expanded") === "true" ? true : false
                          };
                          items.push(item);
                        }
                      });
                      new Accordion($accordionEl, items, {
                        alwaysOpen: alwaysOpen === "open" ? true : false,
                        activeClasses: activeClasses ? activeClasses : Default.activeClasses,
                        inactiveClasses: inactiveClasses ? inactiveClasses : Default.inactiveClasses
                      });
                    });
                  }
                  exports2.initAccordions = initAccordions;
                  if (typeof window !== "undefined") {
                    window.Accordion = Accordion;
                    window.initAccordions = initAccordions;
                  }
                  exports2["default"] = Accordion;
                }
              ),
              /***/
              33: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __assign = this && this.__assign || function() {
                    __assign = Object.assign || function(t) {
                      for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p2 in s)
                          if (Object.prototype.hasOwnProperty.call(s, p2))
                            t[p2] = s[p2];
                      }
                      return t;
                    };
                    return __assign.apply(this, arguments);
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.initCarousels = void 0;
                  var instances_1 = __webpack_require__2(423);
                  var Default = {
                    defaultPosition: 0,
                    indicators: {
                      items: [],
                      activeClasses: "bg-white dark:bg-gray-800",
                      inactiveClasses: "bg-white/50 dark:bg-gray-800/50 hover:bg-white dark:hover:bg-gray-800"
                    },
                    interval: 3e3,
                    onNext: function() {
                    },
                    onPrev: function() {
                    },
                    onChange: function() {
                    }
                  };
                  var DefaultInstanceOptions = {
                    id: null,
                    override: true
                  };
                  var Carousel = (
                    /** @class */
                    function() {
                      function Carousel2(carouselEl, items, options, instanceOptions) {
                        if (carouselEl === void 0) {
                          carouselEl = null;
                        }
                        if (items === void 0) {
                          items = [];
                        }
                        if (options === void 0) {
                          options = Default;
                        }
                        if (instanceOptions === void 0) {
                          instanceOptions = DefaultInstanceOptions;
                        }
                        this._instanceId = instanceOptions.id ? instanceOptions.id : carouselEl.id;
                        this._carouselEl = carouselEl;
                        this._items = items;
                        this._options = __assign(__assign(__assign({}, Default), options), { indicators: __assign(__assign({}, Default.indicators), options.indicators) });
                        this._activeItem = this.getItem(this._options.defaultPosition);
                        this._indicators = this._options.indicators.items;
                        this._intervalDuration = this._options.interval;
                        this._intervalInstance = null;
                        this._initialized = false;
                        this.init();
                        instances_1.default.addInstance("Carousel", this, this._instanceId, instanceOptions.override);
                      }
                      Carousel2.prototype.init = function() {
                        var _this = this;
                        if (this._items.length && !this._initialized) {
                          this._items.map(function(item) {
                            item.el.classList.add("absolute", "inset-0", "transition-transform", "transform");
                          });
                          if (this.getActiveItem()) {
                            this.slideTo(this.getActiveItem().position);
                          } else {
                            this.slideTo(0);
                          }
                          this._indicators.map(function(indicator, position) {
                            indicator.el.addEventListener("click", function() {
                              _this.slideTo(position);
                            });
                          });
                          this._initialized = true;
                        }
                      };
                      Carousel2.prototype.destroy = function() {
                        if (this._initialized) {
                          this._initialized = false;
                        }
                      };
                      Carousel2.prototype.removeInstance = function() {
                        instances_1.default.removeInstance("Carousel", this._instanceId);
                      };
                      Carousel2.prototype.destroyAndRemoveInstance = function() {
                        this.destroy();
                        this.removeInstance();
                      };
                      Carousel2.prototype.getItem = function(position) {
                        return this._items[position];
                      };
                      Carousel2.prototype.slideTo = function(position) {
                        var nextItem = this._items[position];
                        var rotationItems = {
                          left: nextItem.position === 0 ? this._items[this._items.length - 1] : this._items[nextItem.position - 1],
                          middle: nextItem,
                          right: nextItem.position === this._items.length - 1 ? this._items[0] : this._items[nextItem.position + 1]
                        };
                        this._rotate(rotationItems);
                        this._setActiveItem(nextItem);
                        if (this._intervalInstance) {
                          this.pause();
                          this.cycle();
                        }
                        this._options.onChange(this);
                      };
                      Carousel2.prototype.next = function() {
                        var activeItem = this.getActiveItem();
                        var nextItem = null;
                        if (activeItem.position === this._items.length - 1) {
                          nextItem = this._items[0];
                        } else {
                          nextItem = this._items[activeItem.position + 1];
                        }
                        this.slideTo(nextItem.position);
                        this._options.onNext(this);
                      };
                      Carousel2.prototype.prev = function() {
                        var activeItem = this.getActiveItem();
                        var prevItem = null;
                        if (activeItem.position === 0) {
                          prevItem = this._items[this._items.length - 1];
                        } else {
                          prevItem = this._items[activeItem.position - 1];
                        }
                        this.slideTo(prevItem.position);
                        this._options.onPrev(this);
                      };
                      Carousel2.prototype._rotate = function(rotationItems) {
                        this._items.map(function(item) {
                          item.el.classList.add("hidden");
                        });
                        if (this._items.length === 1) {
                          rotationItems.middle.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-10");
                          rotationItems.middle.el.classList.add("translate-x-0", "z-20");
                          return;
                        }
                        rotationItems.left.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-20");
                        rotationItems.left.el.classList.add("-translate-x-full", "z-10");
                        rotationItems.middle.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-10");
                        rotationItems.middle.el.classList.add("translate-x-0", "z-30");
                        rotationItems.right.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-30");
                        rotationItems.right.el.classList.add("translate-x-full", "z-20");
                      };
                      Carousel2.prototype.cycle = function() {
                        var _this = this;
                        if (typeof window !== "undefined") {
                          this._intervalInstance = window.setInterval(function() {
                            _this.next();
                          }, this._intervalDuration);
                        }
                      };
                      Carousel2.prototype.pause = function() {
                        clearInterval(this._intervalInstance);
                      };
                      Carousel2.prototype.getActiveItem = function() {
                        return this._activeItem;
                      };
                      Carousel2.prototype._setActiveItem = function(item) {
                        var _a, _b;
                        var _this = this;
                        this._activeItem = item;
                        var position = item.position;
                        if (this._indicators.length) {
                          this._indicators.map(function(indicator) {
                            var _a2, _b2;
                            indicator.el.setAttribute("aria-current", "false");
                            (_a2 = indicator.el.classList).remove.apply(_a2, _this._options.indicators.activeClasses.split(" "));
                            (_b2 = indicator.el.classList).add.apply(_b2, _this._options.indicators.inactiveClasses.split(" "));
                          });
                          (_a = this._indicators[position].el.classList).add.apply(_a, this._options.indicators.activeClasses.split(" "));
                          (_b = this._indicators[position].el.classList).remove.apply(_b, this._options.indicators.inactiveClasses.split(" "));
                          this._indicators[position].el.setAttribute("aria-current", "true");
                        }
                      };
                      Carousel2.prototype.updateOnNext = function(callback) {
                        this._options.onNext = callback;
                      };
                      Carousel2.prototype.updateOnPrev = function(callback) {
                        this._options.onPrev = callback;
                      };
                      Carousel2.prototype.updateOnChange = function(callback) {
                        this._options.onChange = callback;
                      };
                      return Carousel2;
                    }()
                  );
                  function initCarousels() {
                    document.querySelectorAll("[data-carousel]").forEach(function($carouselEl) {
                      var interval = $carouselEl.getAttribute("data-carousel-interval");
                      var slide = $carouselEl.getAttribute("data-carousel") === "slide" ? true : false;
                      var items = [];
                      var defaultPosition = 0;
                      if ($carouselEl.querySelectorAll("[data-carousel-item]").length) {
                        Array.from($carouselEl.querySelectorAll("[data-carousel-item]")).map(function($carouselItemEl, position) {
                          items.push({
                            position,
                            el: $carouselItemEl
                          });
                          if ($carouselItemEl.getAttribute("data-carousel-item") === "active") {
                            defaultPosition = position;
                          }
                        });
                      }
                      var indicators = [];
                      if ($carouselEl.querySelectorAll("[data-carousel-slide-to]").length) {
                        Array.from($carouselEl.querySelectorAll("[data-carousel-slide-to]")).map(function($indicatorEl) {
                          indicators.push({
                            position: parseInt($indicatorEl.getAttribute("data-carousel-slide-to")),
                            el: $indicatorEl
                          });
                        });
                      }
                      var carousel = new Carousel($carouselEl, items, {
                        defaultPosition,
                        indicators: {
                          items: indicators
                        },
                        interval: interval ? interval : Default.interval
                      });
                      if (slide) {
                        carousel.cycle();
                      }
                      var carouselNextEl = $carouselEl.querySelector("[data-carousel-next]");
                      var carouselPrevEl = $carouselEl.querySelector("[data-carousel-prev]");
                      if (carouselNextEl) {
                        carouselNextEl.addEventListener("click", function() {
                          carousel.next();
                        });
                      }
                      if (carouselPrevEl) {
                        carouselPrevEl.addEventListener("click", function() {
                          carousel.prev();
                        });
                      }
                    });
                  }
                  exports2.initCarousels = initCarousels;
                  if (typeof window !== "undefined") {
                    window.Carousel = Carousel;
                    window.initCarousels = initCarousels;
                  }
                  exports2["default"] = Carousel;
                }
              ),
              /***/
              673: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __assign = this && this.__assign || function() {
                    __assign = Object.assign || function(t) {
                      for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p2 in s)
                          if (Object.prototype.hasOwnProperty.call(s, p2))
                            t[p2] = s[p2];
                      }
                      return t;
                    };
                    return __assign.apply(this, arguments);
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.initCopyClipboards = void 0;
                  var instances_1 = __webpack_require__2(423);
                  var Default = {
                    htmlEntities: false,
                    contentType: "input",
                    onCopy: function() {
                    }
                  };
                  var DefaultInstanceOptions = {
                    id: null,
                    override: true
                  };
                  var CopyClipboard = (
                    /** @class */
                    function() {
                      function CopyClipboard2(triggerEl, targetEl, options, instanceOptions) {
                        if (triggerEl === void 0) {
                          triggerEl = null;
                        }
                        if (targetEl === void 0) {
                          targetEl = null;
                        }
                        if (options === void 0) {
                          options = Default;
                        }
                        if (instanceOptions === void 0) {
                          instanceOptions = DefaultInstanceOptions;
                        }
                        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                        this._triggerEl = triggerEl;
                        this._targetEl = targetEl;
                        this._options = __assign(__assign({}, Default), options);
                        this._initialized = false;
                        this.init();
                        instances_1.default.addInstance("CopyClipboard", this, this._instanceId, instanceOptions.override);
                      }
                      CopyClipboard2.prototype.init = function() {
                        var _this = this;
                        if (this._targetEl && this._triggerEl && !this._initialized) {
                          this._triggerElClickHandler = function() {
                            _this.copy();
                          };
                          if (this._triggerEl) {
                            this._triggerEl.addEventListener("click", this._triggerElClickHandler);
                          }
                          this._initialized = true;
                        }
                      };
                      CopyClipboard2.prototype.destroy = function() {
                        if (this._triggerEl && this._targetEl && this._initialized) {
                          if (this._triggerEl) {
                            this._triggerEl.removeEventListener("click", this._triggerElClickHandler);
                          }
                          this._initialized = false;
                        }
                      };
                      CopyClipboard2.prototype.removeInstance = function() {
                        instances_1.default.removeInstance("CopyClipboard", this._instanceId);
                      };
                      CopyClipboard2.prototype.destroyAndRemoveInstance = function() {
                        this.destroy();
                        this.removeInstance();
                      };
                      CopyClipboard2.prototype.getTargetValue = function() {
                        if (this._options.contentType === "input") {
                          return this._targetEl.value;
                        }
                        if (this._options.contentType === "innerHTML") {
                          return this._targetEl.innerHTML;
                        }
                        if (this._options.contentType === "textContent") {
                          return this._targetEl.textContent.replace(/\s+/g, " ").trim();
                        }
                      };
                      CopyClipboard2.prototype.copy = function() {
                        var textToCopy = this.getTargetValue();
                        if (this._options.htmlEntities) {
                          textToCopy = this.decodeHTML(textToCopy);
                        }
                        var tempTextArea = document.createElement("textarea");
                        tempTextArea.value = textToCopy;
                        document.body.appendChild(tempTextArea);
                        tempTextArea.select();
                        document.execCommand("copy");
                        document.body.removeChild(tempTextArea);
                        this._options.onCopy(this);
                        return textToCopy;
                      };
                      CopyClipboard2.prototype.decodeHTML = function(html) {
                        var textarea = document.createElement("textarea");
                        textarea.innerHTML = html;
                        return textarea.textContent;
                      };
                      CopyClipboard2.prototype.updateOnCopyCallback = function(callback) {
                        this._options.onCopy = callback;
                      };
                      return CopyClipboard2;
                    }()
                  );
                  function initCopyClipboards() {
                    document.querySelectorAll("[data-copy-to-clipboard-target]").forEach(function($triggerEl) {
                      var targetId = $triggerEl.getAttribute("data-copy-to-clipboard-target");
                      var $targetEl = document.getElementById(targetId);
                      var contentType = $triggerEl.getAttribute("data-copy-to-clipboard-content-type");
                      var htmlEntities = $triggerEl.getAttribute("data-copy-to-clipboard-html-entities");
                      if ($targetEl) {
                        if (!instances_1.default.instanceExists("CopyClipboard", $targetEl.getAttribute("id"))) {
                          new CopyClipboard($triggerEl, $targetEl, {
                            htmlEntities: htmlEntities && htmlEntities === "true" ? true : Default.htmlEntities,
                            contentType: contentType ? contentType : Default.contentType
                          });
                        }
                      } else {
                        console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-copy-to-clipboard-target attribute.'));
                      }
                    });
                  }
                  exports2.initCopyClipboards = initCopyClipboards;
                  if (typeof window !== "undefined") {
                    window.CopyClipboard = CopyClipboard;
                    window.initClipboards = initCopyClipboards;
                  }
                  exports2["default"] = CopyClipboard;
                }
              ),
              /***/
              922: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __assign = this && this.__assign || function() {
                    __assign = Object.assign || function(t) {
                      for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p2 in s)
                          if (Object.prototype.hasOwnProperty.call(s, p2))
                            t[p2] = s[p2];
                      }
                      return t;
                    };
                    return __assign.apply(this, arguments);
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.initCollapses = void 0;
                  var instances_1 = __webpack_require__2(423);
                  var Default = {
                    onCollapse: function() {
                    },
                    onExpand: function() {
                    },
                    onToggle: function() {
                    }
                  };
                  var DefaultInstanceOptions = {
                    id: null,
                    override: true
                  };
                  var Collapse = (
                    /** @class */
                    function() {
                      function Collapse2(targetEl, triggerEl, options, instanceOptions) {
                        if (targetEl === void 0) {
                          targetEl = null;
                        }
                        if (triggerEl === void 0) {
                          triggerEl = null;
                        }
                        if (options === void 0) {
                          options = Default;
                        }
                        if (instanceOptions === void 0) {
                          instanceOptions = DefaultInstanceOptions;
                        }
                        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                        this._targetEl = targetEl;
                        this._triggerEl = triggerEl;
                        this._options = __assign(__assign({}, Default), options);
                        this._visible = false;
                        this._initialized = false;
                        this.init();
                        instances_1.default.addInstance("Collapse", this, this._instanceId, instanceOptions.override);
                      }
                      Collapse2.prototype.init = function() {
                        var _this = this;
                        if (this._triggerEl && this._targetEl && !this._initialized) {
                          if (this._triggerEl.hasAttribute("aria-expanded")) {
                            this._visible = this._triggerEl.getAttribute("aria-expanded") === "true";
                          } else {
                            this._visible = !this._targetEl.classList.contains("hidden");
                          }
                          this._clickHandler = function() {
                            _this.toggle();
                          };
                          this._triggerEl.addEventListener("click", this._clickHandler);
                          this._initialized = true;
                        }
                      };
                      Collapse2.prototype.destroy = function() {
                        if (this._triggerEl && this._initialized) {
                          this._triggerEl.removeEventListener("click", this._clickHandler);
                          this._initialized = false;
                        }
                      };
                      Collapse2.prototype.removeInstance = function() {
                        instances_1.default.removeInstance("Collapse", this._instanceId);
                      };
                      Collapse2.prototype.destroyAndRemoveInstance = function() {
                        this.destroy();
                        this.removeInstance();
                      };
                      Collapse2.prototype.collapse = function() {
                        this._targetEl.classList.add("hidden");
                        if (this._triggerEl) {
                          this._triggerEl.setAttribute("aria-expanded", "false");
                        }
                        this._visible = false;
                        this._options.onCollapse(this);
                      };
                      Collapse2.prototype.expand = function() {
                        this._targetEl.classList.remove("hidden");
                        if (this._triggerEl) {
                          this._triggerEl.setAttribute("aria-expanded", "true");
                        }
                        this._visible = true;
                        this._options.onExpand(this);
                      };
                      Collapse2.prototype.toggle = function() {
                        if (this._visible) {
                          this.collapse();
                        } else {
                          this.expand();
                        }
                        this._options.onToggle(this);
                      };
                      Collapse2.prototype.updateOnCollapse = function(callback) {
                        this._options.onCollapse = callback;
                      };
                      Collapse2.prototype.updateOnExpand = function(callback) {
                        this._options.onExpand = callback;
                      };
                      Collapse2.prototype.updateOnToggle = function(callback) {
                        this._options.onToggle = callback;
                      };
                      return Collapse2;
                    }()
                  );
                  function initCollapses() {
                    document.querySelectorAll("[data-collapse-toggle]").forEach(function($triggerEl) {
                      var targetId = $triggerEl.getAttribute("data-collapse-toggle");
                      var $targetEl = document.getElementById(targetId);
                      if ($targetEl) {
                        if (!instances_1.default.instanceExists("Collapse", $targetEl.getAttribute("id"))) {
                          new Collapse($targetEl, $triggerEl);
                        } else {
                          new Collapse($targetEl, $triggerEl, {}, {
                            id: $targetEl.getAttribute("id") + "_" + instances_1.default._generateRandomId()
                          });
                        }
                      } else {
                        console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-collapse-toggle attribute.'));
                      }
                    });
                  }
                  exports2.initCollapses = initCollapses;
                  if (typeof window !== "undefined") {
                    window.Collapse = Collapse;
                    window.initCollapses = initCollapses;
                  }
                  exports2["default"] = Collapse;
                }
              ),
              /***/
              132: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __assign = this && this.__assign || function() {
                    __assign = Object.assign || function(t) {
                      for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p2 in s)
                          if (Object.prototype.hasOwnProperty.call(s, p2))
                            t[p2] = s[p2];
                      }
                      return t;
                    };
                    return __assign.apply(this, arguments);
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.initDatepickers = void 0;
                  var instances_1 = __webpack_require__2(423);
                  var flowbite_datepicker_1 = __webpack_require__2(554);
                  var Default = {
                    defaultDatepickerId: null,
                    autohide: false,
                    format: "mm/dd/yyyy",
                    maxDate: null,
                    minDate: null,
                    orientation: "bottom",
                    buttons: false,
                    autoSelectToday: 0,
                    title: null,
                    language: "en",
                    rangePicker: false,
                    onShow: function() {
                    },
                    onHide: function() {
                    }
                  };
                  var DefaultInstanceOptions = {
                    id: null,
                    override: true
                  };
                  var Datepicker = (
                    /** @class */
                    function() {
                      function Datepicker2(datepickerEl, options, instanceOptions) {
                        if (datepickerEl === void 0) {
                          datepickerEl = null;
                        }
                        if (options === void 0) {
                          options = Default;
                        }
                        if (instanceOptions === void 0) {
                          instanceOptions = DefaultInstanceOptions;
                        }
                        this._instanceId = instanceOptions.id ? instanceOptions.id : datepickerEl.id;
                        this._datepickerEl = datepickerEl;
                        this._datepickerInstance = null;
                        this._options = __assign(__assign({}, Default), options);
                        this._initialized = false;
                        this.init();
                        instances_1.default.addInstance("Datepicker", this, this._instanceId, instanceOptions.override);
                      }
                      Datepicker2.prototype.init = function() {
                        if (this._datepickerEl && !this._initialized) {
                          if (this._options.rangePicker) {
                            this._datepickerInstance = new flowbite_datepicker_1.DateRangePicker(this._datepickerEl, this._getDatepickerOptions(this._options));
                          } else {
                            this._datepickerInstance = new flowbite_datepicker_1.Datepicker(this._datepickerEl, this._getDatepickerOptions(this._options));
                          }
                          this._initialized = true;
                        }
                      };
                      Datepicker2.prototype.destroy = function() {
                        if (this._initialized) {
                          this._initialized = false;
                          this._datepickerInstance.destroy();
                        }
                      };
                      Datepicker2.prototype.removeInstance = function() {
                        this.destroy();
                        instances_1.default.removeInstance("Datepicker", this._instanceId);
                      };
                      Datepicker2.prototype.destroyAndRemoveInstance = function() {
                        this.destroy();
                        this.removeInstance();
                      };
                      Datepicker2.prototype.getDatepickerInstance = function() {
                        return this._datepickerInstance;
                      };
                      Datepicker2.prototype.getDate = function() {
                        if (this._options.rangePicker && this._datepickerInstance instanceof flowbite_datepicker_1.DateRangePicker) {
                          return this._datepickerInstance.getDates();
                        }
                        if (!this._options.rangePicker && this._datepickerInstance instanceof flowbite_datepicker_1.Datepicker) {
                          return this._datepickerInstance.getDate();
                        }
                      };
                      Datepicker2.prototype.setDate = function(date) {
                        if (this._options.rangePicker && this._datepickerInstance instanceof flowbite_datepicker_1.DateRangePicker) {
                          return this._datepickerInstance.setDates(date);
                        }
                        if (!this._options.rangePicker && this._datepickerInstance instanceof flowbite_datepicker_1.Datepicker) {
                          return this._datepickerInstance.setDate(date);
                        }
                      };
                      Datepicker2.prototype.show = function() {
                        this._datepickerInstance.show();
                        this._options.onShow(this);
                      };
                      Datepicker2.prototype.hide = function() {
                        this._datepickerInstance.hide();
                        this._options.onHide(this);
                      };
                      Datepicker2.prototype._getDatepickerOptions = function(options) {
                        var datepickerOptions = {};
                        if (options.buttons) {
                          datepickerOptions.todayBtn = true;
                          datepickerOptions.clearBtn = true;
                          if (options.autoSelectToday) {
                            datepickerOptions.todayBtnMode = 1;
                          }
                        }
                        if (options.autohide) {
                          datepickerOptions.autohide = true;
                        }
                        if (options.format) {
                          datepickerOptions.format = options.format;
                        }
                        if (options.maxDate) {
                          datepickerOptions.maxDate = options.maxDate;
                        }
                        if (options.minDate) {
                          datepickerOptions.minDate = options.minDate;
                        }
                        if (options.orientation) {
                          datepickerOptions.orientation = options.orientation;
                        }
                        if (options.title) {
                          datepickerOptions.title = options.title;
                        }
                        if (options.language) {
                          datepickerOptions.language = options.language;
                        }
                        return datepickerOptions;
                      };
                      Datepicker2.prototype.updateOnShow = function(callback) {
                        this._options.onShow = callback;
                      };
                      Datepicker2.prototype.updateOnHide = function(callback) {
                        this._options.onHide = callback;
                      };
                      return Datepicker2;
                    }()
                  );
                  function initDatepickers() {
                    document.querySelectorAll("[datepicker], [inline-datepicker], [date-rangepicker]").forEach(function($datepickerEl) {
                      if ($datepickerEl) {
                        var buttons = $datepickerEl.hasAttribute("datepicker-buttons");
                        var autoselectToday = $datepickerEl.hasAttribute("datepicker-autoselect-today");
                        var autohide = $datepickerEl.hasAttribute("datepicker-autohide");
                        var format = $datepickerEl.getAttribute("datepicker-format");
                        var maxDate = $datepickerEl.getAttribute("datepicker-max-date");
                        var minDate = $datepickerEl.getAttribute("datepicker-min-date");
                        var orientation = $datepickerEl.getAttribute("datepicker-orientation");
                        var title = $datepickerEl.getAttribute("datepicker-title");
                        var language = $datepickerEl.getAttribute("datepicker-language");
                        var rangePicker = $datepickerEl.hasAttribute("date-rangepicker");
                        new Datepicker($datepickerEl, {
                          buttons: buttons ? buttons : Default.buttons,
                          autoSelectToday: autoselectToday ? autoselectToday : Default.autoSelectToday,
                          autohide: autohide ? autohide : Default.autohide,
                          format: format ? format : Default.format,
                          maxDate: maxDate ? maxDate : Default.maxDate,
                          minDate: minDate ? minDate : Default.minDate,
                          orientation: orientation ? orientation : Default.orientation,
                          title: title ? title : Default.title,
                          language: language ? language : Default.language,
                          rangePicker: rangePicker ? rangePicker : Default.rangePicker
                        });
                      } else {
                        console.error("The datepicker element does not exist. Please check the datepicker attribute.");
                      }
                    });
                  }
                  exports2.initDatepickers = initDatepickers;
                  if (typeof window !== "undefined") {
                    window.Datepicker = Datepicker;
                    window.initDatepickers = initDatepickers;
                  }
                  exports2["default"] = Datepicker;
                }
              ),
              /***/
              556: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __assign = this && this.__assign || function() {
                    __assign = Object.assign || function(t) {
                      for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p2 in s)
                          if (Object.prototype.hasOwnProperty.call(s, p2))
                            t[p2] = s[p2];
                      }
                      return t;
                    };
                    return __assign.apply(this, arguments);
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.initDials = void 0;
                  var instances_1 = __webpack_require__2(423);
                  var Default = {
                    triggerType: "hover",
                    onShow: function() {
                    },
                    onHide: function() {
                    },
                    onToggle: function() {
                    }
                  };
                  var DefaultInstanceOptions = {
                    id: null,
                    override: true
                  };
                  var Dial = (
                    /** @class */
                    function() {
                      function Dial2(parentEl, triggerEl, targetEl, options, instanceOptions) {
                        if (parentEl === void 0) {
                          parentEl = null;
                        }
                        if (triggerEl === void 0) {
                          triggerEl = null;
                        }
                        if (targetEl === void 0) {
                          targetEl = null;
                        }
                        if (options === void 0) {
                          options = Default;
                        }
                        if (instanceOptions === void 0) {
                          instanceOptions = DefaultInstanceOptions;
                        }
                        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                        this._parentEl = parentEl;
                        this._triggerEl = triggerEl;
                        this._targetEl = targetEl;
                        this._options = __assign(__assign({}, Default), options);
                        this._visible = false;
                        this._initialized = false;
                        this.init();
                        instances_1.default.addInstance("Dial", this, this._instanceId, instanceOptions.override);
                      }
                      Dial2.prototype.init = function() {
                        var _this = this;
                        if (this._triggerEl && this._targetEl && !this._initialized) {
                          var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);
                          this._showEventHandler = function() {
                            _this.show();
                          };
                          triggerEventTypes.showEvents.forEach(function(ev) {
                            _this._triggerEl.addEventListener(ev, _this._showEventHandler);
                            _this._targetEl.addEventListener(ev, _this._showEventHandler);
                          });
                          this._hideEventHandler = function() {
                            if (!_this._parentEl.matches(":hover")) {
                              _this.hide();
                            }
                          };
                          triggerEventTypes.hideEvents.forEach(function(ev) {
                            _this._parentEl.addEventListener(ev, _this._hideEventHandler);
                          });
                          this._initialized = true;
                        }
                      };
                      Dial2.prototype.destroy = function() {
                        var _this = this;
                        if (this._initialized) {
                          var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);
                          triggerEventTypes.showEvents.forEach(function(ev) {
                            _this._triggerEl.removeEventListener(ev, _this._showEventHandler);
                            _this._targetEl.removeEventListener(ev, _this._showEventHandler);
                          });
                          triggerEventTypes.hideEvents.forEach(function(ev) {
                            _this._parentEl.removeEventListener(ev, _this._hideEventHandler);
                          });
                          this._initialized = false;
                        }
                      };
                      Dial2.prototype.removeInstance = function() {
                        instances_1.default.removeInstance("Dial", this._instanceId);
                      };
                      Dial2.prototype.destroyAndRemoveInstance = function() {
                        this.destroy();
                        this.removeInstance();
                      };
                      Dial2.prototype.hide = function() {
                        this._targetEl.classList.add("hidden");
                        if (this._triggerEl) {
                          this._triggerEl.setAttribute("aria-expanded", "false");
                        }
                        this._visible = false;
                        this._options.onHide(this);
                      };
                      Dial2.prototype.show = function() {
                        this._targetEl.classList.remove("hidden");
                        if (this._triggerEl) {
                          this._triggerEl.setAttribute("aria-expanded", "true");
                        }
                        this._visible = true;
                        this._options.onShow(this);
                      };
                      Dial2.prototype.toggle = function() {
                        if (this._visible) {
                          this.hide();
                        } else {
                          this.show();
                        }
                      };
                      Dial2.prototype.isHidden = function() {
                        return !this._visible;
                      };
                      Dial2.prototype.isVisible = function() {
                        return this._visible;
                      };
                      Dial2.prototype._getTriggerEventTypes = function(triggerType) {
                        switch (triggerType) {
                          case "hover":
                            return {
                              showEvents: ["mouseenter", "focus"],
                              hideEvents: ["mouseleave", "blur"]
                            };
                          case "click":
                            return {
                              showEvents: ["click", "focus"],
                              hideEvents: ["focusout", "blur"]
                            };
                          case "none":
                            return {
                              showEvents: [],
                              hideEvents: []
                            };
                          default:
                            return {
                              showEvents: ["mouseenter", "focus"],
                              hideEvents: ["mouseleave", "blur"]
                            };
                        }
                      };
                      Dial2.prototype.updateOnShow = function(callback) {
                        this._options.onShow = callback;
                      };
                      Dial2.prototype.updateOnHide = function(callback) {
                        this._options.onHide = callback;
                      };
                      Dial2.prototype.updateOnToggle = function(callback) {
                        this._options.onToggle = callback;
                      };
                      return Dial2;
                    }()
                  );
                  function initDials() {
                    document.querySelectorAll("[data-dial-init]").forEach(function($parentEl) {
                      var $triggerEl = $parentEl.querySelector("[data-dial-toggle]");
                      if ($triggerEl) {
                        var dialId = $triggerEl.getAttribute("data-dial-toggle");
                        var $dialEl = document.getElementById(dialId);
                        if ($dialEl) {
                          var triggerType = $triggerEl.getAttribute("data-dial-trigger");
                          new Dial($parentEl, $triggerEl, $dialEl, {
                            triggerType: triggerType ? triggerType : Default.triggerType
                          });
                        } else {
                          console.error("Dial with id ".concat(dialId, " does not exist. Are you sure that the data-dial-toggle attribute points to the correct modal id?"));
                        }
                      } else {
                        console.error("Dial with id ".concat($parentEl.id, " does not have a trigger element. Are you sure that the data-dial-toggle attribute exists?"));
                      }
                    });
                  }
                  exports2.initDials = initDials;
                  if (typeof window !== "undefined") {
                    window.Dial = Dial;
                    window.initDials = initDials;
                  }
                  exports2["default"] = Dial;
                }
              ),
              /***/
              791: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __assign = this && this.__assign || function() {
                    __assign = Object.assign || function(t) {
                      for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p2 in s)
                          if (Object.prototype.hasOwnProperty.call(s, p2))
                            t[p2] = s[p2];
                      }
                      return t;
                    };
                    return __assign.apply(this, arguments);
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.initDismisses = void 0;
                  var instances_1 = __webpack_require__2(423);
                  var Default = {
                    transition: "transition-opacity",
                    duration: 300,
                    timing: "ease-out",
                    onHide: function() {
                    }
                  };
                  var DefaultInstanceOptions = {
                    id: null,
                    override: true
                  };
                  var Dismiss = (
                    /** @class */
                    function() {
                      function Dismiss2(targetEl, triggerEl, options, instanceOptions) {
                        if (targetEl === void 0) {
                          targetEl = null;
                        }
                        if (triggerEl === void 0) {
                          triggerEl = null;
                        }
                        if (options === void 0) {
                          options = Default;
                        }
                        if (instanceOptions === void 0) {
                          instanceOptions = DefaultInstanceOptions;
                        }
                        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                        this._targetEl = targetEl;
                        this._triggerEl = triggerEl;
                        this._options = __assign(__assign({}, Default), options);
                        this._initialized = false;
                        this.init();
                        instances_1.default.addInstance("Dismiss", this, this._instanceId, instanceOptions.override);
                      }
                      Dismiss2.prototype.init = function() {
                        var _this = this;
                        if (this._triggerEl && this._targetEl && !this._initialized) {
                          this._clickHandler = function() {
                            _this.hide();
                          };
                          this._triggerEl.addEventListener("click", this._clickHandler);
                          this._initialized = true;
                        }
                      };
                      Dismiss2.prototype.destroy = function() {
                        if (this._triggerEl && this._initialized) {
                          this._triggerEl.removeEventListener("click", this._clickHandler);
                          this._initialized = false;
                        }
                      };
                      Dismiss2.prototype.removeInstance = function() {
                        instances_1.default.removeInstance("Dismiss", this._instanceId);
                      };
                      Dismiss2.prototype.destroyAndRemoveInstance = function() {
                        this.destroy();
                        this.removeInstance();
                      };
                      Dismiss2.prototype.hide = function() {
                        var _this = this;
                        this._targetEl.classList.add(this._options.transition, "duration-".concat(this._options.duration), this._options.timing, "opacity-0");
                        setTimeout(function() {
                          _this._targetEl.classList.add("hidden");
                        }, this._options.duration);
                        this._options.onHide(this, this._targetEl);
                      };
                      Dismiss2.prototype.updateOnHide = function(callback) {
                        this._options.onHide = callback;
                      };
                      return Dismiss2;
                    }()
                  );
                  function initDismisses() {
                    document.querySelectorAll("[data-dismiss-target]").forEach(function($triggerEl) {
                      var targetId = $triggerEl.getAttribute("data-dismiss-target");
                      var $dismissEl = document.querySelector(targetId);
                      if ($dismissEl) {
                        new Dismiss($dismissEl, $triggerEl);
                      } else {
                        console.error('The dismiss element with id "'.concat(targetId, '" does not exist. Please check the data-dismiss-target attribute.'));
                      }
                    });
                  }
                  exports2.initDismisses = initDismisses;
                  if (typeof window !== "undefined") {
                    window.Dismiss = Dismiss;
                    window.initDismisses = initDismisses;
                  }
                  exports2["default"] = Dismiss;
                }
              ),
              /***/
              340: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __assign = this && this.__assign || function() {
                    __assign = Object.assign || function(t) {
                      for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p2 in s)
                          if (Object.prototype.hasOwnProperty.call(s, p2))
                            t[p2] = s[p2];
                      }
                      return t;
                    };
                    return __assign.apply(this, arguments);
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.initDrawers = void 0;
                  var instances_1 = __webpack_require__2(423);
                  var Default = {
                    placement: "left",
                    bodyScrolling: false,
                    backdrop: true,
                    edge: false,
                    edgeOffset: "bottom-[60px]",
                    backdropClasses: "bg-gray-900/50 dark:bg-gray-900/80 fixed inset-0 z-30",
                    onShow: function() {
                    },
                    onHide: function() {
                    },
                    onToggle: function() {
                    }
                  };
                  var DefaultInstanceOptions = {
                    id: null,
                    override: true
                  };
                  var Drawer = (
                    /** @class */
                    function() {
                      function Drawer2(targetEl, options, instanceOptions) {
                        if (targetEl === void 0) {
                          targetEl = null;
                        }
                        if (options === void 0) {
                          options = Default;
                        }
                        if (instanceOptions === void 0) {
                          instanceOptions = DefaultInstanceOptions;
                        }
                        this._eventListenerInstances = [];
                        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                        this._targetEl = targetEl;
                        this._options = __assign(__assign({}, Default), options);
                        this._visible = false;
                        this._initialized = false;
                        this.init();
                        instances_1.default.addInstance("Drawer", this, this._instanceId, instanceOptions.override);
                      }
                      Drawer2.prototype.init = function() {
                        var _this = this;
                        if (this._targetEl && !this._initialized) {
                          this._targetEl.setAttribute("aria-hidden", "true");
                          this._targetEl.classList.add("transition-transform");
                          this._getPlacementClasses(this._options.placement).base.map(function(c) {
                            _this._targetEl.classList.add(c);
                          });
                          this._handleEscapeKey = function(event) {
                            if (event.key === "Escape") {
                              if (_this.isVisible()) {
                                _this.hide();
                              }
                            }
                          };
                          document.addEventListener("keydown", this._handleEscapeKey);
                          this._initialized = true;
                        }
                      };
                      Drawer2.prototype.destroy = function() {
                        if (this._initialized) {
                          this.removeAllEventListenerInstances();
                          this._destroyBackdropEl();
                          document.removeEventListener("keydown", this._handleEscapeKey);
                          this._initialized = false;
                        }
                      };
                      Drawer2.prototype.removeInstance = function() {
                        instances_1.default.removeInstance("Drawer", this._instanceId);
                      };
                      Drawer2.prototype.destroyAndRemoveInstance = function() {
                        this.destroy();
                        this.removeInstance();
                      };
                      Drawer2.prototype.hide = function() {
                        var _this = this;
                        if (this._options.edge) {
                          this._getPlacementClasses(this._options.placement + "-edge").active.map(function(c) {
                            _this._targetEl.classList.remove(c);
                          });
                          this._getPlacementClasses(this._options.placement + "-edge").inactive.map(function(c) {
                            _this._targetEl.classList.add(c);
                          });
                        } else {
                          this._getPlacementClasses(this._options.placement).active.map(function(c) {
                            _this._targetEl.classList.remove(c);
                          });
                          this._getPlacementClasses(this._options.placement).inactive.map(function(c) {
                            _this._targetEl.classList.add(c);
                          });
                        }
                        this._targetEl.setAttribute("aria-hidden", "true");
                        this._targetEl.removeAttribute("aria-modal");
                        this._targetEl.removeAttribute("role");
                        if (!this._options.bodyScrolling) {
                          document.body.classList.remove("overflow-hidden");
                        }
                        if (this._options.backdrop) {
                          this._destroyBackdropEl();
                        }
                        this._visible = false;
                        this._options.onHide(this);
                      };
                      Drawer2.prototype.show = function() {
                        var _this = this;
                        if (this._options.edge) {
                          this._getPlacementClasses(this._options.placement + "-edge").active.map(function(c) {
                            _this._targetEl.classList.add(c);
                          });
                          this._getPlacementClasses(this._options.placement + "-edge").inactive.map(function(c) {
                            _this._targetEl.classList.remove(c);
                          });
                        } else {
                          this._getPlacementClasses(this._options.placement).active.map(function(c) {
                            _this._targetEl.classList.add(c);
                          });
                          this._getPlacementClasses(this._options.placement).inactive.map(function(c) {
                            _this._targetEl.classList.remove(c);
                          });
                        }
                        this._targetEl.setAttribute("aria-modal", "true");
                        this._targetEl.setAttribute("role", "dialog");
                        this._targetEl.removeAttribute("aria-hidden");
                        if (!this._options.bodyScrolling) {
                          document.body.classList.add("overflow-hidden");
                        }
                        if (this._options.backdrop) {
                          this._createBackdrop();
                        }
                        this._visible = true;
                        this._options.onShow(this);
                      };
                      Drawer2.prototype.toggle = function() {
                        if (this.isVisible()) {
                          this.hide();
                        } else {
                          this.show();
                        }
                      };
                      Drawer2.prototype._createBackdrop = function() {
                        var _a;
                        var _this = this;
                        if (!this._visible) {
                          var backdropEl = document.createElement("div");
                          backdropEl.setAttribute("drawer-backdrop", "");
                          (_a = backdropEl.classList).add.apply(_a, this._options.backdropClasses.split(" "));
                          document.querySelector("body").append(backdropEl);
                          backdropEl.addEventListener("click", function() {
                            _this.hide();
                          });
                        }
                      };
                      Drawer2.prototype._destroyBackdropEl = function() {
                        if (this._visible && document.querySelector("[drawer-backdrop]") !== null) {
                          document.querySelector("[drawer-backdrop]").remove();
                        }
                      };
                      Drawer2.prototype._getPlacementClasses = function(placement) {
                        switch (placement) {
                          case "top":
                            return {
                              base: ["top-0", "left-0", "right-0"],
                              active: ["transform-none"],
                              inactive: ["-translate-y-full"]
                            };
                          case "right":
                            return {
                              base: ["right-0", "top-0"],
                              active: ["transform-none"],
                              inactive: ["translate-x-full"]
                            };
                          case "bottom":
                            return {
                              base: ["bottom-0", "left-0", "right-0"],
                              active: ["transform-none"],
                              inactive: ["translate-y-full"]
                            };
                          case "left":
                            return {
                              base: ["left-0", "top-0"],
                              active: ["transform-none"],
                              inactive: ["-translate-x-full"]
                            };
                          case "bottom-edge":
                            return {
                              base: ["left-0", "top-0"],
                              active: ["transform-none"],
                              inactive: ["translate-y-full", this._options.edgeOffset]
                            };
                          default:
                            return {
                              base: ["left-0", "top-0"],
                              active: ["transform-none"],
                              inactive: ["-translate-x-full"]
                            };
                        }
                      };
                      Drawer2.prototype.isHidden = function() {
                        return !this._visible;
                      };
                      Drawer2.prototype.isVisible = function() {
                        return this._visible;
                      };
                      Drawer2.prototype.addEventListenerInstance = function(element, type, handler) {
                        this._eventListenerInstances.push({
                          element,
                          type,
                          handler
                        });
                      };
                      Drawer2.prototype.removeAllEventListenerInstances = function() {
                        this._eventListenerInstances.map(function(eventListenerInstance) {
                          eventListenerInstance.element.removeEventListener(eventListenerInstance.type, eventListenerInstance.handler);
                        });
                        this._eventListenerInstances = [];
                      };
                      Drawer2.prototype.getAllEventListenerInstances = function() {
                        return this._eventListenerInstances;
                      };
                      Drawer2.prototype.updateOnShow = function(callback) {
                        this._options.onShow = callback;
                      };
                      Drawer2.prototype.updateOnHide = function(callback) {
                        this._options.onHide = callback;
                      };
                      Drawer2.prototype.updateOnToggle = function(callback) {
                        this._options.onToggle = callback;
                      };
                      return Drawer2;
                    }()
                  );
                  function initDrawers() {
                    document.querySelectorAll("[data-drawer-target]").forEach(function($triggerEl) {
                      var drawerId = $triggerEl.getAttribute("data-drawer-target");
                      var $drawerEl = document.getElementById(drawerId);
                      if ($drawerEl) {
                        var placement = $triggerEl.getAttribute("data-drawer-placement");
                        var bodyScrolling = $triggerEl.getAttribute("data-drawer-body-scrolling");
                        var backdrop = $triggerEl.getAttribute("data-drawer-backdrop");
                        var edge = $triggerEl.getAttribute("data-drawer-edge");
                        var edgeOffset = $triggerEl.getAttribute("data-drawer-edge-offset");
                        new Drawer($drawerEl, {
                          placement: placement ? placement : Default.placement,
                          bodyScrolling: bodyScrolling ? bodyScrolling === "true" ? true : false : Default.bodyScrolling,
                          backdrop: backdrop ? backdrop === "true" ? true : false : Default.backdrop,
                          edge: edge ? edge === "true" ? true : false : Default.edge,
                          edgeOffset: edgeOffset ? edgeOffset : Default.edgeOffset
                        });
                      } else {
                        console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
                      }
                    });
                    document.querySelectorAll("[data-drawer-toggle]").forEach(function($triggerEl) {
                      var drawerId = $triggerEl.getAttribute("data-drawer-toggle");
                      var $drawerEl = document.getElementById(drawerId);
                      if ($drawerEl) {
                        var drawer_1 = instances_1.default.getInstance("Drawer", drawerId);
                        if (drawer_1) {
                          var toggleDrawer = function() {
                            drawer_1.toggle();
                          };
                          $triggerEl.addEventListener("click", toggleDrawer);
                          drawer_1.addEventListenerInstance($triggerEl, "click", toggleDrawer);
                        } else {
                          console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
                        }
                      } else {
                        console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
                      }
                    });
                    document.querySelectorAll("[data-drawer-dismiss], [data-drawer-hide]").forEach(function($triggerEl) {
                      var drawerId = $triggerEl.getAttribute("data-drawer-dismiss") ? $triggerEl.getAttribute("data-drawer-dismiss") : $triggerEl.getAttribute("data-drawer-hide");
                      var $drawerEl = document.getElementById(drawerId);
                      if ($drawerEl) {
                        var drawer_2 = instances_1.default.getInstance("Drawer", drawerId);
                        if (drawer_2) {
                          var hideDrawer = function() {
                            drawer_2.hide();
                          };
                          $triggerEl.addEventListener("click", hideDrawer);
                          drawer_2.addEventListenerInstance($triggerEl, "click", hideDrawer);
                        } else {
                          console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
                        }
                      } else {
                        console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id"));
                      }
                    });
                    document.querySelectorAll("[data-drawer-show]").forEach(function($triggerEl) {
                      var drawerId = $triggerEl.getAttribute("data-drawer-show");
                      var $drawerEl = document.getElementById(drawerId);
                      if ($drawerEl) {
                        var drawer_3 = instances_1.default.getInstance("Drawer", drawerId);
                        if (drawer_3) {
                          var showDrawer = function() {
                            drawer_3.show();
                          };
                          $triggerEl.addEventListener("click", showDrawer);
                          drawer_3.addEventListenerInstance($triggerEl, "click", showDrawer);
                        } else {
                          console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
                        }
                      } else {
                        console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
                      }
                    });
                  }
                  exports2.initDrawers = initDrawers;
                  if (typeof window !== "undefined") {
                    window.Drawer = Drawer;
                    window.initDrawers = initDrawers;
                  }
                  exports2["default"] = Drawer;
                }
              ),
              /***/
              316: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __assign = this && this.__assign || function() {
                    __assign = Object.assign || function(t) {
                      for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p2 in s)
                          if (Object.prototype.hasOwnProperty.call(s, p2))
                            t[p2] = s[p2];
                      }
                      return t;
                    };
                    return __assign.apply(this, arguments);
                  };
                  var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
                    if (pack || arguments.length === 2)
                      for (var i = 0, l = from.length, ar; i < l; i++) {
                        if (ar || !(i in from)) {
                          if (!ar)
                            ar = Array.prototype.slice.call(from, 0, i);
                          ar[i] = from[i];
                        }
                      }
                    return to.concat(ar || Array.prototype.slice.call(from));
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.initDropdowns = void 0;
                  var core_1 = __webpack_require__2(853);
                  var instances_1 = __webpack_require__2(423);
                  var Default = {
                    placement: "bottom",
                    triggerType: "click",
                    offsetSkidding: 0,
                    offsetDistance: 10,
                    delay: 300,
                    ignoreClickOutsideClass: false,
                    onShow: function() {
                    },
                    onHide: function() {
                    },
                    onToggle: function() {
                    }
                  };
                  var DefaultInstanceOptions = {
                    id: null,
                    override: true
                  };
                  var Dropdown = (
                    /** @class */
                    function() {
                      function Dropdown2(targetElement, triggerElement, options, instanceOptions) {
                        if (targetElement === void 0) {
                          targetElement = null;
                        }
                        if (triggerElement === void 0) {
                          triggerElement = null;
                        }
                        if (options === void 0) {
                          options = Default;
                        }
                        if (instanceOptions === void 0) {
                          instanceOptions = DefaultInstanceOptions;
                        }
                        this._instanceId = instanceOptions.id ? instanceOptions.id : targetElement.id;
                        this._targetEl = targetElement;
                        this._triggerEl = triggerElement;
                        this._options = __assign(__assign({}, Default), options);
                        this._popperInstance = null;
                        this._visible = false;
                        this._initialized = false;
                        this.init();
                        instances_1.default.addInstance("Dropdown", this, this._instanceId, instanceOptions.override);
                      }
                      Dropdown2.prototype.init = function() {
                        if (this._triggerEl && this._targetEl && !this._initialized) {
                          this._popperInstance = this._createPopperInstance();
                          this._setupEventListeners();
                          this._initialized = true;
                        }
                      };
                      Dropdown2.prototype.destroy = function() {
                        var _this = this;
                        var triggerEvents = this._getTriggerEvents();
                        if (this._options.triggerType === "click") {
                          triggerEvents.showEvents.forEach(function(ev) {
                            _this._triggerEl.removeEventListener(ev, _this._clickHandler);
                          });
                        }
                        if (this._options.triggerType === "hover") {
                          triggerEvents.showEvents.forEach(function(ev) {
                            _this._triggerEl.removeEventListener(ev, _this._hoverShowTriggerElHandler);
                            _this._targetEl.removeEventListener(ev, _this._hoverShowTargetElHandler);
                          });
                          triggerEvents.hideEvents.forEach(function(ev) {
                            _this._triggerEl.removeEventListener(ev, _this._hoverHideHandler);
                            _this._targetEl.removeEventListener(ev, _this._hoverHideHandler);
                          });
                        }
                        this._popperInstance.destroy();
                        this._initialized = false;
                      };
                      Dropdown2.prototype.removeInstance = function() {
                        instances_1.default.removeInstance("Dropdown", this._instanceId);
                      };
                      Dropdown2.prototype.destroyAndRemoveInstance = function() {
                        this.destroy();
                        this.removeInstance();
                      };
                      Dropdown2.prototype._setupEventListeners = function() {
                        var _this = this;
                        var triggerEvents = this._getTriggerEvents();
                        this._clickHandler = function() {
                          _this.toggle();
                        };
                        if (this._options.triggerType === "click") {
                          triggerEvents.showEvents.forEach(function(ev) {
                            _this._triggerEl.addEventListener(ev, _this._clickHandler);
                          });
                        }
                        this._hoverShowTriggerElHandler = function(ev) {
                          if (ev.type === "click") {
                            _this.toggle();
                          } else {
                            setTimeout(function() {
                              _this.show();
                            }, _this._options.delay);
                          }
                        };
                        this._hoverShowTargetElHandler = function() {
                          _this.show();
                        };
                        this._hoverHideHandler = function() {
                          setTimeout(function() {
                            if (!_this._targetEl.matches(":hover")) {
                              _this.hide();
                            }
                          }, _this._options.delay);
                        };
                        if (this._options.triggerType === "hover") {
                          triggerEvents.showEvents.forEach(function(ev) {
                            _this._triggerEl.addEventListener(ev, _this._hoverShowTriggerElHandler);
                            _this._targetEl.addEventListener(ev, _this._hoverShowTargetElHandler);
                          });
                          triggerEvents.hideEvents.forEach(function(ev) {
                            _this._triggerEl.addEventListener(ev, _this._hoverHideHandler);
                            _this._targetEl.addEventListener(ev, _this._hoverHideHandler);
                          });
                        }
                      };
                      Dropdown2.prototype._createPopperInstance = function() {
                        return (0, core_1.createPopper)(this._triggerEl, this._targetEl, {
                          placement: this._options.placement,
                          modifiers: [
                            {
                              name: "offset",
                              options: {
                                offset: [
                                  this._options.offsetSkidding,
                                  this._options.offsetDistance
                                ]
                              }
                            }
                          ]
                        });
                      };
                      Dropdown2.prototype._setupClickOutsideListener = function() {
                        var _this = this;
                        this._clickOutsideEventListener = function(ev) {
                          _this._handleClickOutside(ev, _this._targetEl);
                        };
                        document.body.addEventListener("click", this._clickOutsideEventListener, true);
                      };
                      Dropdown2.prototype._removeClickOutsideListener = function() {
                        document.body.removeEventListener("click", this._clickOutsideEventListener, true);
                      };
                      Dropdown2.prototype._handleClickOutside = function(ev, targetEl) {
                        var clickedEl = ev.target;
                        var ignoreClickOutsideClass = this._options.ignoreClickOutsideClass;
                        var isIgnored = false;
                        if (ignoreClickOutsideClass) {
                          var ignoredClickOutsideEls = document.querySelectorAll(".".concat(ignoreClickOutsideClass));
                          ignoredClickOutsideEls.forEach(function(el) {
                            if (el.contains(clickedEl)) {
                              isIgnored = true;
                              return;
                            }
                          });
                        }
                        if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && !isIgnored && this.isVisible()) {
                          this.hide();
                        }
                      };
                      Dropdown2.prototype._getTriggerEvents = function() {
                        switch (this._options.triggerType) {
                          case "hover":
                            return {
                              showEvents: ["mouseenter", "click"],
                              hideEvents: ["mouseleave"]
                            };
                          case "click":
                            return {
                              showEvents: ["click"],
                              hideEvents: []
                            };
                          case "none":
                            return {
                              showEvents: [],
                              hideEvents: []
                            };
                          default:
                            return {
                              showEvents: ["click"],
                              hideEvents: []
                            };
                        }
                      };
                      Dropdown2.prototype.toggle = function() {
                        if (this.isVisible()) {
                          this.hide();
                        } else {
                          this.show();
                        }
                        this._options.onToggle(this);
                      };
                      Dropdown2.prototype.isVisible = function() {
                        return this._visible;
                      };
                      Dropdown2.prototype.show = function() {
                        this._targetEl.classList.remove("hidden");
                        this._targetEl.classList.add("block");
                        this._popperInstance.setOptions(function(options) {
                          return __assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                            { name: "eventListeners", enabled: true }
                          ], false) });
                        });
                        this._setupClickOutsideListener();
                        this._popperInstance.update();
                        this._visible = true;
                        this._options.onShow(this);
                      };
                      Dropdown2.prototype.hide = function() {
                        this._targetEl.classList.remove("block");
                        this._targetEl.classList.add("hidden");
                        this._popperInstance.setOptions(function(options) {
                          return __assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                            { name: "eventListeners", enabled: false }
                          ], false) });
                        });
                        this._visible = false;
                        this._removeClickOutsideListener();
                        this._options.onHide(this);
                      };
                      Dropdown2.prototype.updateOnShow = function(callback) {
                        this._options.onShow = callback;
                      };
                      Dropdown2.prototype.updateOnHide = function(callback) {
                        this._options.onHide = callback;
                      };
                      Dropdown2.prototype.updateOnToggle = function(callback) {
                        this._options.onToggle = callback;
                      };
                      return Dropdown2;
                    }()
                  );
                  function initDropdowns() {
                    document.querySelectorAll("[data-dropdown-toggle]").forEach(function($triggerEl) {
                      var dropdownId = $triggerEl.getAttribute("data-dropdown-toggle");
                      var $dropdownEl = document.getElementById(dropdownId);
                      if ($dropdownEl) {
                        var placement = $triggerEl.getAttribute("data-dropdown-placement");
                        var offsetSkidding = $triggerEl.getAttribute("data-dropdown-offset-skidding");
                        var offsetDistance = $triggerEl.getAttribute("data-dropdown-offset-distance");
                        var triggerType = $triggerEl.getAttribute("data-dropdown-trigger");
                        var delay = $triggerEl.getAttribute("data-dropdown-delay");
                        var ignoreClickOutsideClass = $triggerEl.getAttribute("data-dropdown-ignore-click-outside-class");
                        new Dropdown($dropdownEl, $triggerEl, {
                          placement: placement ? placement : Default.placement,
                          triggerType: triggerType ? triggerType : Default.triggerType,
                          offsetSkidding: offsetSkidding ? parseInt(offsetSkidding) : Default.offsetSkidding,
                          offsetDistance: offsetDistance ? parseInt(offsetDistance) : Default.offsetDistance,
                          delay: delay ? parseInt(delay) : Default.delay,
                          ignoreClickOutsideClass: ignoreClickOutsideClass ? ignoreClickOutsideClass : Default.ignoreClickOutsideClass
                        });
                      } else {
                        console.error('The dropdown element with id "'.concat(dropdownId, '" does not exist. Please check the data-dropdown-toggle attribute.'));
                      }
                    });
                  }
                  exports2.initDropdowns = initDropdowns;
                  if (typeof window !== "undefined") {
                    window.Dropdown = Dropdown;
                    window.initDropdowns = initDropdowns;
                  }
                  exports2["default"] = Dropdown;
                }
              ),
              /***/
              311: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.initFlowbite = void 0;
                  var accordion_1 = __webpack_require__2(902);
                  var carousel_1 = __webpack_require__2(33);
                  var clipboard_1 = __webpack_require__2(673);
                  var collapse_1 = __webpack_require__2(922);
                  var dial_1 = __webpack_require__2(556);
                  var dismiss_1 = __webpack_require__2(791);
                  var drawer_1 = __webpack_require__2(340);
                  var dropdown_1 = __webpack_require__2(316);
                  var input_counter_1 = __webpack_require__2(656);
                  var modal_1 = __webpack_require__2(16);
                  var popover_1 = __webpack_require__2(903);
                  var tabs_1 = __webpack_require__2(247);
                  var tooltip_1 = __webpack_require__2(671);
                  var datepicker_1 = __webpack_require__2(132);
                  function initFlowbite() {
                    (0, accordion_1.initAccordions)();
                    (0, collapse_1.initCollapses)();
                    (0, carousel_1.initCarousels)();
                    (0, dismiss_1.initDismisses)();
                    (0, dropdown_1.initDropdowns)();
                    (0, modal_1.initModals)();
                    (0, drawer_1.initDrawers)();
                    (0, tabs_1.initTabs)();
                    (0, tooltip_1.initTooltips)();
                    (0, popover_1.initPopovers)();
                    (0, dial_1.initDials)();
                    (0, input_counter_1.initInputCounters)();
                    (0, clipboard_1.initCopyClipboards)();
                    (0, datepicker_1.initDatepickers)();
                  }
                  exports2.initFlowbite = initFlowbite;
                  if (typeof window !== "undefined") {
                    window.initFlowbite = initFlowbite;
                  }
                }
              ),
              /***/
              656: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __assign = this && this.__assign || function() {
                    __assign = Object.assign || function(t) {
                      for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p2 in s)
                          if (Object.prototype.hasOwnProperty.call(s, p2))
                            t[p2] = s[p2];
                      }
                      return t;
                    };
                    return __assign.apply(this, arguments);
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.initInputCounters = void 0;
                  var instances_1 = __webpack_require__2(423);
                  var Default = {
                    minValue: null,
                    maxValue: null,
                    onIncrement: function() {
                    },
                    onDecrement: function() {
                    }
                  };
                  var DefaultInstanceOptions = {
                    id: null,
                    override: true
                  };
                  var InputCounter = (
                    /** @class */
                    function() {
                      function InputCounter2(targetEl, incrementEl, decrementEl, options, instanceOptions) {
                        if (targetEl === void 0) {
                          targetEl = null;
                        }
                        if (incrementEl === void 0) {
                          incrementEl = null;
                        }
                        if (decrementEl === void 0) {
                          decrementEl = null;
                        }
                        if (options === void 0) {
                          options = Default;
                        }
                        if (instanceOptions === void 0) {
                          instanceOptions = DefaultInstanceOptions;
                        }
                        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                        this._targetEl = targetEl;
                        this._incrementEl = incrementEl;
                        this._decrementEl = decrementEl;
                        this._options = __assign(__assign({}, Default), options);
                        this._initialized = false;
                        this.init();
                        instances_1.default.addInstance("InputCounter", this, this._instanceId, instanceOptions.override);
                      }
                      InputCounter2.prototype.init = function() {
                        var _this = this;
                        if (this._targetEl && !this._initialized) {
                          this._inputHandler = function(event) {
                            {
                              var target = event.target;
                              if (!/^\d*$/.test(target.value)) {
                                target.value = target.value.replace(/[^\d]/g, "");
                              }
                              if (_this._options.maxValue !== null && parseInt(target.value) > _this._options.maxValue) {
                                target.value = _this._options.maxValue.toString();
                              }
                              if (_this._options.minValue !== null && parseInt(target.value) < _this._options.minValue) {
                                target.value = _this._options.minValue.toString();
                              }
                            }
                          };
                          this._incrementClickHandler = function() {
                            _this.increment();
                          };
                          this._decrementClickHandler = function() {
                            _this.decrement();
                          };
                          this._targetEl.addEventListener("input", this._inputHandler);
                          if (this._incrementEl) {
                            this._incrementEl.addEventListener("click", this._incrementClickHandler);
                          }
                          if (this._decrementEl) {
                            this._decrementEl.addEventListener("click", this._decrementClickHandler);
                          }
                          this._initialized = true;
                        }
                      };
                      InputCounter2.prototype.destroy = function() {
                        if (this._targetEl && this._initialized) {
                          this._targetEl.removeEventListener("input", this._inputHandler);
                          if (this._incrementEl) {
                            this._incrementEl.removeEventListener("click", this._incrementClickHandler);
                          }
                          if (this._decrementEl) {
                            this._decrementEl.removeEventListener("click", this._decrementClickHandler);
                          }
                          this._initialized = false;
                        }
                      };
                      InputCounter2.prototype.removeInstance = function() {
                        instances_1.default.removeInstance("InputCounter", this._instanceId);
                      };
                      InputCounter2.prototype.destroyAndRemoveInstance = function() {
                        this.destroy();
                        this.removeInstance();
                      };
                      InputCounter2.prototype.getCurrentValue = function() {
                        return parseInt(this._targetEl.value) || 0;
                      };
                      InputCounter2.prototype.increment = function() {
                        if (this._options.maxValue !== null && this.getCurrentValue() >= this._options.maxValue) {
                          return;
                        }
                        this._targetEl.value = (this.getCurrentValue() + 1).toString();
                        this._options.onIncrement(this);
                      };
                      InputCounter2.prototype.decrement = function() {
                        if (this._options.minValue !== null && this.getCurrentValue() <= this._options.minValue) {
                          return;
                        }
                        this._targetEl.value = (this.getCurrentValue() - 1).toString();
                        this._options.onDecrement(this);
                      };
                      InputCounter2.prototype.updateOnIncrement = function(callback) {
                        this._options.onIncrement = callback;
                      };
                      InputCounter2.prototype.updateOnDecrement = function(callback) {
                        this._options.onDecrement = callback;
                      };
                      return InputCounter2;
                    }()
                  );
                  function initInputCounters() {
                    document.querySelectorAll("[data-input-counter]").forEach(function($targetEl) {
                      var targetId = $targetEl.id;
                      var $incrementEl = document.querySelector('[data-input-counter-increment="' + targetId + '"]');
                      var $decrementEl = document.querySelector('[data-input-counter-decrement="' + targetId + '"]');
                      var minValue = $targetEl.getAttribute("data-input-counter-min");
                      var maxValue = $targetEl.getAttribute("data-input-counter-max");
                      if ($targetEl) {
                        if (!instances_1.default.instanceExists("InputCounter", $targetEl.getAttribute("id"))) {
                          new InputCounter($targetEl, $incrementEl ? $incrementEl : null, $decrementEl ? $decrementEl : null, {
                            minValue: minValue ? parseInt(minValue) : null,
                            maxValue: maxValue ? parseInt(maxValue) : null
                          });
                        }
                      } else {
                        console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-input-counter attribute.'));
                      }
                    });
                  }
                  exports2.initInputCounters = initInputCounters;
                  if (typeof window !== "undefined") {
                    window.InputCounter = InputCounter;
                    window.initInputCounters = initInputCounters;
                  }
                  exports2["default"] = InputCounter;
                }
              ),
              /***/
              16: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __assign = this && this.__assign || function() {
                    __assign = Object.assign || function(t) {
                      for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p2 in s)
                          if (Object.prototype.hasOwnProperty.call(s, p2))
                            t[p2] = s[p2];
                      }
                      return t;
                    };
                    return __assign.apply(this, arguments);
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.initModals = void 0;
                  var instances_1 = __webpack_require__2(423);
                  var Default = {
                    placement: "center",
                    backdropClasses: "bg-gray-900/50 dark:bg-gray-900/80 fixed inset-0 z-40",
                    backdrop: "dynamic",
                    closable: true,
                    onHide: function() {
                    },
                    onShow: function() {
                    },
                    onToggle: function() {
                    }
                  };
                  var DefaultInstanceOptions = {
                    id: null,
                    override: true
                  };
                  var Modal = (
                    /** @class */
                    function() {
                      function Modal2(targetEl, options, instanceOptions) {
                        if (targetEl === void 0) {
                          targetEl = null;
                        }
                        if (options === void 0) {
                          options = Default;
                        }
                        if (instanceOptions === void 0) {
                          instanceOptions = DefaultInstanceOptions;
                        }
                        this._eventListenerInstances = [];
                        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                        this._targetEl = targetEl;
                        this._options = __assign(__assign({}, Default), options);
                        this._isHidden = true;
                        this._backdropEl = null;
                        this._initialized = false;
                        this.init();
                        instances_1.default.addInstance("Modal", this, this._instanceId, instanceOptions.override);
                      }
                      Modal2.prototype.init = function() {
                        var _this = this;
                        if (this._targetEl && !this._initialized) {
                          this._getPlacementClasses().map(function(c) {
                            _this._targetEl.classList.add(c);
                          });
                          this._initialized = true;
                        }
                      };
                      Modal2.prototype.destroy = function() {
                        if (this._initialized) {
                          this.removeAllEventListenerInstances();
                          this._destroyBackdropEl();
                          this._initialized = false;
                        }
                      };
                      Modal2.prototype.removeInstance = function() {
                        instances_1.default.removeInstance("Modal", this._instanceId);
                      };
                      Modal2.prototype.destroyAndRemoveInstance = function() {
                        this.destroy();
                        this.removeInstance();
                      };
                      Modal2.prototype._createBackdrop = function() {
                        var _a;
                        if (this._isHidden) {
                          var backdropEl = document.createElement("div");
                          (_a = backdropEl.classList).add.apply(_a, this._options.backdropClasses.split(" "));
                          document.querySelector("body").append(backdropEl);
                          this._backdropEl = backdropEl;
                        }
                      };
                      Modal2.prototype._destroyBackdropEl = function() {
                        if (!this._isHidden && this._backdropEl) {
                          this._backdropEl.remove();
                          this._backdropEl = null;
                        }
                      };
                      Modal2.prototype._setupModalCloseEventListeners = function() {
                        var _this = this;
                        if (this._options.backdrop === "dynamic") {
                          this._clickOutsideEventListener = function(ev) {
                            _this._handleOutsideClick(ev.target);
                          };
                          this._targetEl.addEventListener("click", this._clickOutsideEventListener, true);
                        }
                        this._keydownEventListener = function(ev) {
                          if (ev.key === "Escape") {
                            _this.hide();
                          }
                        };
                        document.body.addEventListener("keydown", this._keydownEventListener, true);
                      };
                      Modal2.prototype._removeModalCloseEventListeners = function() {
                        if (this._options.backdrop === "dynamic") {
                          this._targetEl.removeEventListener("click", this._clickOutsideEventListener, true);
                        }
                        document.body.removeEventListener("keydown", this._keydownEventListener, true);
                      };
                      Modal2.prototype._handleOutsideClick = function(target) {
                        if (target === this._targetEl || target === this._backdropEl && this.isVisible()) {
                          this.hide();
                        }
                      };
                      Modal2.prototype._getPlacementClasses = function() {
                        switch (this._options.placement) {
                          case "top-left":
                            return ["justify-start", "items-start"];
                          case "top-center":
                            return ["justify-center", "items-start"];
                          case "top-right":
                            return ["justify-end", "items-start"];
                          case "center-left":
                            return ["justify-start", "items-center"];
                          case "center":
                            return ["justify-center", "items-center"];
                          case "center-right":
                            return ["justify-end", "items-center"];
                          case "bottom-left":
                            return ["justify-start", "items-end"];
                          case "bottom-center":
                            return ["justify-center", "items-end"];
                          case "bottom-right":
                            return ["justify-end", "items-end"];
                          default:
                            return ["justify-center", "items-center"];
                        }
                      };
                      Modal2.prototype.toggle = function() {
                        if (this._isHidden) {
                          this.show();
                        } else {
                          this.hide();
                        }
                        this._options.onToggle(this);
                      };
                      Modal2.prototype.show = function() {
                        if (this.isHidden) {
                          this._targetEl.classList.add("flex");
                          this._targetEl.classList.remove("hidden");
                          this._targetEl.setAttribute("aria-modal", "true");
                          this._targetEl.setAttribute("role", "dialog");
                          this._targetEl.removeAttribute("aria-hidden");
                          this._createBackdrop();
                          this._isHidden = false;
                          if (this._options.closable) {
                            this._setupModalCloseEventListeners();
                          }
                          document.body.classList.add("overflow-hidden");
                          this._options.onShow(this);
                        }
                      };
                      Modal2.prototype.hide = function() {
                        if (this.isVisible) {
                          this._targetEl.classList.add("hidden");
                          this._targetEl.classList.remove("flex");
                          this._targetEl.setAttribute("aria-hidden", "true");
                          this._targetEl.removeAttribute("aria-modal");
                          this._targetEl.removeAttribute("role");
                          this._destroyBackdropEl();
                          this._isHidden = true;
                          document.body.classList.remove("overflow-hidden");
                          if (this._options.closable) {
                            this._removeModalCloseEventListeners();
                          }
                          this._options.onHide(this);
                        }
                      };
                      Modal2.prototype.isVisible = function() {
                        return !this._isHidden;
                      };
                      Modal2.prototype.isHidden = function() {
                        return this._isHidden;
                      };
                      Modal2.prototype.addEventListenerInstance = function(element, type, handler) {
                        this._eventListenerInstances.push({
                          element,
                          type,
                          handler
                        });
                      };
                      Modal2.prototype.removeAllEventListenerInstances = function() {
                        this._eventListenerInstances.map(function(eventListenerInstance) {
                          eventListenerInstance.element.removeEventListener(eventListenerInstance.type, eventListenerInstance.handler);
                        });
                        this._eventListenerInstances = [];
                      };
                      Modal2.prototype.getAllEventListenerInstances = function() {
                        return this._eventListenerInstances;
                      };
                      Modal2.prototype.updateOnShow = function(callback) {
                        this._options.onShow = callback;
                      };
                      Modal2.prototype.updateOnHide = function(callback) {
                        this._options.onHide = callback;
                      };
                      Modal2.prototype.updateOnToggle = function(callback) {
                        this._options.onToggle = callback;
                      };
                      return Modal2;
                    }()
                  );
                  function initModals() {
                    document.querySelectorAll("[data-modal-target]").forEach(function($triggerEl) {
                      var modalId = $triggerEl.getAttribute("data-modal-target");
                      var $modalEl = document.getElementById(modalId);
                      if ($modalEl) {
                        var placement = $modalEl.getAttribute("data-modal-placement");
                        var backdrop = $modalEl.getAttribute("data-modal-backdrop");
                        new Modal($modalEl, {
                          placement: placement ? placement : Default.placement,
                          backdrop: backdrop ? backdrop : Default.backdrop
                        });
                      } else {
                        console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-target attribute points to the correct modal id?."));
                      }
                    });
                    document.querySelectorAll("[data-modal-toggle]").forEach(function($triggerEl) {
                      var modalId = $triggerEl.getAttribute("data-modal-toggle");
                      var $modalEl = document.getElementById(modalId);
                      if ($modalEl) {
                        var modal_1 = instances_1.default.getInstance("Modal", modalId);
                        if (modal_1) {
                          var toggleModal = function() {
                            modal_1.toggle();
                          };
                          $triggerEl.addEventListener("click", toggleModal);
                          modal_1.addEventListenerInstance($triggerEl, "click", toggleModal);
                        } else {
                          console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
                        }
                      } else {
                        console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-toggle attribute points to the correct modal id?"));
                      }
                    });
                    document.querySelectorAll("[data-modal-show]").forEach(function($triggerEl) {
                      var modalId = $triggerEl.getAttribute("data-modal-show");
                      var $modalEl = document.getElementById(modalId);
                      if ($modalEl) {
                        var modal_2 = instances_1.default.getInstance("Modal", modalId);
                        if (modal_2) {
                          var showModal = function() {
                            modal_2.show();
                          };
                          $triggerEl.addEventListener("click", showModal);
                          modal_2.addEventListenerInstance($triggerEl, "click", showModal);
                        } else {
                          console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
                        }
                      } else {
                        console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-show attribute points to the correct modal id?"));
                      }
                    });
                    document.querySelectorAll("[data-modal-hide]").forEach(function($triggerEl) {
                      var modalId = $triggerEl.getAttribute("data-modal-hide");
                      var $modalEl = document.getElementById(modalId);
                      if ($modalEl) {
                        var modal_3 = instances_1.default.getInstance("Modal", modalId);
                        if (modal_3) {
                          var hideModal = function() {
                            modal_3.hide();
                          };
                          $triggerEl.addEventListener("click", hideModal);
                          modal_3.addEventListenerInstance($triggerEl, "click", hideModal);
                        } else {
                          console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
                        }
                      } else {
                        console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-hide attribute points to the correct modal id?"));
                      }
                    });
                  }
                  exports2.initModals = initModals;
                  if (typeof window !== "undefined") {
                    window.Modal = Modal;
                    window.initModals = initModals;
                  }
                  exports2["default"] = Modal;
                }
              ),
              /***/
              903: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __assign = this && this.__assign || function() {
                    __assign = Object.assign || function(t) {
                      for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p2 in s)
                          if (Object.prototype.hasOwnProperty.call(s, p2))
                            t[p2] = s[p2];
                      }
                      return t;
                    };
                    return __assign.apply(this, arguments);
                  };
                  var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
                    if (pack || arguments.length === 2)
                      for (var i = 0, l = from.length, ar; i < l; i++) {
                        if (ar || !(i in from)) {
                          if (!ar)
                            ar = Array.prototype.slice.call(from, 0, i);
                          ar[i] = from[i];
                        }
                      }
                    return to.concat(ar || Array.prototype.slice.call(from));
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.initPopovers = void 0;
                  var core_1 = __webpack_require__2(853);
                  var instances_1 = __webpack_require__2(423);
                  var Default = {
                    placement: "top",
                    offset: 10,
                    triggerType: "hover",
                    onShow: function() {
                    },
                    onHide: function() {
                    },
                    onToggle: function() {
                    }
                  };
                  var DefaultInstanceOptions = {
                    id: null,
                    override: true
                  };
                  var Popover = (
                    /** @class */
                    function() {
                      function Popover2(targetEl, triggerEl, options, instanceOptions) {
                        if (targetEl === void 0) {
                          targetEl = null;
                        }
                        if (triggerEl === void 0) {
                          triggerEl = null;
                        }
                        if (options === void 0) {
                          options = Default;
                        }
                        if (instanceOptions === void 0) {
                          instanceOptions = DefaultInstanceOptions;
                        }
                        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                        this._targetEl = targetEl;
                        this._triggerEl = triggerEl;
                        this._options = __assign(__assign({}, Default), options);
                        this._popperInstance = null;
                        this._visible = false;
                        this._initialized = false;
                        this.init();
                        instances_1.default.addInstance("Popover", this, instanceOptions.id ? instanceOptions.id : this._targetEl.id, instanceOptions.override);
                      }
                      Popover2.prototype.init = function() {
                        if (this._triggerEl && this._targetEl && !this._initialized) {
                          this._setupEventListeners();
                          this._popperInstance = this._createPopperInstance();
                          this._initialized = true;
                        }
                      };
                      Popover2.prototype.destroy = function() {
                        var _this = this;
                        if (this._initialized) {
                          var triggerEvents = this._getTriggerEvents();
                          triggerEvents.showEvents.forEach(function(ev) {
                            _this._triggerEl.removeEventListener(ev, _this._showHandler);
                            _this._targetEl.removeEventListener(ev, _this._showHandler);
                          });
                          triggerEvents.hideEvents.forEach(function(ev) {
                            _this._triggerEl.removeEventListener(ev, _this._hideHandler);
                            _this._targetEl.removeEventListener(ev, _this._hideHandler);
                          });
                          this._removeKeydownListener();
                          this._removeClickOutsideListener();
                          if (this._popperInstance) {
                            this._popperInstance.destroy();
                          }
                          this._initialized = false;
                        }
                      };
                      Popover2.prototype.removeInstance = function() {
                        instances_1.default.removeInstance("Popover", this._instanceId);
                      };
                      Popover2.prototype.destroyAndRemoveInstance = function() {
                        this.destroy();
                        this.removeInstance();
                      };
                      Popover2.prototype._setupEventListeners = function() {
                        var _this = this;
                        var triggerEvents = this._getTriggerEvents();
                        this._showHandler = function() {
                          _this.show();
                        };
                        this._hideHandler = function() {
                          setTimeout(function() {
                            if (!_this._targetEl.matches(":hover")) {
                              _this.hide();
                            }
                          }, 100);
                        };
                        triggerEvents.showEvents.forEach(function(ev) {
                          _this._triggerEl.addEventListener(ev, _this._showHandler);
                          _this._targetEl.addEventListener(ev, _this._showHandler);
                        });
                        triggerEvents.hideEvents.forEach(function(ev) {
                          _this._triggerEl.addEventListener(ev, _this._hideHandler);
                          _this._targetEl.addEventListener(ev, _this._hideHandler);
                        });
                      };
                      Popover2.prototype._createPopperInstance = function() {
                        return (0, core_1.createPopper)(this._triggerEl, this._targetEl, {
                          placement: this._options.placement,
                          modifiers: [
                            {
                              name: "offset",
                              options: {
                                offset: [0, this._options.offset]
                              }
                            }
                          ]
                        });
                      };
                      Popover2.prototype._getTriggerEvents = function() {
                        switch (this._options.triggerType) {
                          case "hover":
                            return {
                              showEvents: ["mouseenter", "focus"],
                              hideEvents: ["mouseleave", "blur"]
                            };
                          case "click":
                            return {
                              showEvents: ["click", "focus"],
                              hideEvents: ["focusout", "blur"]
                            };
                          case "none":
                            return {
                              showEvents: [],
                              hideEvents: []
                            };
                          default:
                            return {
                              showEvents: ["mouseenter", "focus"],
                              hideEvents: ["mouseleave", "blur"]
                            };
                        }
                      };
                      Popover2.prototype._setupKeydownListener = function() {
                        var _this = this;
                        this._keydownEventListener = function(ev) {
                          if (ev.key === "Escape") {
                            _this.hide();
                          }
                        };
                        document.body.addEventListener("keydown", this._keydownEventListener, true);
                      };
                      Popover2.prototype._removeKeydownListener = function() {
                        document.body.removeEventListener("keydown", this._keydownEventListener, true);
                      };
                      Popover2.prototype._setupClickOutsideListener = function() {
                        var _this = this;
                        this._clickOutsideEventListener = function(ev) {
                          _this._handleClickOutside(ev, _this._targetEl);
                        };
                        document.body.addEventListener("click", this._clickOutsideEventListener, true);
                      };
                      Popover2.prototype._removeClickOutsideListener = function() {
                        document.body.removeEventListener("click", this._clickOutsideEventListener, true);
                      };
                      Popover2.prototype._handleClickOutside = function(ev, targetEl) {
                        var clickedEl = ev.target;
                        if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && this.isVisible()) {
                          this.hide();
                        }
                      };
                      Popover2.prototype.isVisible = function() {
                        return this._visible;
                      };
                      Popover2.prototype.toggle = function() {
                        if (this.isVisible()) {
                          this.hide();
                        } else {
                          this.show();
                        }
                        this._options.onToggle(this);
                      };
                      Popover2.prototype.show = function() {
                        this._targetEl.classList.remove("opacity-0", "invisible");
                        this._targetEl.classList.add("opacity-100", "visible");
                        this._popperInstance.setOptions(function(options) {
                          return __assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                            { name: "eventListeners", enabled: true }
                          ], false) });
                        });
                        this._setupClickOutsideListener();
                        this._setupKeydownListener();
                        this._popperInstance.update();
                        this._visible = true;
                        this._options.onShow(this);
                      };
                      Popover2.prototype.hide = function() {
                        this._targetEl.classList.remove("opacity-100", "visible");
                        this._targetEl.classList.add("opacity-0", "invisible");
                        this._popperInstance.setOptions(function(options) {
                          return __assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                            { name: "eventListeners", enabled: false }
                          ], false) });
                        });
                        this._removeClickOutsideListener();
                        this._removeKeydownListener();
                        this._visible = false;
                        this._options.onHide(this);
                      };
                      Popover2.prototype.updateOnShow = function(callback) {
                        this._options.onShow = callback;
                      };
                      Popover2.prototype.updateOnHide = function(callback) {
                        this._options.onHide = callback;
                      };
                      Popover2.prototype.updateOnToggle = function(callback) {
                        this._options.onToggle = callback;
                      };
                      return Popover2;
                    }()
                  );
                  function initPopovers() {
                    document.querySelectorAll("[data-popover-target]").forEach(function($triggerEl) {
                      var popoverID = $triggerEl.getAttribute("data-popover-target");
                      var $popoverEl = document.getElementById(popoverID);
                      if ($popoverEl) {
                        var triggerType = $triggerEl.getAttribute("data-popover-trigger");
                        var placement = $triggerEl.getAttribute("data-popover-placement");
                        var offset = $triggerEl.getAttribute("data-popover-offset");
                        new Popover($popoverEl, $triggerEl, {
                          placement: placement ? placement : Default.placement,
                          offset: offset ? parseInt(offset) : Default.offset,
                          triggerType: triggerType ? triggerType : Default.triggerType
                        });
                      } else {
                        console.error('The popover element with id "'.concat(popoverID, '" does not exist. Please check the data-popover-target attribute.'));
                      }
                    });
                  }
                  exports2.initPopovers = initPopovers;
                  if (typeof window !== "undefined") {
                    window.Popover = Popover;
                    window.initPopovers = initPopovers;
                  }
                  exports2["default"] = Popover;
                }
              ),
              /***/
              247: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __assign = this && this.__assign || function() {
                    __assign = Object.assign || function(t) {
                      for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p2 in s)
                          if (Object.prototype.hasOwnProperty.call(s, p2))
                            t[p2] = s[p2];
                      }
                      return t;
                    };
                    return __assign.apply(this, arguments);
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.initTabs = void 0;
                  var instances_1 = __webpack_require__2(423);
                  var Default = {
                    defaultTabId: null,
                    activeClasses: "text-blue-600 hover:text-blue-600 dark:text-blue-500 dark:hover:text-blue-500 border-blue-600 dark:border-blue-500",
                    inactiveClasses: "dark:border-transparent text-gray-500 hover:text-gray-600 dark:text-gray-400 border-gray-100 hover:border-gray-300 dark:border-gray-700 dark:hover:text-gray-300",
                    onShow: function() {
                    }
                  };
                  var DefaultInstanceOptions = {
                    id: null,
                    override: true
                  };
                  var Tabs = (
                    /** @class */
                    function() {
                      function Tabs2(tabsEl, items, options, instanceOptions) {
                        if (tabsEl === void 0) {
                          tabsEl = null;
                        }
                        if (items === void 0) {
                          items = [];
                        }
                        if (options === void 0) {
                          options = Default;
                        }
                        if (instanceOptions === void 0) {
                          instanceOptions = DefaultInstanceOptions;
                        }
                        this._instanceId = instanceOptions.id ? instanceOptions.id : tabsEl.id;
                        this._tabsEl = tabsEl;
                        this._items = items;
                        this._activeTab = options ? this.getTab(options.defaultTabId) : null;
                        this._options = __assign(__assign({}, Default), options);
                        this._initialized = false;
                        this.init();
                        instances_1.default.addInstance("Tabs", this, this._instanceId, instanceOptions.override);
                      }
                      Tabs2.prototype.init = function() {
                        var _this = this;
                        if (this._items.length && !this._initialized) {
                          if (!this._activeTab) {
                            this.setActiveTab(this._items[0]);
                          }
                          this.show(this._activeTab.id, true);
                          this._items.map(function(tab) {
                            tab.triggerEl.addEventListener("click", function(event) {
                              event.preventDefault();
                              _this.show(tab.id);
                            });
                          });
                        }
                      };
                      Tabs2.prototype.destroy = function() {
                        if (this._initialized) {
                          this._initialized = false;
                        }
                      };
                      Tabs2.prototype.removeInstance = function() {
                        this.destroy();
                        instances_1.default.removeInstance("Tabs", this._instanceId);
                      };
                      Tabs2.prototype.destroyAndRemoveInstance = function() {
                        this.destroy();
                        this.removeInstance();
                      };
                      Tabs2.prototype.getActiveTab = function() {
                        return this._activeTab;
                      };
                      Tabs2.prototype.setActiveTab = function(tab) {
                        this._activeTab = tab;
                      };
                      Tabs2.prototype.getTab = function(id) {
                        return this._items.filter(function(t) {
                          return t.id === id;
                        })[0];
                      };
                      Tabs2.prototype.show = function(id, forceShow) {
                        var _a, _b;
                        var _this = this;
                        if (forceShow === void 0) {
                          forceShow = false;
                        }
                        var tab = this.getTab(id);
                        if (tab === this._activeTab && !forceShow) {
                          return;
                        }
                        this._items.map(function(t) {
                          var _a2, _b2;
                          if (t !== tab) {
                            (_a2 = t.triggerEl.classList).remove.apply(_a2, _this._options.activeClasses.split(" "));
                            (_b2 = t.triggerEl.classList).add.apply(_b2, _this._options.inactiveClasses.split(" "));
                            t.targetEl.classList.add("hidden");
                            t.triggerEl.setAttribute("aria-selected", "false");
                          }
                        });
                        (_a = tab.triggerEl.classList).add.apply(_a, this._options.activeClasses.split(" "));
                        (_b = tab.triggerEl.classList).remove.apply(_b, this._options.inactiveClasses.split(" "));
                        tab.triggerEl.setAttribute("aria-selected", "true");
                        tab.targetEl.classList.remove("hidden");
                        this.setActiveTab(tab);
                        this._options.onShow(this, tab);
                      };
                      Tabs2.prototype.updateOnShow = function(callback) {
                        this._options.onShow = callback;
                      };
                      return Tabs2;
                    }()
                  );
                  function initTabs() {
                    document.querySelectorAll("[data-tabs-toggle]").forEach(function($parentEl) {
                      var tabItems = [];
                      var activeClasses = $parentEl.getAttribute("data-tabs-active-classes");
                      var inactiveClasses = $parentEl.getAttribute("data-tabs-inactive-classes");
                      var defaultTabId = null;
                      $parentEl.querySelectorAll('[role="tab"]').forEach(function($triggerEl) {
                        var isActive = $triggerEl.getAttribute("aria-selected") === "true";
                        var tab = {
                          id: $triggerEl.getAttribute("data-tabs-target"),
                          triggerEl: $triggerEl,
                          targetEl: document.querySelector($triggerEl.getAttribute("data-tabs-target"))
                        };
                        tabItems.push(tab);
                        if (isActive) {
                          defaultTabId = tab.id;
                        }
                      });
                      new Tabs($parentEl, tabItems, {
                        defaultTabId,
                        activeClasses: activeClasses ? activeClasses : Default.activeClasses,
                        inactiveClasses: inactiveClasses ? inactiveClasses : Default.inactiveClasses
                      });
                    });
                  }
                  exports2.initTabs = initTabs;
                  if (typeof window !== "undefined") {
                    window.Tabs = Tabs;
                    window.initTabs = initTabs;
                  }
                  exports2["default"] = Tabs;
                }
              ),
              /***/
              671: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __assign = this && this.__assign || function() {
                    __assign = Object.assign || function(t) {
                      for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p2 in s)
                          if (Object.prototype.hasOwnProperty.call(s, p2))
                            t[p2] = s[p2];
                      }
                      return t;
                    };
                    return __assign.apply(this, arguments);
                  };
                  var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
                    if (pack || arguments.length === 2)
                      for (var i = 0, l = from.length, ar; i < l; i++) {
                        if (ar || !(i in from)) {
                          if (!ar)
                            ar = Array.prototype.slice.call(from, 0, i);
                          ar[i] = from[i];
                        }
                      }
                    return to.concat(ar || Array.prototype.slice.call(from));
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.initTooltips = void 0;
                  var core_1 = __webpack_require__2(853);
                  var instances_1 = __webpack_require__2(423);
                  var Default = {
                    placement: "top",
                    triggerType: "hover",
                    onShow: function() {
                    },
                    onHide: function() {
                    },
                    onToggle: function() {
                    }
                  };
                  var DefaultInstanceOptions = {
                    id: null,
                    override: true
                  };
                  var Tooltip = (
                    /** @class */
                    function() {
                      function Tooltip2(targetEl, triggerEl, options, instanceOptions) {
                        if (targetEl === void 0) {
                          targetEl = null;
                        }
                        if (triggerEl === void 0) {
                          triggerEl = null;
                        }
                        if (options === void 0) {
                          options = Default;
                        }
                        if (instanceOptions === void 0) {
                          instanceOptions = DefaultInstanceOptions;
                        }
                        this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                        this._targetEl = targetEl;
                        this._triggerEl = triggerEl;
                        this._options = __assign(__assign({}, Default), options);
                        this._popperInstance = null;
                        this._visible = false;
                        this._initialized = false;
                        this.init();
                        instances_1.default.addInstance("Tooltip", this, this._instanceId, instanceOptions.override);
                      }
                      Tooltip2.prototype.init = function() {
                        if (this._triggerEl && this._targetEl && !this._initialized) {
                          this._setupEventListeners();
                          this._popperInstance = this._createPopperInstance();
                          this._initialized = true;
                        }
                      };
                      Tooltip2.prototype.destroy = function() {
                        var _this = this;
                        if (this._initialized) {
                          var triggerEvents = this._getTriggerEvents();
                          triggerEvents.showEvents.forEach(function(ev) {
                            _this._triggerEl.removeEventListener(ev, _this._showHandler);
                          });
                          triggerEvents.hideEvents.forEach(function(ev) {
                            _this._triggerEl.removeEventListener(ev, _this._hideHandler);
                          });
                          this._removeKeydownListener();
                          this._removeClickOutsideListener();
                          if (this._popperInstance) {
                            this._popperInstance.destroy();
                          }
                          this._initialized = false;
                        }
                      };
                      Tooltip2.prototype.removeInstance = function() {
                        instances_1.default.removeInstance("Tooltip", this._instanceId);
                      };
                      Tooltip2.prototype.destroyAndRemoveInstance = function() {
                        this.destroy();
                        this.removeInstance();
                      };
                      Tooltip2.prototype._setupEventListeners = function() {
                        var _this = this;
                        var triggerEvents = this._getTriggerEvents();
                        this._showHandler = function() {
                          _this.show();
                        };
                        this._hideHandler = function() {
                          _this.hide();
                        };
                        triggerEvents.showEvents.forEach(function(ev) {
                          _this._triggerEl.addEventListener(ev, _this._showHandler);
                        });
                        triggerEvents.hideEvents.forEach(function(ev) {
                          _this._triggerEl.addEventListener(ev, _this._hideHandler);
                        });
                      };
                      Tooltip2.prototype._createPopperInstance = function() {
                        return (0, core_1.createPopper)(this._triggerEl, this._targetEl, {
                          placement: this._options.placement,
                          modifiers: [
                            {
                              name: "offset",
                              options: {
                                offset: [0, 8]
                              }
                            }
                          ]
                        });
                      };
                      Tooltip2.prototype._getTriggerEvents = function() {
                        switch (this._options.triggerType) {
                          case "hover":
                            return {
                              showEvents: ["mouseenter", "focus"],
                              hideEvents: ["mouseleave", "blur"]
                            };
                          case "click":
                            return {
                              showEvents: ["click", "focus"],
                              hideEvents: ["focusout", "blur"]
                            };
                          case "none":
                            return {
                              showEvents: [],
                              hideEvents: []
                            };
                          default:
                            return {
                              showEvents: ["mouseenter", "focus"],
                              hideEvents: ["mouseleave", "blur"]
                            };
                        }
                      };
                      Tooltip2.prototype._setupKeydownListener = function() {
                        var _this = this;
                        this._keydownEventListener = function(ev) {
                          if (ev.key === "Escape") {
                            _this.hide();
                          }
                        };
                        document.body.addEventListener("keydown", this._keydownEventListener, true);
                      };
                      Tooltip2.prototype._removeKeydownListener = function() {
                        document.body.removeEventListener("keydown", this._keydownEventListener, true);
                      };
                      Tooltip2.prototype._setupClickOutsideListener = function() {
                        var _this = this;
                        this._clickOutsideEventListener = function(ev) {
                          _this._handleClickOutside(ev, _this._targetEl);
                        };
                        document.body.addEventListener("click", this._clickOutsideEventListener, true);
                      };
                      Tooltip2.prototype._removeClickOutsideListener = function() {
                        document.body.removeEventListener("click", this._clickOutsideEventListener, true);
                      };
                      Tooltip2.prototype._handleClickOutside = function(ev, targetEl) {
                        var clickedEl = ev.target;
                        if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && this.isVisible()) {
                          this.hide();
                        }
                      };
                      Tooltip2.prototype.isVisible = function() {
                        return this._visible;
                      };
                      Tooltip2.prototype.toggle = function() {
                        if (this.isVisible()) {
                          this.hide();
                        } else {
                          this.show();
                        }
                      };
                      Tooltip2.prototype.show = function() {
                        this._targetEl.classList.remove("opacity-0", "invisible");
                        this._targetEl.classList.add("opacity-100", "visible");
                        this._popperInstance.setOptions(function(options) {
                          return __assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                            { name: "eventListeners", enabled: true }
                          ], false) });
                        });
                        this._setupClickOutsideListener();
                        this._setupKeydownListener();
                        this._popperInstance.update();
                        this._visible = true;
                        this._options.onShow(this);
                      };
                      Tooltip2.prototype.hide = function() {
                        this._targetEl.classList.remove("opacity-100", "visible");
                        this._targetEl.classList.add("opacity-0", "invisible");
                        this._popperInstance.setOptions(function(options) {
                          return __assign(__assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [
                            { name: "eventListeners", enabled: false }
                          ], false) });
                        });
                        this._removeClickOutsideListener();
                        this._removeKeydownListener();
                        this._visible = false;
                        this._options.onHide(this);
                      };
                      Tooltip2.prototype.updateOnShow = function(callback) {
                        this._options.onShow = callback;
                      };
                      Tooltip2.prototype.updateOnHide = function(callback) {
                        this._options.onHide = callback;
                      };
                      Tooltip2.prototype.updateOnToggle = function(callback) {
                        this._options.onToggle = callback;
                      };
                      return Tooltip2;
                    }()
                  );
                  function initTooltips() {
                    document.querySelectorAll("[data-tooltip-target]").forEach(function($triggerEl) {
                      var tooltipId = $triggerEl.getAttribute("data-tooltip-target");
                      var $tooltipEl = document.getElementById(tooltipId);
                      if ($tooltipEl) {
                        var triggerType = $triggerEl.getAttribute("data-tooltip-trigger");
                        var placement = $triggerEl.getAttribute("data-tooltip-placement");
                        new Tooltip($tooltipEl, $triggerEl, {
                          placement: placement ? placement : Default.placement,
                          triggerType: triggerType ? triggerType : Default.triggerType
                        });
                      } else {
                        console.error('The tooltip element with id "'.concat(tooltipId, '" does not exist. Please check the data-tooltip-target attribute.'));
                      }
                    });
                  }
                  exports2.initTooltips = initTooltips;
                  if (typeof window !== "undefined") {
                    window.Tooltip = Tooltip;
                    window.initTooltips = initTooltips;
                  }
                  exports2["default"] = Tooltip;
                }
              ),
              /***/
              947: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  var Events2 = (
                    /** @class */
                    function() {
                      function Events3(eventType, eventFunctions) {
                        if (eventFunctions === void 0) {
                          eventFunctions = [];
                        }
                        this._eventType = eventType;
                        this._eventFunctions = eventFunctions;
                      }
                      Events3.prototype.init = function() {
                        var _this = this;
                        this._eventFunctions.forEach(function(eventFunction) {
                          if (typeof window !== "undefined") {
                            window.addEventListener(_this._eventType, eventFunction);
                          }
                        });
                      };
                      return Events3;
                    }()
                  );
                  exports2["default"] = Events2;
                }
              ),
              /***/
              423: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  var Instances = (
                    /** @class */
                    function() {
                      function Instances2() {
                        this._instances = {
                          Accordion: {},
                          Carousel: {},
                          Collapse: {},
                          Dial: {},
                          Dismiss: {},
                          Drawer: {},
                          Dropdown: {},
                          Modal: {},
                          Popover: {},
                          Tabs: {},
                          Tooltip: {},
                          InputCounter: {},
                          CopyClipboard: {},
                          Datepicker: {}
                        };
                      }
                      Instances2.prototype.addInstance = function(component, instance, id, override) {
                        if (override === void 0) {
                          override = false;
                        }
                        if (!this._instances[component]) {
                          console.warn("Flowbite: Component ".concat(component, " does not exist."));
                          return false;
                        }
                        if (this._instances[component][id] && !override) {
                          console.warn("Flowbite: Instance with ID ".concat(id, " already exists."));
                          return;
                        }
                        if (override && this._instances[component][id]) {
                          this._instances[component][id].destroyAndRemoveInstance();
                        }
                        this._instances[component][id ? id : this._generateRandomId()] = instance;
                      };
                      Instances2.prototype.getAllInstances = function() {
                        return this._instances;
                      };
                      Instances2.prototype.getInstances = function(component) {
                        if (!this._instances[component]) {
                          console.warn("Flowbite: Component ".concat(component, " does not exist."));
                          return false;
                        }
                        return this._instances[component];
                      };
                      Instances2.prototype.getInstance = function(component, id) {
                        if (!this._componentAndInstanceCheck(component, id)) {
                          return;
                        }
                        if (!this._instances[component][id]) {
                          console.warn("Flowbite: Instance with ID ".concat(id, " does not exist."));
                          return;
                        }
                        return this._instances[component][id];
                      };
                      Instances2.prototype.destroyAndRemoveInstance = function(component, id) {
                        if (!this._componentAndInstanceCheck(component, id)) {
                          return;
                        }
                        this.destroyInstanceObject(component, id);
                        this.removeInstance(component, id);
                      };
                      Instances2.prototype.removeInstance = function(component, id) {
                        if (!this._componentAndInstanceCheck(component, id)) {
                          return;
                        }
                        delete this._instances[component][id];
                      };
                      Instances2.prototype.destroyInstanceObject = function(component, id) {
                        if (!this._componentAndInstanceCheck(component, id)) {
                          return;
                        }
                        this._instances[component][id].destroy();
                      };
                      Instances2.prototype.instanceExists = function(component, id) {
                        if (!this._instances[component]) {
                          return false;
                        }
                        if (!this._instances[component][id]) {
                          return false;
                        }
                        return true;
                      };
                      Instances2.prototype._generateRandomId = function() {
                        return Math.random().toString(36).substr(2, 9);
                      };
                      Instances2.prototype._componentAndInstanceCheck = function(component, id) {
                        if (!this._instances[component]) {
                          console.warn("Flowbite: Component ".concat(component, " does not exist."));
                          return false;
                        }
                        if (!this._instances[component][id]) {
                          console.warn("Flowbite: Instance with ID ".concat(id, " does not exist."));
                          return false;
                        }
                        return true;
                      };
                      return Instances2;
                    }()
                  );
                  var instances = new Instances();
                  exports2["default"] = instances;
                  if (typeof window !== "undefined") {
                    window.FlowbiteInstances = instances;
                  }
                }
              )
              /******/
            };
            var __webpack_module_cache__ = {};
            function __webpack_require__(moduleId) {
              var cachedModule = __webpack_module_cache__[moduleId];
              if (cachedModule !== void 0) {
                return cachedModule.exports;
              }
              var module2 = __webpack_module_cache__[moduleId] = {
                /******/
                // no module.id needed
                /******/
                // no module.loaded needed
                /******/
                exports: {}
                /******/
              };
              __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
              return module2.exports;
            }
            !function() {
              __webpack_require__.d = function(exports2, definition) {
                for (var key in definition) {
                  if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                    Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                  }
                }
              };
            }();
            !function() {
              __webpack_require__.o = function(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
              };
            }();
            !function() {
              __webpack_require__.r = function(exports2) {
                if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
                }
                Object.defineProperty(exports2, "__esModule", { value: true });
              };
            }();
            var __webpack_exports__ = {};
            !function() {
              var exports2 = __webpack_exports__;
              Object.defineProperty(exports2, "__esModule", { value: true });
              var accordion_1 = __webpack_require__(902);
              var carousel_1 = __webpack_require__(33);
              var collapse_1 = __webpack_require__(922);
              var dial_1 = __webpack_require__(556);
              var dismiss_1 = __webpack_require__(791);
              var drawer_1 = __webpack_require__(340);
              var dropdown_1 = __webpack_require__(316);
              var modal_1 = __webpack_require__(16);
              var popover_1 = __webpack_require__(903);
              var tabs_1 = __webpack_require__(247);
              var tooltip_1 = __webpack_require__(671);
              var input_counter_1 = __webpack_require__(656);
              var clipboard_1 = __webpack_require__(673);
              var datepicker_1 = __webpack_require__(132);
              var index_1 = __webpack_require__(311);
              var events_1 = __webpack_require__(947);
              var afterRenderEvent = new Event("turbo:after-stream-render");
              addEventListener("turbo:before-stream-render", function(event) {
                var originalRender = event.detail.render;
                event.detail.render = function(streamElement) {
                  originalRender(streamElement);
                  document.dispatchEvent(afterRenderEvent);
                };
              });
              var turboLoadEvents = new events_1.default("turbo:load", [index_1.initFlowbite]);
              turboLoadEvents.init();
              var turboFrameLoadEvents = new events_1.default("turbo:frame-load", [index_1.initFlowbite]);
              turboFrameLoadEvents.init();
              var turboStreamLoadEvents = new events_1.default("turbo:after-stream-render", [
                index_1.initFlowbite
              ]);
              turboStreamLoadEvents.init();
              exports2["default"] = {
                Accordion: accordion_1.default,
                Carousel: carousel_1.default,
                Collapse: collapse_1.default,
                Dial: dial_1.default,
                Drawer: drawer_1.default,
                Dismiss: dismiss_1.default,
                Dropdown: dropdown_1.default,
                Modal: modal_1.default,
                Popover: popover_1.default,
                Tabs: tabs_1.default,
                Tooltip: tooltip_1.default,
                InputCounter: input_counter_1.default,
                CopyClipboard: clipboard_1.default,
                Datepicker: datepicker_1.default,
                Events: events_1.default
              };
            }();
            return __webpack_exports__;
          }()
        );
      });
    }
  });

  // node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
  var turbo_es2017_esm_exports = {};
  __export(turbo_es2017_esm_exports, {
    FetchEnctype: () => FetchEnctype,
    FetchMethod: () => FetchMethod,
    FetchRequest: () => FetchRequest,
    FetchResponse: () => FetchResponse,
    FrameElement: () => FrameElement,
    FrameLoadingStyle: () => FrameLoadingStyle,
    FrameRenderer: () => FrameRenderer,
    PageRenderer: () => PageRenderer,
    PageSnapshot: () => PageSnapshot,
    StreamActions: () => StreamActions,
    StreamElement: () => StreamElement,
    StreamSourceElement: () => StreamSourceElement,
    cache: () => cache,
    clearCache: () => clearCache,
    connectStreamSource: () => connectStreamSource,
    disconnectStreamSource: () => disconnectStreamSource,
    fetch: () => fetchWithTurboHeaders,
    fetchEnctypeFromString: () => fetchEnctypeFromString,
    fetchMethodFromString: () => fetchMethodFromString,
    isSafe: () => isSafe,
    navigator: () => navigator$1,
    registerAdapter: () => registerAdapter,
    renderStreamMessage: () => renderStreamMessage,
    session: () => session,
    setConfirmMethod: () => setConfirmMethod,
    setFormMode: () => setFormMode,
    setProgressBarDelay: () => setProgressBarDelay,
    start: () => start,
    visit: () => visit
  });
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function")
      return;
    prototype.requestSubmit = function(submitter) {
      if (submitter) {
        validateSubmitter(submitter, this);
        submitter.click();
      } else {
        submitter = document.createElement("input");
        submitter.type = "submit";
        submitter.hidden = true;
        this.appendChild(submitter);
        submitter.click();
        this.removeChild(submitter);
      }
    };
    function validateSubmitter(submitter, form) {
      submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    function raise(errorConstructor, message, name) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
    }
  })(HTMLFormElement.prototype);
  var submittersByForm = /* @__PURE__ */ new WeakMap();
  function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = element ? element.closest("input, button") : null;
    return candidate?.type == "submit" ? candidate : null;
  }
  function clickCaptured(event) {
    const submitter = findSubmitterFromClickTarget(event.target);
    if (submitter && submitter.form) {
      submittersByForm.set(submitter.form, submitter);
    }
  }
  (function() {
    if ("submitter" in Event.prototype)
      return;
    let prototype = window.Event.prototype;
    if ("SubmitEvent" in window) {
      const prototypeOfSubmitEvent = window.SubmitEvent.prototype;
      if (/Apple Computer/.test(navigator.vendor) && !("submitter" in prototypeOfSubmitEvent)) {
        prototype = prototypeOfSubmitEvent;
      } else {
        return;
      }
    }
    addEventListener("click", clickCaptured, true);
    Object.defineProperty(prototype, "submitter", {
      get() {
        if (this.type == "submit" && this.target instanceof HTMLFormElement) {
          return submittersByForm.get(this.target);
        }
      }
    });
  })();
  var FrameLoadingStyle = {
    eager: "eager",
    lazy: "lazy"
  };
  var FrameElement = class _FrameElement extends HTMLElement {
    static delegateConstructor = void 0;
    loaded = Promise.resolve();
    static get observedAttributes() {
      return ["disabled", "loading", "src"];
    }
    constructor() {
      super();
      this.delegate = new _FrameElement.delegateConstructor(this);
    }
    connectedCallback() {
      this.delegate.connect();
    }
    disconnectedCallback() {
      this.delegate.disconnect();
    }
    reload() {
      return this.delegate.sourceURLReloaded();
    }
    attributeChangedCallback(name) {
      if (name == "loading") {
        this.delegate.loadingStyleChanged();
      } else if (name == "src") {
        this.delegate.sourceURLChanged();
      } else if (name == "disabled") {
        this.delegate.disabledChanged();
      }
    }
    /**
     * Gets the URL to lazily load source HTML from
     */
    get src() {
      return this.getAttribute("src");
    }
    /**
     * Sets the URL to lazily load source HTML from
     */
    set src(value) {
      if (value) {
        this.setAttribute("src", value);
      } else {
        this.removeAttribute("src");
      }
    }
    /**
     * Gets the refresh mode for the frame.
     */
    get refresh() {
      return this.getAttribute("refresh");
    }
    /**
     * Sets the refresh mode for the frame.
     */
    set refresh(value) {
      if (value) {
        this.setAttribute("refresh", value);
      } else {
        this.removeAttribute("refresh");
      }
    }
    /**
     * Determines if the element is loading
     */
    get loading() {
      return frameLoadingStyleFromString(this.getAttribute("loading") || "");
    }
    /**
     * Sets the value of if the element is loading
     */
    set loading(value) {
      if (value) {
        this.setAttribute("loading", value);
      } else {
        this.removeAttribute("loading");
      }
    }
    /**
     * Gets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    get disabled() {
      return this.hasAttribute("disabled");
    }
    /**
     * Sets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    set disabled(value) {
      if (value) {
        this.setAttribute("disabled", "");
      } else {
        this.removeAttribute("disabled");
      }
    }
    /**
     * Gets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    get autoscroll() {
      return this.hasAttribute("autoscroll");
    }
    /**
     * Sets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    set autoscroll(value) {
      if (value) {
        this.setAttribute("autoscroll", "");
      } else {
        this.removeAttribute("autoscroll");
      }
    }
    /**
     * Determines if the element has finished loading
     */
    get complete() {
      return !this.delegate.isLoading;
    }
    /**
     * Gets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isActive() {
      return this.ownerDocument === document && !this.isPreview;
    }
    /**
     * Sets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isPreview() {
      return this.ownerDocument?.documentElement?.hasAttribute("data-turbo-preview");
    }
  };
  function frameLoadingStyleFromString(style) {
    switch (style.toLowerCase()) {
      case "lazy":
        return FrameLoadingStyle.lazy;
      default:
        return FrameLoadingStyle.eager;
    }
  }
  function expandURL(locatable) {
    return new URL(locatable.toString(), document.baseURI);
  }
  function getAnchor(url) {
    let anchorMatch;
    if (url.hash) {
      return url.hash.slice(1);
    } else if (anchorMatch = url.href.match(/#(.*)$/)) {
      return anchorMatch[1];
    }
  }
  function getAction$1(form, submitter) {
    const action = submitter?.getAttribute("formaction") || form.getAttribute("action") || form.action;
    return expandURL(action);
  }
  function getExtension(url) {
    return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
  }
  function isHTML(url) {
    return !!getExtension(url).match(/^(?:|\.(?:htm|html|xhtml|php))$/);
  }
  function isPrefixedBy(baseURL, url) {
    const prefix = getPrefix(url);
    return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
  }
  function locationIsVisitable(location2, rootLocation) {
    return isPrefixedBy(location2, rootLocation) && isHTML(location2);
  }
  function getRequestURL(url) {
    const anchor = getAnchor(url);
    return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
  }
  function toCacheKey(url) {
    return getRequestURL(url);
  }
  function urlsAreEqual(left, right) {
    return expandURL(left).href == expandURL(right).href;
  }
  function getPathComponents(url) {
    return url.pathname.split("/").slice(1);
  }
  function getLastPathComponent(url) {
    return getPathComponents(url).slice(-1)[0];
  }
  function getPrefix(url) {
    return addTrailingSlash(url.origin + url.pathname);
  }
  function addTrailingSlash(value) {
    return value.endsWith("/") ? value : value + "/";
  }
  var FetchResponse = class {
    constructor(response) {
      this.response = response;
    }
    get succeeded() {
      return this.response.ok;
    }
    get failed() {
      return !this.succeeded;
    }
    get clientError() {
      return this.statusCode >= 400 && this.statusCode <= 499;
    }
    get serverError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
    get redirected() {
      return this.response.redirected;
    }
    get location() {
      return expandURL(this.response.url);
    }
    get isHTML() {
      return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
    }
    get statusCode() {
      return this.response.status;
    }
    get contentType() {
      return this.header("Content-Type");
    }
    get responseText() {
      return this.response.clone().text();
    }
    get responseHTML() {
      if (this.isHTML) {
        return this.response.clone().text();
      } else {
        return Promise.resolve(void 0);
      }
    }
    header(name) {
      return this.response.headers.get(name);
    }
  };
  function activateScriptElement(element) {
    if (element.getAttribute("data-turbo-eval") == "false") {
      return element;
    } else {
      const createdScriptElement = document.createElement("script");
      const cspNonce = getMetaContent("csp-nonce");
      if (cspNonce) {
        createdScriptElement.nonce = cspNonce;
      }
      createdScriptElement.textContent = element.textContent;
      createdScriptElement.async = false;
      copyElementAttributes(createdScriptElement, element);
      return createdScriptElement;
    }
  }
  function copyElementAttributes(destinationElement, sourceElement) {
    for (const { name, value } of sourceElement.attributes) {
      destinationElement.setAttribute(name, value);
    }
  }
  function createDocumentFragment(html) {
    const template = document.createElement("template");
    template.innerHTML = html;
    return template.content;
  }
  function dispatch(eventName, { target, cancelable, detail } = {}) {
    const event = new CustomEvent(eventName, {
      cancelable,
      bubbles: true,
      composed: true,
      detail
    });
    if (target && target.isConnected) {
      target.dispatchEvent(event);
    } else {
      document.documentElement.dispatchEvent(event);
    }
    return event;
  }
  function nextRepaint() {
    if (document.visibilityState === "hidden") {
      return nextEventLoopTick();
    } else {
      return nextAnimationFrame();
    }
  }
  function nextAnimationFrame() {
    return new Promise((resolve2) => requestAnimationFrame(() => resolve2()));
  }
  function nextEventLoopTick() {
    return new Promise((resolve2) => setTimeout(() => resolve2(), 0));
  }
  function nextMicrotask() {
    return Promise.resolve();
  }
  function parseHTMLDocument(html = "") {
    return new DOMParser().parseFromString(html, "text/html");
  }
  function unindent(strings, ...values2) {
    const lines = interpolate(strings, values2).replace(/^\n/, "").split("\n");
    const match = lines[0].match(/^\s+/);
    const indent = match ? match[0].length : 0;
    return lines.map((line) => line.slice(indent)).join("\n");
  }
  function interpolate(strings, values2) {
    return strings.reduce((result, string, i) => {
      const value = values2[i] == void 0 ? "" : values2[i];
      return result + string + value;
    }, "");
  }
  function uuid() {
    return Array.from({ length: 36 }).map((_2, i) => {
      if (i == 8 || i == 13 || i == 18 || i == 23) {
        return "-";
      } else if (i == 14) {
        return "4";
      } else if (i == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16);
      } else {
        return Math.floor(Math.random() * 15).toString(16);
      }
    }).join("");
  }
  function getAttribute(attributeName, ...elements) {
    for (const value of elements.map((element) => element?.getAttribute(attributeName))) {
      if (typeof value == "string")
        return value;
    }
    return null;
  }
  function hasAttribute(attributeName, ...elements) {
    return elements.some((element) => element && element.hasAttribute(attributeName));
  }
  function markAsBusy(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.setAttribute("busy", "");
      }
      element.setAttribute("aria-busy", "true");
    }
  }
  function clearBusyState(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.removeAttribute("busy");
      }
      element.removeAttribute("aria-busy");
    }
  }
  function waitForLoad(element, timeoutInMilliseconds = 2e3) {
    return new Promise((resolve2) => {
      const onComplete = () => {
        element.removeEventListener("error", onComplete);
        element.removeEventListener("load", onComplete);
        resolve2();
      };
      element.addEventListener("load", onComplete, { once: true });
      element.addEventListener("error", onComplete, { once: true });
      setTimeout(resolve2, timeoutInMilliseconds);
    });
  }
  function getHistoryMethodForAction(action) {
    switch (action) {
      case "replace":
        return history.replaceState;
      case "advance":
      case "restore":
        return history.pushState;
    }
  }
  function isAction(action) {
    return action == "advance" || action == "replace" || action == "restore";
  }
  function getVisitAction(...elements) {
    const action = getAttribute("data-turbo-action", ...elements);
    return isAction(action) ? action : null;
  }
  function getMetaElement(name) {
    return document.querySelector(`meta[name="${name}"]`);
  }
  function getMetaContent(name) {
    const element = getMetaElement(name);
    return element && element.content;
  }
  function setMetaContent(name, content) {
    let element = getMetaElement(name);
    if (!element) {
      element = document.createElement("meta");
      element.setAttribute("name", name);
      document.head.appendChild(element);
    }
    element.setAttribute("content", content);
    return element;
  }
  function findClosestRecursively(element, selector) {
    if (element instanceof Element) {
      return element.closest(selector) || findClosestRecursively(element.assignedSlot || element.getRootNode()?.host, selector);
    }
  }
  function elementIsFocusable(element) {
    const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
    return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == "function";
  }
  function queryAutofocusableElement(elementOrDocumentFragment) {
    return Array.from(elementOrDocumentFragment.querySelectorAll("[autofocus]")).find(elementIsFocusable);
  }
  async function around(callback, reader) {
    const before = reader();
    callback();
    await nextAnimationFrame();
    const after = reader();
    return [before, after];
  }
  function doesNotTargetIFrame(anchor) {
    if (anchor.hasAttribute("target")) {
      for (const element of document.getElementsByName(anchor.target)) {
        if (element instanceof HTMLIFrameElement)
          return false;
      }
    }
    return true;
  }
  function findLinkFromClickTarget(target) {
    return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
  }
  function getLocationForLink(link) {
    return expandURL(link.getAttribute("href") || "");
  }
  function debounce(fn, delay) {
    let timeoutId = null;
    return (...args) => {
      const callback = () => fn.apply(this, args);
      clearTimeout(timeoutId);
      timeoutId = setTimeout(callback, delay);
    };
  }
  var LimitedSet = class extends Set {
    constructor(maxSize) {
      super();
      this.maxSize = maxSize;
    }
    add(value) {
      if (this.size >= this.maxSize) {
        const iterator = this.values();
        const oldestValue = iterator.next().value;
        this.delete(oldestValue);
      }
      super.add(value);
    }
  };
  var recentRequests = new LimitedSet(20);
  var nativeFetch = window.fetch;
  function fetchWithTurboHeaders(url, options = {}) {
    const modifiedHeaders = new Headers(options.headers || {});
    const requestUID = uuid();
    recentRequests.add(requestUID);
    modifiedHeaders.append("X-Turbo-Request-Id", requestUID);
    return nativeFetch(url, {
      ...options,
      headers: modifiedHeaders
    });
  }
  function fetchMethodFromString(method) {
    switch (method.toLowerCase()) {
      case "get":
        return FetchMethod.get;
      case "post":
        return FetchMethod.post;
      case "put":
        return FetchMethod.put;
      case "patch":
        return FetchMethod.patch;
      case "delete":
        return FetchMethod.delete;
    }
  }
  var FetchMethod = {
    get: "get",
    post: "post",
    put: "put",
    patch: "patch",
    delete: "delete"
  };
  function fetchEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
      case FetchEnctype.multipart:
        return FetchEnctype.multipart;
      case FetchEnctype.plain:
        return FetchEnctype.plain;
      default:
        return FetchEnctype.urlEncoded;
    }
  }
  var FetchEnctype = {
    urlEncoded: "application/x-www-form-urlencoded",
    multipart: "multipart/form-data",
    plain: "text/plain"
  };
  var FetchRequest = class {
    abortController = new AbortController();
    #resolveRequestPromise = (_value) => {
    };
    constructor(delegate, method, location2, requestBody = new URLSearchParams(), target = null, enctype = FetchEnctype.urlEncoded) {
      const [url, body] = buildResourceAndBody(expandURL(location2), method, requestBody, enctype);
      this.delegate = delegate;
      this.url = url;
      this.target = target;
      this.fetchOptions = {
        credentials: "same-origin",
        redirect: "follow",
        method,
        headers: { ...this.defaultHeaders },
        body,
        signal: this.abortSignal,
        referrer: this.delegate.referrer?.href
      };
      this.enctype = enctype;
    }
    get method() {
      return this.fetchOptions.method;
    }
    set method(value) {
      const fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData();
      const fetchMethod = fetchMethodFromString(value) || FetchMethod.get;
      this.url.search = "";
      const [url, body] = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype);
      this.url = url;
      this.fetchOptions.body = body;
      this.fetchOptions.method = fetchMethod;
    }
    get headers() {
      return this.fetchOptions.headers;
    }
    set headers(value) {
      this.fetchOptions.headers = value;
    }
    get body() {
      if (this.isSafe) {
        return this.url.searchParams;
      } else {
        return this.fetchOptions.body;
      }
    }
    set body(value) {
      this.fetchOptions.body = value;
    }
    get location() {
      return this.url;
    }
    get params() {
      return this.url.searchParams;
    }
    get entries() {
      return this.body ? Array.from(this.body.entries()) : [];
    }
    cancel() {
      this.abortController.abort();
    }
    async perform() {
      const { fetchOptions } = this;
      this.delegate.prepareRequest(this);
      const event = await this.#allowRequestToBeIntercepted(fetchOptions);
      try {
        this.delegate.requestStarted(this);
        if (event.detail.fetchRequest) {
          this.response = event.detail.fetchRequest.response;
        } else {
          this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);
        }
        const response = await this.response;
        return await this.receive(response);
      } catch (error2) {
        if (error2.name !== "AbortError") {
          if (this.#willDelegateErrorHandling(error2)) {
            this.delegate.requestErrored(this, error2);
          }
          throw error2;
        }
      } finally {
        this.delegate.requestFinished(this);
      }
    }
    async receive(response) {
      const fetchResponse = new FetchResponse(response);
      const event = dispatch("turbo:before-fetch-response", {
        cancelable: true,
        detail: { fetchResponse },
        target: this.target
      });
      if (event.defaultPrevented) {
        this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
      } else if (fetchResponse.succeeded) {
        this.delegate.requestSucceededWithResponse(this, fetchResponse);
      } else {
        this.delegate.requestFailedWithResponse(this, fetchResponse);
      }
      return fetchResponse;
    }
    get defaultHeaders() {
      return {
        Accept: "text/html, application/xhtml+xml"
      };
    }
    get isSafe() {
      return isSafe(this.method);
    }
    get abortSignal() {
      return this.abortController.signal;
    }
    acceptResponseType(mimeType) {
      this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
    }
    async #allowRequestToBeIntercepted(fetchOptions) {
      const requestInterception = new Promise((resolve2) => this.#resolveRequestPromise = resolve2);
      const event = dispatch("turbo:before-fetch-request", {
        cancelable: true,
        detail: {
          fetchOptions,
          url: this.url,
          resume: this.#resolveRequestPromise
        },
        target: this.target
      });
      this.url = event.detail.url;
      if (event.defaultPrevented)
        await requestInterception;
      return event;
    }
    #willDelegateErrorHandling(error2) {
      const event = dispatch("turbo:fetch-request-error", {
        target: this.target,
        cancelable: true,
        detail: { request: this, error: error2 }
      });
      return !event.defaultPrevented;
    }
  };
  function isSafe(fetchMethod) {
    return fetchMethodFromString(fetchMethod) == FetchMethod.get;
  }
  function buildResourceAndBody(resource, method, requestBody, enctype) {
    const searchParams = Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;
    if (isSafe(method)) {
      return [mergeIntoURLSearchParams(resource, searchParams), null];
    } else if (enctype == FetchEnctype.urlEncoded) {
      return [resource, searchParams];
    } else {
      return [resource, requestBody];
    }
  }
  function entriesExcludingFiles(requestBody) {
    const entries = [];
    for (const [name, value] of requestBody) {
      if (value instanceof File)
        continue;
      else
        entries.push([name, value]);
    }
    return entries;
  }
  function mergeIntoURLSearchParams(url, requestBody) {
    const searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));
    url.search = searchParams.toString();
    return url;
  }
  var AppearanceObserver = class {
    started = false;
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
      }
    }
    intersect = (entries) => {
      const lastEntry = entries.slice(-1)[0];
      if (lastEntry?.isIntersecting) {
        this.delegate.elementAppearedInViewport(this.element);
      }
    };
  };
  var StreamMessage = class {
    static contentType = "text/vnd.turbo-stream.html";
    static wrap(message) {
      if (typeof message == "string") {
        return new this(createDocumentFragment(message));
      } else {
        return message;
      }
    }
    constructor(fragment) {
      this.fragment = importStreamElements(fragment);
    }
  };
  function importStreamElements(fragment) {
    for (const element of fragment.querySelectorAll("turbo-stream")) {
      const streamElement = document.importNode(element, true);
      for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
        inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
      }
      element.replaceWith(streamElement);
    }
    return fragment;
  }
  var PREFETCH_DELAY = 100;
  var PrefetchCache = class {
    #prefetchTimeout = null;
    #prefetched = null;
    get(url) {
      if (this.#prefetched && this.#prefetched.url === url && this.#prefetched.expire > Date.now()) {
        return this.#prefetched.request;
      }
    }
    setLater(url, request, ttl) {
      this.clear();
      this.#prefetchTimeout = setTimeout(() => {
        request.perform();
        this.set(url, request, ttl);
        this.#prefetchTimeout = null;
      }, PREFETCH_DELAY);
    }
    set(url, request, ttl) {
      this.#prefetched = { url, request, expire: new Date((/* @__PURE__ */ new Date()).getTime() + ttl) };
    }
    clear() {
      if (this.#prefetchTimeout)
        clearTimeout(this.#prefetchTimeout);
      this.#prefetched = null;
    }
  };
  var cacheTtl = 10 * 1e3;
  var prefetchCache = new PrefetchCache();
  var FormSubmissionState = {
    initialized: "initialized",
    requesting: "requesting",
    waiting: "waiting",
    receiving: "receiving",
    stopping: "stopping",
    stopped: "stopped"
  };
  var FormSubmission = class _FormSubmission {
    state = FormSubmissionState.initialized;
    static confirmMethod(message, _element, _submitter) {
      return Promise.resolve(confirm(message));
    }
    constructor(delegate, formElement, submitter, mustRedirect = false) {
      const method = getMethod(formElement, submitter);
      const action = getAction(getFormAction(formElement, submitter), method);
      const body = buildFormData(formElement, submitter);
      const enctype = getEnctype(formElement, submitter);
      this.delegate = delegate;
      this.formElement = formElement;
      this.submitter = submitter;
      this.fetchRequest = new FetchRequest(this, method, action, body, formElement, enctype);
      this.mustRedirect = mustRedirect;
    }
    get method() {
      return this.fetchRequest.method;
    }
    set method(value) {
      this.fetchRequest.method = value;
    }
    get action() {
      return this.fetchRequest.url.toString();
    }
    set action(value) {
      this.fetchRequest.url = expandURL(value);
    }
    get body() {
      return this.fetchRequest.body;
    }
    get enctype() {
      return this.fetchRequest.enctype;
    }
    get isSafe() {
      return this.fetchRequest.isSafe;
    }
    get location() {
      return this.fetchRequest.url;
    }
    // The submission process
    async start() {
      const { initialized, requesting } = FormSubmissionState;
      const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
      if (typeof confirmationMessage === "string") {
        const answer = await _FormSubmission.confirmMethod(confirmationMessage, this.formElement, this.submitter);
        if (!answer) {
          return;
        }
      }
      if (this.state == initialized) {
        this.state = requesting;
        return this.fetchRequest.perform();
      }
    }
    stop() {
      const { stopping, stopped } = FormSubmissionState;
      if (this.state != stopping && this.state != stopped) {
        this.state = stopping;
        this.fetchRequest.cancel();
        return true;
      }
    }
    // Fetch request delegate
    prepareRequest(request) {
      if (!request.isSafe) {
        const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
        if (token) {
          request.headers["X-CSRF-Token"] = token;
        }
      }
      if (this.requestAcceptsTurboStreamResponse(request)) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      this.state = FormSubmissionState.waiting;
      this.submitter?.setAttribute("disabled", "");
      this.setSubmitsWith();
      markAsBusy(this.formElement);
      dispatch("turbo:submit-start", {
        target: this.formElement,
        detail: { formSubmission: this }
      });
      this.delegate.formSubmissionStarted(this);
    }
    requestPreventedHandlingResponse(request, response) {
      prefetchCache.clear();
      this.result = { success: response.succeeded, fetchResponse: response };
    }
    requestSucceededWithResponse(request, response) {
      if (response.clientError || response.serverError) {
        this.delegate.formSubmissionFailedWithResponse(this, response);
        return;
      }
      prefetchCache.clear();
      if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
        const error2 = new Error("Form responses must redirect to another location");
        this.delegate.formSubmissionErrored(this, error2);
      } else {
        this.state = FormSubmissionState.receiving;
        this.result = { success: true, fetchResponse: response };
        this.delegate.formSubmissionSucceededWithResponse(this, response);
      }
    }
    requestFailedWithResponse(request, response) {
      this.result = { success: false, fetchResponse: response };
      this.delegate.formSubmissionFailedWithResponse(this, response);
    }
    requestErrored(request, error2) {
      this.result = { success: false, error: error2 };
      this.delegate.formSubmissionErrored(this, error2);
    }
    requestFinished(_request) {
      this.state = FormSubmissionState.stopped;
      this.submitter?.removeAttribute("disabled");
      this.resetSubmitterText();
      clearBusyState(this.formElement);
      dispatch("turbo:submit-end", {
        target: this.formElement,
        detail: { formSubmission: this, ...this.result }
      });
      this.delegate.formSubmissionFinished(this);
    }
    // Private
    setSubmitsWith() {
      if (!this.submitter || !this.submitsWith)
        return;
      if (this.submitter.matches("button")) {
        this.originalSubmitText = this.submitter.innerHTML;
        this.submitter.innerHTML = this.submitsWith;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        this.originalSubmitText = input.value;
        input.value = this.submitsWith;
      }
    }
    resetSubmitterText() {
      if (!this.submitter || !this.originalSubmitText)
        return;
      if (this.submitter.matches("button")) {
        this.submitter.innerHTML = this.originalSubmitText;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        input.value = this.originalSubmitText;
      }
    }
    requestMustRedirect(request) {
      return !request.isSafe && this.mustRedirect;
    }
    requestAcceptsTurboStreamResponse(request) {
      return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
    }
    get submitsWith() {
      return this.submitter?.getAttribute("data-turbo-submits-with");
    }
  };
  function buildFormData(formElement, submitter) {
    const formData = new FormData(formElement);
    const name = submitter?.getAttribute("name");
    const value = submitter?.getAttribute("value");
    if (name) {
      formData.append(name, value || "");
    }
    return formData;
  }
  function getCookieValue(cookieName) {
    if (cookieName != null) {
      const cookies = document.cookie ? document.cookie.split("; ") : [];
      const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
      if (cookie) {
        const value = cookie.split("=").slice(1).join("=");
        return value ? decodeURIComponent(value) : void 0;
      }
    }
  }
  function responseSucceededWithoutRedirect(response) {
    return response.statusCode == 200 && !response.redirected;
  }
  function getFormAction(formElement, submitter) {
    const formElementAction = typeof formElement.action === "string" ? formElement.action : null;
    if (submitter?.hasAttribute("formaction")) {
      return submitter.getAttribute("formaction") || "";
    } else {
      return formElement.getAttribute("action") || formElementAction || "";
    }
  }
  function getAction(formAction, fetchMethod) {
    const action = expandURL(formAction);
    if (isSafe(fetchMethod)) {
      action.search = "";
    }
    return action;
  }
  function getMethod(formElement, submitter) {
    const method = submitter?.getAttribute("formmethod") || formElement.getAttribute("method") || "";
    return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
  }
  function getEnctype(formElement, submitter) {
    return fetchEnctypeFromString(submitter?.getAttribute("formenctype") || formElement.enctype);
  }
  var Snapshot = class {
    constructor(element) {
      this.element = element;
    }
    get activeElement() {
      return this.element.ownerDocument.activeElement;
    }
    get children() {
      return [...this.element.children];
    }
    hasAnchor(anchor) {
      return this.getElementForAnchor(anchor) != null;
    }
    getElementForAnchor(anchor) {
      return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
    }
    get isConnected() {
      return this.element.isConnected;
    }
    get firstAutofocusableElement() {
      return queryAutofocusableElement(this.element);
    }
    get permanentElements() {
      return queryPermanentElementsAll(this.element);
    }
    getPermanentElementById(id) {
      return getPermanentElementById(this.element, id);
    }
    getPermanentElementMapForSnapshot(snapshot) {
      const permanentElementMap = {};
      for (const currentPermanentElement of this.permanentElements) {
        const { id } = currentPermanentElement;
        const newPermanentElement = snapshot.getPermanentElementById(id);
        if (newPermanentElement) {
          permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
        }
      }
      return permanentElementMap;
    }
  };
  function getPermanentElementById(node, id) {
    return node.querySelector(`#${id}[data-turbo-permanent]`);
  }
  function queryPermanentElementsAll(node) {
    return node.querySelectorAll("[id][data-turbo-permanent]");
  }
  var FormSubmitObserver = class {
    started = false;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("submit", this.submitCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
        this.started = false;
      }
    }
    submitCaptured = () => {
      this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
      this.eventTarget.addEventListener("submit", this.submitBubbled, false);
    };
    submitBubbled = (event) => {
      if (!event.defaultPrevented) {
        const form = event.target instanceof HTMLFormElement ? event.target : void 0;
        const submitter = event.submitter || void 0;
        if (form && submissionDoesNotDismissDialog(form, submitter) && submissionDoesNotTargetIFrame(form, submitter) && this.delegate.willSubmitForm(form, submitter)) {
          event.preventDefault();
          event.stopImmediatePropagation();
          this.delegate.formSubmitted(form, submitter);
        }
      }
    };
  };
  function submissionDoesNotDismissDialog(form, submitter) {
    const method = submitter?.getAttribute("formmethod") || form.getAttribute("method");
    return method != "dialog";
  }
  function submissionDoesNotTargetIFrame(form, submitter) {
    if (submitter?.hasAttribute("formtarget") || form.hasAttribute("target")) {
      const target = submitter?.getAttribute("formtarget") || form.target;
      for (const element of document.getElementsByName(target)) {
        if (element instanceof HTMLIFrameElement)
          return false;
      }
      return true;
    } else {
      return true;
    }
  }
  var View = class {
    #resolveRenderPromise = (_value) => {
    };
    #resolveInterceptionPromise = (_value) => {
    };
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
    }
    // Scrolling
    scrollToAnchor(anchor) {
      const element = this.snapshot.getElementForAnchor(anchor);
      if (element) {
        this.scrollToElement(element);
        this.focusElement(element);
      } else {
        this.scrollToPosition({ x: 0, y: 0 });
      }
    }
    scrollToAnchorFromLocation(location2) {
      this.scrollToAnchor(getAnchor(location2));
    }
    scrollToElement(element) {
      element.scrollIntoView();
    }
    focusElement(element) {
      if (element instanceof HTMLElement) {
        if (element.hasAttribute("tabindex")) {
          element.focus();
        } else {
          element.setAttribute("tabindex", "-1");
          element.focus();
          element.removeAttribute("tabindex");
        }
      }
    }
    scrollToPosition({ x, y }) {
      this.scrollRoot.scrollTo(x, y);
    }
    scrollToTop() {
      this.scrollToPosition({ x: 0, y: 0 });
    }
    get scrollRoot() {
      return window;
    }
    // Rendering
    async render(renderer2) {
      const { isPreview, shouldRender, willRender, newSnapshot: snapshot } = renderer2;
      const shouldInvalidate = willRender;
      if (shouldRender) {
        try {
          this.renderPromise = new Promise((resolve2) => this.#resolveRenderPromise = resolve2);
          this.renderer = renderer2;
          await this.prepareToRenderSnapshot(renderer2);
          const renderInterception = new Promise((resolve2) => this.#resolveInterceptionPromise = resolve2);
          const options = { resume: this.#resolveInterceptionPromise, render: this.renderer.renderElement, renderMethod: this.renderer.renderMethod };
          const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
          if (!immediateRender)
            await renderInterception;
          await this.renderSnapshot(renderer2);
          this.delegate.viewRenderedSnapshot(snapshot, isPreview, this.renderer.renderMethod);
          this.delegate.preloadOnLoadLinksForView(this.element);
          this.finishRenderingSnapshot(renderer2);
        } finally {
          delete this.renderer;
          this.#resolveRenderPromise(void 0);
          delete this.renderPromise;
        }
      } else if (shouldInvalidate) {
        this.invalidate(renderer2.reloadReason);
      }
    }
    invalidate(reason) {
      this.delegate.viewInvalidated(reason);
    }
    async prepareToRenderSnapshot(renderer2) {
      this.markAsPreview(renderer2.isPreview);
      await renderer2.prepareToRender();
    }
    markAsPreview(isPreview) {
      if (isPreview) {
        this.element.setAttribute("data-turbo-preview", "");
      } else {
        this.element.removeAttribute("data-turbo-preview");
      }
    }
    markVisitDirection(direction) {
      this.element.setAttribute("data-turbo-visit-direction", direction);
    }
    unmarkVisitDirection() {
      this.element.removeAttribute("data-turbo-visit-direction");
    }
    async renderSnapshot(renderer2) {
      await renderer2.render();
    }
    finishRenderingSnapshot(renderer2) {
      renderer2.finishRendering();
    }
  };
  var FrameView = class extends View {
    missing() {
      this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
    }
    get snapshot() {
      return new Snapshot(this.element);
    }
  };
  var LinkInterceptor = class {
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("click", this.clickBubbled);
      document.addEventListener("turbo:click", this.linkClicked);
      document.addEventListener("turbo:before-visit", this.willVisit);
    }
    stop() {
      this.element.removeEventListener("click", this.clickBubbled);
      document.removeEventListener("turbo:click", this.linkClicked);
      document.removeEventListener("turbo:before-visit", this.willVisit);
    }
    clickBubbled = (event) => {
      if (this.respondsToEventTarget(event.target)) {
        this.clickEvent = event;
      } else {
        delete this.clickEvent;
      }
    };
    linkClicked = (event) => {
      if (this.clickEvent && this.respondsToEventTarget(event.target) && event.target instanceof Element) {
        if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
          this.clickEvent.preventDefault();
          event.preventDefault();
          this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
        }
      }
      delete this.clickEvent;
    };
    willVisit = (_event) => {
      delete this.clickEvent;
    };
    respondsToEventTarget(target) {
      const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
      return element && element.closest("turbo-frame, html") == this.element;
    }
  };
  var LinkClickObserver = class {
    started = false;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("click", this.clickCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("click", this.clickCaptured, true);
        this.started = false;
      }
    }
    clickCaptured = () => {
      this.eventTarget.removeEventListener("click", this.clickBubbled, false);
      this.eventTarget.addEventListener("click", this.clickBubbled, false);
    };
    clickBubbled = (event) => {
      if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
        const target = event.composedPath && event.composedPath()[0] || event.target;
        const link = findLinkFromClickTarget(target);
        if (link && doesNotTargetIFrame(link)) {
          const location2 = getLocationForLink(link);
          if (this.delegate.willFollowLinkToLocation(link, location2, event)) {
            event.preventDefault();
            this.delegate.followedLinkToLocation(link, location2);
          }
        }
      }
    };
    clickEventIsSignificant(event) {
      return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
    }
  };
  var FormLinkClickObserver = class {
    constructor(delegate, element) {
      this.delegate = delegate;
      this.linkInterceptor = new LinkClickObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
    }
    stop() {
      this.linkInterceptor.stop();
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link, location2) {
      return false;
    }
    prefetchAndCacheRequestToLocation(link, location2) {
      return;
    }
    // Link click observer delegate
    willFollowLinkToLocation(link, location2, originalEvent) {
      return this.delegate.willSubmitFormLinkToLocation(link, location2, originalEvent) && (link.hasAttribute("data-turbo-method") || link.hasAttribute("data-turbo-stream"));
    }
    followedLinkToLocation(link, location2) {
      const form = document.createElement("form");
      const type = "hidden";
      for (const [name, value] of location2.searchParams) {
        form.append(Object.assign(document.createElement("input"), { type, name, value }));
      }
      const action = Object.assign(location2, { search: "" });
      form.setAttribute("data-turbo", "true");
      form.setAttribute("action", action.href);
      form.setAttribute("hidden", "");
      const method = link.getAttribute("data-turbo-method");
      if (method)
        form.setAttribute("method", method);
      const turboFrame = link.getAttribute("data-turbo-frame");
      if (turboFrame)
        form.setAttribute("data-turbo-frame", turboFrame);
      const turboAction = getVisitAction(link);
      if (turboAction)
        form.setAttribute("data-turbo-action", turboAction);
      const turboConfirm = link.getAttribute("data-turbo-confirm");
      if (turboConfirm)
        form.setAttribute("data-turbo-confirm", turboConfirm);
      const turboStream = link.hasAttribute("data-turbo-stream");
      if (turboStream)
        form.setAttribute("data-turbo-stream", "");
      this.delegate.submittedFormLinkToLocation(link, location2, form);
      document.body.appendChild(form);
      form.addEventListener("turbo:submit-end", () => form.remove(), { once: true });
      requestAnimationFrame(() => form.requestSubmit());
    }
  };
  var Bardo = class {
    static async preservingPermanentElements(delegate, permanentElementMap, callback) {
      const bardo = new this(delegate, permanentElementMap);
      bardo.enter();
      await callback();
      bardo.leave();
    }
    constructor(delegate, permanentElementMap) {
      this.delegate = delegate;
      this.permanentElementMap = permanentElementMap;
    }
    enter() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id];
        this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
      }
    }
    leave() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement] = this.permanentElementMap[id];
        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
        this.replacePlaceholderWithPermanentElement(currentPermanentElement);
        this.delegate.leavingBardo(currentPermanentElement);
      }
    }
    replaceNewPermanentElementWithPlaceholder(permanentElement) {
      const placeholder = createPlaceholderForPermanentElement(permanentElement);
      permanentElement.replaceWith(placeholder);
    }
    replaceCurrentPermanentElementWithClone(permanentElement) {
      const clone = permanentElement.cloneNode(true);
      permanentElement.replaceWith(clone);
    }
    replacePlaceholderWithPermanentElement(permanentElement) {
      const placeholder = this.getPlaceholderById(permanentElement.id);
      placeholder?.replaceWith(permanentElement);
    }
    getPlaceholderById(id) {
      return this.placeholders.find((element) => element.content == id);
    }
    get placeholders() {
      return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
    }
  };
  function createPlaceholderForPermanentElement(permanentElement) {
    const element = document.createElement("meta");
    element.setAttribute("name", "turbo-permanent-placeholder");
    element.setAttribute("content", permanentElement.id);
    return element;
  }
  var Renderer = class {
    #activeElement = null;
    constructor(currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      this.currentSnapshot = currentSnapshot;
      this.newSnapshot = newSnapshot;
      this.isPreview = isPreview;
      this.willRender = willRender;
      this.renderElement = renderElement;
      this.promise = new Promise((resolve2, reject) => this.resolvingFunctions = { resolve: resolve2, reject });
    }
    get shouldRender() {
      return true;
    }
    get reloadReason() {
      return;
    }
    prepareToRender() {
      return;
    }
    render() {
    }
    finishRendering() {
      if (this.resolvingFunctions) {
        this.resolvingFunctions.resolve();
        delete this.resolvingFunctions;
      }
    }
    async preservingPermanentElements(callback) {
      await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
    }
    focusFirstAutofocusableElement() {
      const element = this.connectedSnapshot.firstAutofocusableElement;
      if (element) {
        element.focus();
      }
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement) {
      if (this.#activeElement)
        return;
      if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
        this.#activeElement = this.currentSnapshot.activeElement;
      }
    }
    leavingBardo(currentPermanentElement) {
      if (currentPermanentElement.contains(this.#activeElement) && this.#activeElement instanceof HTMLElement) {
        this.#activeElement.focus();
        this.#activeElement = null;
      }
    }
    get connectedSnapshot() {
      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
    }
    get currentElement() {
      return this.currentSnapshot.element;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    get permanentElementMap() {
      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
    }
    get renderMethod() {
      return "replace";
    }
  };
  var FrameRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      const destinationRange = document.createRange();
      destinationRange.selectNodeContents(currentElement);
      destinationRange.deleteContents();
      const frameElement = newElement;
      const sourceRange = frameElement.ownerDocument?.createRange();
      if (sourceRange) {
        sourceRange.selectNodeContents(frameElement);
        currentElement.appendChild(sourceRange.extractContents());
      }
    }
    constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
      this.delegate = delegate;
    }
    get shouldRender() {
      return true;
    }
    async render() {
      await nextRepaint();
      this.preservingPermanentElements(() => {
        this.loadFrameElement();
      });
      this.scrollFrameIntoView();
      await nextRepaint();
      this.focusFirstAutofocusableElement();
      await nextRepaint();
      this.activateScriptElements();
    }
    loadFrameElement() {
      this.delegate.willRenderFrame(this.currentElement, this.newElement);
      this.renderElement(this.currentElement, this.newElement);
    }
    scrollFrameIntoView() {
      if (this.currentElement.autoscroll || this.newElement.autoscroll) {
        const element = this.currentElement.firstElementChild;
        const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
        const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
        if (element) {
          element.scrollIntoView({ block, behavior });
          return true;
        }
      }
      return false;
    }
    activateScriptElements() {
      for (const inertScriptElement of this.newScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    get newScriptElements() {
      return this.currentElement.querySelectorAll("script");
    }
  };
  function readScrollLogicalPosition(value, defaultValue) {
    if (value == "end" || value == "start" || value == "center" || value == "nearest") {
      return value;
    } else {
      return defaultValue;
    }
  }
  function readScrollBehavior(value, defaultValue) {
    if (value == "auto" || value == "smooth") {
      return value;
    } else {
      return defaultValue;
    }
  }
  var ProgressBar = class _ProgressBar {
    static animationDuration = 300;
    /*ms*/
    static get defaultCSS() {
      return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${_ProgressBar.animationDuration}ms ease-out,
          opacity ${_ProgressBar.animationDuration / 2}ms ${_ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
    }
    hiding = false;
    value = 0;
    visible = false;
    constructor() {
      this.stylesheetElement = this.createStylesheetElement();
      this.progressElement = this.createProgressElement();
      this.installStylesheetElement();
      this.setValue(0);
    }
    show() {
      if (!this.visible) {
        this.visible = true;
        this.installProgressElement();
        this.startTrickling();
      }
    }
    hide() {
      if (this.visible && !this.hiding) {
        this.hiding = true;
        this.fadeProgressElement(() => {
          this.uninstallProgressElement();
          this.stopTrickling();
          this.visible = false;
          this.hiding = false;
        });
      }
    }
    setValue(value) {
      this.value = value;
      this.refresh();
    }
    // Private
    installStylesheetElement() {
      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
      this.progressElement.style.width = "0";
      this.progressElement.style.opacity = "1";
      document.documentElement.insertBefore(this.progressElement, document.body);
      this.refresh();
    }
    fadeProgressElement(callback) {
      this.progressElement.style.opacity = "0";
      setTimeout(callback, _ProgressBar.animationDuration * 1.5);
    }
    uninstallProgressElement() {
      if (this.progressElement.parentNode) {
        document.documentElement.removeChild(this.progressElement);
      }
    }
    startTrickling() {
      if (!this.trickleInterval) {
        this.trickleInterval = window.setInterval(this.trickle, _ProgressBar.animationDuration);
      }
    }
    stopTrickling() {
      window.clearInterval(this.trickleInterval);
      delete this.trickleInterval;
    }
    trickle = () => {
      this.setValue(this.value + Math.random() / 100);
    };
    refresh() {
      requestAnimationFrame(() => {
        this.progressElement.style.width = `${10 + this.value * 90}%`;
      });
    }
    createStylesheetElement() {
      const element = document.createElement("style");
      element.type = "text/css";
      element.textContent = _ProgressBar.defaultCSS;
      if (this.cspNonce) {
        element.nonce = this.cspNonce;
      }
      return element;
    }
    createProgressElement() {
      const element = document.createElement("div");
      element.className = "turbo-progress-bar";
      return element;
    }
    get cspNonce() {
      return getMetaContent("csp-nonce");
    }
  };
  var HeadSnapshot = class extends Snapshot {
    detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
      const { outerHTML } = element;
      const details = outerHTML in result ? result[outerHTML] : {
        type: elementType(element),
        tracked: elementIsTracked(element),
        elements: []
      };
      return {
        ...result,
        [outerHTML]: {
          ...details,
          elements: [...details.elements, element]
        }
      };
    }, {});
    get trackedElementSignature() {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
    }
    getScriptElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
    }
    getStylesheetElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
    }
    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
    }
    get provisionalElements() {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
        if (type == null && !tracked) {
          return [...result, ...elements];
        } else if (elements.length > 1) {
          return [...result, ...elements.slice(1)];
        } else {
          return result;
        }
      }, []);
    }
    getMetaValue(name) {
      const element = this.findMetaElementByName(name);
      return element ? element.getAttribute("content") : null;
    }
    findMetaElementByName(name) {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const {
          elements: [element]
        } = this.detailsByOuterHTML[outerHTML];
        return elementIsMetaElementWithName(element, name) ? element : result;
      }, void 0 | void 0);
    }
  };
  function elementType(element) {
    if (elementIsScript(element)) {
      return "script";
    } else if (elementIsStylesheet(element)) {
      return "stylesheet";
    }
  }
  function elementIsTracked(element) {
    return element.getAttribute("data-turbo-track") == "reload";
  }
  function elementIsScript(element) {
    const tagName = element.localName;
    return tagName == "script";
  }
  function elementIsNoscript(element) {
    const tagName = element.localName;
    return tagName == "noscript";
  }
  function elementIsStylesheet(element) {
    const tagName = element.localName;
    return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
  }
  function elementIsMetaElementWithName(element, name) {
    const tagName = element.localName;
    return tagName == "meta" && element.getAttribute("name") == name;
  }
  function elementWithoutNonce(element) {
    if (element.hasAttribute("nonce")) {
      element.setAttribute("nonce", "");
    }
    return element;
  }
  var PageSnapshot = class _PageSnapshot extends Snapshot {
    static fromHTMLString(html = "") {
      return this.fromDocument(parseHTMLDocument(html));
    }
    static fromElement(element) {
      return this.fromDocument(element.ownerDocument);
    }
    static fromDocument({ documentElement, body, head }) {
      return new this(documentElement, body, new HeadSnapshot(head));
    }
    constructor(documentElement, body, headSnapshot) {
      super(body);
      this.documentElement = documentElement;
      this.headSnapshot = headSnapshot;
    }
    clone() {
      const clonedElement = this.element.cloneNode(true);
      const selectElements = this.element.querySelectorAll("select");
      const clonedSelectElements = clonedElement.querySelectorAll("select");
      for (const [index, source] of selectElements.entries()) {
        const clone = clonedSelectElements[index];
        for (const option of clone.selectedOptions)
          option.selected = false;
        for (const option of source.selectedOptions)
          clone.options[option.index].selected = true;
      }
      for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
        clonedPasswordInput.value = "";
      }
      return new _PageSnapshot(this.documentElement, clonedElement, this.headSnapshot);
    }
    get lang() {
      return this.documentElement.getAttribute("lang");
    }
    get headElement() {
      return this.headSnapshot.element;
    }
    get rootLocation() {
      const root = this.getSetting("root") ?? "/";
      return expandURL(root);
    }
    get cacheControlValue() {
      return this.getSetting("cache-control");
    }
    get isPreviewable() {
      return this.cacheControlValue != "no-preview";
    }
    get isCacheable() {
      return this.cacheControlValue != "no-cache";
    }
    get isVisitable() {
      return this.getSetting("visit-control") != "reload";
    }
    get prefersViewTransitions() {
      return this.headSnapshot.getMetaValue("view-transition") === "same-origin";
    }
    get shouldMorphPage() {
      return this.getSetting("refresh-method") === "morph";
    }
    get shouldPreserveScrollPosition() {
      return this.getSetting("refresh-scroll") === "preserve";
    }
    // Private
    getSetting(name) {
      return this.headSnapshot.getMetaValue(`turbo-${name}`);
    }
  };
  var ViewTransitioner = class {
    #viewTransitionStarted = false;
    #lastOperation = Promise.resolve();
    renderChange(useViewTransition, render2) {
      if (useViewTransition && this.viewTransitionsAvailable && !this.#viewTransitionStarted) {
        this.#viewTransitionStarted = true;
        this.#lastOperation = this.#lastOperation.then(async () => {
          await document.startViewTransition(render2).finished;
        });
      } else {
        this.#lastOperation = this.#lastOperation.then(render2);
      }
      return this.#lastOperation;
    }
    get viewTransitionsAvailable() {
      return document.startViewTransition;
    }
  };
  var defaultOptions = {
    action: "advance",
    historyChanged: false,
    visitCachedSnapshot: () => {
    },
    willRender: true,
    updateHistory: true,
    shouldCacheSnapshot: true,
    acceptsStreamResponse: false
  };
  var TimingMetric = {
    visitStart: "visitStart",
    requestStart: "requestStart",
    requestEnd: "requestEnd",
    visitEnd: "visitEnd"
  };
  var VisitState = {
    initialized: "initialized",
    started: "started",
    canceled: "canceled",
    failed: "failed",
    completed: "completed"
  };
  var SystemStatusCode = {
    networkFailure: 0,
    timeoutFailure: -1,
    contentTypeMismatch: -2
  };
  var Direction = {
    advance: "forward",
    restore: "back",
    replace: "none"
  };
  var Visit = class {
    identifier = uuid();
    // Required by turbo-ios
    timingMetrics = {};
    followedRedirect = false;
    historyChanged = false;
    scrolled = false;
    shouldCacheSnapshot = true;
    acceptsStreamResponse = false;
    snapshotCached = false;
    state = VisitState.initialized;
    viewTransitioner = new ViewTransitioner();
    constructor(delegate, location2, restorationIdentifier, options = {}) {
      this.delegate = delegate;
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier || uuid();
      const {
        action,
        historyChanged,
        referrer,
        snapshot,
        snapshotHTML,
        response,
        visitCachedSnapshot,
        willRender,
        updateHistory,
        shouldCacheSnapshot,
        acceptsStreamResponse,
        direction
      } = {
        ...defaultOptions,
        ...options
      };
      this.action = action;
      this.historyChanged = historyChanged;
      this.referrer = referrer;
      this.snapshot = snapshot;
      this.snapshotHTML = snapshotHTML;
      this.response = response;
      this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
      this.isPageRefresh = this.view.isPageRefresh(this);
      this.visitCachedSnapshot = visitCachedSnapshot;
      this.willRender = willRender;
      this.updateHistory = updateHistory;
      this.scrolled = !willRender;
      this.shouldCacheSnapshot = shouldCacheSnapshot;
      this.acceptsStreamResponse = acceptsStreamResponse;
      this.direction = direction || Direction[action];
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    get restorationData() {
      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
    }
    get silent() {
      return this.isSamePage;
    }
    start() {
      if (this.state == VisitState.initialized) {
        this.recordTimingMetric(TimingMetric.visitStart);
        this.state = VisitState.started;
        this.adapter.visitStarted(this);
        this.delegate.visitStarted(this);
      }
    }
    cancel() {
      if (this.state == VisitState.started) {
        if (this.request) {
          this.request.cancel();
        }
        this.cancelRender();
        this.state = VisitState.canceled;
      }
    }
    complete() {
      if (this.state == VisitState.started) {
        this.recordTimingMetric(TimingMetric.visitEnd);
        this.adapter.visitCompleted(this);
        this.state = VisitState.completed;
        this.followRedirect();
        if (!this.followedRedirect) {
          this.delegate.visitCompleted(this);
        }
      }
    }
    fail() {
      if (this.state == VisitState.started) {
        this.state = VisitState.failed;
        this.adapter.visitFailed(this);
        this.delegate.visitCompleted(this);
      }
    }
    changeHistory() {
      if (!this.historyChanged && this.updateHistory) {
        const actionForHistory = this.location.href === this.referrer?.href ? "replace" : this.action;
        const method = getHistoryMethodForAction(actionForHistory);
        this.history.update(method, this.location, this.restorationIdentifier);
        this.historyChanged = true;
      }
    }
    issueRequest() {
      if (this.hasPreloadedResponse()) {
        this.simulateRequest();
      } else if (this.shouldIssueRequest() && !this.request) {
        this.request = new FetchRequest(this, FetchMethod.get, this.location);
        this.request.perform();
      }
    }
    simulateRequest() {
      if (this.response) {
        this.startRequest();
        this.recordResponse();
        this.finishRequest();
      }
    }
    startRequest() {
      this.recordTimingMetric(TimingMetric.requestStart);
      this.adapter.visitRequestStarted(this);
    }
    recordResponse(response = this.response) {
      this.response = response;
      if (response) {
        const { statusCode } = response;
        if (isSuccessful(statusCode)) {
          this.adapter.visitRequestCompleted(this);
        } else {
          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
        }
      }
    }
    finishRequest() {
      this.recordTimingMetric(TimingMetric.requestEnd);
      this.adapter.visitRequestFinished(this);
    }
    loadResponse() {
      if (this.response) {
        const { statusCode, responseHTML } = this.response;
        this.render(async () => {
          if (this.shouldCacheSnapshot)
            this.cacheSnapshot();
          if (this.view.renderPromise)
            await this.view.renderPromise;
          if (isSuccessful(statusCode) && responseHTML != null) {
            const snapshot = PageSnapshot.fromHTMLString(responseHTML);
            await this.renderPageSnapshot(snapshot, false);
            this.adapter.visitRendered(this);
            this.complete();
          } else {
            await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
            this.adapter.visitRendered(this);
            this.fail();
          }
        });
      }
    }
    getCachedSnapshot() {
      const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
        if (this.action == "restore" || snapshot.isPreviewable) {
          return snapshot;
        }
      }
    }
    getPreloadedSnapshot() {
      if (this.snapshotHTML) {
        return PageSnapshot.fromHTMLString(this.snapshotHTML);
      }
    }
    hasCachedSnapshot() {
      return this.getCachedSnapshot() != null;
    }
    loadCachedSnapshot() {
      const snapshot = this.getCachedSnapshot();
      if (snapshot) {
        const isPreview = this.shouldIssueRequest();
        this.render(async () => {
          this.cacheSnapshot();
          if (this.isSamePage || this.isPageRefresh) {
            this.adapter.visitRendered(this);
          } else {
            if (this.view.renderPromise)
              await this.view.renderPromise;
            await this.renderPageSnapshot(snapshot, isPreview);
            this.adapter.visitRendered(this);
            if (!isPreview) {
              this.complete();
            }
          }
        });
      }
    }
    followRedirect() {
      if (this.redirectedToLocation && !this.followedRedirect && this.response?.redirected) {
        this.adapter.visitProposedToLocation(this.redirectedToLocation, {
          action: "replace",
          response: this.response,
          shouldCacheSnapshot: false,
          willRender: false
        });
        this.followedRedirect = true;
      }
    }
    goToSamePageAnchor() {
      if (this.isSamePage) {
        this.render(async () => {
          this.cacheSnapshot();
          this.performScroll();
          this.changeHistory();
          this.adapter.visitRendered(this);
        });
      }
    }
    // Fetch request delegate
    prepareRequest(request) {
      if (this.acceptsStreamResponse) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted() {
      this.startRequest();
    }
    requestPreventedHandlingResponse(_request, _response) {
    }
    async requestSucceededWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.redirectedToLocation = response.redirected ? response.location : void 0;
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    async requestFailedWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    requestErrored(_request, _error) {
      this.recordResponse({
        statusCode: SystemStatusCode.networkFailure,
        redirected: false
      });
    }
    requestFinished() {
      this.finishRequest();
    }
    // Scrolling
    performScroll() {
      if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {
        if (this.action == "restore") {
          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
        } else {
          this.scrollToAnchor() || this.view.scrollToTop();
        }
        if (this.isSamePage) {
          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
        }
        this.scrolled = true;
      }
    }
    scrollToRestoredPosition() {
      const { scrollPosition } = this.restorationData;
      if (scrollPosition) {
        this.view.scrollToPosition(scrollPosition);
        return true;
      }
    }
    scrollToAnchor() {
      const anchor = getAnchor(this.location);
      if (anchor != null) {
        this.view.scrollToAnchor(anchor);
        return true;
      }
    }
    // Instrumentation
    recordTimingMetric(metric) {
      this.timingMetrics[metric] = (/* @__PURE__ */ new Date()).getTime();
    }
    getTimingMetrics() {
      return { ...this.timingMetrics };
    }
    // Private
    getHistoryMethodForAction(action) {
      switch (action) {
        case "replace":
          return history.replaceState;
        case "advance":
        case "restore":
          return history.pushState;
      }
    }
    hasPreloadedResponse() {
      return typeof this.response == "object";
    }
    shouldIssueRequest() {
      if (this.isSamePage) {
        return false;
      } else if (this.action == "restore") {
        return !this.hasCachedSnapshot();
      } else {
        return this.willRender;
      }
    }
    cacheSnapshot() {
      if (!this.snapshotCached) {
        this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
        this.snapshotCached = true;
      }
    }
    async render(callback) {
      this.cancelRender();
      this.frame = await nextRepaint();
      await callback();
      delete this.frame;
    }
    async renderPageSnapshot(snapshot, isPreview) {
      await this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), async () => {
        await this.view.renderPage(snapshot, isPreview, this.willRender, this);
        this.performScroll();
      });
    }
    cancelRender() {
      if (this.frame) {
        cancelAnimationFrame(this.frame);
        delete this.frame;
      }
    }
  };
  function isSuccessful(statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }
  var BrowserAdapter = class {
    progressBar = new ProgressBar();
    constructor(session2) {
      this.session = session2;
    }
    visitProposedToLocation(location2, options) {
      if (locationIsVisitable(location2, this.navigator.rootLocation)) {
        this.navigator.startVisit(location2, options?.restorationIdentifier || uuid(), options);
      } else {
        window.location.href = location2.toString();
      }
    }
    visitStarted(visit2) {
      this.location = visit2.location;
      visit2.loadCachedSnapshot();
      visit2.issueRequest();
      visit2.goToSamePageAnchor();
    }
    visitRequestStarted(visit2) {
      this.progressBar.setValue(0);
      if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
        this.showVisitProgressBarAfterDelay();
      } else {
        this.showProgressBar();
      }
    }
    visitRequestCompleted(visit2) {
      visit2.loadResponse();
    }
    visitRequestFailedWithStatusCode(visit2, statusCode) {
      switch (statusCode) {
        case SystemStatusCode.networkFailure:
        case SystemStatusCode.timeoutFailure:
        case SystemStatusCode.contentTypeMismatch:
          return this.reload({
            reason: "request_failed",
            context: {
              statusCode
            }
          });
        default:
          return visit2.loadResponse();
      }
    }
    visitRequestFinished(_visit) {
    }
    visitCompleted(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    pageInvalidated(reason) {
      this.reload(reason);
    }
    visitFailed(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    visitRendered(_visit) {
    }
    // Form Submission Delegate
    formSubmissionStarted(_formSubmission) {
      this.progressBar.setValue(0);
      this.showFormProgressBarAfterDelay();
    }
    formSubmissionFinished(_formSubmission) {
      this.progressBar.setValue(1);
      this.hideFormProgressBar();
    }
    // Private
    showVisitProgressBarAfterDelay() {
      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
    hideVisitProgressBar() {
      this.progressBar.hide();
      if (this.visitProgressBarTimeout != null) {
        window.clearTimeout(this.visitProgressBarTimeout);
        delete this.visitProgressBarTimeout;
      }
    }
    showFormProgressBarAfterDelay() {
      if (this.formProgressBarTimeout == null) {
        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
      }
    }
    hideFormProgressBar() {
      this.progressBar.hide();
      if (this.formProgressBarTimeout != null) {
        window.clearTimeout(this.formProgressBarTimeout);
        delete this.formProgressBarTimeout;
      }
    }
    showProgressBar = () => {
      this.progressBar.show();
    };
    reload(reason) {
      dispatch("turbo:reload", { detail: reason });
      window.location.href = this.location?.toString() || window.location.href;
    }
    get navigator() {
      return this.session.navigator;
    }
  };
  var CacheObserver = class {
    selector = "[data-turbo-temporary]";
    deprecatedSelector = "[data-turbo-cache=false]";
    started = false;
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    removeTemporaryElements = (_event) => {
      for (const element of this.temporaryElements) {
        element.remove();
      }
    };
    get temporaryElements() {
      return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
    }
    get temporaryElementsWithDeprecation() {
      const elements = document.querySelectorAll(this.deprecatedSelector);
      if (elements.length) {
        console.warn(
          `The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`
        );
      }
      return [...elements];
    }
  };
  var FrameRedirector = class {
    constructor(session2, element) {
      this.session = session2;
      this.element = element;
      this.linkInterceptor = new LinkInterceptor(this, element);
      this.formSubmitObserver = new FormSubmitObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
    stop() {
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return this.#shouldRedirect(element);
    }
    linkClickIntercepted(element, url, event) {
      const frame = this.#findFrameElement(element);
      if (frame) {
        frame.delegate.linkClickIntercepted(element, url, event);
      }
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter) {
      return element.closest("turbo-frame") == null && this.#shouldSubmit(element, submitter) && this.#shouldRedirect(element, submitter);
    }
    formSubmitted(element, submitter) {
      const frame = this.#findFrameElement(element, submitter);
      if (frame) {
        frame.delegate.formSubmitted(element, submitter);
      }
    }
    #shouldSubmit(form, submitter) {
      const action = getAction$1(form, submitter);
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const rootLocation = expandURL(meta?.content ?? "/");
      return this.#shouldRedirect(form, submitter) && locationIsVisitable(action, rootLocation);
    }
    #shouldRedirect(element, submitter) {
      const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter) : this.session.elementIsNavigatable(element);
      if (isNavigatable) {
        const frame = this.#findFrameElement(element, submitter);
        return frame ? frame != element.closest("turbo-frame") : false;
      } else {
        return false;
      }
    }
    #findFrameElement(element, submitter) {
      const id = submitter?.getAttribute("data-turbo-frame") || element.getAttribute("data-turbo-frame");
      if (id && id != "_top") {
        const frame = this.element.querySelector(`#${id}:not([disabled])`);
        if (frame instanceof FrameElement) {
          return frame;
        }
      }
    }
  };
  var History = class {
    location;
    restorationIdentifier = uuid();
    restorationData = {};
    started = false;
    pageLoaded = false;
    currentIndex = 0;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("popstate", this.onPopState, false);
        addEventListener("load", this.onPageLoad, false);
        this.currentIndex = history.state?.turbo?.restorationIndex || 0;
        this.started = true;
        this.replace(new URL(window.location.href));
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("popstate", this.onPopState, false);
        removeEventListener("load", this.onPageLoad, false);
        this.started = false;
      }
    }
    push(location2, restorationIdentifier) {
      this.update(history.pushState, location2, restorationIdentifier);
    }
    replace(location2, restorationIdentifier) {
      this.update(history.replaceState, location2, restorationIdentifier);
    }
    update(method, location2, restorationIdentifier = uuid()) {
      if (method === history.pushState)
        ++this.currentIndex;
      const state = { turbo: { restorationIdentifier, restorationIndex: this.currentIndex } };
      method.call(history, state, "", location2.href);
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier;
    }
    // Restoration data
    getRestorationDataForIdentifier(restorationIdentifier) {
      return this.restorationData[restorationIdentifier] || {};
    }
    updateRestorationData(additionalData) {
      const { restorationIdentifier } = this;
      const restorationData = this.restorationData[restorationIdentifier];
      this.restorationData[restorationIdentifier] = {
        ...restorationData,
        ...additionalData
      };
    }
    // Scroll restoration
    assumeControlOfScrollRestoration() {
      if (!this.previousScrollRestoration) {
        this.previousScrollRestoration = history.scrollRestoration ?? "auto";
        history.scrollRestoration = "manual";
      }
    }
    relinquishControlOfScrollRestoration() {
      if (this.previousScrollRestoration) {
        history.scrollRestoration = this.previousScrollRestoration;
        delete this.previousScrollRestoration;
      }
    }
    // Event handlers
    onPopState = (event) => {
      if (this.shouldHandlePopState()) {
        const { turbo } = event.state || {};
        if (turbo) {
          this.location = new URL(window.location.href);
          const { restorationIdentifier, restorationIndex } = turbo;
          this.restorationIdentifier = restorationIdentifier;
          const direction = restorationIndex > this.currentIndex ? "forward" : "back";
          this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, restorationIdentifier, direction);
          this.currentIndex = restorationIndex;
        }
      }
    };
    onPageLoad = async (_event) => {
      await nextMicrotask();
      this.pageLoaded = true;
    };
    // Private
    shouldHandlePopState() {
      return this.pageIsLoaded();
    }
    pageIsLoaded() {
      return this.pageLoaded || document.readyState == "complete";
    }
  };
  var LinkPrefetchObserver = class {
    started = false;
    #prefetchedLink = null;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (this.started)
        return;
      if (this.eventTarget.readyState === "loading") {
        this.eventTarget.addEventListener("DOMContentLoaded", this.#enable, { once: true });
      } else {
        this.#enable();
      }
    }
    stop() {
      if (!this.started)
        return;
      this.eventTarget.removeEventListener("mouseenter", this.#tryToPrefetchRequest, {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("mouseleave", this.#cancelRequestIfObsolete, {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
      this.started = false;
    }
    #enable = () => {
      this.eventTarget.addEventListener("mouseenter", this.#tryToPrefetchRequest, {
        capture: true,
        passive: true
      });
      this.eventTarget.addEventListener("mouseleave", this.#cancelRequestIfObsolete, {
        capture: true,
        passive: true
      });
      this.eventTarget.addEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
      this.started = true;
    };
    #tryToPrefetchRequest = (event) => {
      if (getMetaContent("turbo-prefetch") === "false")
        return;
      const target = event.target;
      const isLink = target.matches && target.matches("a[href]:not([target^=_]):not([download])");
      if (isLink && this.#isPrefetchable(target)) {
        const link = target;
        const location2 = getLocationForLink(link);
        if (this.delegate.canPrefetchRequestToLocation(link, location2)) {
          this.#prefetchedLink = link;
          const fetchRequest = new FetchRequest(
            this,
            FetchMethod.get,
            location2,
            new URLSearchParams(),
            target
          );
          prefetchCache.setLater(location2.toString(), fetchRequest, this.#cacheTtl);
        }
      }
    };
    #cancelRequestIfObsolete = (event) => {
      if (event.target === this.#prefetchedLink)
        this.#cancelPrefetchRequest();
    };
    #cancelPrefetchRequest = () => {
      prefetchCache.clear();
      this.#prefetchedLink = null;
    };
    #tryToUsePrefetchedRequest = (event) => {
      if (event.target.tagName !== "FORM" && event.detail.fetchOptions.method === "get") {
        const cached = prefetchCache.get(event.detail.url.toString());
        if (cached) {
          event.detail.fetchRequest = cached;
        }
        prefetchCache.clear();
      }
    };
    prepareRequest(request) {
      const link = request.target;
      request.headers["X-Sec-Purpose"] = "prefetch";
      const turboFrame = link.closest("turbo-frame");
      const turboFrameTarget = link.getAttribute("data-turbo-frame") || turboFrame?.getAttribute("target") || turboFrame?.id;
      if (turboFrameTarget && turboFrameTarget !== "_top") {
        request.headers["Turbo-Frame"] = turboFrameTarget;
      }
    }
    // Fetch request interface
    requestSucceededWithResponse() {
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
    get #cacheTtl() {
      return Number(getMetaContent("turbo-prefetch-cache-time")) || cacheTtl;
    }
    #isPrefetchable(link) {
      const href = link.getAttribute("href");
      if (!href)
        return false;
      if (unfetchableLink(link))
        return false;
      if (linkToTheSamePage(link))
        return false;
      if (linkOptsOut(link))
        return false;
      if (nonSafeLink(link))
        return false;
      if (eventPrevented(link))
        return false;
      return true;
    }
  };
  var unfetchableLink = (link) => {
    return link.origin !== document.location.origin || !["http:", "https:"].includes(link.protocol) || link.hasAttribute("target");
  };
  var linkToTheSamePage = (link) => {
    return link.pathname + link.search === document.location.pathname + document.location.search || link.href.startsWith("#");
  };
  var linkOptsOut = (link) => {
    if (link.getAttribute("data-turbo-prefetch") === "false")
      return true;
    if (link.getAttribute("data-turbo") === "false")
      return true;
    const turboPrefetchParent = findClosestRecursively(link, "[data-turbo-prefetch]");
    if (turboPrefetchParent && turboPrefetchParent.getAttribute("data-turbo-prefetch") === "false")
      return true;
    return false;
  };
  var nonSafeLink = (link) => {
    const turboMethod = link.getAttribute("data-turbo-method");
    if (turboMethod && turboMethod.toLowerCase() !== "get")
      return true;
    if (isUJS(link))
      return true;
    if (link.hasAttribute("data-turbo-confirm"))
      return true;
    if (link.hasAttribute("data-turbo-stream"))
      return true;
    return false;
  };
  var isUJS = (link) => {
    return link.hasAttribute("data-remote") || link.hasAttribute("data-behavior") || link.hasAttribute("data-confirm") || link.hasAttribute("data-method");
  };
  var eventPrevented = (link) => {
    const event = dispatch("turbo:before-prefetch", { target: link, cancelable: true });
    return event.defaultPrevented;
  };
  var Navigator = class {
    constructor(delegate) {
      this.delegate = delegate;
    }
    proposeVisit(location2, options = {}) {
      if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
        this.delegate.visitProposedToLocation(location2, options);
      }
    }
    startVisit(locatable, restorationIdentifier, options = {}) {
      this.stop();
      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, {
        referrer: this.location,
        ...options
      });
      this.currentVisit.start();
    }
    submitForm(form, submitter) {
      this.stop();
      this.formSubmission = new FormSubmission(this, form, submitter, true);
      this.formSubmission.start();
    }
    stop() {
      if (this.formSubmission) {
        this.formSubmission.stop();
        delete this.formSubmission;
      }
      if (this.currentVisit) {
        this.currentVisit.cancel();
        delete this.currentVisit;
      }
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get rootLocation() {
      return this.view.snapshot.rootLocation;
    }
    get history() {
      return this.delegate.history;
    }
    // Form submission delegate
    formSubmissionStarted(formSubmission) {
      if (typeof this.adapter.formSubmissionStarted === "function") {
        this.adapter.formSubmissionStarted(formSubmission);
      }
    }
    async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
      if (formSubmission == this.formSubmission) {
        const responseHTML = await fetchResponse.responseHTML;
        if (responseHTML) {
          const shouldCacheSnapshot = formSubmission.isSafe;
          if (!shouldCacheSnapshot) {
            this.view.clearSnapshotCache();
          }
          const { statusCode, redirected } = fetchResponse;
          const action = this.#getActionForFormSubmission(formSubmission, fetchResponse);
          const visitOptions = {
            action,
            shouldCacheSnapshot,
            response: { statusCode, responseHTML, redirected }
          };
          this.proposeVisit(fetchResponse.location, visitOptions);
        }
      }
    }
    async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        if (fetchResponse.serverError) {
          await this.view.renderError(snapshot, this.currentVisit);
        } else {
          await this.view.renderPage(snapshot, false, true, this.currentVisit);
        }
        if (!snapshot.shouldPreserveScrollPosition) {
          this.view.scrollToTop();
        }
        this.view.clearSnapshotCache();
      }
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished(formSubmission) {
      if (typeof this.adapter.formSubmissionFinished === "function") {
        this.adapter.formSubmissionFinished(formSubmission);
      }
    }
    // Visit delegate
    visitStarted(visit2) {
      this.delegate.visitStarted(visit2);
    }
    visitCompleted(visit2) {
      this.delegate.visitCompleted(visit2);
    }
    locationWithActionIsSamePage(location2, action) {
      const anchor = getAnchor(location2);
      const currentAnchor = getAnchor(this.view.lastRenderedLocation);
      const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
      return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
    }
    // Visits
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    #getActionForFormSubmission(formSubmission, fetchResponse) {
      const { submitter, formElement } = formSubmission;
      return getVisitAction(submitter, formElement) || this.#getDefaultAction(fetchResponse);
    }
    #getDefaultAction(fetchResponse) {
      const sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === this.location?.href;
      return sameLocationRedirect ? "replace" : "advance";
    }
  };
  var PageStage = {
    initial: 0,
    loading: 1,
    interactive: 2,
    complete: 3
  };
  var PageObserver = class {
    stage = PageStage.initial;
    started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        if (this.stage == PageStage.initial) {
          this.stage = PageStage.loading;
        }
        document.addEventListener("readystatechange", this.interpretReadyState, false);
        addEventListener("pagehide", this.pageWillUnload, false);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        document.removeEventListener("readystatechange", this.interpretReadyState, false);
        removeEventListener("pagehide", this.pageWillUnload, false);
        this.started = false;
      }
    }
    interpretReadyState = () => {
      const { readyState } = this;
      if (readyState == "interactive") {
        this.pageIsInteractive();
      } else if (readyState == "complete") {
        this.pageIsComplete();
      }
    };
    pageIsInteractive() {
      if (this.stage == PageStage.loading) {
        this.stage = PageStage.interactive;
        this.delegate.pageBecameInteractive();
      }
    }
    pageIsComplete() {
      this.pageIsInteractive();
      if (this.stage == PageStage.interactive) {
        this.stage = PageStage.complete;
        this.delegate.pageLoaded();
      }
    }
    pageWillUnload = () => {
      this.delegate.pageWillUnload();
    };
    get readyState() {
      return document.readyState;
    }
  };
  var ScrollObserver = class {
    started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("scroll", this.onScroll, false);
        this.onScroll();
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("scroll", this.onScroll, false);
        this.started = false;
      }
    }
    onScroll = () => {
      this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
    };
    // Private
    updatePosition(position) {
      this.delegate.scrollPositionChanged(position);
    }
  };
  var StreamMessageRenderer = class {
    render({ fragment }) {
      Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => {
        withAutofocusFromFragment(fragment, () => {
          withPreservedFocus(() => {
            document.documentElement.appendChild(fragment);
          });
        });
      });
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement, newPermanentElement) {
      newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
    }
    leavingBardo() {
    }
  };
  function getPermanentElementMapForFragment(fragment) {
    const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
    const permanentElementMap = {};
    for (const permanentElementInDocument of permanentElementsInDocument) {
      const { id } = permanentElementInDocument;
      for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
        const elementInStream = getPermanentElementById(streamElement.templateElement.content, id);
        if (elementInStream) {
          permanentElementMap[id] = [permanentElementInDocument, elementInStream];
        }
      }
    }
    return permanentElementMap;
  }
  async function withAutofocusFromFragment(fragment, callback) {
    const generatedID = `turbo-stream-autofocus-${uuid()}`;
    const turboStreams = fragment.querySelectorAll("turbo-stream");
    const elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);
    let willAutofocusId = null;
    if (elementWithAutofocus) {
      if (elementWithAutofocus.id) {
        willAutofocusId = elementWithAutofocus.id;
      } else {
        willAutofocusId = generatedID;
      }
      elementWithAutofocus.id = willAutofocusId;
    }
    callback();
    await nextRepaint();
    const hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;
    if (hasNoActiveElement && willAutofocusId) {
      const elementToAutofocus = document.getElementById(willAutofocusId);
      if (elementIsFocusable(elementToAutofocus)) {
        elementToAutofocus.focus();
      }
      if (elementToAutofocus && elementToAutofocus.id == generatedID) {
        elementToAutofocus.removeAttribute("id");
      }
    }
  }
  async function withPreservedFocus(callback) {
    const [activeElementBeforeRender, activeElementAfterRender] = await around(callback, () => document.activeElement);
    const restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;
    if (restoreFocusTo) {
      const elementToFocus = document.getElementById(restoreFocusTo);
      if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {
        elementToFocus.focus();
      }
    }
  }
  function firstAutofocusableElementInStreams(nodeListOfStreamElements) {
    for (const streamElement of nodeListOfStreamElements) {
      const elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);
      if (elementWithAutofocus)
        return elementWithAutofocus;
    }
    return null;
  }
  var StreamObserver = class {
    sources = /* @__PURE__ */ new Set();
    #started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.#started) {
        this.#started = true;
        addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    stop() {
      if (this.#started) {
        this.#started = false;
        removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    connectStreamSource(source) {
      if (!this.streamSourceIsConnected(source)) {
        this.sources.add(source);
        source.addEventListener("message", this.receiveMessageEvent, false);
      }
    }
    disconnectStreamSource(source) {
      if (this.streamSourceIsConnected(source)) {
        this.sources.delete(source);
        source.removeEventListener("message", this.receiveMessageEvent, false);
      }
    }
    streamSourceIsConnected(source) {
      return this.sources.has(source);
    }
    inspectFetchResponse = (event) => {
      const response = fetchResponseFromEvent(event);
      if (response && fetchResponseIsStream(response)) {
        event.preventDefault();
        this.receiveMessageResponse(response);
      }
    };
    receiveMessageEvent = (event) => {
      if (this.#started && typeof event.data == "string") {
        this.receiveMessageHTML(event.data);
      }
    };
    async receiveMessageResponse(response) {
      const html = await response.responseHTML;
      if (html) {
        this.receiveMessageHTML(html);
      }
    }
    receiveMessageHTML(html) {
      this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
    }
  };
  function fetchResponseFromEvent(event) {
    const fetchResponse = event.detail?.fetchResponse;
    if (fetchResponse instanceof FetchResponse) {
      return fetchResponse;
    }
  }
  function fetchResponseIsStream(response) {
    const contentType = response.contentType ?? "";
    return contentType.startsWith(StreamMessage.contentType);
  }
  var ErrorRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      const { documentElement, body } = document;
      documentElement.replaceChild(newElement, body);
    }
    async render() {
      this.replaceHeadAndBody();
      this.activateScriptElements();
    }
    replaceHeadAndBody() {
      const { documentElement, head } = document;
      documentElement.replaceChild(this.newHead, head);
      this.renderElement(this.currentElement, this.newElement);
    }
    activateScriptElements() {
      for (const replaceableElement of this.scriptElements) {
        const parentNode = replaceableElement.parentNode;
        if (parentNode) {
          const element = activateScriptElement(replaceableElement);
          parentNode.replaceChild(element, replaceableElement);
        }
      }
    }
    get newHead() {
      return this.newSnapshot.headSnapshot.element;
    }
    get scriptElements() {
      return document.documentElement.querySelectorAll("script");
    }
  };
  var Idiomorph = /* @__PURE__ */ function() {
    let EMPTY_SET = /* @__PURE__ */ new Set();
    let defaults = {
      morphStyle: "outerHTML",
      callbacks: {
        beforeNodeAdded: noOp,
        afterNodeAdded: noOp,
        beforeNodeMorphed: noOp,
        afterNodeMorphed: noOp,
        beforeNodeRemoved: noOp,
        afterNodeRemoved: noOp,
        beforeAttributeUpdated: noOp
      },
      head: {
        style: "merge",
        shouldPreserve: function(elt) {
          return elt.getAttribute("im-preserve") === "true";
        },
        shouldReAppend: function(elt) {
          return elt.getAttribute("im-re-append") === "true";
        },
        shouldRemove: noOp,
        afterHeadMorphed: noOp
      }
    };
    function morph(oldNode, newContent, config = {}) {
      if (oldNode instanceof Document) {
        oldNode = oldNode.documentElement;
      }
      if (typeof newContent === "string") {
        newContent = parseContent(newContent);
      }
      let normalizedContent = normalizeContent(newContent);
      let ctx = createMorphContext(oldNode, normalizedContent, config);
      return morphNormalizedContent(oldNode, normalizedContent, ctx);
    }
    function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {
      if (ctx.head.block) {
        let oldHead = oldNode.querySelector("head");
        let newHead = normalizedNewContent.querySelector("head");
        if (oldHead && newHead) {
          let promises = handleHeadElement(newHead, oldHead, ctx);
          Promise.all(promises).then(function() {
            morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {
              head: {
                block: false,
                ignore: true
              }
            }));
          });
          return;
        }
      }
      if (ctx.morphStyle === "innerHTML") {
        morphChildren(normalizedNewContent, oldNode, ctx);
        return oldNode.children;
      } else if (ctx.morphStyle === "outerHTML" || ctx.morphStyle == null) {
        let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);
        let previousSibling = bestMatch?.previousSibling;
        let nextSibling = bestMatch?.nextSibling;
        let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);
        if (bestMatch) {
          return insertSiblings(previousSibling, morphedNode, nextSibling);
        } else {
          return [];
        }
      } else {
        throw "Do not understand how to morph style " + ctx.morphStyle;
      }
    }
    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {
      return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;
    }
    function morphOldNodeTo(oldNode, newContent, ctx) {
      if (ctx.ignoreActive && oldNode === document.activeElement)
        ;
      else if (newContent == null) {
        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false)
          return oldNode;
        oldNode.remove();
        ctx.callbacks.afterNodeRemoved(oldNode);
        return null;
      } else if (!isSoftMatch(oldNode, newContent)) {
        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false)
          return oldNode;
        if (ctx.callbacks.beforeNodeAdded(newContent) === false)
          return oldNode;
        oldNode.parentElement.replaceChild(newContent, oldNode);
        ctx.callbacks.afterNodeAdded(newContent);
        ctx.callbacks.afterNodeRemoved(oldNode);
        return newContent;
      } else {
        if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false)
          return oldNode;
        if (oldNode instanceof HTMLHeadElement && ctx.head.ignore)
          ;
        else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== "morph") {
          handleHeadElement(newContent, oldNode, ctx);
        } else {
          syncNodeFrom(newContent, oldNode, ctx);
          if (!ignoreValueOfActiveElement(oldNode, ctx)) {
            morphChildren(newContent, oldNode, ctx);
          }
        }
        ctx.callbacks.afterNodeMorphed(oldNode, newContent);
        return oldNode;
      }
    }
    function morphChildren(newParent, oldParent, ctx) {
      let nextNewChild = newParent.firstChild;
      let insertionPoint = oldParent.firstChild;
      let newChild;
      while (nextNewChild) {
        newChild = nextNewChild;
        nextNewChild = newChild.nextSibling;
        if (insertionPoint == null) {
          if (ctx.callbacks.beforeNodeAdded(newChild) === false)
            return;
          oldParent.appendChild(newChild);
          ctx.callbacks.afterNodeAdded(newChild);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        if (isIdSetMatch(newChild, insertionPoint, ctx)) {
          morphOldNodeTo(insertionPoint, newChild, ctx);
          insertionPoint = insertionPoint.nextSibling;
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);
        if (idSetMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);
          morphOldNodeTo(idSetMatch, newChild, ctx);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);
        if (softMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);
          morphOldNodeTo(softMatch, newChild, ctx);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        if (ctx.callbacks.beforeNodeAdded(newChild) === false)
          return;
        oldParent.insertBefore(newChild, insertionPoint);
        ctx.callbacks.afterNodeAdded(newChild);
        removeIdsFromConsideration(ctx, newChild);
      }
      while (insertionPoint !== null) {
        let tempNode = insertionPoint;
        insertionPoint = insertionPoint.nextSibling;
        removeNode(tempNode, ctx);
      }
    }
    function ignoreAttribute(attr, to, updateType, ctx) {
      if (attr === "value" && ctx.ignoreActiveValue && to === document.activeElement) {
        return true;
      }
      return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;
    }
    function syncNodeFrom(from, to, ctx) {
      let type = from.nodeType;
      if (type === 1) {
        const fromAttributes = from.attributes;
        const toAttributes = to.attributes;
        for (const fromAttribute of fromAttributes) {
          if (ignoreAttribute(fromAttribute.name, to, "update", ctx)) {
            continue;
          }
          if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {
            to.setAttribute(fromAttribute.name, fromAttribute.value);
          }
        }
        for (let i = toAttributes.length - 1; 0 <= i; i--) {
          const toAttribute = toAttributes[i];
          if (ignoreAttribute(toAttribute.name, to, "remove", ctx)) {
            continue;
          }
          if (!from.hasAttribute(toAttribute.name)) {
            to.removeAttribute(toAttribute.name);
          }
        }
      }
      if (type === 8 || type === 3) {
        if (to.nodeValue !== from.nodeValue) {
          to.nodeValue = from.nodeValue;
        }
      }
      if (!ignoreValueOfActiveElement(to, ctx)) {
        syncInputValue(from, to, ctx);
      }
    }
    function syncBooleanAttribute(from, to, attributeName, ctx) {
      if (from[attributeName] !== to[attributeName]) {
        let ignoreUpdate = ignoreAttribute(attributeName, to, "update", ctx);
        if (!ignoreUpdate) {
          to[attributeName] = from[attributeName];
        }
        if (from[attributeName]) {
          if (!ignoreUpdate) {
            to.setAttribute(attributeName, from[attributeName]);
          }
        } else {
          if (!ignoreAttribute(attributeName, to, "remove", ctx)) {
            to.removeAttribute(attributeName);
          }
        }
      }
    }
    function syncInputValue(from, to, ctx) {
      if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== "file") {
        let fromValue = from.value;
        let toValue2 = to.value;
        syncBooleanAttribute(from, to, "checked", ctx);
        syncBooleanAttribute(from, to, "disabled", ctx);
        if (!from.hasAttribute("value")) {
          if (!ignoreAttribute("value", to, "remove", ctx)) {
            to.value = "";
            to.removeAttribute("value");
          }
        } else if (fromValue !== toValue2) {
          if (!ignoreAttribute("value", to, "update", ctx)) {
            to.setAttribute("value", fromValue);
            to.value = fromValue;
          }
        }
      } else if (from instanceof HTMLOptionElement) {
        syncBooleanAttribute(from, to, "selected", ctx);
      } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {
        let fromValue = from.value;
        let toValue2 = to.value;
        if (ignoreAttribute("value", to, "update", ctx)) {
          return;
        }
        if (fromValue !== toValue2) {
          to.value = fromValue;
        }
        if (to.firstChild && to.firstChild.nodeValue !== fromValue) {
          to.firstChild.nodeValue = fromValue;
        }
      }
    }
    function handleHeadElement(newHeadTag, currentHead, ctx) {
      let added = [];
      let removed = [];
      let preserved = [];
      let nodesToAppend = [];
      let headMergeStyle = ctx.head.style;
      let srcToNewHeadNodes = /* @__PURE__ */ new Map();
      for (const newHeadChild of newHeadTag.children) {
        srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
      }
      for (const currentHeadElt of currentHead.children) {
        let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
        let isReAppended = ctx.head.shouldReAppend(currentHeadElt);
        let isPreserved = ctx.head.shouldPreserve(currentHeadElt);
        if (inNewContent || isPreserved) {
          if (isReAppended) {
            removed.push(currentHeadElt);
          } else {
            srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
            preserved.push(currentHeadElt);
          }
        } else {
          if (headMergeStyle === "append") {
            if (isReAppended) {
              removed.push(currentHeadElt);
              nodesToAppend.push(currentHeadElt);
            }
          } else {
            if (ctx.head.shouldRemove(currentHeadElt) !== false) {
              removed.push(currentHeadElt);
            }
          }
        }
      }
      nodesToAppend.push(...srcToNewHeadNodes.values());
      let promises = [];
      for (const newNode of nodesToAppend) {
        let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;
        if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {
          if (newElt.href || newElt.src) {
            let resolve2 = null;
            let promise = new Promise(function(_resolve) {
              resolve2 = _resolve;
            });
            newElt.addEventListener("load", function() {
              resolve2();
            });
            promises.push(promise);
          }
          currentHead.appendChild(newElt);
          ctx.callbacks.afterNodeAdded(newElt);
          added.push(newElt);
        }
      }
      for (const removedElement of removed) {
        if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {
          currentHead.removeChild(removedElement);
          ctx.callbacks.afterNodeRemoved(removedElement);
        }
      }
      ctx.head.afterHeadMorphed(currentHead, { added, kept: preserved, removed });
      return promises;
    }
    function noOp() {
    }
    function mergeDefaults2(config) {
      let finalConfig = {};
      Object.assign(finalConfig, defaults);
      Object.assign(finalConfig, config);
      finalConfig.callbacks = {};
      Object.assign(finalConfig.callbacks, defaults.callbacks);
      Object.assign(finalConfig.callbacks, config.callbacks);
      finalConfig.head = {};
      Object.assign(finalConfig.head, defaults.head);
      Object.assign(finalConfig.head, config.head);
      return finalConfig;
    }
    function createMorphContext(oldNode, newContent, config) {
      config = mergeDefaults2(config);
      return {
        target: oldNode,
        newContent,
        config,
        morphStyle: config.morphStyle,
        ignoreActive: config.ignoreActive,
        ignoreActiveValue: config.ignoreActiveValue,
        idMap: createIdMap(oldNode, newContent),
        deadIds: /* @__PURE__ */ new Set(),
        callbacks: config.callbacks,
        head: config.head
      };
    }
    function isIdSetMatch(node1, node2, ctx) {
      if (node1 == null || node2 == null) {
        return false;
      }
      if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {
        if (node1.id !== "" && node1.id === node2.id) {
          return true;
        } else {
          return getIdIntersectionCount(ctx, node1, node2) > 0;
        }
      }
      return false;
    }
    function isSoftMatch(node1, node2) {
      if (node1 == null || node2 == null) {
        return false;
      }
      return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;
    }
    function removeNodesBetween(startInclusive, endExclusive, ctx) {
      while (startInclusive !== endExclusive) {
        let tempNode = startInclusive;
        startInclusive = startInclusive.nextSibling;
        removeNode(tempNode, ctx);
      }
      removeIdsFromConsideration(ctx, endExclusive);
      return endExclusive.nextSibling;
    }
    function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
      let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);
      let potentialMatch = null;
      if (newChildPotentialIdCount > 0) {
        let potentialMatch2 = insertionPoint;
        let otherMatchCount = 0;
        while (potentialMatch2 != null) {
          if (isIdSetMatch(newChild, potentialMatch2, ctx)) {
            return potentialMatch2;
          }
          otherMatchCount += getIdIntersectionCount(ctx, potentialMatch2, newContent);
          if (otherMatchCount > newChildPotentialIdCount) {
            return null;
          }
          potentialMatch2 = potentialMatch2.nextSibling;
        }
      }
      return potentialMatch;
    }
    function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
      let potentialSoftMatch = insertionPoint;
      let nextSibling = newChild.nextSibling;
      let siblingSoftMatchCount = 0;
      while (potentialSoftMatch != null) {
        if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {
          return null;
        }
        if (isSoftMatch(newChild, potentialSoftMatch)) {
          return potentialSoftMatch;
        }
        if (isSoftMatch(nextSibling, potentialSoftMatch)) {
          siblingSoftMatchCount++;
          nextSibling = nextSibling.nextSibling;
          if (siblingSoftMatchCount >= 2) {
            return null;
          }
        }
        potentialSoftMatch = potentialSoftMatch.nextSibling;
      }
      return potentialSoftMatch;
    }
    function parseContent(newContent) {
      let parser = new DOMParser();
      let contentWithSvgsRemoved = newContent.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
      if (contentWithSvgsRemoved.match(/<\/html>/) || contentWithSvgsRemoved.match(/<\/head>/) || contentWithSvgsRemoved.match(/<\/body>/)) {
        let content = parser.parseFromString(newContent, "text/html");
        if (contentWithSvgsRemoved.match(/<\/html>/)) {
          content.generatedByIdiomorph = true;
          return content;
        } else {
          let htmlElement = content.firstChild;
          if (htmlElement) {
            htmlElement.generatedByIdiomorph = true;
            return htmlElement;
          } else {
            return null;
          }
        }
      } else {
        let responseDoc = parser.parseFromString("<body><template>" + newContent + "</template></body>", "text/html");
        let content = responseDoc.body.querySelector("template").content;
        content.generatedByIdiomorph = true;
        return content;
      }
    }
    function normalizeContent(newContent) {
      if (newContent == null) {
        const dummyParent = document.createElement("div");
        return dummyParent;
      } else if (newContent.generatedByIdiomorph) {
        return newContent;
      } else if (newContent instanceof Node) {
        const dummyParent = document.createElement("div");
        dummyParent.append(newContent);
        return dummyParent;
      } else {
        const dummyParent = document.createElement("div");
        for (const elt of [...newContent]) {
          dummyParent.append(elt);
        }
        return dummyParent;
      }
    }
    function insertSiblings(previousSibling, morphedNode, nextSibling) {
      let stack3 = [];
      let added = [];
      while (previousSibling != null) {
        stack3.push(previousSibling);
        previousSibling = previousSibling.previousSibling;
      }
      while (stack3.length > 0) {
        let node = stack3.pop();
        added.push(node);
        morphedNode.parentElement.insertBefore(node, morphedNode);
      }
      added.push(morphedNode);
      while (nextSibling != null) {
        stack3.push(nextSibling);
        added.push(nextSibling);
        nextSibling = nextSibling.nextSibling;
      }
      while (stack3.length > 0) {
        morphedNode.parentElement.insertBefore(stack3.pop(), morphedNode.nextSibling);
      }
      return added;
    }
    function findBestNodeMatch(newContent, oldNode, ctx) {
      let currentElement;
      currentElement = newContent.firstChild;
      let bestElement = currentElement;
      let score = 0;
      while (currentElement) {
        let newScore = scoreElement(currentElement, oldNode, ctx);
        if (newScore > score) {
          bestElement = currentElement;
          score = newScore;
        }
        currentElement = currentElement.nextSibling;
      }
      return bestElement;
    }
    function scoreElement(node1, node2, ctx) {
      if (isSoftMatch(node1, node2)) {
        return 0.5 + getIdIntersectionCount(ctx, node1, node2);
      }
      return 0;
    }
    function removeNode(tempNode, ctx) {
      removeIdsFromConsideration(ctx, tempNode);
      if (ctx.callbacks.beforeNodeRemoved(tempNode) === false)
        return;
      tempNode.remove();
      ctx.callbacks.afterNodeRemoved(tempNode);
    }
    function isIdInConsideration(ctx, id) {
      return !ctx.deadIds.has(id);
    }
    function idIsWithinNode(ctx, id, targetNode) {
      let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;
      return idSet.has(id);
    }
    function removeIdsFromConsideration(ctx, node) {
      let idSet = ctx.idMap.get(node) || EMPTY_SET;
      for (const id of idSet) {
        ctx.deadIds.add(id);
      }
    }
    function getIdIntersectionCount(ctx, node1, node2) {
      let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;
      let matchCount = 0;
      for (const id of sourceSet) {
        if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {
          ++matchCount;
        }
      }
      return matchCount;
    }
    function populateIdMapForNode(node, idMap) {
      let nodeParent = node.parentElement;
      let idElements = node.querySelectorAll("[id]");
      for (const elt of idElements) {
        let current = elt;
        while (current !== nodeParent && current != null) {
          let idSet = idMap.get(current);
          if (idSet == null) {
            idSet = /* @__PURE__ */ new Set();
            idMap.set(current, idSet);
          }
          idSet.add(elt.id);
          current = current.parentElement;
        }
      }
    }
    function createIdMap(oldContent, newContent) {
      let idMap = /* @__PURE__ */ new Map();
      populateIdMapForNode(oldContent, idMap);
      populateIdMapForNode(newContent, idMap);
      return idMap;
    }
    return {
      morph,
      defaults
    };
  }();
  var PageRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      if (document.body && newElement instanceof HTMLBodyElement) {
        document.body.replaceWith(newElement);
      } else {
        document.documentElement.appendChild(newElement);
      }
    }
    get shouldRender() {
      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
    }
    get reloadReason() {
      if (!this.newSnapshot.isVisitable) {
        return {
          reason: "turbo_visit_control_is_reload"
        };
      }
      if (!this.trackedElementsAreIdentical) {
        return {
          reason: "tracked_element_mismatch"
        };
      }
    }
    async prepareToRender() {
      this.#setLanguage();
      await this.mergeHead();
    }
    async render() {
      if (this.willRender) {
        await this.replaceBody();
      }
    }
    finishRendering() {
      super.finishRendering();
      if (!this.isPreview) {
        this.focusFirstAutofocusableElement();
      }
    }
    get currentHeadSnapshot() {
      return this.currentSnapshot.headSnapshot;
    }
    get newHeadSnapshot() {
      return this.newSnapshot.headSnapshot;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    #setLanguage() {
      const { documentElement } = this.currentSnapshot;
      const { lang } = this.newSnapshot;
      if (lang) {
        documentElement.setAttribute("lang", lang);
      } else {
        documentElement.removeAttribute("lang");
      }
    }
    async mergeHead() {
      const mergedHeadElements = this.mergeProvisionalElements();
      const newStylesheetElements = this.copyNewHeadStylesheetElements();
      this.copyNewHeadScriptElements();
      await mergedHeadElements;
      await newStylesheetElements;
      if (this.willRender) {
        this.removeUnusedDynamicStylesheetElements();
      }
    }
    async replaceBody() {
      await this.preservingPermanentElements(async () => {
        this.activateNewBody();
        await this.assignNewBody();
      });
    }
    get trackedElementsAreIdentical() {
      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
    }
    async copyNewHeadStylesheetElements() {
      const loadingElements = [];
      for (const element of this.newHeadStylesheetElements) {
        loadingElements.push(waitForLoad(element));
        document.head.appendChild(element);
      }
      await Promise.all(loadingElements);
    }
    copyNewHeadScriptElements() {
      for (const element of this.newHeadScriptElements) {
        document.head.appendChild(activateScriptElement(element));
      }
    }
    removeUnusedDynamicStylesheetElements() {
      for (const element of this.unusedDynamicStylesheetElements) {
        document.head.removeChild(element);
      }
    }
    async mergeProvisionalElements() {
      const newHeadElements = [...this.newHeadProvisionalElements];
      for (const element of this.currentHeadProvisionalElements) {
        if (!this.isCurrentElementInElementList(element, newHeadElements)) {
          document.head.removeChild(element);
        }
      }
      for (const element of newHeadElements) {
        document.head.appendChild(element);
      }
    }
    isCurrentElementInElementList(element, elementList) {
      for (const [index, newElement] of elementList.entries()) {
        if (element.tagName == "TITLE") {
          if (newElement.tagName != "TITLE") {
            continue;
          }
          if (element.innerHTML == newElement.innerHTML) {
            elementList.splice(index, 1);
            return true;
          }
        }
        if (newElement.isEqualNode(element)) {
          elementList.splice(index, 1);
          return true;
        }
      }
      return false;
    }
    removeCurrentHeadProvisionalElements() {
      for (const element of this.currentHeadProvisionalElements) {
        document.head.removeChild(element);
      }
    }
    copyNewHeadProvisionalElements() {
      for (const element of this.newHeadProvisionalElements) {
        document.head.appendChild(element);
      }
    }
    activateNewBody() {
      document.adoptNode(this.newElement);
      this.activateNewBodyScriptElements();
    }
    activateNewBodyScriptElements() {
      for (const inertScriptElement of this.newBodyScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    async assignNewBody() {
      await this.renderElement(this.currentElement, this.newElement);
    }
    get unusedDynamicStylesheetElements() {
      return this.oldHeadStylesheetElements.filter((element) => {
        return element.getAttribute("data-turbo-track") === "dynamic";
      });
    }
    get oldHeadStylesheetElements() {
      return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot);
    }
    get newHeadStylesheetElements() {
      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get newHeadScriptElements() {
      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get currentHeadProvisionalElements() {
      return this.currentHeadSnapshot.provisionalElements;
    }
    get newHeadProvisionalElements() {
      return this.newHeadSnapshot.provisionalElements;
    }
    get newBodyScriptElements() {
      return this.newElement.querySelectorAll("script");
    }
  };
  var MorphRenderer = class extends PageRenderer {
    async render() {
      if (this.willRender)
        await this.#morphBody();
    }
    get renderMethod() {
      return "morph";
    }
    // Private
    async #morphBody() {
      this.#morphElements(this.currentElement, this.newElement);
      this.#reloadRemoteFrames();
      dispatch("turbo:morph", {
        detail: {
          currentElement: this.currentElement,
          newElement: this.newElement
        }
      });
    }
    #morphElements(currentElement, newElement, morphStyle = "outerHTML") {
      this.isMorphingTurboFrame = this.#isFrameReloadedWithMorph(currentElement);
      Idiomorph.morph(currentElement, newElement, {
        morphStyle,
        callbacks: {
          beforeNodeAdded: this.#shouldAddElement,
          beforeNodeMorphed: this.#shouldMorphElement,
          beforeAttributeUpdated: this.#shouldUpdateAttribute,
          beforeNodeRemoved: this.#shouldRemoveElement,
          afterNodeMorphed: this.#didMorphElement
        }
      });
    }
    #shouldAddElement = (node) => {
      return !(node.id && node.hasAttribute("data-turbo-permanent") && document.getElementById(node.id));
    };
    #shouldMorphElement = (oldNode, newNode) => {
      if (oldNode instanceof HTMLElement) {
        if (!oldNode.hasAttribute("data-turbo-permanent") && (this.isMorphingTurboFrame || !this.#isFrameReloadedWithMorph(oldNode))) {
          const event = dispatch("turbo:before-morph-element", {
            cancelable: true,
            target: oldNode,
            detail: {
              newElement: newNode
            }
          });
          return !event.defaultPrevented;
        } else {
          return false;
        }
      }
    };
    #shouldUpdateAttribute = (attributeName, target, mutationType) => {
      const event = dispatch("turbo:before-morph-attribute", { cancelable: true, target, detail: { attributeName, mutationType } });
      return !event.defaultPrevented;
    };
    #didMorphElement = (oldNode, newNode) => {
      if (newNode instanceof HTMLElement) {
        dispatch("turbo:morph-element", {
          target: oldNode,
          detail: {
            newElement: newNode
          }
        });
      }
    };
    #shouldRemoveElement = (node) => {
      return this.#shouldMorphElement(node);
    };
    #reloadRemoteFrames() {
      this.#remoteFrames().forEach((frame) => {
        if (this.#isFrameReloadedWithMorph(frame)) {
          this.#renderFrameWithMorph(frame);
          frame.reload();
        }
      });
    }
    #renderFrameWithMorph(frame) {
      frame.addEventListener("turbo:before-frame-render", (event) => {
        event.detail.render = this.#morphFrameUpdate;
      }, { once: true });
    }
    #morphFrameUpdate = (currentElement, newElement) => {
      dispatch("turbo:before-frame-morph", {
        target: currentElement,
        detail: { currentElement, newElement }
      });
      this.#morphElements(currentElement, newElement.children, "innerHTML");
    };
    #isFrameReloadedWithMorph(element) {
      return element.src && element.refresh === "morph";
    }
    #remoteFrames() {
      return Array.from(document.querySelectorAll("turbo-frame[src]")).filter((frame) => {
        return !frame.closest("[data-turbo-permanent]");
      });
    }
  };
  var SnapshotCache = class {
    keys = [];
    snapshots = {};
    constructor(size2) {
      this.size = size2;
    }
    has(location2) {
      return toCacheKey(location2) in this.snapshots;
    }
    get(location2) {
      if (this.has(location2)) {
        const snapshot = this.read(location2);
        this.touch(location2);
        return snapshot;
      }
    }
    put(location2, snapshot) {
      this.write(location2, snapshot);
      this.touch(location2);
      return snapshot;
    }
    clear() {
      this.snapshots = {};
    }
    // Private
    read(location2) {
      return this.snapshots[toCacheKey(location2)];
    }
    write(location2, snapshot) {
      this.snapshots[toCacheKey(location2)] = snapshot;
    }
    touch(location2) {
      const key = toCacheKey(location2);
      const index = this.keys.indexOf(key);
      if (index > -1)
        this.keys.splice(index, 1);
      this.keys.unshift(key);
      this.trim();
    }
    trim() {
      for (const key of this.keys.splice(this.size)) {
        delete this.snapshots[key];
      }
    }
  };
  var PageView = class extends View {
    snapshotCache = new SnapshotCache(10);
    lastRenderedLocation = new URL(location.href);
    forceReloaded = false;
    shouldTransitionTo(newSnapshot) {
      return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions;
    }
    renderPage(snapshot, isPreview = false, willRender = true, visit2) {
      const shouldMorphPage = this.isPageRefresh(visit2) && this.snapshot.shouldMorphPage;
      const rendererClass = shouldMorphPage ? MorphRenderer : PageRenderer;
      const renderer2 = new rendererClass(this.snapshot, snapshot, PageRenderer.renderElement, isPreview, willRender);
      if (!renderer2.shouldRender) {
        this.forceReloaded = true;
      } else {
        visit2?.changeHistory();
      }
      return this.render(renderer2);
    }
    renderError(snapshot, visit2) {
      visit2?.changeHistory();
      const renderer2 = new ErrorRenderer(this.snapshot, snapshot, ErrorRenderer.renderElement, false);
      return this.render(renderer2);
    }
    clearSnapshotCache() {
      this.snapshotCache.clear();
    }
    async cacheSnapshot(snapshot = this.snapshot) {
      if (snapshot.isCacheable) {
        this.delegate.viewWillCacheSnapshot();
        const { lastRenderedLocation: location2 } = this;
        await nextEventLoopTick();
        const cachedSnapshot = snapshot.clone();
        this.snapshotCache.put(location2, cachedSnapshot);
        return cachedSnapshot;
      }
    }
    getCachedSnapshotForLocation(location2) {
      return this.snapshotCache.get(location2);
    }
    isPageRefresh(visit2) {
      return !visit2 || this.lastRenderedLocation.pathname === visit2.location.pathname && visit2.action === "replace";
    }
    shouldPreserveScrollPosition(visit2) {
      return this.isPageRefresh(visit2) && this.snapshot.shouldPreserveScrollPosition;
    }
    get snapshot() {
      return PageSnapshot.fromElement(this.element);
    }
  };
  var Preloader = class {
    selector = "a[data-turbo-preload]";
    constructor(delegate, snapshotCache) {
      this.delegate = delegate;
      this.snapshotCache = snapshotCache;
    }
    start() {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", this.#preloadAll);
      } else {
        this.preloadOnLoadLinksForView(document.body);
      }
    }
    stop() {
      document.removeEventListener("DOMContentLoaded", this.#preloadAll);
    }
    preloadOnLoadLinksForView(element) {
      for (const link of element.querySelectorAll(this.selector)) {
        if (this.delegate.shouldPreloadLink(link)) {
          this.preloadURL(link);
        }
      }
    }
    async preloadURL(link) {
      const location2 = new URL(link.href);
      if (this.snapshotCache.has(location2)) {
        return;
      }
      const fetchRequest = new FetchRequest(this, FetchMethod.get, location2, new URLSearchParams(), link);
      await fetchRequest.perform();
    }
    // Fetch request delegate
    prepareRequest(fetchRequest) {
      fetchRequest.headers["X-Sec-Purpose"] = "prefetch";
    }
    async requestSucceededWithResponse(fetchRequest, fetchResponse) {
      try {
        const responseHTML = await fetchResponse.responseHTML;
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        this.snapshotCache.put(fetchRequest.url, snapshot);
      } catch (_2) {
      }
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
    #preloadAll = () => {
      this.preloadOnLoadLinksForView(document.body);
    };
  };
  var Cache = class {
    constructor(session2) {
      this.session = session2;
    }
    clear() {
      this.session.clearCache();
    }
    resetCacheControl() {
      this.#setCacheControl("");
    }
    exemptPageFromCache() {
      this.#setCacheControl("no-cache");
    }
    exemptPageFromPreview() {
      this.#setCacheControl("no-preview");
    }
    #setCacheControl(value) {
      setMetaContent("turbo-cache-control", value);
    }
  };
  var Session = class {
    navigator = new Navigator(this);
    history = new History(this);
    view = new PageView(this, document.documentElement);
    adapter = new BrowserAdapter(this);
    pageObserver = new PageObserver(this);
    cacheObserver = new CacheObserver();
    linkPrefetchObserver = new LinkPrefetchObserver(this, document);
    linkClickObserver = new LinkClickObserver(this, window);
    formSubmitObserver = new FormSubmitObserver(this, document);
    scrollObserver = new ScrollObserver(this);
    streamObserver = new StreamObserver(this);
    formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
    frameRedirector = new FrameRedirector(this, document.documentElement);
    streamMessageRenderer = new StreamMessageRenderer();
    cache = new Cache(this);
    drive = true;
    enabled = true;
    progressBarDelay = 500;
    started = false;
    formMode = "on";
    #pageRefreshDebouncePeriod = 150;
    constructor(recentRequests2) {
      this.recentRequests = recentRequests2;
      this.preloader = new Preloader(this, this.view.snapshotCache);
      this.debouncedRefresh = this.refresh;
      this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;
    }
    start() {
      if (!this.started) {
        this.pageObserver.start();
        this.cacheObserver.start();
        this.linkPrefetchObserver.start();
        this.formLinkClickObserver.start();
        this.linkClickObserver.start();
        this.formSubmitObserver.start();
        this.scrollObserver.start();
        this.streamObserver.start();
        this.frameRedirector.start();
        this.history.start();
        this.preloader.start();
        this.started = true;
        this.enabled = true;
      }
    }
    disable() {
      this.enabled = false;
    }
    stop() {
      if (this.started) {
        this.pageObserver.stop();
        this.cacheObserver.stop();
        this.linkPrefetchObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkClickObserver.stop();
        this.formSubmitObserver.stop();
        this.scrollObserver.stop();
        this.streamObserver.stop();
        this.frameRedirector.stop();
        this.history.stop();
        this.preloader.stop();
        this.started = false;
      }
    }
    registerAdapter(adapter) {
      this.adapter = adapter;
    }
    visit(location2, options = {}) {
      const frameElement = options.frame ? document.getElementById(options.frame) : null;
      if (frameElement instanceof FrameElement) {
        const action = options.action || getVisitAction(frameElement);
        frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);
        frameElement.src = location2.toString();
      } else {
        this.navigator.proposeVisit(expandURL(location2), options);
      }
    }
    refresh(url, requestId) {
      const isRecentRequest = requestId && this.recentRequests.has(requestId);
      if (!isRecentRequest) {
        this.visit(url, { action: "replace", shouldCacheSnapshot: false });
      }
    }
    connectStreamSource(source) {
      this.streamObserver.connectStreamSource(source);
    }
    disconnectStreamSource(source) {
      this.streamObserver.disconnectStreamSource(source);
    }
    renderStreamMessage(message) {
      this.streamMessageRenderer.render(StreamMessage.wrap(message));
    }
    clearCache() {
      this.view.clearSnapshotCache();
    }
    setProgressBarDelay(delay) {
      this.progressBarDelay = delay;
    }
    setFormMode(mode) {
      this.formMode = mode;
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    get pageRefreshDebouncePeriod() {
      return this.#pageRefreshDebouncePeriod;
    }
    set pageRefreshDebouncePeriod(value) {
      this.refresh = debounce(this.debouncedRefresh.bind(this), value);
      this.#pageRefreshDebouncePeriod = value;
    }
    // Preloader delegate
    shouldPreloadLink(element) {
      const isUnsafe = element.hasAttribute("data-turbo-method");
      const isStream = element.hasAttribute("data-turbo-stream");
      const frameTarget = element.getAttribute("data-turbo-frame");
      const frame = frameTarget == "_top" ? null : document.getElementById(frameTarget) || findClosestRecursively(element, "turbo-frame:not([disabled])");
      if (isUnsafe || isStream || frame instanceof FrameElement) {
        return false;
      } else {
        const location2 = new URL(element.href);
        return this.elementIsNavigatable(element) && locationIsVisitable(location2, this.snapshot.rootLocation);
      }
    }
    // History delegate
    historyPoppedToLocationWithRestorationIdentifierAndDirection(location2, restorationIdentifier, direction) {
      if (this.enabled) {
        this.navigator.startVisit(location2, restorationIdentifier, {
          action: "restore",
          historyChanged: true,
          direction
        });
      } else {
        this.adapter.pageInvalidated({
          reason: "turbo_disabled"
        });
      }
    }
    // Scroll observer delegate
    scrollPositionChanged(position) {
      this.history.updateRestorationData({ scrollPosition: position });
    }
    // Form click observer delegate
    willSubmitFormLinkToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    submittedFormLinkToLocation() {
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    // Link click observer delegate
    willFollowLinkToLocation(link, location2, event) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2, event);
    }
    followedLinkToLocation(link, location2) {
      const action = this.getActionForLink(link);
      const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");
      this.visit(location2.href, { action, acceptsStreamResponse });
    }
    // Navigator delegate
    allowsVisitingLocationWithAction(location2, action) {
      return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
    }
    visitProposedToLocation(location2, options) {
      extendURLWithDeprecatedProperties(location2);
      this.adapter.visitProposedToLocation(location2, options);
    }
    // Visit delegate
    visitStarted(visit2) {
      if (!visit2.acceptsStreamResponse) {
        markAsBusy(document.documentElement);
        this.view.markVisitDirection(visit2.direction);
      }
      extendURLWithDeprecatedProperties(visit2.location);
      if (!visit2.silent) {
        this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
      }
    }
    visitCompleted(visit2) {
      this.view.unmarkVisitDirection();
      clearBusyState(document.documentElement);
      this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
    }
    locationWithActionIsSamePage(location2, action) {
      return this.navigator.locationWithActionIsSamePage(location2, action);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
    }
    // Form submit observer delegate
    willSubmitForm(form, submitter) {
      const action = getAction$1(form, submitter);
      return this.submissionIsNavigatable(form, submitter) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
    }
    formSubmitted(form, submitter) {
      this.navigator.submitForm(form, submitter);
    }
    // Page observer delegate
    pageBecameInteractive() {
      this.view.lastRenderedLocation = this.location;
      this.notifyApplicationAfterPageLoad();
    }
    pageLoaded() {
      this.history.assumeControlOfScrollRestoration();
    }
    pageWillUnload() {
      this.history.relinquishControlOfScrollRestoration();
    }
    // Stream observer delegate
    receivedMessageFromStream(message) {
      this.renderStreamMessage(message);
    }
    // Page view delegate
    viewWillCacheSnapshot() {
      if (!this.navigator.currentVisit?.silent) {
        this.notifyApplicationBeforeCachingSnapshot();
      }
    }
    allowsImmediateRender({ element }, options) {
      const event = this.notifyApplicationBeforeRender(element, options);
      const {
        defaultPrevented,
        detail: { render: render2 }
      } = event;
      if (this.view.renderer && render2) {
        this.view.renderer.renderElement = render2;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {
      this.view.lastRenderedLocation = this.history.location;
      this.notifyApplicationAfterRender(renderMethod);
    }
    preloadOnLoadLinksForView(element) {
      this.preloader.preloadOnLoadLinksForView(element);
    }
    viewInvalidated(reason) {
      this.adapter.pageInvalidated(reason);
    }
    // Frame element
    frameLoaded(frame) {
      this.notifyApplicationAfterFrameLoad(frame);
    }
    frameRendered(fetchResponse, frame) {
      this.notifyApplicationAfterFrameRender(fetchResponse, frame);
    }
    // Application events
    applicationAllowsFollowingLinkToLocation(link, location2, ev) {
      const event = this.notifyApplicationAfterClickingLinkToLocation(link, location2, ev);
      return !event.defaultPrevented;
    }
    applicationAllowsVisitingLocation(location2) {
      const event = this.notifyApplicationBeforeVisitingLocation(location2);
      return !event.defaultPrevented;
    }
    notifyApplicationAfterClickingLinkToLocation(link, location2, event) {
      return dispatch("turbo:click", {
        target: link,
        detail: { url: location2.href, originalEvent: event },
        cancelable: true
      });
    }
    notifyApplicationBeforeVisitingLocation(location2) {
      return dispatch("turbo:before-visit", {
        detail: { url: location2.href },
        cancelable: true
      });
    }
    notifyApplicationAfterVisitingLocation(location2, action) {
      return dispatch("turbo:visit", { detail: { url: location2.href, action } });
    }
    notifyApplicationBeforeCachingSnapshot() {
      return dispatch("turbo:before-cache");
    }
    notifyApplicationBeforeRender(newBody, options) {
      return dispatch("turbo:before-render", {
        detail: { newBody, ...options },
        cancelable: true
      });
    }
    notifyApplicationAfterRender(renderMethod) {
      return dispatch("turbo:render", { detail: { renderMethod } });
    }
    notifyApplicationAfterPageLoad(timing = {}) {
      return dispatch("turbo:load", {
        detail: { url: this.location.href, timing }
      });
    }
    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
      dispatchEvent(
        new HashChangeEvent("hashchange", {
          oldURL: oldURL.toString(),
          newURL: newURL.toString()
        })
      );
    }
    notifyApplicationAfterFrameLoad(frame) {
      return dispatch("turbo:frame-load", { target: frame });
    }
    notifyApplicationAfterFrameRender(fetchResponse, frame) {
      return dispatch("turbo:frame-render", {
        detail: { fetchResponse },
        target: frame,
        cancelable: true
      });
    }
    // Helpers
    submissionIsNavigatable(form, submitter) {
      if (this.formMode == "off") {
        return false;
      } else {
        const submitterIsNavigatable = submitter ? this.elementIsNavigatable(submitter) : true;
        if (this.formMode == "optin") {
          return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
        } else {
          return submitterIsNavigatable && this.elementIsNavigatable(form);
        }
      }
    }
    elementIsNavigatable(element) {
      const container = findClosestRecursively(element, "[data-turbo]");
      const withinFrame = findClosestRecursively(element, "turbo-frame");
      if (this.drive || withinFrame) {
        if (container) {
          return container.getAttribute("data-turbo") != "false";
        } else {
          return true;
        }
      } else {
        if (container) {
          return container.getAttribute("data-turbo") == "true";
        } else {
          return false;
        }
      }
    }
    // Private
    getActionForLink(link) {
      return getVisitAction(link) || "advance";
    }
    get snapshot() {
      return this.view.snapshot;
    }
  };
  function extendURLWithDeprecatedProperties(url) {
    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
  }
  var deprecatedLocationPropertyDescriptors = {
    absoluteURL: {
      get() {
        return this.toString();
      }
    }
  };
  var session = new Session(recentRequests);
  var { cache, navigator: navigator$1 } = session;
  function start() {
    session.start();
  }
  function registerAdapter(adapter) {
    session.registerAdapter(adapter);
  }
  function visit(location2, options) {
    session.visit(location2, options);
  }
  function connectStreamSource(source) {
    session.connectStreamSource(source);
  }
  function disconnectStreamSource(source) {
    session.disconnectStreamSource(source);
  }
  function renderStreamMessage(message) {
    session.renderStreamMessage(message);
  }
  function clearCache() {
    console.warn(
      "Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    session.clearCache();
  }
  function setProgressBarDelay(delay) {
    session.setProgressBarDelay(delay);
  }
  function setConfirmMethod(confirmMethod) {
    FormSubmission.confirmMethod = confirmMethod;
  }
  function setFormMode(mode) {
    session.setFormMode(mode);
  }
  var Turbo = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    navigator: navigator$1,
    session,
    cache,
    PageRenderer,
    PageSnapshot,
    FrameRenderer,
    fetch: fetchWithTurboHeaders,
    start,
    registerAdapter,
    visit,
    connectStreamSource,
    disconnectStreamSource,
    renderStreamMessage,
    clearCache,
    setProgressBarDelay,
    setConfirmMethod,
    setFormMode
  });
  var TurboFrameMissingError = class extends Error {
  };
  var FrameController = class {
    fetchResponseLoaded = (_fetchResponse) => Promise.resolve();
    #currentFetchRequest = null;
    #resolveVisitPromise = () => {
    };
    #connected = false;
    #hasBeenLoaded = false;
    #ignoredAttributes = /* @__PURE__ */ new Set();
    action = null;
    constructor(element) {
      this.element = element;
      this.view = new FrameView(this, this.element);
      this.appearanceObserver = new AppearanceObserver(this, this.element);
      this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
      this.linkInterceptor = new LinkInterceptor(this, this.element);
      this.restorationIdentifier = uuid();
      this.formSubmitObserver = new FormSubmitObserver(this, this.element);
    }
    // Frame delegate
    connect() {
      if (!this.#connected) {
        this.#connected = true;
        if (this.loadingStyle == FrameLoadingStyle.lazy) {
          this.appearanceObserver.start();
        } else {
          this.#loadSourceURL();
        }
        this.formLinkClickObserver.start();
        this.linkInterceptor.start();
        this.formSubmitObserver.start();
      }
    }
    disconnect() {
      if (this.#connected) {
        this.#connected = false;
        this.appearanceObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkInterceptor.stop();
        this.formSubmitObserver.stop();
      }
    }
    disabledChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager) {
        this.#loadSourceURL();
      }
    }
    sourceURLChanged() {
      if (this.#isIgnoringChangesTo("src"))
        return;
      if (this.element.isConnected) {
        this.complete = false;
      }
      if (this.loadingStyle == FrameLoadingStyle.eager || this.#hasBeenLoaded) {
        this.#loadSourceURL();
      }
    }
    sourceURLReloaded() {
      const { src } = this.element;
      this.element.removeAttribute("complete");
      this.element.src = null;
      this.element.src = src;
      return this.element.loaded;
    }
    loadingStyleChanged() {
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.appearanceObserver.stop();
        this.#loadSourceURL();
      }
    }
    async #loadSourceURL() {
      if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
        this.element.loaded = this.#visit(expandURL(this.sourceURL));
        this.appearanceObserver.stop();
        await this.element.loaded;
        this.#hasBeenLoaded = true;
      }
    }
    async loadResponse(fetchResponse) {
      if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
        this.sourceURL = fetchResponse.response.url;
      }
      try {
        const html = await fetchResponse.responseHTML;
        if (html) {
          const document2 = parseHTMLDocument(html);
          const pageSnapshot = PageSnapshot.fromDocument(document2);
          if (pageSnapshot.isVisitable) {
            await this.#loadFrameResponse(fetchResponse, document2);
          } else {
            await this.#handleUnvisitableFrameResponse(fetchResponse);
          }
        }
      } finally {
        this.fetchResponseLoaded = () => Promise.resolve();
      }
    }
    // Appearance observer delegate
    elementAppearedInViewport(element) {
      this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));
      this.#loadSourceURL();
    }
    // Form link click observer delegate
    willSubmitFormLinkToLocation(link) {
      return this.#shouldInterceptNavigation(link);
    }
    submittedFormLinkToLocation(link, _location, form) {
      const frame = this.#findFrameElement(link);
      if (frame)
        form.setAttribute("data-turbo-frame", frame.id);
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return this.#shouldInterceptNavigation(element);
    }
    linkClickIntercepted(element, location2) {
      this.#navigateFrame(element, location2);
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter) {
      return element.closest("turbo-frame") == this.element && this.#shouldInterceptNavigation(element, submitter);
    }
    formSubmitted(element, submitter) {
      if (this.formSubmission) {
        this.formSubmission.stop();
      }
      this.formSubmission = new FormSubmission(this, element, submitter);
      const { fetchRequest } = this.formSubmission;
      this.prepareRequest(fetchRequest);
      this.formSubmission.start();
    }
    // Fetch request delegate
    prepareRequest(request) {
      request.headers["Turbo-Frame"] = this.id;
      if (this.currentNavigationElement?.hasAttribute("data-turbo-stream")) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      markAsBusy(this.element);
    }
    requestPreventedHandlingResponse(_request, _response) {
      this.#resolveVisitPromise();
    }
    async requestSucceededWithResponse(request, response) {
      await this.loadResponse(response);
      this.#resolveVisitPromise();
    }
    async requestFailedWithResponse(request, response) {
      await this.loadResponse(response);
      this.#resolveVisitPromise();
    }
    requestErrored(request, error2) {
      console.error(error2);
      this.#resolveVisitPromise();
    }
    requestFinished(_request) {
      clearBusyState(this.element);
    }
    // Form submission delegate
    formSubmissionStarted({ formElement }) {
      markAsBusy(formElement, this.#findFrameElement(formElement));
    }
    formSubmissionSucceededWithResponse(formSubmission, response) {
      const frame = this.#findFrameElement(formSubmission.formElement, formSubmission.submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame));
      frame.delegate.loadResponse(response);
      if (!formSubmission.isSafe) {
        session.clearCache();
      }
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      this.element.delegate.loadResponse(fetchResponse);
      session.clearCache();
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished({ formElement }) {
      clearBusyState(formElement, this.#findFrameElement(formElement));
    }
    // View delegate
    allowsImmediateRender({ element: newFrame }, options) {
      const event = dispatch("turbo:before-frame-render", {
        target: this.element,
        detail: { newFrame, ...options },
        cancelable: true
      });
      const {
        defaultPrevented,
        detail: { render: render2 }
      } = event;
      if (this.view.renderer && render2) {
        this.view.renderer.renderElement = render2;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {
    }
    preloadOnLoadLinksForView(element) {
      session.preloadOnLoadLinksForView(element);
    }
    viewInvalidated() {
    }
    // Frame renderer delegate
    willRenderFrame(currentElement, _newElement) {
      this.previousFrameElement = currentElement.cloneNode(true);
    }
    visitCachedSnapshot = ({ element }) => {
      const frame = element.querySelector("#" + this.element.id);
      if (frame && this.previousFrameElement) {
        frame.replaceChildren(...this.previousFrameElement.children);
      }
      delete this.previousFrameElement;
    };
    // Private
    async #loadFrameResponse(fetchResponse, document2) {
      const newFrameElement = await this.extractForeignFrameElement(document2.body);
      if (newFrameElement) {
        const snapshot = new Snapshot(newFrameElement);
        const renderer2 = new FrameRenderer(this, this.view.snapshot, snapshot, FrameRenderer.renderElement, false, false);
        if (this.view.renderPromise)
          await this.view.renderPromise;
        this.changeHistory();
        await this.view.render(renderer2);
        this.complete = true;
        session.frameRendered(fetchResponse, this.element);
        session.frameLoaded(this.element);
        await this.fetchResponseLoaded(fetchResponse);
      } else if (this.#willHandleFrameMissingFromResponse(fetchResponse)) {
        this.#handleFrameMissingFromResponse(fetchResponse);
      }
    }
    async #visit(url) {
      const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
      this.#currentFetchRequest?.cancel();
      this.#currentFetchRequest = request;
      return new Promise((resolve2) => {
        this.#resolveVisitPromise = () => {
          this.#resolveVisitPromise = () => {
          };
          this.#currentFetchRequest = null;
          resolve2();
        };
        request.perform();
      });
    }
    #navigateFrame(element, url, submitter) {
      const frame = this.#findFrameElement(element, submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(submitter, element, frame));
      this.#withCurrentNavigationElement(element, () => {
        frame.src = url;
      });
    }
    proposeVisitIfNavigatedWithAction(frame, action = null) {
      this.action = action;
      if (this.action) {
        const pageSnapshot = PageSnapshot.fromElement(frame).clone();
        const { visitCachedSnapshot } = frame.delegate;
        frame.delegate.fetchResponseLoaded = async (fetchResponse) => {
          if (frame.src) {
            const { statusCode, redirected } = fetchResponse;
            const responseHTML = await fetchResponse.responseHTML;
            const response = { statusCode, redirected, responseHTML };
            const options = {
              response,
              visitCachedSnapshot,
              willRender: false,
              updateHistory: false,
              restorationIdentifier: this.restorationIdentifier,
              snapshot: pageSnapshot
            };
            if (this.action)
              options.action = this.action;
            session.visit(frame.src, options);
          }
        };
      }
    }
    changeHistory() {
      if (this.action) {
        const method = getHistoryMethodForAction(this.action);
        session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
      }
    }
    async #handleUnvisitableFrameResponse(fetchResponse) {
      console.warn(
        `The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`
      );
      await this.#visitResponse(fetchResponse.response);
    }
    #willHandleFrameMissingFromResponse(fetchResponse) {
      this.element.setAttribute("complete", "");
      const response = fetchResponse.response;
      const visit2 = async (url, options) => {
        if (url instanceof Response) {
          this.#visitResponse(url);
        } else {
          session.visit(url, options);
        }
      };
      const event = dispatch("turbo:frame-missing", {
        target: this.element,
        detail: { response, visit: visit2 },
        cancelable: true
      });
      return !event.defaultPrevented;
    }
    #handleFrameMissingFromResponse(fetchResponse) {
      this.view.missing();
      this.#throwFrameMissingError(fetchResponse);
    }
    #throwFrameMissingError(fetchResponse) {
      const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
      throw new TurboFrameMissingError(message);
    }
    async #visitResponse(response) {
      const wrapped = new FetchResponse(response);
      const responseHTML = await wrapped.responseHTML;
      const { location: location2, redirected, statusCode } = wrapped;
      return session.visit(location2, { response: { redirected, statusCode, responseHTML } });
    }
    #findFrameElement(element, submitter) {
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      return getFrameElementById(id) ?? this.element;
    }
    async extractForeignFrameElement(container) {
      let element;
      const id = CSS.escape(this.id);
      try {
        element = activateElement(container.querySelector(`turbo-frame#${id}`), this.sourceURL);
        if (element) {
          return element;
        }
        element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.sourceURL);
        if (element) {
          await element.loaded;
          return await this.extractForeignFrameElement(element);
        }
      } catch (error2) {
        console.error(error2);
        return new FrameElement();
      }
      return null;
    }
    #formActionIsVisitable(form, submitter) {
      const action = getAction$1(form, submitter);
      return locationIsVisitable(expandURL(action), this.rootLocation);
    }
    #shouldInterceptNavigation(element, submitter) {
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      if (element instanceof HTMLFormElement && !this.#formActionIsVisitable(element, submitter)) {
        return false;
      }
      if (!this.enabled || id == "_top") {
        return false;
      }
      if (id) {
        const frameElement = getFrameElementById(id);
        if (frameElement) {
          return !frameElement.disabled;
        }
      }
      if (!session.elementIsNavigatable(element)) {
        return false;
      }
      if (submitter && !session.elementIsNavigatable(submitter)) {
        return false;
      }
      return true;
    }
    // Computed properties
    get id() {
      return this.element.id;
    }
    get enabled() {
      return !this.element.disabled;
    }
    get sourceURL() {
      if (this.element.src) {
        return this.element.src;
      }
    }
    set sourceURL(sourceURL) {
      this.#ignoringChangesToAttribute("src", () => {
        this.element.src = sourceURL ?? null;
      });
    }
    get loadingStyle() {
      return this.element.loading;
    }
    get isLoading() {
      return this.formSubmission !== void 0 || this.#resolveVisitPromise() !== void 0;
    }
    get complete() {
      return this.element.hasAttribute("complete");
    }
    set complete(value) {
      if (value) {
        this.element.setAttribute("complete", "");
      } else {
        this.element.removeAttribute("complete");
      }
    }
    get isActive() {
      return this.element.isActive && this.#connected;
    }
    get rootLocation() {
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const root = meta?.content ?? "/";
      return expandURL(root);
    }
    #isIgnoringChangesTo(attributeName) {
      return this.#ignoredAttributes.has(attributeName);
    }
    #ignoringChangesToAttribute(attributeName, callback) {
      this.#ignoredAttributes.add(attributeName);
      callback();
      this.#ignoredAttributes.delete(attributeName);
    }
    #withCurrentNavigationElement(element, callback) {
      this.currentNavigationElement = element;
      callback();
      delete this.currentNavigationElement;
    }
  };
  function getFrameElementById(id) {
    if (id != null) {
      const element = document.getElementById(id);
      if (element instanceof FrameElement) {
        return element;
      }
    }
  }
  function activateElement(element, currentURL) {
    if (element) {
      const src = element.getAttribute("src");
      if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
        throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
      }
      if (element.ownerDocument !== document) {
        element = document.importNode(element, true);
      }
      if (element instanceof FrameElement) {
        element.connectedCallback();
        element.disconnectedCallback();
        return element;
      }
    }
  }
  var StreamActions = {
    after() {
      this.targetElements.forEach((e) => e.parentElement?.insertBefore(this.templateContent, e.nextSibling));
    },
    append() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e) => e.append(this.templateContent));
    },
    before() {
      this.targetElements.forEach((e) => e.parentElement?.insertBefore(this.templateContent, e));
    },
    prepend() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e) => e.prepend(this.templateContent));
    },
    remove() {
      this.targetElements.forEach((e) => e.remove());
    },
    replace() {
      this.targetElements.forEach((e) => e.replaceWith(this.templateContent));
    },
    update() {
      this.targetElements.forEach((targetElement) => {
        targetElement.innerHTML = "";
        targetElement.append(this.templateContent);
      });
    },
    refresh() {
      session.refresh(this.baseURI, this.requestId);
    }
  };
  var StreamElement = class _StreamElement extends HTMLElement {
    static async renderElement(newElement) {
      await newElement.performAction();
    }
    async connectedCallback() {
      try {
        await this.render();
      } catch (error2) {
        console.error(error2);
      } finally {
        this.disconnect();
      }
    }
    async render() {
      return this.renderPromise ??= (async () => {
        const event = this.beforeRenderEvent;
        if (this.dispatchEvent(event)) {
          await nextRepaint();
          await event.detail.render(this);
        }
      })();
    }
    disconnect() {
      try {
        this.remove();
      } catch {
      }
    }
    /**
     * Removes duplicate children (by ID)
     */
    removeDuplicateTargetChildren() {
      this.duplicateChildren.forEach((c) => c.remove());
    }
    /**
     * Gets the list of duplicate children (i.e. those with the same ID)
     */
    get duplicateChildren() {
      const existingChildren = this.targetElements.flatMap((e) => [...e.children]).filter((c) => !!c.id);
      const newChildrenIds = [...this.templateContent?.children || []].filter((c) => !!c.id).map((c) => c.id);
      return existingChildren.filter((c) => newChildrenIds.includes(c.id));
    }
    /**
     * Gets the action function to be performed.
     */
    get performAction() {
      if (this.action) {
        const actionFunction = StreamActions[this.action];
        if (actionFunction) {
          return actionFunction;
        }
        this.#raise("unknown action");
      }
      this.#raise("action attribute is missing");
    }
    /**
     * Gets the target elements which the template will be rendered to.
     */
    get targetElements() {
      if (this.target) {
        return this.targetElementsById;
      } else if (this.targets) {
        return this.targetElementsByQuery;
      } else {
        this.#raise("target or targets attribute is missing");
      }
    }
    /**
     * Gets the contents of the main `<template>`.
     */
    get templateContent() {
      return this.templateElement.content.cloneNode(true);
    }
    /**
     * Gets the main `<template>` used for rendering
     */
    get templateElement() {
      if (this.firstElementChild === null) {
        const template = this.ownerDocument.createElement("template");
        this.appendChild(template);
        return template;
      } else if (this.firstElementChild instanceof HTMLTemplateElement) {
        return this.firstElementChild;
      }
      this.#raise("first child element must be a <template> element");
    }
    /**
     * Gets the current action.
     */
    get action() {
      return this.getAttribute("action");
    }
    /**
     * Gets the current target (an element ID) to which the result will
     * be rendered.
     */
    get target() {
      return this.getAttribute("target");
    }
    /**
     * Gets the current "targets" selector (a CSS selector)
     */
    get targets() {
      return this.getAttribute("targets");
    }
    /**
     * Reads the request-id attribute
     */
    get requestId() {
      return this.getAttribute("request-id");
    }
    #raise(message) {
      throw new Error(`${this.description}: ${message}`);
    }
    get description() {
      return (this.outerHTML.match(/<[^>]+>/) ?? [])[0] ?? "<turbo-stream>";
    }
    get beforeRenderEvent() {
      return new CustomEvent("turbo:before-stream-render", {
        bubbles: true,
        cancelable: true,
        detail: { newStream: this, render: _StreamElement.renderElement }
      });
    }
    get targetElementsById() {
      const element = this.ownerDocument?.getElementById(this.target);
      if (element !== null) {
        return [element];
      } else {
        return [];
      }
    }
    get targetElementsByQuery() {
      const elements = this.ownerDocument?.querySelectorAll(this.targets);
      if (elements.length !== 0) {
        return Array.prototype.slice.call(elements);
      } else {
        return [];
      }
    }
  };
  var StreamSourceElement = class extends HTMLElement {
    streamSource = null;
    connectedCallback() {
      this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
      connectStreamSource(this.streamSource);
    }
    disconnectedCallback() {
      if (this.streamSource) {
        this.streamSource.close();
        disconnectStreamSource(this.streamSource);
      }
    }
    get src() {
      return this.getAttribute("src") || "";
    }
  };
  FrameElement.delegateConstructor = FrameController;
  if (customElements.get("turbo-frame") === void 0) {
    customElements.define("turbo-frame", FrameElement);
  }
  if (customElements.get("turbo-stream") === void 0) {
    customElements.define("turbo-stream", StreamElement);
  }
  if (customElements.get("turbo-stream-source") === void 0) {
    customElements.define("turbo-stream-source", StreamSourceElement);
  }
  (() => {
    let element = document.currentScript;
    if (!element)
      return;
    if (element.hasAttribute("data-turbo-suppress-warning"))
      return;
    element = element.parentElement;
    while (element) {
      if (element == document.body) {
        return console.warn(
          unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your applications JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `,
          element.outerHTML
        );
      }
      element = element.parentElement;
    }
  })();
  window.Turbo = { ...Turbo, StreamActions };
  start();

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
  var consumer;
  async function getConsumer() {
    return consumer || setConsumer(createConsumer2().then(setConsumer));
  }
  function setConsumer(newConsumer) {
    return consumer = newConsumer;
  }
  async function createConsumer2() {
    const { createConsumer: createConsumer3 } = await Promise.resolve().then(() => (init_src(), src_exports));
    return createConsumer3();
  }
  async function subscribeTo(channel, mixin) {
    const { subscriptions } = await getConsumer();
    return subscriptions.create(channel, mixin);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/snakeize.js
  function walk(obj) {
    if (!obj || typeof obj !== "object")
      return obj;
    if (obj instanceof Date || obj instanceof RegExp)
      return obj;
    if (Array.isArray(obj))
      return obj.map(walk);
    return Object.keys(obj).reduce(function(acc, key) {
      var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function(m, x) {
        return "_" + x.toLowerCase();
      });
      acc[camel] = walk(obj[key]);
      return acc;
    }, {});
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
  var TurboCableStreamSourceElement = class extends HTMLElement {
    async connectedCallback() {
      connectStreamSource(this);
      this.subscription = await subscribeTo(this.channel, {
        received: this.dispatchMessageEvent.bind(this),
        connected: this.subscriptionConnected.bind(this),
        disconnected: this.subscriptionDisconnected.bind(this)
      });
    }
    disconnectedCallback() {
      disconnectStreamSource(this);
      if (this.subscription)
        this.subscription.unsubscribe();
    }
    dispatchMessageEvent(data) {
      const event = new MessageEvent("message", { data });
      return this.dispatchEvent(event);
    }
    subscriptionConnected() {
      this.setAttribute("connected", "");
    }
    subscriptionDisconnected() {
      this.removeAttribute("connected");
    }
    get channel() {
      const channel = this.getAttribute("channel");
      const signed_stream_name = this.getAttribute("signed-stream-name");
      return { channel, signed_stream_name, ...walk({ ...this.dataset }) };
    }
  };
  if (customElements.get("turbo-cable-stream-source") === void 0) {
    customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/fetch_requests.js
  function encodeMethodIntoRequestBody(event) {
    if (event.target instanceof HTMLFormElement) {
      const { target: form, detail: { fetchOptions } } = event;
      form.addEventListener("turbo:submit-start", ({ detail: { formSubmission: { submitter } } }) => {
        const body = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams();
        const method = determineFetchMethod(submitter, body, form);
        if (!/get/i.test(method)) {
          if (/post/i.test(method)) {
            body.delete("_method");
          } else {
            body.set("_method", method);
          }
          fetchOptions.method = "post";
        }
      }, { once: true });
    }
  }
  function determineFetchMethod(submitter, body, form) {
    const formMethod = determineFormMethod(submitter);
    const overrideMethod = body.get("_method");
    const method = form.getAttribute("method") || "get";
    if (typeof formMethod == "string") {
      return formMethod;
    } else if (typeof overrideMethod == "string") {
      return overrideMethod;
    } else {
      return method;
    }
  }
  function determineFormMethod(submitter) {
    if (submitter instanceof HTMLButtonElement || submitter instanceof HTMLInputElement) {
      if (submitter.name === "_method") {
        return submitter.value;
      } else if (submitter.hasAttribute("formmethod")) {
        return submitter.formMethod;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  function isBodyInit(body) {
    return body instanceof FormData || body instanceof URLSearchParams;
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/index.js
  window.Turbo = turbo_es2017_esm_exports;
  addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);

  // node_modules/@hotwired/stimulus/dist/stimulus.js
  var EventListener = class {
    constructor(eventTarget, eventName, eventOptions) {
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this.eventOptions = eventOptions;
      this.unorderedBindings = /* @__PURE__ */ new Set();
    }
    connect() {
      this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
      this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
      this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
      this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
      const extendedEvent = extendEvent(event);
      for (const binding of this.bindings) {
        if (extendedEvent.immediatePropagationStopped) {
          break;
        } else {
          binding.handleEvent(extendedEvent);
        }
      }
    }
    hasBindings() {
      return this.unorderedBindings.size > 0;
    }
    get bindings() {
      return Array.from(this.unorderedBindings).sort((left, right) => {
        const leftIndex = left.index, rightIndex = right.index;
        return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
      });
    }
  };
  function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
      return event;
    } else {
      const { stopImmediatePropagation } = event;
      return Object.assign(event, {
        immediatePropagationStopped: false,
        stopImmediatePropagation() {
          this.immediatePropagationStopped = true;
          stopImmediatePropagation.call(this);
        }
      });
    }
  }
  var Dispatcher = class {
    constructor(application2) {
      this.application = application2;
      this.eventListenerMaps = /* @__PURE__ */ new Map();
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.eventListeners.forEach((eventListener) => eventListener.connect());
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.eventListeners.forEach((eventListener) => eventListener.disconnect());
      }
    }
    get eventListeners() {
      return Array.from(this.eventListenerMaps.values()).reduce((listeners, map2) => listeners.concat(Array.from(map2.values())), []);
    }
    bindingConnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding, clearEventListeners = false) {
      this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
      if (clearEventListeners)
        this.clearEventListenersForBinding(binding);
    }
    handleError(error2, message, detail = {}) {
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    clearEventListenersForBinding(binding) {
      const eventListener = this.fetchEventListenerForBinding(binding);
      if (!eventListener.hasBindings()) {
        eventListener.disconnect();
        this.removeMappedEventListenerFor(binding);
      }
    }
    removeMappedEventListenerFor(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      eventListenerMap.delete(cacheKey);
      if (eventListenerMap.size == 0)
        this.eventListenerMaps.delete(eventTarget);
    }
    fetchEventListenerForBinding(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      let eventListener = eventListenerMap.get(cacheKey);
      if (!eventListener) {
        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
        eventListenerMap.set(cacheKey, eventListener);
      }
      return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
      const eventListener = new EventListener(eventTarget, eventName, eventOptions);
      if (this.started) {
        eventListener.connect();
      }
      return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
      let eventListenerMap = this.eventListenerMaps.get(eventTarget);
      if (!eventListenerMap) {
        eventListenerMap = /* @__PURE__ */ new Map();
        this.eventListenerMaps.set(eventTarget, eventListenerMap);
      }
      return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
      const parts = [eventName];
      Object.keys(eventOptions).sort().forEach((key) => {
        parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
      });
      return parts.join(":");
    }
  };
  var defaultActionDescriptorFilters = {
    stop({ event, value }) {
      if (value)
        event.stopPropagation();
      return true;
    },
    prevent({ event, value }) {
      if (value)
        event.preventDefault();
      return true;
    },
    self({ event, value, element }) {
      if (value) {
        return element === event.target;
      } else {
        return true;
      }
    }
  };
  var descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
  function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches2 = source.match(descriptorPattern) || [];
    let eventName = matches2[2];
    let keyFilter = matches2[3];
    if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
      eventName += `.${keyFilter}`;
      keyFilter = "";
    }
    return {
      eventTarget: parseEventTarget(matches2[4]),
      eventName,
      eventOptions: matches2[7] ? parseEventOptions(matches2[7]) : {},
      identifier: matches2[5],
      methodName: matches2[6],
      keyFilter: matches2[1] || keyFilter
    };
  }
  function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
      return window;
    } else if (eventTargetName == "document") {
      return document;
    }
  }
  function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
  }
  function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
      return "window";
    } else if (eventTarget == document) {
      return "document";
    }
  }
  function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_2, char) => char.toUpperCase());
  }
  function namespaceCamelize(value) {
    return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
  }
  function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
  function dasherize(value) {
    return value.replace(/([A-Z])/g, (_2, char) => `-${char.toLowerCase()}`);
  }
  function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
  }
  function isSomething(object) {
    return object !== null && object !== void 0;
  }
  function hasProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }
  var allModifiers = ["meta", "ctrl", "alt", "shift"];
  var Action = class {
    constructor(element, index, descriptor, schema) {
      this.element = element;
      this.index = index;
      this.eventTarget = descriptor.eventTarget || element;
      this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
      this.eventOptions = descriptor.eventOptions || {};
      this.identifier = descriptor.identifier || error("missing identifier");
      this.methodName = descriptor.methodName || error("missing method name");
      this.keyFilter = descriptor.keyFilter || "";
      this.schema = schema;
    }
    static forToken(token, schema) {
      return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
    }
    toString() {
      const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
      const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
      return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
    }
    shouldIgnoreKeyboardEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = this.keyFilter.split("+");
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];
      if (!standardFilter) {
        return false;
      }
      if (!hasProperty(this.keyMappings, standardFilter)) {
        error(`contains unknown key filter: ${this.keyFilter}`);
      }
      return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
    }
    shouldIgnoreMouseEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = [this.keyFilter];
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      return false;
    }
    get params() {
      const params = {};
      const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
      for (const { name, value } of Array.from(this.element.attributes)) {
        const match = name.match(pattern);
        const key = match && match[1];
        if (key) {
          params[camelize(key)] = typecast(value);
        }
      }
      return params;
    }
    get eventTargetName() {
      return stringifyEventTarget(this.eventTarget);
    }
    get keyMappings() {
      return this.schema.keyMappings;
    }
    keyFilterDissatisfied(event, filters) {
      const [meta, ctrl, alt, shift] = allModifiers.map((modifier) => filters.includes(modifier));
      return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift;
    }
  };
  var defaultEventNames = {
    a: () => "click",
    button: () => "click",
    form: () => "submit",
    details: () => "toggle",
    input: (e) => e.getAttribute("type") == "submit" ? "click" : "input",
    select: () => "change",
    textarea: () => "input"
  };
  function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
      return defaultEventNames[tagName](element);
    }
  }
  function error(message) {
    throw new Error(message);
  }
  function typecast(value) {
    try {
      return JSON.parse(value);
    } catch (o_O) {
      return value;
    }
  }
  var Binding = class {
    constructor(context, action) {
      this.context = context;
      this.action = action;
    }
    get index() {
      return this.action.index;
    }
    get eventTarget() {
      return this.action.eventTarget;
    }
    get eventOptions() {
      return this.action.eventOptions;
    }
    get identifier() {
      return this.context.identifier;
    }
    handleEvent(event) {
      const actionEvent = this.prepareActionEvent(event);
      if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {
        this.invokeWithEvent(actionEvent);
      }
    }
    get eventName() {
      return this.action.eventName;
    }
    get method() {
      const method = this.controller[this.methodName];
      if (typeof method == "function") {
        return method;
      }
      throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    applyEventModifiers(event) {
      const { element } = this.action;
      const { actionDescriptorFilters } = this.context.application;
      const { controller } = this.context;
      let passes = true;
      for (const [name, value] of Object.entries(this.eventOptions)) {
        if (name in actionDescriptorFilters) {
          const filter = actionDescriptorFilters[name];
          passes = passes && filter({ name, value, event, element, controller });
        } else {
          continue;
        }
      }
      return passes;
    }
    prepareActionEvent(event) {
      return Object.assign(event, { params: this.action.params });
    }
    invokeWithEvent(event) {
      const { target, currentTarget } = event;
      try {
        this.method.call(this.controller, event);
        this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
      } catch (error2) {
        const { identifier, controller, element, index } = this;
        const detail = { identifier, controller, element, index, event };
        this.context.handleError(error2, `invoking action "${this.action}"`, detail);
      }
    }
    willBeInvokedByEvent(event) {
      const eventTarget = event.target;
      if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {
        return false;
      }
      if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {
        return false;
      }
      if (this.element === eventTarget) {
        return true;
      } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
        return this.scope.containsElement(eventTarget);
      } else {
        return this.scope.containsElement(this.action.element);
      }
    }
    get controller() {
      return this.context.controller;
    }
    get methodName() {
      return this.action.methodName;
    }
    get element() {
      return this.scope.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var ElementObserver = class {
    constructor(element, delegate) {
      this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
      this.element = element;
      this.started = false;
      this.delegate = delegate;
      this.elements = /* @__PURE__ */ new Set();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.refresh();
      }
    }
    pause(callback) {
      if (this.started) {
        this.mutationObserver.disconnect();
        this.started = false;
      }
      callback();
      if (!this.started) {
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        const matches2 = new Set(this.matchElementsInTree());
        for (const element of Array.from(this.elements)) {
          if (!matches2.has(element)) {
            this.removeElement(element);
          }
        }
        for (const element of Array.from(matches2)) {
          this.addElement(element);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      if (mutation.type == "attributes") {
        this.processAttributeChange(mutation.target, mutation.attributeName);
      } else if (mutation.type == "childList") {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
      }
    }
    processAttributeChange(element, attributeName) {
      if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
          this.delegate.elementAttributeChanged(element, attributeName);
        } else {
          this.removeElement(element);
        }
      } else if (this.matchElement(element)) {
        this.addElement(element);
      }
    }
    processRemovedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element) {
          this.processTree(element, this.removeElement);
        }
      }
    }
    processAddedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element && this.elementIsActive(element)) {
          this.processTree(element, this.addElement);
        }
      }
    }
    matchElement(element) {
      return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
      return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
      for (const element of this.matchElementsInTree(tree)) {
        processor.call(this, element);
      }
    }
    elementFromNode(node) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        return node;
      }
    }
    elementIsActive(element) {
      if (element.isConnected != this.element.isConnected) {
        return false;
      } else {
        return this.element.contains(element);
      }
    }
    addElement(element) {
      if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
          this.elements.add(element);
          if (this.delegate.elementMatched) {
            this.delegate.elementMatched(element);
          }
        }
      }
    }
    removeElement(element) {
      if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
          this.delegate.elementUnmatched(element);
        }
      }
    }
  };
  var AttributeObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeName = attributeName;
      this.delegate = delegate;
      this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
      return this.elementObserver.element;
    }
    get selector() {
      return `[${this.attributeName}]`;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get started() {
      return this.elementObserver.started;
    }
    matchElement(element) {
      return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches2 = Array.from(tree.querySelectorAll(this.selector));
      return match.concat(matches2);
    }
    elementMatched(element) {
      if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
      }
    }
    elementUnmatched(element) {
      if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
      }
    }
    elementAttributeChanged(element, attributeName) {
      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
      }
    }
  };
  function add(map2, key, value) {
    fetch(map2, key).add(value);
  }
  function del(map2, key, value) {
    fetch(map2, key).delete(value);
    prune(map2, key);
  }
  function fetch(map2, key) {
    let values2 = map2.get(key);
    if (!values2) {
      values2 = /* @__PURE__ */ new Set();
      map2.set(key, values2);
    }
    return values2;
  }
  function prune(map2, key) {
    const values2 = map2.get(key);
    if (values2 != null && values2.size == 0) {
      map2.delete(key);
    }
  }
  var Multimap = class {
    constructor() {
      this.valuesByKey = /* @__PURE__ */ new Map();
    }
    get keys() {
      return Array.from(this.valuesByKey.keys());
    }
    get values() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((values2, set2) => values2.concat(Array.from(set2)), []);
    }
    get size() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((size2, set2) => size2 + set2.size, 0);
    }
    add(key, value) {
      add(this.valuesByKey, key, value);
    }
    delete(key, value) {
      del(this.valuesByKey, key, value);
    }
    has(key, value) {
      const values2 = this.valuesByKey.get(key);
      return values2 != null && values2.has(value);
    }
    hasKey(key) {
      return this.valuesByKey.has(key);
    }
    hasValue(value) {
      const sets = Array.from(this.valuesByKey.values());
      return sets.some((set2) => set2.has(value));
    }
    getValuesForKey(key) {
      const values2 = this.valuesByKey.get(key);
      return values2 ? Array.from(values2) : [];
    }
    getKeysForValue(value) {
      return Array.from(this.valuesByKey).filter(([_key, values2]) => values2.has(value)).map(([key, _values]) => key);
    }
  };
  var SelectorObserver = class {
    constructor(element, selector, delegate, details) {
      this._selector = selector;
      this.details = details;
      this.elementObserver = new ElementObserver(element, this);
      this.delegate = delegate;
      this.matchesByElement = new Multimap();
    }
    get started() {
      return this.elementObserver.started;
    }
    get selector() {
      return this._selector;
    }
    set selector(selector) {
      this._selector = selector;
      this.refresh();
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get element() {
      return this.elementObserver.element;
    }
    matchElement(element) {
      const { selector } = this;
      if (selector) {
        const matches2 = element.matches(selector);
        if (this.delegate.selectorMatchElement) {
          return matches2 && this.delegate.selectorMatchElement(element, this.details);
        }
        return matches2;
      } else {
        return false;
      }
    }
    matchElementsInTree(tree) {
      const { selector } = this;
      if (selector) {
        const match = this.matchElement(tree) ? [tree] : [];
        const matches2 = Array.from(tree.querySelectorAll(selector)).filter((match2) => this.matchElement(match2));
        return match.concat(matches2);
      } else {
        return [];
      }
    }
    elementMatched(element) {
      const { selector } = this;
      if (selector) {
        this.selectorMatched(element, selector);
      }
    }
    elementUnmatched(element) {
      const selectors = this.matchesByElement.getKeysForValue(element);
      for (const selector of selectors) {
        this.selectorUnmatched(element, selector);
      }
    }
    elementAttributeChanged(element, _attributeName) {
      const { selector } = this;
      if (selector) {
        const matches2 = this.matchElement(element);
        const matchedBefore = this.matchesByElement.has(selector, element);
        if (matches2 && !matchedBefore) {
          this.selectorMatched(element, selector);
        } else if (!matches2 && matchedBefore) {
          this.selectorUnmatched(element, selector);
        }
      }
    }
    selectorMatched(element, selector) {
      this.delegate.selectorMatched(element, selector, this.details);
      this.matchesByElement.add(selector, element);
    }
    selectorUnmatched(element, selector) {
      this.delegate.selectorUnmatched(element, selector, this.details);
      this.matchesByElement.delete(selector, element);
    }
  };
  var StringMapObserver = class {
    constructor(element, delegate) {
      this.element = element;
      this.delegate = delegate;
      this.started = false;
      this.stringMap = /* @__PURE__ */ new Map();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
        this.refresh();
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        for (const attributeName of this.knownAttributeNames) {
          this.refreshAttribute(attributeName, null);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      const attributeName = mutation.attributeName;
      if (attributeName) {
        this.refreshAttribute(attributeName, mutation.oldValue);
      }
    }
    refreshAttribute(attributeName, oldValue) {
      const key = this.delegate.getStringMapKeyForAttribute(attributeName);
      if (key != null) {
        if (!this.stringMap.has(attributeName)) {
          this.stringMapKeyAdded(key, attributeName);
        }
        const value = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value) {
          this.stringMapValueChanged(value, key, oldValue);
        }
        if (value == null) {
          const oldValue2 = this.stringMap.get(attributeName);
          this.stringMap.delete(attributeName);
          if (oldValue2)
            this.stringMapKeyRemoved(key, attributeName, oldValue2);
        } else {
          this.stringMap.set(attributeName, value);
        }
      }
    }
    stringMapKeyAdded(key, attributeName) {
      if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key, attributeName);
      }
    }
    stringMapValueChanged(value, key, oldValue) {
      if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value, key, oldValue);
      }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
      }
    }
    get knownAttributeNames() {
      return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
      return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
      return Array.from(this.stringMap.keys());
    }
  };
  var TokenListObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeObserver = new AttributeObserver(element, attributeName, this);
      this.delegate = delegate;
      this.tokensByElement = new Multimap();
    }
    get started() {
      return this.attributeObserver.started;
    }
    start() {
      this.attributeObserver.start();
    }
    pause(callback) {
      this.attributeObserver.pause(callback);
    }
    stop() {
      this.attributeObserver.stop();
    }
    refresh() {
      this.attributeObserver.refresh();
    }
    get element() {
      return this.attributeObserver.element;
    }
    get attributeName() {
      return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
      this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
      const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
      this.tokensUnmatched(unmatchedTokens);
      this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
      tokens.forEach((token) => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
      tokens.forEach((token) => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
      this.delegate.tokenMatched(token);
      this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
      this.delegate.tokenUnmatched(token);
      this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
      const previousTokens = this.tokensByElement.getValuesForKey(element);
      const currentTokens = this.readTokensForElement(element);
      const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
      if (firstDifferingIndex == -1) {
        return [[], []];
      } else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
      }
    }
    readTokensForElement(element) {
      const attributeName = this.attributeName;
      const tokenString = element.getAttribute(attributeName) || "";
      return parseTokenString(tokenString, element, attributeName);
    }
  };
  function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index) => ({ element, attributeName, content, index }));
  }
  function zip(left, right) {
    const length = Math.max(left.length, right.length);
    return Array.from({ length }, (_2, index) => [left[index], right[index]]);
  }
  function tokensAreEqual(left, right) {
    return left && right && left.index == right.index && left.content == right.content;
  }
  var ValueListObserver = class {
    constructor(element, attributeName, delegate) {
      this.tokenListObserver = new TokenListObserver(element, attributeName, this);
      this.delegate = delegate;
      this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
      this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
    }
    get started() {
      return this.tokenListObserver.started;
    }
    start() {
      this.tokenListObserver.start();
    }
    stop() {
      this.tokenListObserver.stop();
    }
    refresh() {
      this.tokenListObserver.refresh();
    }
    get element() {
      return this.tokenListObserver.element;
    }
    get attributeName() {
      return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).set(token, value);
        this.delegate.elementMatchedValue(element, value);
      }
    }
    tokenUnmatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).delete(token);
        this.delegate.elementUnmatchedValue(element, value);
      }
    }
    fetchParseResultForToken(token) {
      let parseResult = this.parseResultsByToken.get(token);
      if (!parseResult) {
        parseResult = this.parseToken(token);
        this.parseResultsByToken.set(token, parseResult);
      }
      return parseResult;
    }
    fetchValuesByTokenForElement(element) {
      let valuesByToken = this.valuesByTokenByElement.get(element);
      if (!valuesByToken) {
        valuesByToken = /* @__PURE__ */ new Map();
        this.valuesByTokenByElement.set(element, valuesByToken);
      }
      return valuesByToken;
    }
    parseToken(token) {
      try {
        const value = this.delegate.parseValueForToken(token);
        return { value };
      } catch (error2) {
        return { error: error2 };
      }
    }
  };
  var BindingObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.bindingsByAction = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.valueListObserver) {
        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
        this.valueListObserver.start();
      }
    }
    stop() {
      if (this.valueListObserver) {
        this.valueListObserver.stop();
        delete this.valueListObserver;
        this.disconnectAllActions();
      }
    }
    get element() {
      return this.context.element;
    }
    get identifier() {
      return this.context.identifier;
    }
    get actionAttribute() {
      return this.schema.actionAttribute;
    }
    get schema() {
      return this.context.schema;
    }
    get bindings() {
      return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
      const binding = new Binding(this.context, action);
      this.bindingsByAction.set(action, binding);
      this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
      const binding = this.bindingsByAction.get(action);
      if (binding) {
        this.bindingsByAction.delete(action);
        this.delegate.bindingDisconnected(binding);
      }
    }
    disconnectAllActions() {
      this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
      this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
      const action = Action.forToken(token, this.schema);
      if (action.identifier == this.identifier) {
        return action;
      }
    }
    elementMatchedValue(element, action) {
      this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
      this.disconnectAction(action);
    }
  };
  var ValueObserver = class {
    constructor(context, receiver) {
      this.context = context;
      this.receiver = receiver;
      this.stringMapObserver = new StringMapObserver(this.element, this);
      this.valueDescriptorMap = this.controller.valueDescriptorMap;
    }
    start() {
      this.stringMapObserver.start();
      this.invokeChangedCallbacksForDefaultValues();
    }
    stop() {
      this.stringMapObserver.stop();
    }
    get element() {
      return this.context.element;
    }
    get controller() {
      return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
      if (attributeName in this.valueDescriptorMap) {
        return this.valueDescriptorMap[attributeName].name;
      }
    }
    stringMapKeyAdded(key, attributeName) {
      const descriptor = this.valueDescriptorMap[attributeName];
      if (!this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
      }
    }
    stringMapValueChanged(value, name, oldValue) {
      const descriptor = this.valueDescriptorNameMap[name];
      if (value === null)
        return;
      if (oldValue === null) {
        oldValue = descriptor.writer(descriptor.defaultValue);
      }
      this.invokeChangedCallback(name, value, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      const descriptor = this.valueDescriptorNameMap[key];
      if (this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
      } else {
        this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
      }
    }
    invokeChangedCallbacksForDefaultValues() {
      for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
        if (defaultValue != void 0 && !this.controller.data.has(key)) {
          this.invokeChangedCallback(name, writer(defaultValue), void 0);
        }
      }
    }
    invokeChangedCallback(name, rawValue, rawOldValue) {
      const changedMethodName = `${name}Changed`;
      const changedMethod = this.receiver[changedMethodName];
      if (typeof changedMethod == "function") {
        const descriptor = this.valueDescriptorNameMap[name];
        try {
          const value = descriptor.reader(rawValue);
          let oldValue = rawOldValue;
          if (rawOldValue) {
            oldValue = descriptor.reader(rawOldValue);
          }
          changedMethod.call(this.receiver, value, oldValue);
        } catch (error2) {
          if (error2 instanceof TypeError) {
            error2.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error2.message}`;
          }
          throw error2;
        }
      }
    }
    get valueDescriptors() {
      const { valueDescriptorMap } = this;
      return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
      const descriptors = {};
      Object.keys(this.valueDescriptorMap).forEach((key) => {
        const descriptor = this.valueDescriptorMap[key];
        descriptors[descriptor.name] = descriptor;
      });
      return descriptors;
    }
    hasValue(attributeName) {
      const descriptor = this.valueDescriptorNameMap[attributeName];
      const hasMethodName = `has${capitalize(descriptor.name)}`;
      return this.receiver[hasMethodName];
    }
  };
  var TargetObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.targetsByName = new Multimap();
    }
    start() {
      if (!this.tokenListObserver) {
        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
        this.tokenListObserver.start();
      }
    }
    stop() {
      if (this.tokenListObserver) {
        this.disconnectAllTargets();
        this.tokenListObserver.stop();
        delete this.tokenListObserver;
      }
    }
    tokenMatched({ element, content: name }) {
      if (this.scope.containsElement(element)) {
        this.connectTarget(element, name);
      }
    }
    tokenUnmatched({ element, content: name }) {
      this.disconnectTarget(element, name);
    }
    connectTarget(element, name) {
      var _a;
      if (!this.targetsByName.has(name, element)) {
        this.targetsByName.add(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
      }
    }
    disconnectTarget(element, name) {
      var _a;
      if (this.targetsByName.has(name, element)) {
        this.targetsByName.delete(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
      }
    }
    disconnectAllTargets() {
      for (const name of this.targetsByName.keys) {
        for (const element of this.targetsByName.getValuesForKey(name)) {
          this.disconnectTarget(element, name);
        }
      }
    }
    get attributeName() {
      return `data-${this.context.identifier}-target`;
    }
    get element() {
      return this.context.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values2, constructor2) => {
      getOwnStaticArrayValues(constructor2, propertyName).forEach((name) => values2.add(name));
      return values2;
    }, /* @__PURE__ */ new Set()));
  }
  function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor2) => {
      pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
      return pairs;
    }, []);
  }
  function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
      ancestors.push(constructor);
      constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
  }
  function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
  }
  function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
  }
  var OutletObserver = class {
    constructor(context, delegate) {
      this.started = false;
      this.context = context;
      this.delegate = delegate;
      this.outletsByName = new Multimap();
      this.outletElementsByName = new Multimap();
      this.selectorObserverMap = /* @__PURE__ */ new Map();
      this.attributeObserverMap = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.started) {
        this.outletDefinitions.forEach((outletName) => {
          this.setupSelectorObserverForOutlet(outletName);
          this.setupAttributeObserverForOutlet(outletName);
        });
        this.started = true;
        this.dependentContexts.forEach((context) => context.refresh());
      }
    }
    refresh() {
      this.selectorObserverMap.forEach((observer) => observer.refresh());
      this.attributeObserverMap.forEach((observer) => observer.refresh());
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.disconnectAllOutlets();
        this.stopSelectorObservers();
        this.stopAttributeObservers();
      }
    }
    stopSelectorObservers() {
      if (this.selectorObserverMap.size > 0) {
        this.selectorObserverMap.forEach((observer) => observer.stop());
        this.selectorObserverMap.clear();
      }
    }
    stopAttributeObservers() {
      if (this.attributeObserverMap.size > 0) {
        this.attributeObserverMap.forEach((observer) => observer.stop());
        this.attributeObserverMap.clear();
      }
    }
    selectorMatched(element, _selector, { outletName }) {
      const outlet = this.getOutlet(element, outletName);
      if (outlet) {
        this.connectOutlet(outlet, element, outletName);
      }
    }
    selectorUnmatched(element, _selector, { outletName }) {
      const outlet = this.getOutletFromMap(element, outletName);
      if (outlet) {
        this.disconnectOutlet(outlet, element, outletName);
      }
    }
    selectorMatchElement(element, { outletName }) {
      const selector = this.selector(outletName);
      const hasOutlet = this.hasOutlet(element, outletName);
      const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
      if (selector) {
        return hasOutlet && hasOutletController && element.matches(selector);
      } else {
        return false;
      }
    }
    elementMatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementAttributeValueChanged(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementUnmatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    connectOutlet(outlet, element, outletName) {
      var _a;
      if (!this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.add(outletName, outlet);
        this.outletElementsByName.add(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
      }
    }
    disconnectOutlet(outlet, element, outletName) {
      var _a;
      if (this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.delete(outletName, outlet);
        this.outletElementsByName.delete(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
      }
    }
    disconnectAllOutlets() {
      for (const outletName of this.outletElementsByName.keys) {
        for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
          for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
            this.disconnectOutlet(outlet, element, outletName);
          }
        }
      }
    }
    updateSelectorObserverForOutlet(outletName) {
      const observer = this.selectorObserverMap.get(outletName);
      if (observer) {
        observer.selector = this.selector(outletName);
      }
    }
    setupSelectorObserverForOutlet(outletName) {
      const selector = this.selector(outletName);
      const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });
      this.selectorObserverMap.set(outletName, selectorObserver);
      selectorObserver.start();
    }
    setupAttributeObserverForOutlet(outletName) {
      const attributeName = this.attributeNameForOutletName(outletName);
      const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
      this.attributeObserverMap.set(outletName, attributeObserver);
      attributeObserver.start();
    }
    selector(outletName) {
      return this.scope.outlets.getSelectorForOutletName(outletName);
    }
    attributeNameForOutletName(outletName) {
      return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
    }
    getOutletNameFromOutletAttributeName(attributeName) {
      return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);
    }
    get outletDependencies() {
      const dependencies = new Multimap();
      this.router.modules.forEach((module) => {
        const constructor = module.definition.controllerConstructor;
        const outlets = readInheritableStaticArrayValues(constructor, "outlets");
        outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
      });
      return dependencies;
    }
    get outletDefinitions() {
      return this.outletDependencies.getKeysForValue(this.identifier);
    }
    get dependentControllerIdentifiers() {
      return this.outletDependencies.getValuesForKey(this.identifier);
    }
    get dependentContexts() {
      const identifiers = this.dependentControllerIdentifiers;
      return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
    }
    hasOutlet(element, outletName) {
      return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
    }
    getOutlet(element, outletName) {
      return this.application.getControllerForElementAndIdentifier(element, outletName);
    }
    getOutletFromMap(element, outletName) {
      return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
    }
    get scope() {
      return this.context.scope;
    }
    get schema() {
      return this.context.schema;
    }
    get identifier() {
      return this.context.identifier;
    }
    get application() {
      return this.context.application;
    }
    get router() {
      return this.application.router;
    }
  };
  var Context = class {
    constructor(module, scope) {
      this.logDebugActivity = (functionName, detail = {}) => {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.logDebugActivity(this.identifier, functionName, detail);
      };
      this.module = module;
      this.scope = scope;
      this.controller = new module.controllerConstructor(this);
      this.bindingObserver = new BindingObserver(this, this.dispatcher);
      this.valueObserver = new ValueObserver(this, this.controller);
      this.targetObserver = new TargetObserver(this, this);
      this.outletObserver = new OutletObserver(this, this);
      try {
        this.controller.initialize();
        this.logDebugActivity("initialize");
      } catch (error2) {
        this.handleError(error2, "initializing controller");
      }
    }
    connect() {
      this.bindingObserver.start();
      this.valueObserver.start();
      this.targetObserver.start();
      this.outletObserver.start();
      try {
        this.controller.connect();
        this.logDebugActivity("connect");
      } catch (error2) {
        this.handleError(error2, "connecting controller");
      }
    }
    refresh() {
      this.outletObserver.refresh();
    }
    disconnect() {
      try {
        this.controller.disconnect();
        this.logDebugActivity("disconnect");
      } catch (error2) {
        this.handleError(error2, "disconnecting controller");
      }
      this.outletObserver.stop();
      this.targetObserver.stop();
      this.valueObserver.stop();
      this.bindingObserver.stop();
    }
    get application() {
      return this.module.application;
    }
    get identifier() {
      return this.module.identifier;
    }
    get schema() {
      return this.application.schema;
    }
    get dispatcher() {
      return this.application.dispatcher;
    }
    get element() {
      return this.scope.element;
    }
    get parentElement() {
      return this.element.parentElement;
    }
    handleError(error2, message, detail = {}) {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    targetConnected(element, name) {
      this.invokeControllerMethod(`${name}TargetConnected`, element);
    }
    targetDisconnected(element, name) {
      this.invokeControllerMethod(`${name}TargetDisconnected`, element);
    }
    outletConnected(outlet, element, name) {
      this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
    }
    outletDisconnected(outlet, element, name) {
      this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
    }
    invokeControllerMethod(methodName, ...args) {
      const controller = this.controller;
      if (typeof controller[methodName] == "function") {
        controller[methodName](...args);
      }
    }
  };
  function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
  }
  function shadow(constructor, properties) {
    const shadowConstructor = extend2(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
  }
  function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
      const properties = blessing(constructor);
      for (const key in properties) {
        const descriptor = blessedProperties[key] || {};
        blessedProperties[key] = Object.assign(descriptor, properties[key]);
      }
      return blessedProperties;
    }, {});
  }
  function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
      const descriptor = getShadowedDescriptor(prototype, properties, key);
      if (descriptor) {
        Object.assign(shadowProperties, { [key]: descriptor });
      }
      return shadowProperties;
    }, {});
  }
  function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
      const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
      if (shadowingDescriptor) {
        descriptor.get = shadowingDescriptor.get || descriptor.get;
        descriptor.set = shadowingDescriptor.set || descriptor.set;
      }
      return descriptor;
    }
  }
  var getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
      return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
    } else {
      return Object.getOwnPropertyNames;
    }
  })();
  var extend2 = (() => {
    function extendWithReflect(constructor) {
      function extended() {
        return Reflect.construct(constructor, arguments, new.target);
      }
      extended.prototype = Object.create(constructor.prototype, {
        constructor: { value: extended }
      });
      Reflect.setPrototypeOf(extended, constructor);
      return extended;
    }
    function testReflectExtension() {
      const a = function() {
        this.a.call(this);
      };
      const b = extendWithReflect(a);
      b.prototype.a = function() {
      };
      return new b();
    }
    try {
      testReflectExtension();
      return extendWithReflect;
    } catch (error2) {
      return (constructor) => class extended extends constructor {
      };
    }
  })();
  function blessDefinition(definition) {
    return {
      identifier: definition.identifier,
      controllerConstructor: bless(definition.controllerConstructor)
    };
  }
  var Module = class {
    constructor(application2, definition) {
      this.application = application2;
      this.definition = blessDefinition(definition);
      this.contextsByScope = /* @__PURE__ */ new WeakMap();
      this.connectedContexts = /* @__PURE__ */ new Set();
    }
    get identifier() {
      return this.definition.identifier;
    }
    get controllerConstructor() {
      return this.definition.controllerConstructor;
    }
    get contexts() {
      return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
      const context = this.fetchContextForScope(scope);
      this.connectedContexts.add(context);
      context.connect();
    }
    disconnectContextForScope(scope) {
      const context = this.contextsByScope.get(scope);
      if (context) {
        this.connectedContexts.delete(context);
        context.disconnect();
      }
    }
    fetchContextForScope(scope) {
      let context = this.contextsByScope.get(scope);
      if (!context) {
        context = new Context(this, scope);
        this.contextsByScope.set(scope, context);
      }
      return context;
    }
  };
  var ClassMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    has(name) {
      return this.data.has(this.getDataKey(name));
    }
    get(name) {
      return this.getAll(name)[0];
    }
    getAll(name) {
      const tokenString = this.data.get(this.getDataKey(name)) || "";
      return tokenize(tokenString);
    }
    getAttributeName(name) {
      return this.data.getAttributeNameForKey(this.getDataKey(name));
    }
    getDataKey(name) {
      return `${name}-class`;
    }
    get data() {
      return this.scope.data;
    }
  };
  var DataMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.getAttribute(name);
    }
    set(key, value) {
      const name = this.getAttributeNameForKey(key);
      this.element.setAttribute(name, value);
      return this.get(key);
    }
    has(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.hasAttribute(name);
    }
    delete(key) {
      if (this.has(key)) {
        const name = this.getAttributeNameForKey(key);
        this.element.removeAttribute(name);
        return true;
      } else {
        return false;
      }
    }
    getAttributeNameForKey(key) {
      return `data-${this.identifier}-${dasherize(key)}`;
    }
  };
  var Guide = class {
    constructor(logger) {
      this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
      this.logger = logger;
    }
    warn(object, key, message) {
      let warnedKeys = this.warnedKeysByObject.get(object);
      if (!warnedKeys) {
        warnedKeys = /* @__PURE__ */ new Set();
        this.warnedKeysByObject.set(object, warnedKeys);
      }
      if (!warnedKeys.has(key)) {
        warnedKeys.add(key);
        this.logger.warn(message, object);
      }
    }
  };
  function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
  }
  var TargetSet = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(targetName) {
      return this.find(targetName) != null;
    }
    find(...targetNames) {
      return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
    }
    findAll(...targetNames) {
      return targetNames.reduce((targets, targetName) => [
        ...targets,
        ...this.findAllTargets(targetName),
        ...this.findAllLegacyTargets(targetName)
      ], []);
    }
    findTarget(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
      const attributeName = this.schema.targetAttributeForScope(this.identifier);
      return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
      const targetDescriptor = `${this.identifier}.${targetName}`;
      return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
      if (element) {
        const { identifier } = this;
        const attributeName = this.schema.targetAttribute;
        const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
        this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
      }
      return element;
    }
    get guide() {
      return this.scope.guide;
    }
  };
  var OutletSet = class {
    constructor(scope, controllerElement) {
      this.scope = scope;
      this.controllerElement = controllerElement;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(outletName) {
      return this.find(outletName) != null;
    }
    find(...outletNames) {
      return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), void 0);
    }
    findAll(...outletNames) {
      return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
    }
    getSelectorForOutletName(outletName) {
      const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
      return this.controllerElement.getAttribute(attributeName);
    }
    findOutlet(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      if (selector)
        return this.findElement(selector, outletName);
    }
    findAllOutlets(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      return selector ? this.findAllElements(selector, outletName) : [];
    }
    findElement(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];
    }
    findAllElements(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName));
    }
    matchesElement(element, selector, outletName) {
      const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
      return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
    }
  };
  var Scope = class _Scope {
    constructor(schema, element, identifier, logger) {
      this.targets = new TargetSet(this);
      this.classes = new ClassMap(this);
      this.data = new DataMap(this);
      this.containsElement = (element2) => {
        return element2.closest(this.controllerSelector) === this.element;
      };
      this.schema = schema;
      this.element = element;
      this.identifier = identifier;
      this.guide = new Guide(logger);
      this.outlets = new OutletSet(this.documentScope, element);
    }
    findElement(selector) {
      return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
      return [
        ...this.element.matches(selector) ? [this.element] : [],
        ...this.queryElements(selector).filter(this.containsElement)
      ];
    }
    queryElements(selector) {
      return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
      return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
    get isDocumentScope() {
      return this.element === document.documentElement;
    }
    get documentScope() {
      return this.isDocumentScope ? this : new _Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
    }
  };
  var ScopeObserver = class {
    constructor(element, schema, delegate) {
      this.element = element;
      this.schema = schema;
      this.delegate = delegate;
      this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
      this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
      this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
    }
    start() {
      this.valueListObserver.start();
    }
    stop() {
      this.valueListObserver.stop();
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
      const { element, content: identifier } = token;
      return this.parseValueForElementAndIdentifier(element, identifier);
    }
    parseValueForElementAndIdentifier(element, identifier) {
      const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
      let scope = scopesByIdentifier.get(identifier);
      if (!scope) {
        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
        scopesByIdentifier.set(identifier, scope);
      }
      return scope;
    }
    elementMatchedValue(element, value) {
      const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
      this.scopeReferenceCounts.set(value, referenceCount);
      if (referenceCount == 1) {
        this.delegate.scopeConnected(value);
      }
    }
    elementUnmatchedValue(element, value) {
      const referenceCount = this.scopeReferenceCounts.get(value);
      if (referenceCount) {
        this.scopeReferenceCounts.set(value, referenceCount - 1);
        if (referenceCount == 1) {
          this.delegate.scopeDisconnected(value);
        }
      }
    }
    fetchScopesByIdentifierForElement(element) {
      let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
      if (!scopesByIdentifier) {
        scopesByIdentifier = /* @__PURE__ */ new Map();
        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
      }
      return scopesByIdentifier;
    }
  };
  var Router = class {
    constructor(application2) {
      this.application = application2;
      this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
      this.scopesByIdentifier = new Multimap();
      this.modulesByIdentifier = /* @__PURE__ */ new Map();
    }
    get element() {
      return this.application.element;
    }
    get schema() {
      return this.application.schema;
    }
    get logger() {
      return this.application.logger;
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    get modules() {
      return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
      return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
    }
    start() {
      this.scopeObserver.start();
    }
    stop() {
      this.scopeObserver.stop();
    }
    loadDefinition(definition) {
      this.unloadIdentifier(definition.identifier);
      const module = new Module(this.application, definition);
      this.connectModule(module);
      const afterLoad = definition.controllerConstructor.afterLoad;
      if (afterLoad) {
        afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
      }
    }
    unloadIdentifier(identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        this.disconnectModule(module);
      }
    }
    getContextForElementAndIdentifier(element, identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        return module.contexts.find((context) => context.element == element);
      }
    }
    proposeToConnectScopeForElementAndIdentifier(element, identifier) {
      const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
      if (scope) {
        this.scopeObserver.elementMatchedValue(scope.element, scope);
      } else {
        console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
      }
    }
    handleError(error2, message, detail) {
      this.application.handleError(error2, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
      return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
      this.scopesByIdentifier.add(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.connectContextForScope(scope);
      }
    }
    scopeDisconnected(scope) {
      this.scopesByIdentifier.delete(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.disconnectContextForScope(scope);
      }
    }
    connectModule(module) {
      this.modulesByIdentifier.set(module.identifier, module);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.connectContextForScope(scope));
    }
    disconnectModule(module) {
      this.modulesByIdentifier.delete(module.identifier);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.disconnectContextForScope(scope));
    }
  };
  var defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`,
    outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
    keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End", page_up: "PageUp", page_down: "PageDown" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c) => [c, c]))), objectFromEntries("0123456789".split("").map((n) => [n, n])))
  };
  function objectFromEntries(array) {
    return array.reduce((memo, [k, v]) => Object.assign(Object.assign({}, memo), { [k]: v }), {});
  }
  var Application = class {
    constructor(element = document.documentElement, schema = defaultSchema) {
      this.logger = console;
      this.debug = false;
      this.logDebugActivity = (identifier, functionName, detail = {}) => {
        if (this.debug) {
          this.logFormattedMessage(identifier, functionName, detail);
        }
      };
      this.element = element;
      this.schema = schema;
      this.dispatcher = new Dispatcher(this);
      this.router = new Router(this);
      this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
    }
    static start(element, schema) {
      const application2 = new this(element, schema);
      application2.start();
      return application2;
    }
    async start() {
      await domReady();
      this.logDebugActivity("application", "starting");
      this.dispatcher.start();
      this.router.start();
      this.logDebugActivity("application", "start");
    }
    stop() {
      this.logDebugActivity("application", "stopping");
      this.dispatcher.stop();
      this.router.stop();
      this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
      this.load({ identifier, controllerConstructor });
    }
    registerActionOption(name, filter) {
      this.actionDescriptorFilters[name] = filter;
    }
    load(head, ...rest) {
      const definitions = Array.isArray(head) ? head : [head, ...rest];
      definitions.forEach((definition) => {
        if (definition.controllerConstructor.shouldLoad) {
          this.router.loadDefinition(definition);
        }
      });
    }
    unload(head, ...rest) {
      const identifiers = Array.isArray(head) ? head : [head, ...rest];
      identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
      return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
      const context = this.router.getContextForElementAndIdentifier(element, identifier);
      return context ? context.controller : null;
    }
    handleError(error2, message, detail) {
      var _a;
      this.logger.error(`%s

%o

%o`, message, error2, detail);
      (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error2);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
      detail = Object.assign({ application: this }, detail);
      this.logger.groupCollapsed(`${identifier} #${functionName}`);
      this.logger.log("details:", Object.assign({}, detail));
      this.logger.groupEnd();
    }
  };
  function domReady() {
    return new Promise((resolve2) => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", () => resolve2());
      } else {
        resolve2();
      }
    });
  }
  function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
      return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
  }
  function propertiesForClassDefinition(key) {
    return {
      [`${key}Class`]: {
        get() {
          const { classes } = this;
          if (classes.has(key)) {
            return classes.get(key);
          } else {
            const attribute = classes.getAttributeName(key);
            throw new Error(`Missing attribute "${attribute}"`);
          }
        }
      },
      [`${key}Classes`]: {
        get() {
          return this.classes.getAll(key);
        }
      },
      [`has${capitalize(key)}Class`]: {
        get() {
          return this.classes.has(key);
        }
      }
    };
  }
  function OutletPropertiesBlessing(constructor) {
    const outlets = readInheritableStaticArrayValues(constructor, "outlets");
    return outlets.reduce((properties, outletDefinition) => {
      return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
    }, {});
  }
  function getOutletController(controller, element, identifier) {
    return controller.application.getControllerForElementAndIdentifier(element, identifier);
  }
  function getControllerAndEnsureConnectedScope(controller, element, outletName) {
    let outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
    controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
    outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
  }
  function propertiesForOutletDefinition(name) {
    const camelizedName = namespaceCamelize(name);
    return {
      [`${camelizedName}Outlet`]: {
        get() {
          const outletElement = this.outlets.find(name);
          const selector = this.outlets.getSelectorForOutletName(name);
          if (outletElement) {
            const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
            if (outletController)
              return outletController;
            throw new Error(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`);
          }
          throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
        }
      },
      [`${camelizedName}Outlets`]: {
        get() {
          const outlets = this.outlets.findAll(name);
          if (outlets.length > 0) {
            return outlets.map((outletElement) => {
              const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
              if (outletController)
                return outletController;
              console.warn(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`, outletElement);
            }).filter((controller) => controller);
          }
          return [];
        }
      },
      [`${camelizedName}OutletElement`]: {
        get() {
          const outletElement = this.outlets.find(name);
          const selector = this.outlets.getSelectorForOutletName(name);
          if (outletElement) {
            return outletElement;
          } else {
            throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
          }
        }
      },
      [`${camelizedName}OutletElements`]: {
        get() {
          return this.outlets.findAll(name);
        }
      },
      [`has${capitalize(camelizedName)}Outlet`]: {
        get() {
          return this.outlets.has(name);
        }
      }
    };
  }
  function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
      return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
  }
  function propertiesForTargetDefinition(name) {
    return {
      [`${name}Target`]: {
        get() {
          const target = this.targets.find(name);
          if (target) {
            return target;
          } else {
            throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${name}Targets`]: {
        get() {
          return this.targets.findAll(name);
        }
      },
      [`has${capitalize(name)}Target`]: {
        get() {
          return this.targets.has(name);
        }
      }
    };
  }
  function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
      valueDescriptorMap: {
        get() {
          return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
            const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
            const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
            return Object.assign(result, { [attributeName]: valueDescriptor });
          }, {});
        }
      }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
      return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
  }
  function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
    const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
    const { key, name, reader: read, writer: write } = definition;
    return {
      [name]: {
        get() {
          const value = this.data.get(key);
          if (value !== null) {
            return read(value);
          } else {
            return definition.defaultValue;
          }
        },
        set(value) {
          if (value === void 0) {
            this.data.delete(key);
          } else {
            this.data.set(key, write(value));
          }
        }
      },
      [`has${capitalize(name)}`]: {
        get() {
          return this.data.has(key) || definition.hasCustomDefaultValue;
        }
      }
    };
  }
  function parseValueDefinitionPair([token, typeDefinition], controller) {
    return valueDescriptorForTokenAndTypeDefinition({
      controller,
      token,
      typeDefinition
    });
  }
  function parseValueTypeConstant(constant) {
    switch (constant) {
      case Array:
        return "array";
      case Boolean:
        return "boolean";
      case Number:
        return "number";
      case Object:
        return "object";
      case String:
        return "string";
    }
  }
  function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
    }
    if (Array.isArray(defaultValue))
      return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
      return "object";
  }
  function parseValueTypeObject(payload) {
    const { controller, token, typeObject } = payload;
    const hasType = isSomething(typeObject.type);
    const hasDefault = isSomething(typeObject.default);
    const fullObject = hasType && hasDefault;
    const onlyType = hasType && !hasDefault;
    const onlyDefault = !hasType && hasDefault;
    const typeFromObject = parseValueTypeConstant(typeObject.type);
    const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
    if (onlyType)
      return typeFromObject;
    if (onlyDefault)
      return typeFromDefaultValue;
    if (typeFromObject !== typeFromDefaultValue) {
      const propertyPath = controller ? `${controller}.${token}` : token;
      throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
    }
    if (fullObject)
      return typeFromObject;
  }
  function parseValueTypeDefinition(payload) {
    const { controller, token, typeDefinition } = payload;
    const typeObject = { controller, token, typeObject: typeDefinition };
    const typeFromObject = parseValueTypeObject(typeObject);
    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
    const typeFromConstant = parseValueTypeConstant(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
      return type;
    const propertyPath = controller ? `${controller}.${typeDefinition}` : token;
    throw new Error(`Unknown value type "${propertyPath}" for "${token}" value`);
  }
  function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
      return defaultValuesByType[constant];
    const hasDefault = hasProperty(typeDefinition, "default");
    const hasType = hasProperty(typeDefinition, "type");
    const typeObject = typeDefinition;
    if (hasDefault)
      return typeObject.default;
    if (hasType) {
      const { type } = typeObject;
      const constantFromType = parseValueTypeConstant(type);
      if (constantFromType)
        return defaultValuesByType[constantFromType];
    }
    return typeDefinition;
  }
  function valueDescriptorForTokenAndTypeDefinition(payload) {
    const { token, typeDefinition } = payload;
    const key = `${dasherize(token)}-value`;
    const type = parseValueTypeDefinition(payload);
    return {
      type,
      key,
      name: camelize(key),
      get defaultValue() {
        return defaultValueForDefinition(typeDefinition);
      },
      get hasCustomDefaultValue() {
        return parseValueTypeDefault(typeDefinition) !== void 0;
      },
      reader: readers[type],
      writer: writers[type] || writers.default
    };
  }
  var defaultValuesByType = {
    get array() {
      return [];
    },
    boolean: false,
    number: 0,
    get object() {
      return {};
    },
    string: ""
  };
  var readers = {
    array(value) {
      const array = JSON.parse(value);
      if (!Array.isArray(array)) {
        throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
      }
      return array;
    },
    boolean(value) {
      return !(value == "0" || String(value).toLowerCase() == "false");
    },
    number(value) {
      return Number(value.replace(/_/g, ""));
    },
    object(value) {
      const object = JSON.parse(value);
      if (object === null || typeof object != "object" || Array.isArray(object)) {
        throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
      }
      return object;
    },
    string(value) {
      return value;
    }
  };
  var writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
  };
  function writeJSON(value) {
    return JSON.stringify(value);
  }
  function writeString(value) {
    return `${value}`;
  }
  var Controller = class {
    constructor(context) {
      this.context = context;
    }
    static get shouldLoad() {
      return true;
    }
    static afterLoad(_identifier, _application) {
      return;
    }
    get application() {
      return this.context.application;
    }
    get scope() {
      return this.context.scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get targets() {
      return this.scope.targets;
    }
    get outlets() {
      return this.scope.outlets;
    }
    get classes() {
      return this.scope.classes;
    }
    get data() {
      return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
      const type = prefix ? `${prefix}:${eventName}` : eventName;
      const event = new CustomEvent(type, { detail, bubbles, cancelable });
      target.dispatchEvent(event);
      return event;
    }
  };
  Controller.blessings = [
    ClassPropertiesBlessing,
    TargetPropertiesBlessing,
    ValuePropertiesBlessing,
    OutletPropertiesBlessing
  ];
  Controller.targets = [];
  Controller.outlets = [];
  Controller.values = {};

  // app/javascript/controllers/application.js
  var application = Application.start();
  application.debug = false;
  window.Stimulus = application;

  // app/javascript/controllers/hello_controller.js
  var hello_controller_default = class extends Controller {
    connect() {
      this.element.textContent = "Hello World!";
    }
  };

  // app/javascript/controllers/index.js
  application.register("hello", hello_controller_default);

  // app/javascript/application.js
  var import_jquery3 = __toESM(require_jquery());
  var import_moment = __toESM(require_moment());
  var import_select2 = __toESM(require_select2());
  var import_toastify_js = __toESM(require_toastify());

  // node_modules/datatables.net-dt/js/dataTables.dataTables.mjs
  var import_jquery2 = __toESM(require_jquery(), 1);

  // node_modules/datatables.net/js/jquery.dataTables.mjs
  var import_jquery = __toESM(require_jquery(), 1);
  var $2 = import_jquery.default;
  var DataTable = function(selector, options) {
    if (DataTable.factory(selector, options)) {
      return DataTable;
    }
    if (this instanceof DataTable) {
      return $2(selector).DataTable(options);
    } else {
      options = selector;
    }
    this.$ = function(sSelector, oOpts) {
      return this.api(true).$(sSelector, oOpts);
    };
    this._ = function(sSelector, oOpts) {
      return this.api(true).rows(sSelector, oOpts).data();
    };
    this.api = function(traditional) {
      return traditional ? new _Api(
        _fnSettingsFromNode(this[_ext.iApiIndex])
      ) : new _Api(this);
    };
    this.fnAddData = function(data, redraw) {
      var api = this.api(true);
      var rows = Array.isArray(data) && (Array.isArray(data[0]) || $2.isPlainObject(data[0])) ? api.rows.add(data) : api.row.add(data);
      if (redraw === void 0 || redraw) {
        api.draw();
      }
      return rows.flatten().toArray();
    };
    this.fnAdjustColumnSizing = function(bRedraw) {
      var api = this.api(true).columns.adjust();
      var settings = api.settings()[0];
      var scroll = settings.oScroll;
      if (bRedraw === void 0 || bRedraw) {
        api.draw(false);
      } else if (scroll.sX !== "" || scroll.sY !== "") {
        _fnScrollDraw(settings);
      }
    };
    this.fnClearTable = function(bRedraw) {
      var api = this.api(true).clear();
      if (bRedraw === void 0 || bRedraw) {
        api.draw();
      }
    };
    this.fnClose = function(nTr) {
      this.api(true).row(nTr).child.hide();
    };
    this.fnDeleteRow = function(target, callback, redraw) {
      var api = this.api(true);
      var rows = api.rows(target);
      var settings = rows.settings()[0];
      var data = settings.aoData[rows[0][0]];
      rows.remove();
      if (callback) {
        callback.call(this, settings, data);
      }
      if (redraw === void 0 || redraw) {
        api.draw();
      }
      return data;
    };
    this.fnDestroy = function(remove2) {
      this.api(true).destroy(remove2);
    };
    this.fnDraw = function(complete) {
      this.api(true).draw(complete);
    };
    this.fnFilter = function(sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
      var api = this.api(true);
      if (iColumn === null || iColumn === void 0) {
        api.search(sInput, bRegex, bSmart, bCaseInsensitive);
      } else {
        api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive);
      }
      api.draw();
    };
    this.fnGetData = function(src, col) {
      var api = this.api(true);
      if (src !== void 0) {
        var type = src.nodeName ? src.nodeName.toLowerCase() : "";
        return col !== void 0 || type == "td" || type == "th" ? api.cell(src, col).data() : api.row(src).data() || null;
      }
      return api.data().toArray();
    };
    this.fnGetNodes = function(iRow) {
      var api = this.api(true);
      return iRow !== void 0 ? api.row(iRow).node() : api.rows().nodes().flatten().toArray();
    };
    this.fnGetPosition = function(node) {
      var api = this.api(true);
      var nodeName = node.nodeName.toUpperCase();
      if (nodeName == "TR") {
        return api.row(node).index();
      } else if (nodeName == "TD" || nodeName == "TH") {
        var cell = api.cell(node).index();
        return [
          cell.row,
          cell.columnVisible,
          cell.column
        ];
      }
      return null;
    };
    this.fnIsOpen = function(nTr) {
      return this.api(true).row(nTr).child.isShown();
    };
    this.fnOpen = function(nTr, mHtml, sClass) {
      return this.api(true).row(nTr).child(mHtml, sClass).show().child()[0];
    };
    this.fnPageChange = function(mAction, bRedraw) {
      var api = this.api(true).page(mAction);
      if (bRedraw === void 0 || bRedraw) {
        api.draw(false);
      }
    };
    this.fnSetColumnVis = function(iCol, bShow, bRedraw) {
      var api = this.api(true).column(iCol).visible(bShow);
      if (bRedraw === void 0 || bRedraw) {
        api.columns.adjust().draw();
      }
    };
    this.fnSettings = function() {
      return _fnSettingsFromNode(this[_ext.iApiIndex]);
    };
    this.fnSort = function(aaSort) {
      this.api(true).order(aaSort).draw();
    };
    this.fnSortListener = function(nNode, iColumn, fnCallback) {
      this.api(true).order.listener(nNode, iColumn, fnCallback);
    };
    this.fnUpdate = function(mData, mRow, iColumn, bRedraw, bAction) {
      var api = this.api(true);
      if (iColumn === void 0 || iColumn === null) {
        api.row(mRow).data(mData);
      } else {
        api.cell(mRow, iColumn).data(mData);
      }
      if (bAction === void 0 || bAction) {
        api.columns.adjust();
      }
      if (bRedraw === void 0 || bRedraw) {
        api.draw();
      }
      return 0;
    };
    this.fnVersionCheck = _ext.fnVersionCheck;
    var _that = this;
    var emptyInit = options === void 0;
    var len = this.length;
    if (emptyInit) {
      options = {};
    }
    this.oApi = this.internal = _ext.internal;
    for (var fn in DataTable.ext.internal) {
      if (fn) {
        this[fn] = _fnExternApiFunc(fn);
      }
    }
    this.each(function() {
      var o = {};
      var oInit = len > 1 ? (
        // optimisation for single table case
        _fnExtend(o, options, true)
      ) : options;
      var i = 0, iLen, j, jLen, k, kLen;
      var sId = this.getAttribute("id");
      var bInitHandedOff = false;
      var defaults = DataTable.defaults;
      var $this = $2(this);
      if (this.nodeName.toLowerCase() != "table") {
        _fnLog(null, 0, "Non-table node initialisation (" + this.nodeName + ")", 2);
        return;
      }
      _fnCompatOpts(defaults);
      _fnCompatCols(defaults.column);
      _fnCamelToHungarian(defaults, defaults, true);
      _fnCamelToHungarian(defaults.column, defaults.column, true);
      _fnCamelToHungarian(defaults, $2.extend(oInit, $this.data()), true);
      var allSettings = DataTable.settings;
      for (i = 0, iLen = allSettings.length; i < iLen; i++) {
        var s = allSettings[i];
        if (s.nTable == this || s.nTHead && s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
          var bRetrieve = oInit.bRetrieve !== void 0 ? oInit.bRetrieve : defaults.bRetrieve;
          var bDestroy = oInit.bDestroy !== void 0 ? oInit.bDestroy : defaults.bDestroy;
          if (emptyInit || bRetrieve) {
            return s.oInstance;
          } else if (bDestroy) {
            s.oInstance.fnDestroy();
            break;
          } else {
            _fnLog(s, 0, "Cannot reinitialise DataTable", 3);
            return;
          }
        }
        if (s.sTableId == this.id) {
          allSettings.splice(i, 1);
          break;
        }
      }
      if (sId === null || sId === "") {
        sId = "DataTables_Table_" + DataTable.ext._unique++;
        this.id = sId;
      }
      var oSettings = $2.extend(true, {}, DataTable.models.oSettings, {
        "sDestroyWidth": $this[0].style.width,
        "sInstance": sId,
        "sTableId": sId
      });
      oSettings.nTable = this;
      oSettings.oApi = _that.internal;
      oSettings.oInit = oInit;
      allSettings.push(oSettings);
      oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable();
      _fnCompatOpts(oInit);
      _fnLanguageCompat(oInit.oLanguage);
      if (oInit.aLengthMenu && !oInit.iDisplayLength) {
        oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
      }
      oInit = _fnExtend($2.extend(true, {}, defaults), oInit);
      _fnMap(oSettings.oFeatures, oInit, [
        "bPaginate",
        "bLengthChange",
        "bFilter",
        "bSort",
        "bSortMulti",
        "bInfo",
        "bProcessing",
        "bAutoWidth",
        "bSortClasses",
        "bServerSide",
        "bDeferRender"
      ]);
      _fnMap(oSettings, oInit, [
        "asStripeClasses",
        "ajax",
        "fnServerData",
        "fnFormatNumber",
        "sServerMethod",
        "aaSorting",
        "aaSortingFixed",
        "aLengthMenu",
        "sPaginationType",
        "sAjaxSource",
        "sAjaxDataProp",
        "iStateDuration",
        "sDom",
        "bSortCellsTop",
        "iTabIndex",
        "fnStateLoadCallback",
        "fnStateSaveCallback",
        "renderer",
        "searchDelay",
        "rowId",
        ["iCookieDuration", "iStateDuration"],
        // backwards compat
        ["oSearch", "oPreviousSearch"],
        ["aoSearchCols", "aoPreSearchCols"],
        ["iDisplayLength", "_iDisplayLength"]
      ]);
      _fnMap(oSettings.oScroll, oInit, [
        ["sScrollX", "sX"],
        ["sScrollXInner", "sXInner"],
        ["sScrollY", "sY"],
        ["bScrollCollapse", "bCollapse"]
      ]);
      _fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");
      _fnCallbackReg(oSettings, "aoDrawCallback", oInit.fnDrawCallback, "user");
      _fnCallbackReg(oSettings, "aoServerParams", oInit.fnServerParams, "user");
      _fnCallbackReg(oSettings, "aoStateSaveParams", oInit.fnStateSaveParams, "user");
      _fnCallbackReg(oSettings, "aoStateLoadParams", oInit.fnStateLoadParams, "user");
      _fnCallbackReg(oSettings, "aoStateLoaded", oInit.fnStateLoaded, "user");
      _fnCallbackReg(oSettings, "aoRowCallback", oInit.fnRowCallback, "user");
      _fnCallbackReg(oSettings, "aoRowCreatedCallback", oInit.fnCreatedRow, "user");
      _fnCallbackReg(oSettings, "aoHeaderCallback", oInit.fnHeaderCallback, "user");
      _fnCallbackReg(oSettings, "aoFooterCallback", oInit.fnFooterCallback, "user");
      _fnCallbackReg(oSettings, "aoInitComplete", oInit.fnInitComplete, "user");
      _fnCallbackReg(oSettings, "aoPreDrawCallback", oInit.fnPreDrawCallback, "user");
      oSettings.rowIdFn = _fnGetObjectDataFn(oInit.rowId);
      _fnBrowserDetect(oSettings);
      var oClasses = oSettings.oClasses;
      $2.extend(oClasses, DataTable.ext.classes, oInit.oClasses);
      $this.addClass(oClasses.sTable);
      if (oSettings.iInitDisplayStart === void 0) {
        oSettings.iInitDisplayStart = oInit.iDisplayStart;
        oSettings._iDisplayStart = oInit.iDisplayStart;
      }
      if (oInit.iDeferLoading !== null) {
        oSettings.bDeferLoading = true;
        var tmp = Array.isArray(oInit.iDeferLoading);
        oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
        oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
      }
      var oLanguage = oSettings.oLanguage;
      $2.extend(true, oLanguage, oInit.oLanguage);
      if (oLanguage.sUrl) {
        $2.ajax({
          dataType: "json",
          url: oLanguage.sUrl,
          success: function(json) {
            _fnCamelToHungarian(defaults.oLanguage, json);
            _fnLanguageCompat(json);
            $2.extend(true, oLanguage, json, oSettings.oInit.oLanguage);
            _fnCallbackFire(oSettings, null, "i18n", [oSettings]);
            _fnInitialise(oSettings);
          },
          error: function() {
            _fnInitialise(oSettings);
          }
        });
        bInitHandedOff = true;
      } else {
        _fnCallbackFire(oSettings, null, "i18n", [oSettings]);
      }
      if (oInit.asStripeClasses === null) {
        oSettings.asStripeClasses = [
          oClasses.sStripeOdd,
          oClasses.sStripeEven
        ];
      }
      var stripeClasses = oSettings.asStripeClasses;
      var rowOne = $this.children("tbody").find("tr").eq(0);
      if ($2.inArray(true, $2.map(stripeClasses, function(el, i2) {
        return rowOne.hasClass(el);
      })) !== -1) {
        $2("tbody tr", this).removeClass(stripeClasses.join(" "));
        oSettings.asDestroyStripes = stripeClasses.slice();
      }
      var anThs = [];
      var aoColumnsInit;
      var nThead = this.getElementsByTagName("thead");
      if (nThead.length !== 0) {
        _fnDetectHeader(oSettings.aoHeader, nThead[0]);
        anThs = _fnGetUniqueThs(oSettings);
      }
      if (oInit.aoColumns === null) {
        aoColumnsInit = [];
        for (i = 0, iLen = anThs.length; i < iLen; i++) {
          aoColumnsInit.push(null);
        }
      } else {
        aoColumnsInit = oInit.aoColumns;
      }
      for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {
        _fnAddColumn(oSettings, anThs ? anThs[i] : null);
      }
      _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function(iCol, oDef) {
        _fnColumnOptions(oSettings, iCol, oDef);
      });
      if (rowOne.length) {
        var a = function(cell, name) {
          return cell.getAttribute("data-" + name) !== null ? name : null;
        };
        $2(rowOne[0]).children("th, td").each(function(i2, cell) {
          var col = oSettings.aoColumns[i2];
          if (!col) {
            _fnLog(oSettings, 0, "Incorrect column count", 18);
          }
          if (col.mData === i2) {
            var sort = a(cell, "sort") || a(cell, "order");
            var filter = a(cell, "filter") || a(cell, "search");
            if (sort !== null || filter !== null) {
              col.mData = {
                _: i2 + ".display",
                sort: sort !== null ? i2 + ".@data-" + sort : void 0,
                type: sort !== null ? i2 + ".@data-" + sort : void 0,
                filter: filter !== null ? i2 + ".@data-" + filter : void 0
              };
              col._isArrayHost = true;
              _fnColumnOptions(oSettings, i2);
            }
          }
        });
      }
      var features = oSettings.oFeatures;
      var loadedInit = function() {
        if (oInit.aaSorting === void 0) {
          var sorting = oSettings.aaSorting;
          for (i = 0, iLen = sorting.length; i < iLen; i++) {
            sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
          }
        }
        _fnSortingClasses(oSettings);
        if (features.bSort) {
          _fnCallbackReg(oSettings, "aoDrawCallback", function() {
            if (oSettings.bSorted) {
              var aSort = _fnSortFlatten(oSettings);
              var sortedColumns = {};
              $2.each(aSort, function(i2, val) {
                sortedColumns[val.src] = val.dir;
              });
              _fnCallbackFire(oSettings, null, "order", [oSettings, aSort, sortedColumns]);
              _fnSortAria(oSettings);
            }
          });
        }
        _fnCallbackReg(oSettings, "aoDrawCallback", function() {
          if (oSettings.bSorted || _fnDataSource(oSettings) === "ssp" || features.bDeferRender) {
            _fnSortingClasses(oSettings);
          }
        }, "sc");
        var captions = $this.children("caption").each(function() {
          this._captionSide = $2(this).css("caption-side");
        });
        var thead = $this.children("thead");
        if (thead.length === 0) {
          thead = $2("<thead/>").appendTo($this);
        }
        oSettings.nTHead = thead[0];
        var tbody = $this.children("tbody");
        if (tbody.length === 0) {
          tbody = $2("<tbody/>").insertAfter(thead);
        }
        oSettings.nTBody = tbody[0];
        var tfoot = $this.children("tfoot");
        if (tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "")) {
          tfoot = $2("<tfoot/>").appendTo($this);
        }
        if (tfoot.length === 0 || tfoot.children().length === 0) {
          $this.addClass(oClasses.sNoFooter);
        } else if (tfoot.length > 0) {
          oSettings.nTFoot = tfoot[0];
          _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);
        }
        if (oInit.aaData) {
          for (i = 0; i < oInit.aaData.length; i++) {
            _fnAddData(oSettings, oInit.aaData[i]);
          }
        } else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == "dom") {
          _fnAddTr(oSettings, $2(oSettings.nTBody).children("tr"));
        }
        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
        oSettings.bInitialised = true;
        if (bInitHandedOff === false) {
          _fnInitialise(oSettings);
        }
      };
      _fnCallbackReg(oSettings, "aoDrawCallback", _fnSaveState, "state_save");
      if (oInit.bStateSave) {
        features.bStateSave = true;
        _fnLoadState(oSettings, oInit, loadedInit);
      } else {
        loadedInit();
      }
    });
    _that = null;
    return this;
  };
  var _ext;
  var _Api;
  var _api_register;
  var _api_registerPlural;
  var _re_dic = {};
  var _re_new_lines = /[\r\n\u2028]/g;
  var _re_html = /<.*?>/g;
  var _re_date = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/;
  var _re_escape_regex = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^", "-"].join("|\\") + ")", "g");
  var _re_formatted_numeric = /['\u00A0,$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;
  var _empty = function(d) {
    return !d || d === true || d === "-" ? true : false;
  };
  var _intVal = function(s) {
    var integer = parseInt(s, 10);
    return !isNaN(integer) && isFinite(s) ? integer : null;
  };
  var _numToDecimal = function(num, decimalPoint) {
    if (!_re_dic[decimalPoint]) {
      _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), "g");
    }
    return typeof num === "string" && decimalPoint !== "." ? num.replace(/\./g, "").replace(_re_dic[decimalPoint], ".") : num;
  };
  var _isNumber = function(d, decimalPoint, formatted) {
    var type = typeof d;
    var strType = type === "string";
    if (type === "number" || type === "bigint") {
      return true;
    }
    if (_empty(d)) {
      return true;
    }
    if (decimalPoint && strType) {
      d = _numToDecimal(d, decimalPoint);
    }
    if (formatted && strType) {
      d = d.replace(_re_formatted_numeric, "");
    }
    return !isNaN(parseFloat(d)) && isFinite(d);
  };
  var _isHtml = function(d) {
    return _empty(d) || typeof d === "string";
  };
  var _htmlNumeric = function(d, decimalPoint, formatted) {
    if (_empty(d)) {
      return true;
    }
    var html = _isHtml(d);
    return !html ? null : _isNumber(_stripHtml(d), decimalPoint, formatted) ? true : null;
  };
  var _pluck = function(a, prop, prop2) {
    var out = [];
    var i = 0, ien = a.length;
    if (prop2 !== void 0) {
      for (; i < ien; i++) {
        if (a[i] && a[i][prop]) {
          out.push(a[i][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[i]) {
          out.push(a[i][prop]);
        }
      }
    }
    return out;
  };
  var _pluck_order = function(a, order, prop, prop2) {
    var out = [];
    var i = 0, ien = order.length;
    if (prop2 !== void 0) {
      for (; i < ien; i++) {
        if (a[order[i]][prop]) {
          out.push(a[order[i]][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        out.push(a[order[i]][prop]);
      }
    }
    return out;
  };
  var _range = function(len, start2) {
    var out = [];
    var end;
    if (start2 === void 0) {
      start2 = 0;
      end = len;
    } else {
      end = start2;
      start2 = len;
    }
    for (var i = start2; i < end; i++) {
      out.push(i);
    }
    return out;
  };
  var _removeEmpty = function(a) {
    var out = [];
    for (var i = 0, ien = a.length; i < ien; i++) {
      if (a[i]) {
        out.push(a[i]);
      }
    }
    return out;
  };
  var _stripHtml = function(d) {
    return d.replace(_re_html, "").replace(/<script/i, "");
  };
  var _areAllUnique = function(src) {
    if (src.length < 2) {
      return true;
    }
    var sorted = src.slice().sort();
    var last2 = sorted[0];
    for (var i = 1, ien = sorted.length; i < ien; i++) {
      if (sorted[i] === last2) {
        return false;
      }
      last2 = sorted[i];
    }
    return true;
  };
  var _unique = function(src) {
    if (_areAllUnique(src)) {
      return src.slice();
    }
    var out = [], val, i, ien = src.length, j, k = 0;
    again:
      for (i = 0; i < ien; i++) {
        val = src[i];
        for (j = 0; j < k; j++) {
          if (out[j] === val) {
            continue again;
          }
        }
        out.push(val);
        k++;
      }
    return out;
  };
  var _flatten = function(out, val) {
    if (Array.isArray(val)) {
      for (var i = 0; i < val.length; i++) {
        _flatten(out, val[i]);
      }
    } else {
      out.push(val);
    }
    return out;
  };
  var _includes = function(search, start2) {
    if (start2 === void 0) {
      start2 = 0;
    }
    return this.indexOf(search, start2) !== -1;
  };
  if (!Array.isArray) {
    Array.isArray = function(arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    };
  }
  if (!Array.prototype.includes) {
    Array.prototype.includes = _includes;
  }
  if (!String.prototype.trim) {
    String.prototype.trim = function() {
      return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    };
  }
  if (!String.prototype.includes) {
    String.prototype.includes = _includes;
  }
  DataTable.util = {
    /**
     * Throttle the calls to a function. Arguments and context are maintained
     * for the throttled function.
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    throttle: function(fn, freq) {
      var frequency = freq !== void 0 ? freq : 200, last2, timer;
      return function() {
        var that = this, now2 = +/* @__PURE__ */ new Date(), args = arguments;
        if (last2 && now2 < last2 + frequency) {
          clearTimeout(timer);
          timer = setTimeout(function() {
            last2 = void 0;
            fn.apply(that, args);
          }, frequency);
        } else {
          last2 = now2;
          fn.apply(that, args);
        }
      };
    },
    /**
     * Escape a string such that it can be used in a regular expression
     *
     *  @param {string} val string to escape
     *  @returns {string} escaped string
     */
    escapeRegex: function(val) {
      return val.replace(_re_escape_regex, "\\$1");
    },
    /**
     * Create a function that will write to a nested object or array
     * @param {*} source JSON notation string
     * @returns Write function
     */
    set: function(source) {
      if ($2.isPlainObject(source)) {
        return DataTable.util.set(source._);
      } else if (source === null) {
        return function() {
        };
      } else if (typeof source === "function") {
        return function(data, val, meta) {
          source(data, "set", val, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var setData = function(data, val, src) {
          var a = _fnSplitObjNotation(src), b;
          var aLast = a[a.length - 1];
          var arrayNotation, funcNotation, o, innerSrc;
          for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
            if (a[i] === "__proto__" || a[i] === "constructor") {
              throw new Error("Cannot set prototype values");
            }
            arrayNotation = a[i].match(__reArray);
            funcNotation = a[i].match(__reFn);
            if (arrayNotation) {
              a[i] = a[i].replace(__reArray, "");
              data[a[i]] = [];
              b = a.slice();
              b.splice(0, i + 1);
              innerSrc = b.join(".");
              if (Array.isArray(val)) {
                for (var j = 0, jLen = val.length; j < jLen; j++) {
                  o = {};
                  setData(o, val[j], innerSrc);
                  data[a[i]].push(o);
                }
              } else {
                data[a[i]] = val;
              }
              return;
            } else if (funcNotation) {
              a[i] = a[i].replace(__reFn, "");
              data = data[a[i]](val);
            }
            if (data[a[i]] === null || data[a[i]] === void 0) {
              data[a[i]] = {};
            }
            data = data[a[i]];
          }
          if (aLast.match(__reFn)) {
            data = data[aLast.replace(__reFn, "")](val);
          } else {
            data[aLast.replace(__reArray, "")] = val;
          }
        };
        return function(data, val) {
          return setData(data, val, source);
        };
      } else {
        return function(data, val) {
          data[source] = val;
        };
      }
    },
    /**
     * Create a function that will read nested objects from arrays, based on JSON notation
     * @param {*} source JSON notation string
     * @returns Value read
     */
    get: function(source) {
      if ($2.isPlainObject(source)) {
        var o = {};
        $2.each(source, function(key, val) {
          if (val) {
            o[key] = DataTable.util.get(val);
          }
        });
        return function(data, type, row, meta) {
          var t = o[type] || o._;
          return t !== void 0 ? t(data, type, row, meta) : data;
        };
      } else if (source === null) {
        return function(data) {
          return data;
        };
      } else if (typeof source === "function") {
        return function(data, type, row, meta) {
          return source(data, type, row, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var fetchData = function(data, type, src) {
          var arrayNotation, funcNotation, out, innerSrc;
          if (src !== "") {
            var a = _fnSplitObjNotation(src);
            for (var i = 0, iLen = a.length; i < iLen; i++) {
              arrayNotation = a[i].match(__reArray);
              funcNotation = a[i].match(__reFn);
              if (arrayNotation) {
                a[i] = a[i].replace(__reArray, "");
                if (a[i] !== "") {
                  data = data[a[i]];
                }
                out = [];
                a.splice(0, i + 1);
                innerSrc = a.join(".");
                if (Array.isArray(data)) {
                  for (var j = 0, jLen = data.length; j < jLen; j++) {
                    out.push(fetchData(data[j], type, innerSrc));
                  }
                }
                var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
                data = join === "" ? out : out.join(join);
                break;
              } else if (funcNotation) {
                a[i] = a[i].replace(__reFn, "");
                data = data[a[i]]();
                continue;
              }
              if (data === null || data[a[i]] === null) {
                return null;
              } else if (data === void 0 || data[a[i]] === void 0) {
                return void 0;
              }
              data = data[a[i]];
            }
          }
          return data;
        };
        return function(data, type) {
          return fetchData(data, type, source);
        };
      } else {
        return function(data, type) {
          return data[source];
        };
      }
    }
  };
  function _fnHungarianMap(o) {
    var hungarian = "a aa ai ao as b fn i m o s ", match, newKey, map2 = {};
    $2.each(o, function(key, val) {
      match = key.match(/^([^A-Z]+?)([A-Z])/);
      if (match && hungarian.indexOf(match[1] + " ") !== -1) {
        newKey = key.replace(match[0], match[2].toLowerCase());
        map2[newKey] = key;
        if (match[1] === "o") {
          _fnHungarianMap(o[key]);
        }
      }
    });
    o._hungarianMap = map2;
  }
  function _fnCamelToHungarian(src, user, force) {
    if (!src._hungarianMap) {
      _fnHungarianMap(src);
    }
    var hungarianKey;
    $2.each(user, function(key, val) {
      hungarianKey = src._hungarianMap[key];
      if (hungarianKey !== void 0 && (force || user[hungarianKey] === void 0)) {
        if (hungarianKey.charAt(0) === "o") {
          if (!user[hungarianKey]) {
            user[hungarianKey] = {};
          }
          $2.extend(true, user[hungarianKey], user[key]);
          _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);
        } else {
          user[hungarianKey] = user[key];
        }
      }
    });
  }
  function _fnLanguageCompat(lang) {
    var defaults = DataTable.defaults.oLanguage;
    var defaultDecimal = defaults.sDecimal;
    if (defaultDecimal) {
      _addNumericSort(defaultDecimal);
    }
    if (lang) {
      var zeroRecords = lang.sZeroRecords;
      if (!lang.sEmptyTable && zeroRecords && defaults.sEmptyTable === "No data available in table") {
        _fnMap(lang, lang, "sZeroRecords", "sEmptyTable");
      }
      if (!lang.sLoadingRecords && zeroRecords && defaults.sLoadingRecords === "Loading...") {
        _fnMap(lang, lang, "sZeroRecords", "sLoadingRecords");
      }
      if (lang.sInfoThousands) {
        lang.sThousands = lang.sInfoThousands;
      }
      var decimal = lang.sDecimal;
      if (decimal && defaultDecimal !== decimal) {
        _addNumericSort(decimal);
      }
    }
  }
  var _fnCompatMap = function(o, knew, old) {
    if (o[knew] !== void 0) {
      o[old] = o[knew];
    }
  };
  function _fnCompatOpts(init) {
    _fnCompatMap(init, "ordering", "bSort");
    _fnCompatMap(init, "orderMulti", "bSortMulti");
    _fnCompatMap(init, "orderClasses", "bSortClasses");
    _fnCompatMap(init, "orderCellsTop", "bSortCellsTop");
    _fnCompatMap(init, "order", "aaSorting");
    _fnCompatMap(init, "orderFixed", "aaSortingFixed");
    _fnCompatMap(init, "paging", "bPaginate");
    _fnCompatMap(init, "pagingType", "sPaginationType");
    _fnCompatMap(init, "pageLength", "iDisplayLength");
    _fnCompatMap(init, "searching", "bFilter");
    if (typeof init.sScrollX === "boolean") {
      init.sScrollX = init.sScrollX ? "100%" : "";
    }
    if (typeof init.scrollX === "boolean") {
      init.scrollX = init.scrollX ? "100%" : "";
    }
    var searchCols = init.aoSearchCols;
    if (searchCols) {
      for (var i = 0, ien = searchCols.length; i < ien; i++) {
        if (searchCols[i]) {
          _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i]);
        }
      }
    }
  }
  function _fnCompatCols(init) {
    _fnCompatMap(init, "orderable", "bSortable");
    _fnCompatMap(init, "orderData", "aDataSort");
    _fnCompatMap(init, "orderSequence", "asSorting");
    _fnCompatMap(init, "orderDataType", "sortDataType");
    var dataSort = init.aDataSort;
    if (typeof dataSort === "number" && !Array.isArray(dataSort)) {
      init.aDataSort = [dataSort];
    }
  }
  function _fnBrowserDetect(settings) {
    if (!DataTable.__browser) {
      var browser = {};
      DataTable.__browser = browser;
      var n = $2("<div/>").css({
        position: "fixed",
        top: 0,
        left: $2(window).scrollLeft() * -1,
        // allow for scrolling
        height: 1,
        width: 1,
        overflow: "hidden"
      }).append(
        $2("<div/>").css({
          position: "absolute",
          top: 1,
          left: 1,
          width: 100,
          overflow: "scroll"
        }).append(
          $2("<div/>").css({
            width: "100%",
            height: 10
          })
        )
      ).appendTo("body");
      var outer = n.children();
      var inner = outer.children();
      browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
      browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100;
      browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1;
      browser.bBounding = n[0].getBoundingClientRect().width ? true : false;
      n.remove();
    }
    $2.extend(settings.oBrowser, DataTable.__browser);
    settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
  }
  function _fnReduce(that, fn, init, start2, end, inc) {
    var i = start2, value, isSet2 = false;
    if (init !== void 0) {
      value = init;
      isSet2 = true;
    }
    while (i !== end) {
      if (!that.hasOwnProperty(i)) {
        continue;
      }
      value = isSet2 ? fn(value, that[i], i, that) : that[i];
      isSet2 = true;
      i += inc;
    }
    return value;
  }
  function _fnAddColumn(oSettings, nTh) {
    var oDefaults = DataTable.defaults.column;
    var iCol = oSettings.aoColumns.length;
    var oCol = $2.extend({}, DataTable.models.oColumn, oDefaults, {
      "nTh": nTh ? nTh : document.createElement("th"),
      "sTitle": oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : "",
      "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
      "mData": oDefaults.mData ? oDefaults.mData : iCol,
      idx: iCol
    });
    oSettings.aoColumns.push(oCol);
    var searchCols = oSettings.aoPreSearchCols;
    searchCols[iCol] = $2.extend({}, DataTable.models.oSearch, searchCols[iCol]);
    _fnColumnOptions(oSettings, iCol, $2(nTh).data());
  }
  function _fnColumnOptions(oSettings, iCol, oOptions) {
    var oCol = oSettings.aoColumns[iCol];
    var oClasses = oSettings.oClasses;
    var th = $2(oCol.nTh);
    if (!oCol.sWidthOrig) {
      oCol.sWidthOrig = th.attr("width") || null;
      var t = (th.attr("style") || "").match(/width:\s*(\d+[pxem%]+)/);
      if (t) {
        oCol.sWidthOrig = t[1];
      }
    }
    if (oOptions !== void 0 && oOptions !== null) {
      _fnCompatCols(oOptions);
      _fnCamelToHungarian(DataTable.defaults.column, oOptions, true);
      if (oOptions.mDataProp !== void 0 && !oOptions.mData) {
        oOptions.mData = oOptions.mDataProp;
      }
      if (oOptions.sType) {
        oCol._sManualType = oOptions.sType;
      }
      if (oOptions.className && !oOptions.sClass) {
        oOptions.sClass = oOptions.className;
      }
      if (oOptions.sClass) {
        th.addClass(oOptions.sClass);
      }
      var origClass = oCol.sClass;
      $2.extend(oCol, oOptions);
      _fnMap(oCol, oOptions, "sWidth", "sWidthOrig");
      if (origClass !== oCol.sClass) {
        oCol.sClass = origClass + " " + oCol.sClass;
      }
      if (oOptions.iDataSort !== void 0) {
        oCol.aDataSort = [oOptions.iDataSort];
      }
      _fnMap(oCol, oOptions, "aDataSort");
      if (!oCol.ariaTitle) {
        oCol.ariaTitle = th.attr("aria-label");
      }
    }
    var mDataSrc = oCol.mData;
    var mData = _fnGetObjectDataFn(mDataSrc);
    var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;
    var attrTest = function(src) {
      return typeof src === "string" && src.indexOf("@") !== -1;
    };
    oCol._bAttrSrc = $2.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
    oCol._setter = null;
    oCol.fnGetData = function(rowData, type, meta) {
      var innerData = mData(rowData, type, void 0, meta);
      return mRender && type ? mRender(innerData, type, rowData, meta) : innerData;
    };
    oCol.fnSetData = function(rowData, val, meta) {
      return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);
    };
    if (typeof mDataSrc !== "number" && !oCol._isArrayHost) {
      oSettings._rowReadObject = true;
    }
    if (!oSettings.oFeatures.bSort) {
      oCol.bSortable = false;
      th.addClass(oClasses.sSortableNone);
    }
    var bAsc = $2.inArray("asc", oCol.asSorting) !== -1;
    var bDesc = $2.inArray("desc", oCol.asSorting) !== -1;
    if (!oCol.bSortable || !bAsc && !bDesc) {
      oCol.sSortingClass = oClasses.sSortableNone;
      oCol.sSortingClassJUI = "";
    } else if (bAsc && !bDesc) {
      oCol.sSortingClass = oClasses.sSortableAsc;
      oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
    } else if (!bAsc && bDesc) {
      oCol.sSortingClass = oClasses.sSortableDesc;
      oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
    } else {
      oCol.sSortingClass = oClasses.sSortable;
      oCol.sSortingClassJUI = oClasses.sSortJUI;
    }
  }
  function _fnAdjustColumnSizing(settings) {
    if (settings.oFeatures.bAutoWidth !== false) {
      var columns = settings.aoColumns;
      _fnCalculateColumnWidths(settings);
      for (var i = 0, iLen = columns.length; i < iLen; i++) {
        columns[i].nTh.style.width = columns[i].sWidth;
      }
    }
    var scroll = settings.oScroll;
    if (scroll.sY !== "" || scroll.sX !== "") {
      _fnScrollDraw(settings);
    }
    _fnCallbackFire(settings, null, "column-sizing", [settings]);
  }
  function _fnVisibleToColumnIndex(oSettings, iMatch) {
    var aiVis = _fnGetColumns(oSettings, "bVisible");
    return typeof aiVis[iMatch] === "number" ? aiVis[iMatch] : null;
  }
  function _fnColumnIndexToVisible(oSettings, iMatch) {
    var aiVis = _fnGetColumns(oSettings, "bVisible");
    var iPos = $2.inArray(iMatch, aiVis);
    return iPos !== -1 ? iPos : null;
  }
  function _fnVisbleColumns(oSettings) {
    var vis = 0;
    $2.each(oSettings.aoColumns, function(i, col) {
      if (col.bVisible && $2(col.nTh).css("display") !== "none") {
        vis++;
      }
    });
    return vis;
  }
  function _fnGetColumns(oSettings, sParam) {
    var a = [];
    $2.map(oSettings.aoColumns, function(val, i) {
      if (val[sParam]) {
        a.push(i);
      }
    });
    return a;
  }
  function _fnColumnTypes(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var types = DataTable.ext.type.detect;
    var i, ien, j, jen, k, ken;
    var col, cell, detectedType, cache2;
    for (i = 0, ien = columns.length; i < ien; i++) {
      col = columns[i];
      cache2 = [];
      if (!col.sType && col._sManualType) {
        col.sType = col._sManualType;
      } else if (!col.sType) {
        for (j = 0, jen = types.length; j < jen; j++) {
          for (k = 0, ken = data.length; k < ken; k++) {
            if (cache2[k] === void 0) {
              cache2[k] = _fnGetCellData(settings, k, i, "type");
            }
            detectedType = types[j](cache2[k], settings);
            if (!detectedType && j !== types.length - 1) {
              break;
            }
            if (detectedType === "html" && !_empty(cache2[k])) {
              break;
            }
          }
          if (detectedType) {
            col.sType = detectedType;
            break;
          }
        }
        if (!col.sType) {
          col.sType = "string";
        }
      }
    }
  }
  function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {
    var i, iLen, j, jLen, k, kLen, def2;
    var columns = oSettings.aoColumns;
    if (aoColDefs) {
      for (i = aoColDefs.length - 1; i >= 0; i--) {
        def2 = aoColDefs[i];
        var aTargets = def2.target !== void 0 ? def2.target : def2.targets !== void 0 ? def2.targets : def2.aTargets;
        if (!Array.isArray(aTargets)) {
          aTargets = [aTargets];
        }
        for (j = 0, jLen = aTargets.length; j < jLen; j++) {
          if (typeof aTargets[j] === "number" && aTargets[j] >= 0) {
            while (columns.length <= aTargets[j]) {
              _fnAddColumn(oSettings);
            }
            fn(aTargets[j], def2);
          } else if (typeof aTargets[j] === "number" && aTargets[j] < 0) {
            fn(columns.length + aTargets[j], def2);
          } else if (typeof aTargets[j] === "string") {
            for (k = 0, kLen = columns.length; k < kLen; k++) {
              if (aTargets[j] == "_all" || $2(columns[k].nTh).hasClass(aTargets[j])) {
                fn(k, def2);
              }
            }
          }
        }
      }
    }
    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        fn(i, aoCols[i]);
      }
    }
  }
  function _fnAddData(oSettings, aDataIn, nTr, anTds) {
    var iRow = oSettings.aoData.length;
    var oData = $2.extend(true, {}, DataTable.models.oRow, {
      src: nTr ? "dom" : "data",
      idx: iRow
    });
    oData._aData = aDataIn;
    oSettings.aoData.push(oData);
    var nTd, sThisType;
    var columns = oSettings.aoColumns;
    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      columns[i].sType = null;
    }
    oSettings.aiDisplayMaster.push(iRow);
    var id = oSettings.rowIdFn(aDataIn);
    if (id !== void 0) {
      oSettings.aIds[id] = oData;
    }
    if (nTr || !oSettings.oFeatures.bDeferRender) {
      _fnCreateTr(oSettings, iRow, nTr, anTds);
    }
    return iRow;
  }
  function _fnAddTr(settings, trs) {
    var row;
    if (!(trs instanceof $2)) {
      trs = $2(trs);
    }
    return trs.map(function(i, el) {
      row = _fnGetRowElements(settings, el);
      return _fnAddData(settings, row.data, el, row.cells);
    });
  }
  function _fnNodeToDataIndex(oSettings, n) {
    return n._DT_RowIndex !== void 0 ? n._DT_RowIndex : null;
  }
  function _fnNodeToColumnIndex(oSettings, iRow, n) {
    return $2.inArray(n, oSettings.aoData[iRow].anCells);
  }
  function _fnGetCellData(settings, rowIdx, colIdx, type) {
    if (type === "search") {
      type = "filter";
    } else if (type === "order") {
      type = "sort";
    }
    var draw = settings.iDraw;
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    var defaultContent = col.sDefaultContent;
    var cellData = col.fnGetData(rowData, type, {
      settings,
      row: rowIdx,
      col: colIdx
    });
    if (cellData === void 0) {
      if (settings.iDrawError != draw && defaultContent === null) {
        _fnLog(settings, 0, "Requested unknown parameter " + (typeof col.mData == "function" ? "{function}" : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4);
        settings.iDrawError = draw;
      }
      return defaultContent;
    }
    if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== void 0) {
      cellData = defaultContent;
    } else if (typeof cellData === "function") {
      return cellData.call(rowData);
    }
    if (cellData === null && type === "display") {
      return "";
    }
    if (type === "filter") {
      var fomatters = DataTable.ext.type.search;
      if (fomatters[col.sType]) {
        cellData = fomatters[col.sType](cellData);
      }
    }
    return cellData;
  }
  function _fnSetCellData(settings, rowIdx, colIdx, val) {
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    col.fnSetData(rowData, val, {
      settings,
      row: rowIdx,
      col: colIdx
    });
  }
  var __reArray = /\[.*?\]$/;
  var __reFn = /\(\)$/;
  function _fnSplitObjNotation(str) {
    return $2.map(str.match(/(\\.|[^\.])+/g) || [""], function(s) {
      return s.replace(/\\\./g, ".");
    });
  }
  var _fnGetObjectDataFn = DataTable.util.get;
  var _fnSetObjectDataFn = DataTable.util.set;
  function _fnGetDataMaster(settings) {
    return _pluck(settings.aoData, "_aData");
  }
  function _fnClearTable(settings) {
    settings.aoData.length = 0;
    settings.aiDisplayMaster.length = 0;
    settings.aiDisplay.length = 0;
    settings.aIds = {};
  }
  function _fnDeleteIndex(a, iTarget, splice) {
    var iTargetIndex = -1;
    for (var i = 0, iLen = a.length; i < iLen; i++) {
      if (a[i] == iTarget) {
        iTargetIndex = i;
      } else if (a[i] > iTarget) {
        a[i]--;
      }
    }
    if (iTargetIndex != -1 && splice === void 0) {
      a.splice(iTargetIndex, 1);
    }
  }
  function _fnInvalidate(settings, rowIdx, src, colIdx) {
    var row = settings.aoData[rowIdx];
    var i, ien;
    var cellWrite = function(cell, col) {
      while (cell.childNodes.length) {
        cell.removeChild(cell.firstChild);
      }
      cell.innerHTML = _fnGetCellData(settings, rowIdx, col, "display");
    };
    if (src === "dom" || (!src || src === "auto") && row.src === "dom") {
      row._aData = _fnGetRowElements(
        settings,
        row,
        colIdx,
        colIdx === void 0 ? void 0 : row._aData
      ).data;
    } else {
      var cells = row.anCells;
      if (cells) {
        if (colIdx !== void 0) {
          cellWrite(cells[colIdx], colIdx);
        } else {
          for (i = 0, ien = cells.length; i < ien; i++) {
            cellWrite(cells[i], i);
          }
        }
      }
    }
    row._aSortData = null;
    row._aFilterData = null;
    var cols = settings.aoColumns;
    if (colIdx !== void 0) {
      cols[colIdx].sType = null;
    } else {
      for (i = 0, ien = cols.length; i < ien; i++) {
        cols[i].sType = null;
      }
      _fnRowAttributes(settings, row);
    }
  }
  function _fnGetRowElements(settings, row, colIdx, d) {
    var tds = [], td = row.firstChild, name, col, o, i = 0, contents, columns = settings.aoColumns, objectRead = settings._rowReadObject;
    d = d !== void 0 ? d : objectRead ? {} : [];
    var attr = function(str, td2) {
      if (typeof str === "string") {
        var idx = str.indexOf("@");
        if (idx !== -1) {
          var attr2 = str.substring(idx + 1);
          var setter = _fnSetObjectDataFn(str);
          setter(d, td2.getAttribute(attr2));
        }
      }
    };
    var cellProcess = function(cell) {
      if (colIdx === void 0 || colIdx === i) {
        col = columns[i];
        contents = cell.innerHTML.trim();
        if (col && col._bAttrSrc) {
          var setter = _fnSetObjectDataFn(col.mData._);
          setter(d, contents);
          attr(col.mData.sort, cell);
          attr(col.mData.type, cell);
          attr(col.mData.filter, cell);
        } else {
          if (objectRead) {
            if (!col._setter) {
              col._setter = _fnSetObjectDataFn(col.mData);
            }
            col._setter(d, contents);
          } else {
            d[i] = contents;
          }
        }
      }
      i++;
    };
    if (td) {
      while (td) {
        name = td.nodeName.toUpperCase();
        if (name == "TD" || name == "TH") {
          cellProcess(td);
          tds.push(td);
        }
        td = td.nextSibling;
      }
    } else {
      tds = row.anCells;
      for (var j = 0, jen = tds.length; j < jen; j++) {
        cellProcess(tds[j]);
      }
    }
    var rowNode = row.firstChild ? row : row.nTr;
    if (rowNode) {
      var id = rowNode.getAttribute("id");
      if (id) {
        _fnSetObjectDataFn(settings.rowId)(d, id);
      }
    }
    return {
      data: d,
      cells: tds
    };
  }
  function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
    var row = oSettings.aoData[iRow], rowData = row._aData, cells = [], nTr, nTd, oCol, i, iLen, create;
    if (row.nTr === null) {
      nTr = nTrIn || document.createElement("tr");
      row.nTr = nTr;
      row.anCells = cells;
      nTr._DT_RowIndex = iRow;
      _fnRowAttributes(oSettings, row);
      for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
        oCol = oSettings.aoColumns[i];
        create = nTrIn ? false : true;
        nTd = create ? document.createElement(oCol.sCellType) : anTds[i];
        if (!nTd) {
          _fnLog(oSettings, 0, "Incorrect column count", 18);
        }
        nTd._DT_CellIndex = {
          row: iRow,
          column: i
        };
        cells.push(nTd);
        if (create || (oCol.mRender || oCol.mData !== i) && (!$2.isPlainObject(oCol.mData) || oCol.mData._ !== i + ".display")) {
          nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, "display");
        }
        if (oCol.sClass) {
          nTd.className += " " + oCol.sClass;
        }
        if (oCol.bVisible && !nTrIn) {
          nTr.appendChild(nTd);
        } else if (!oCol.bVisible && nTrIn) {
          nTd.parentNode.removeChild(nTd);
        }
        if (oCol.fnCreatedCell) {
          oCol.fnCreatedCell.call(
            oSettings.oInstance,
            nTd,
            _fnGetCellData(oSettings, iRow, i),
            rowData,
            iRow,
            i
          );
        }
      }
      _fnCallbackFire(oSettings, "aoRowCreatedCallback", null, [nTr, rowData, iRow, cells]);
    }
  }
  function _fnRowAttributes(settings, row) {
    var tr = row.nTr;
    var data = row._aData;
    if (tr) {
      var id = settings.rowIdFn(data);
      if (id) {
        tr.id = id;
      }
      if (data.DT_RowClass) {
        var a = data.DT_RowClass.split(" ");
        row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a)) : a;
        $2(tr).removeClass(row.__rowc.join(" ")).addClass(data.DT_RowClass);
      }
      if (data.DT_RowAttr) {
        $2(tr).attr(data.DT_RowAttr);
      }
      if (data.DT_RowData) {
        $2(tr).data(data.DT_RowData);
      }
    }
  }
  function _fnBuildHead(oSettings) {
    var i, ien, cell, row, column;
    var thead = oSettings.nTHead;
    var tfoot = oSettings.nTFoot;
    var createHeader = $2("th, td", thead).length === 0;
    var classes = oSettings.oClasses;
    var columns = oSettings.aoColumns;
    if (createHeader) {
      row = $2("<tr/>").appendTo(thead);
    }
    for (i = 0, ien = columns.length; i < ien; i++) {
      column = columns[i];
      cell = $2(column.nTh).addClass(column.sClass);
      if (createHeader) {
        cell.appendTo(row);
      }
      if (oSettings.oFeatures.bSort) {
        cell.addClass(column.sSortingClass);
        if (column.bSortable !== false) {
          cell.attr("tabindex", oSettings.iTabIndex).attr("aria-controls", oSettings.sTableId);
          _fnSortAttachListener(oSettings, column.nTh, i);
        }
      }
      if (column.sTitle != cell[0].innerHTML) {
        cell.html(column.sTitle);
      }
      _fnRenderer(oSettings, "header")(
        oSettings,
        cell,
        column,
        classes
      );
    }
    if (createHeader) {
      _fnDetectHeader(oSettings.aoHeader, thead);
    }
    $2(thead).children("tr").children("th, td").addClass(classes.sHeaderTH);
    $2(tfoot).children("tr").children("th, td").addClass(classes.sFooterTH);
    if (tfoot !== null) {
      var cells = oSettings.aoFooter[0];
      for (i = 0, ien = cells.length; i < ien; i++) {
        column = columns[i];
        if (column) {
          column.nTf = cells[i].cell;
          if (column.sClass) {
            $2(column.nTf).addClass(column.sClass);
          }
        } else {
          _fnLog(oSettings, 0, "Incorrect column count", 18);
        }
      }
    }
  }
  function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
    var i, iLen, j, jLen, k, kLen, n, nLocalTr;
    var aoLocal = [];
    var aApplied = [];
    var iColumns = oSettings.aoColumns.length;
    var iRowspan, iColspan;
    if (!aoSource) {
      return;
    }
    if (bIncludeHidden === void 0) {
      bIncludeHidden = false;
    }
    for (i = 0, iLen = aoSource.length; i < iLen; i++) {
      aoLocal[i] = aoSource[i].slice();
      aoLocal[i].nTr = aoSource[i].nTr;
      for (j = iColumns - 1; j >= 0; j--) {
        if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {
          aoLocal[i].splice(j, 1);
        }
      }
      aApplied.push([]);
    }
    for (i = 0, iLen = aoLocal.length; i < iLen; i++) {
      nLocalTr = aoLocal[i].nTr;
      if (nLocalTr) {
        while (n = nLocalTr.firstChild) {
          nLocalTr.removeChild(n);
        }
      }
      for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {
        iRowspan = 1;
        iColspan = 1;
        if (aApplied[i][j] === void 0) {
          nLocalTr.appendChild(aoLocal[i][j].cell);
          aApplied[i][j] = 1;
          while (aoLocal[i + iRowspan] !== void 0 && aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {
            aApplied[i + iRowspan][j] = 1;
            iRowspan++;
          }
          while (aoLocal[i][j + iColspan] !== void 0 && aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {
            for (k = 0; k < iRowspan; k++) {
              aApplied[i + k][j + iColspan] = 1;
            }
            iColspan++;
          }
          $2(aoLocal[i][j].cell).attr("rowspan", iRowspan).attr("colspan", iColspan);
        }
      }
    }
  }
  function _fnDraw(oSettings, ajaxComplete) {
    _fnStart(oSettings);
    var aPreDraw = _fnCallbackFire(oSettings, "aoPreDrawCallback", "preDraw", [oSettings]);
    if ($2.inArray(false, aPreDraw) !== -1) {
      _fnProcessingDisplay(oSettings, false);
      return;
    }
    var anRows = [];
    var iRowCount = 0;
    var asStripeClasses = oSettings.asStripeClasses;
    var iStripes = asStripeClasses.length;
    var oLang = oSettings.oLanguage;
    var bServerSide = _fnDataSource(oSettings) == "ssp";
    var aiDisplay = oSettings.aiDisplay;
    var iDisplayStart = oSettings._iDisplayStart;
    var iDisplayEnd = oSettings.fnDisplayEnd();
    oSettings.bDrawing = true;
    if (oSettings.bDeferLoading) {
      oSettings.bDeferLoading = false;
      oSettings.iDraw++;
      _fnProcessingDisplay(oSettings, false);
    } else if (!bServerSide) {
      oSettings.iDraw++;
    } else if (!oSettings.bDestroying && !ajaxComplete) {
      _fnAjaxUpdate(oSettings);
      return;
    }
    if (aiDisplay.length !== 0) {
      var iStart = bServerSide ? 0 : iDisplayStart;
      var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
      for (var j = iStart; j < iEnd; j++) {
        var iDataIndex = aiDisplay[j];
        var aoData = oSettings.aoData[iDataIndex];
        if (aoData.nTr === null) {
          _fnCreateTr(oSettings, iDataIndex);
        }
        var nRow = aoData.nTr;
        if (iStripes !== 0) {
          var sStripe = asStripeClasses[iRowCount % iStripes];
          if (aoData._sRowStripe != sStripe) {
            $2(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
            aoData._sRowStripe = sStripe;
          }
        }
        _fnCallbackFire(
          oSettings,
          "aoRowCallback",
          null,
          [nRow, aoData._aData, iRowCount, j, iDataIndex]
        );
        anRows.push(nRow);
        iRowCount++;
      }
    } else {
      var sZero = oLang.sZeroRecords;
      if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == "ajax") {
        sZero = oLang.sLoadingRecords;
      } else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {
        sZero = oLang.sEmptyTable;
      }
      anRows[0] = $2("<tr/>", { "class": iStripes ? asStripeClasses[0] : "" }).append($2("<td />", {
        "valign": "top",
        "colSpan": _fnVisbleColumns(oSettings),
        "class": oSettings.oClasses.sRowEmpty
      }).html(sZero))[0];
    }
    _fnCallbackFire(oSettings, "aoHeaderCallback", "header", [
      $2(oSettings.nTHead).children("tr")[0],
      _fnGetDataMaster(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    _fnCallbackFire(oSettings, "aoFooterCallback", "footer", [
      $2(oSettings.nTFoot).children("tr")[0],
      _fnGetDataMaster(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    var body = $2(oSettings.nTBody);
    body.children().detach();
    body.append($2(anRows));
    _fnCallbackFire(oSettings, "aoDrawCallback", "draw", [oSettings]);
    oSettings.bSorted = false;
    oSettings.bFiltered = false;
    oSettings.bDrawing = false;
  }
  function _fnReDraw(settings, holdPosition) {
    var features = settings.oFeatures, sort = features.bSort, filter = features.bFilter;
    if (sort) {
      _fnSort(settings);
    }
    if (filter) {
      _fnFilterComplete(settings, settings.oPreviousSearch);
    } else {
      settings.aiDisplay = settings.aiDisplayMaster.slice();
    }
    if (holdPosition !== true) {
      settings._iDisplayStart = 0;
    }
    settings._drawHold = holdPosition;
    _fnDraw(settings);
    settings._drawHold = false;
  }
  function _fnAddOptionsHtml(oSettings) {
    var classes = oSettings.oClasses;
    var table = $2(oSettings.nTable);
    var holding = $2("<div/>").insertBefore(table);
    var features = oSettings.oFeatures;
    var insert = $2("<div/>", {
      id: oSettings.sTableId + "_wrapper",
      "class": classes.sWrapper + (oSettings.nTFoot ? "" : " " + classes.sNoFooter)
    });
    oSettings.nHolding = holding[0];
    oSettings.nTableWrapper = insert[0];
    oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
    var aDom = oSettings.sDom.split("");
    var featureNode, cOption, nNewNode, cNext, sAttr, j;
    for (var i = 0; i < aDom.length; i++) {
      featureNode = null;
      cOption = aDom[i];
      if (cOption == "<") {
        nNewNode = $2("<div/>")[0];
        cNext = aDom[i + 1];
        if (cNext == "'" || cNext == '"') {
          sAttr = "";
          j = 2;
          while (aDom[i + j] != cNext) {
            sAttr += aDom[i + j];
            j++;
          }
          if (sAttr == "H") {
            sAttr = classes.sJUIHeader;
          } else if (sAttr == "F") {
            sAttr = classes.sJUIFooter;
          }
          if (sAttr.indexOf(".") != -1) {
            var aSplit = sAttr.split(".");
            nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);
            nNewNode.className = aSplit[1];
          } else if (sAttr.charAt(0) == "#") {
            nNewNode.id = sAttr.substr(1, sAttr.length - 1);
          } else {
            nNewNode.className = sAttr;
          }
          i += j;
        }
        insert.append(nNewNode);
        insert = $2(nNewNode);
      } else if (cOption == ">") {
        insert = insert.parent();
      } else if (cOption == "l" && features.bPaginate && features.bLengthChange) {
        featureNode = _fnFeatureHtmlLength(oSettings);
      } else if (cOption == "f" && features.bFilter) {
        featureNode = _fnFeatureHtmlFilter(oSettings);
      } else if (cOption == "r" && features.bProcessing) {
        featureNode = _fnFeatureHtmlProcessing(oSettings);
      } else if (cOption == "t") {
        featureNode = _fnFeatureHtmlTable(oSettings);
      } else if (cOption == "i" && features.bInfo) {
        featureNode = _fnFeatureHtmlInfo(oSettings);
      } else if (cOption == "p" && features.bPaginate) {
        featureNode = _fnFeatureHtmlPaginate(oSettings);
      } else if (DataTable.ext.feature.length !== 0) {
        var aoFeatures = DataTable.ext.feature;
        for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {
          if (cOption == aoFeatures[k].cFeature) {
            featureNode = aoFeatures[k].fnInit(oSettings);
            break;
          }
        }
      }
      if (featureNode) {
        var aanFeatures = oSettings.aanFeatures;
        if (!aanFeatures[cOption]) {
          aanFeatures[cOption] = [];
        }
        aanFeatures[cOption].push(featureNode);
        insert.append(featureNode);
      }
    }
    holding.replaceWith(insert);
    oSettings.nHolding = null;
  }
  function _fnDetectHeader(aLayout, nThead) {
    var nTrs = $2(nThead).children("tr");
    var nTr, nCell;
    var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
    var bUnique;
    var fnShiftCol = function(a, i2, j) {
      var k2 = a[i2];
      while (k2[j]) {
        j++;
      }
      return j;
    };
    aLayout.splice(0, aLayout.length);
    for (i = 0, iLen = nTrs.length; i < iLen; i++) {
      aLayout.push([]);
    }
    for (i = 0, iLen = nTrs.length; i < iLen; i++) {
      nTr = nTrs[i];
      iColumn = 0;
      nCell = nTr.firstChild;
      while (nCell) {
        if (nCell.nodeName.toUpperCase() == "TD" || nCell.nodeName.toUpperCase() == "TH") {
          iColspan = nCell.getAttribute("colspan") * 1;
          iRowspan = nCell.getAttribute("rowspan") * 1;
          iColspan = !iColspan || iColspan === 0 || iColspan === 1 ? 1 : iColspan;
          iRowspan = !iRowspan || iRowspan === 0 || iRowspan === 1 ? 1 : iRowspan;
          iColShifted = fnShiftCol(aLayout, i, iColumn);
          bUnique = iColspan === 1 ? true : false;
          for (l = 0; l < iColspan; l++) {
            for (k = 0; k < iRowspan; k++) {
              aLayout[i + k][iColShifted + l] = {
                "cell": nCell,
                "unique": bUnique
              };
              aLayout[i + k].nTr = nTr;
            }
          }
        }
        nCell = nCell.nextSibling;
      }
    }
  }
  function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
    var aReturn = [];
    if (!aLayout) {
      aLayout = oSettings.aoHeader;
      if (nHeader) {
        aLayout = [];
        _fnDetectHeader(aLayout, nHeader);
      }
    }
    for (var i = 0, iLen = aLayout.length; i < iLen; i++) {
      for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {
        if (aLayout[i][j].unique && (!aReturn[j] || !oSettings.bSortCellsTop)) {
          aReturn[j] = aLayout[i][j].cell;
        }
      }
    }
    return aReturn;
  }
  function _fnStart(oSettings) {
    var bServerSide = _fnDataSource(oSettings) == "ssp";
    var iInitDisplayStart = oSettings.iInitDisplayStart;
    if (iInitDisplayStart !== void 0 && iInitDisplayStart !== -1) {
      oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
      oSettings.iInitDisplayStart = -1;
    }
  }
  function _fnBuildAjax(oSettings, data, fn) {
    _fnCallbackFire(oSettings, "aoServerParams", "serverParams", [data]);
    if (data && Array.isArray(data)) {
      var tmp = {};
      var rbracket = /(.*?)\[\]$/;
      $2.each(data, function(key, val) {
        var match = val.name.match(rbracket);
        if (match) {
          var name = match[0];
          if (!tmp[name]) {
            tmp[name] = [];
          }
          tmp[name].push(val.value);
        } else {
          tmp[val.name] = val.value;
        }
      });
      data = tmp;
    }
    var ajaxData;
    var ajax = oSettings.ajax;
    var instance = oSettings.oInstance;
    var callback = function(json) {
      var status = oSettings.jqXHR ? oSettings.jqXHR.status : null;
      if (json === null || typeof status === "number" && status == 204) {
        json = {};
        _fnAjaxDataSrc(oSettings, json, []);
      }
      var error2 = json.error || json.sError;
      if (error2) {
        _fnLog(oSettings, 0, error2);
      }
      oSettings.json = json;
      _fnCallbackFire(oSettings, null, "xhr", [oSettings, json, oSettings.jqXHR]);
      fn(json);
    };
    if ($2.isPlainObject(ajax) && ajax.data) {
      ajaxData = ajax.data;
      var newData = typeof ajaxData === "function" ? ajaxData(data, oSettings) : (
        // fn can manipulate data or return
        ajaxData
      );
      data = typeof ajaxData === "function" && newData ? newData : $2.extend(true, data, newData);
      delete ajax.data;
    }
    var baseAjax = {
      "data": data,
      "success": callback,
      "dataType": "json",
      "cache": false,
      "type": oSettings.sServerMethod,
      "error": function(xhr, error2, thrown) {
        var ret = _fnCallbackFire(oSettings, null, "xhr", [oSettings, null, oSettings.jqXHR]);
        if ($2.inArray(true, ret) === -1) {
          if (error2 == "parsererror") {
            _fnLog(oSettings, 0, "Invalid JSON response", 1);
          } else if (xhr.readyState === 4) {
            _fnLog(oSettings, 0, "Ajax error", 7);
          }
        }
        _fnProcessingDisplay(oSettings, false);
      }
    };
    oSettings.oAjaxData = data;
    _fnCallbackFire(oSettings, null, "preXhr", [oSettings, data]);
    if (oSettings.fnServerData) {
      oSettings.fnServerData.call(
        instance,
        oSettings.sAjaxSource,
        $2.map(data, function(val, key) {
          return { name: key, value: val };
        }),
        callback,
        oSettings
      );
    } else if (oSettings.sAjaxSource || typeof ajax === "string") {
      oSettings.jqXHR = $2.ajax($2.extend(baseAjax, {
        url: ajax || oSettings.sAjaxSource
      }));
    } else if (typeof ajax === "function") {
      oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
    } else {
      oSettings.jqXHR = $2.ajax($2.extend(baseAjax, ajax));
      ajax.data = ajaxData;
    }
  }
  function _fnAjaxUpdate(settings) {
    settings.iDraw++;
    _fnProcessingDisplay(settings, true);
    var drawHold = settings._drawHold;
    _fnBuildAjax(
      settings,
      _fnAjaxParameters(settings),
      function(json) {
        settings._drawHold = drawHold;
        _fnAjaxUpdateDraw(settings, json);
        settings._drawHold = false;
      }
    );
  }
  function _fnAjaxParameters(settings) {
    var columns = settings.aoColumns, columnCount = columns.length, features = settings.oFeatures, preSearch = settings.oPreviousSearch, preColSearch = settings.aoPreSearchCols, i, data = [], dataProp, column, columnSearch, sort = _fnSortFlatten(settings), displayStart = settings._iDisplayStart, displayLength = features.bPaginate !== false ? settings._iDisplayLength : -1;
    var param = function(name, value) {
      data.push({ "name": name, "value": value });
    };
    param("sEcho", settings.iDraw);
    param("iColumns", columnCount);
    param("sColumns", _pluck(columns, "sName").join(","));
    param("iDisplayStart", displayStart);
    param("iDisplayLength", displayLength);
    var d = {
      draw: settings.iDraw,
      columns: [],
      order: [],
      start: displayStart,
      length: displayLength,
      search: {
        value: preSearch.sSearch,
        regex: preSearch.bRegex
      }
    };
    for (i = 0; i < columnCount; i++) {
      column = columns[i];
      columnSearch = preColSearch[i];
      dataProp = typeof column.mData == "function" ? "function" : column.mData;
      d.columns.push({
        data: dataProp,
        name: column.sName,
        searchable: column.bSearchable,
        orderable: column.bSortable,
        search: {
          value: columnSearch.sSearch,
          regex: columnSearch.bRegex
        }
      });
      param("mDataProp_" + i, dataProp);
      if (features.bFilter) {
        param("sSearch_" + i, columnSearch.sSearch);
        param("bRegex_" + i, columnSearch.bRegex);
        param("bSearchable_" + i, column.bSearchable);
      }
      if (features.bSort) {
        param("bSortable_" + i, column.bSortable);
      }
    }
    if (features.bFilter) {
      param("sSearch", preSearch.sSearch);
      param("bRegex", preSearch.bRegex);
    }
    if (features.bSort) {
      $2.each(sort, function(i2, val) {
        d.order.push({ column: val.col, dir: val.dir });
        param("iSortCol_" + i2, val.col);
        param("sSortDir_" + i2, val.dir);
      });
      param("iSortingCols", sort.length);
    }
    var legacy = DataTable.ext.legacy.ajax;
    if (legacy === null) {
      return settings.sAjaxSource ? data : d;
    }
    return legacy ? data : d;
  }
  function _fnAjaxUpdateDraw(settings, json) {
    var compat = function(old, modern) {
      return json[old] !== void 0 ? json[old] : json[modern];
    };
    var data = _fnAjaxDataSrc(settings, json);
    var draw = compat("sEcho", "draw");
    var recordsTotal = compat("iTotalRecords", "recordsTotal");
    var recordsFiltered = compat("iTotalDisplayRecords", "recordsFiltered");
    if (draw !== void 0) {
      if (draw * 1 < settings.iDraw) {
        return;
      }
      settings.iDraw = draw * 1;
    }
    if (!data) {
      data = [];
    }
    _fnClearTable(settings);
    settings._iRecordsTotal = parseInt(recordsTotal, 10);
    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
    for (var i = 0, ien = data.length; i < ien; i++) {
      _fnAddData(settings, data[i]);
    }
    settings.aiDisplay = settings.aiDisplayMaster.slice();
    _fnDraw(settings, true);
    if (!settings._bInitComplete) {
      _fnInitComplete(settings, json);
    }
    _fnProcessingDisplay(settings, false);
  }
  function _fnAjaxDataSrc(oSettings, json, write) {
    var dataSrc = $2.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== void 0 ? oSettings.ajax.dataSrc : oSettings.sAjaxDataProp;
    if (!write) {
      if (dataSrc === "data") {
        return json.aaData || json[dataSrc];
      }
      return dataSrc !== "" ? _fnGetObjectDataFn(dataSrc)(json) : json;
    }
    _fnSetObjectDataFn(dataSrc)(json, write);
  }
  function _fnFeatureHtmlFilter(settings) {
    var classes = settings.oClasses;
    var tableId = settings.sTableId;
    var language = settings.oLanguage;
    var previousSearch = settings.oPreviousSearch;
    var features = settings.aanFeatures;
    var input = '<input type="search" class="' + classes.sFilterInput + '"/>';
    var str = language.sSearch;
    str = str.match(/_INPUT_/) ? str.replace("_INPUT_", input) : str + input;
    var filter = $2("<div/>", {
      "id": !features.f ? tableId + "_filter" : null,
      "class": classes.sFilter
    }).append($2("<label/>").append(str));
    var searchFn = function(event) {
      var n = features.f;
      var val = !this.value ? "" : this.value;
      if (previousSearch["return"] && event.key !== "Enter") {
        return;
      }
      if (val != previousSearch.sSearch) {
        _fnFilterComplete(settings, {
          "sSearch": val,
          "bRegex": previousSearch.bRegex,
          "bSmart": previousSearch.bSmart,
          "bCaseInsensitive": previousSearch.bCaseInsensitive,
          "return": previousSearch["return"]
        });
        settings._iDisplayStart = 0;
        _fnDraw(settings);
      }
    };
    var searchDelay = settings.searchDelay !== null ? settings.searchDelay : _fnDataSource(settings) === "ssp" ? 400 : 0;
    var jqFilter = $2("input", filter).val(previousSearch.sSearch).attr("placeholder", language.sSearchPlaceholder).on(
      "keyup.DT search.DT input.DT paste.DT cut.DT",
      searchDelay ? _fnThrottle(searchFn, searchDelay) : searchFn
    ).on("mouseup.DT", function(e) {
      setTimeout(function() {
        searchFn.call(jqFilter[0], e);
      }, 10);
    }).on("keypress.DT", function(e) {
      if (e.keyCode == 13) {
        return false;
      }
    }).attr("aria-controls", tableId);
    $2(settings.nTable).on("search.dt.DT", function(ev, s) {
      if (settings === s) {
        try {
          if (jqFilter[0] !== document.activeElement) {
            jqFilter.val(previousSearch.sSearch);
          }
        } catch (e) {
        }
      }
    });
    return filter[0];
  }
  function _fnFilterComplete(oSettings, oInput, iForce) {
    var oPrevSearch = oSettings.oPreviousSearch;
    var aoPrevSearch = oSettings.aoPreSearchCols;
    var fnSaveFilter = function(oFilter) {
      oPrevSearch.sSearch = oFilter.sSearch;
      oPrevSearch.bRegex = oFilter.bRegex;
      oPrevSearch.bSmart = oFilter.bSmart;
      oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
      oPrevSearch["return"] = oFilter["return"];
    };
    var fnRegex = function(o) {
      return o.bEscapeRegex !== void 0 ? !o.bEscapeRegex : o.bRegex;
    };
    _fnColumnTypes(oSettings);
    if (_fnDataSource(oSettings) != "ssp") {
      _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive);
      fnSaveFilter(oInput);
      for (var i = 0; i < aoPrevSearch.length; i++) {
        _fnFilterColumn(
          oSettings,
          aoPrevSearch[i].sSearch,
          i,
          fnRegex(aoPrevSearch[i]),
          aoPrevSearch[i].bSmart,
          aoPrevSearch[i].bCaseInsensitive
        );
      }
      _fnFilterCustom(oSettings);
    } else {
      fnSaveFilter(oInput);
    }
    oSettings.bFiltered = true;
    _fnCallbackFire(oSettings, null, "search", [oSettings]);
  }
  function _fnFilterCustom(settings) {
    var filters = DataTable.ext.search;
    var displayRows = settings.aiDisplay;
    var row, rowIdx;
    for (var i = 0, ien = filters.length; i < ien; i++) {
      var rows = [];
      for (var j = 0, jen = displayRows.length; j < jen; j++) {
        rowIdx = displayRows[j];
        row = settings.aoData[rowIdx];
        if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
          rows.push(rowIdx);
        }
      }
      displayRows.length = 0;
      $2.merge(displayRows, rows);
    }
  }
  function _fnFilterColumn(settings, searchStr, colIdx, regex, smart, caseInsensitive) {
    if (searchStr === "") {
      return;
    }
    var data;
    var out = [];
    var display = settings.aiDisplay;
    var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive);
    for (var i = 0; i < display.length; i++) {
      data = settings.aoData[display[i]]._aFilterData[colIdx];
      if (rpSearch.test(data)) {
        out.push(display[i]);
      }
    }
    settings.aiDisplay = out;
  }
  function _fnFilter(settings, input, force, regex, smart, caseInsensitive) {
    var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive);
    var prevSearch = settings.oPreviousSearch.sSearch;
    var displayMaster = settings.aiDisplayMaster;
    var display, invalidated, i;
    var filtered = [];
    if (DataTable.ext.search.length !== 0) {
      force = true;
    }
    invalidated = _fnFilterData(settings);
    if (input.length <= 0) {
      settings.aiDisplay = displayMaster.slice();
    } else {
      if (invalidated || force || regex || prevSearch.length > input.length || input.indexOf(prevSearch) !== 0 || settings.bSorted) {
        settings.aiDisplay = displayMaster.slice();
      }
      display = settings.aiDisplay;
      for (i = 0; i < display.length; i++) {
        if (rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {
          filtered.push(display[i]);
        }
      }
      settings.aiDisplay = filtered;
    }
  }
  function _fnFilterCreateSearch(search, regex, smart, caseInsensitive) {
    search = regex ? search : _fnEscapeRegex(search);
    if (smart) {
      var a = $2.map(search.match(/["\u201C][^"\u201D]+["\u201D]|[^ ]+/g) || [""], function(word) {
        if (word.charAt(0) === '"') {
          var m = word.match(/^"(.*)"$/);
          word = m ? m[1] : word;
        } else if (word.charAt(0) === "\u201C") {
          var m = word.match(/^\u201C(.*)\u201D$/);
          word = m ? m[1] : word;
        }
        return word.replace('"', "");
      });
      search = "^(?=.*?" + a.join(")(?=.*?") + ").*$";
    }
    return new RegExp(search, caseInsensitive ? "i" : "");
  }
  var _fnEscapeRegex = DataTable.util.escapeRegex;
  var __filter_div = $2("<div>")[0];
  var __filter_div_textContent = __filter_div.textContent !== void 0;
  function _fnFilterData(settings) {
    var columns = settings.aoColumns;
    var column;
    var i, j, ien, jen, filterData, cellData, row;
    var wasInvalidated = false;
    for (i = 0, ien = settings.aoData.length; i < ien; i++) {
      row = settings.aoData[i];
      if (!row._aFilterData) {
        filterData = [];
        for (j = 0, jen = columns.length; j < jen; j++) {
          column = columns[j];
          if (column.bSearchable) {
            cellData = _fnGetCellData(settings, i, j, "filter");
            if (cellData === null) {
              cellData = "";
            }
            if (typeof cellData !== "string" && cellData.toString) {
              cellData = cellData.toString();
            }
          } else {
            cellData = "";
          }
          if (cellData.indexOf && cellData.indexOf("&") !== -1) {
            __filter_div.innerHTML = cellData;
            cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText;
          }
          if (cellData.replace) {
            cellData = cellData.replace(/[\r\n\u2028]/g, "");
          }
          filterData.push(cellData);
        }
        row._aFilterData = filterData;
        row._sFilterRow = filterData.join("  ");
        wasInvalidated = true;
      }
    }
    return wasInvalidated;
  }
  function _fnSearchToCamel(obj) {
    return {
      search: obj.sSearch,
      smart: obj.bSmart,
      regex: obj.bRegex,
      caseInsensitive: obj.bCaseInsensitive
    };
  }
  function _fnSearchToHung(obj) {
    return {
      sSearch: obj.search,
      bSmart: obj.smart,
      bRegex: obj.regex,
      bCaseInsensitive: obj.caseInsensitive
    };
  }
  function _fnFeatureHtmlInfo(settings) {
    var tid = settings.sTableId, nodes = settings.aanFeatures.i, n = $2("<div/>", {
      "class": settings.oClasses.sInfo,
      "id": !nodes ? tid + "_info" : null
    });
    if (!nodes) {
      settings.aoDrawCallback.push({
        "fn": _fnUpdateInfo,
        "sName": "information"
      });
      n.attr("role", "status").attr("aria-live", "polite");
      $2(settings.nTable).attr("aria-describedby", tid + "_info");
    }
    return n[0];
  }
  function _fnUpdateInfo(settings) {
    var nodes = settings.aanFeatures.i;
    if (nodes.length === 0) {
      return;
    }
    var lang = settings.oLanguage, start2 = settings._iDisplayStart + 1, end = settings.fnDisplayEnd(), max = settings.fnRecordsTotal(), total = settings.fnRecordsDisplay(), out = total ? lang.sInfo : lang.sInfoEmpty;
    if (total !== max) {
      out += " " + lang.sInfoFiltered;
    }
    out += lang.sInfoPostFix;
    out = _fnInfoMacros(settings, out);
    var callback = lang.fnInfoCallback;
    if (callback !== null) {
      out = callback.call(
        settings.oInstance,
        settings,
        start2,
        end,
        max,
        total,
        out
      );
    }
    $2(nodes).html(out);
  }
  function _fnInfoMacros(settings, str) {
    var formatter = settings.fnFormatNumber, start2 = settings._iDisplayStart + 1, len = settings._iDisplayLength, vis = settings.fnRecordsDisplay(), all = len === -1;
    return str.replace(/_START_/g, formatter.call(settings, start2)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal())).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start2 / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)));
  }
  function _fnInitialise(settings) {
    var i, iLen, iAjaxStart = settings.iInitDisplayStart;
    var columns = settings.aoColumns, column;
    var features = settings.oFeatures;
    var deferLoading = settings.bDeferLoading;
    if (!settings.bInitialised) {
      setTimeout(function() {
        _fnInitialise(settings);
      }, 200);
      return;
    }
    _fnAddOptionsHtml(settings);
    _fnBuildHead(settings);
    _fnDrawHead(settings, settings.aoHeader);
    _fnDrawHead(settings, settings.aoFooter);
    _fnProcessingDisplay(settings, true);
    if (features.bAutoWidth) {
      _fnCalculateColumnWidths(settings);
    }
    for (i = 0, iLen = columns.length; i < iLen; i++) {
      column = columns[i];
      if (column.sWidth) {
        column.nTh.style.width = _fnStringToCss(column.sWidth);
      }
    }
    _fnCallbackFire(settings, null, "preInit", [settings]);
    _fnReDraw(settings);
    var dataSrc = _fnDataSource(settings);
    if (dataSrc != "ssp" || deferLoading) {
      if (dataSrc == "ajax") {
        _fnBuildAjax(settings, [], function(json) {
          var aData = _fnAjaxDataSrc(settings, json);
          for (i = 0; i < aData.length; i++) {
            _fnAddData(settings, aData[i]);
          }
          settings.iInitDisplayStart = iAjaxStart;
          _fnReDraw(settings);
          _fnProcessingDisplay(settings, false);
          _fnInitComplete(settings, json);
        }, settings);
      } else {
        _fnProcessingDisplay(settings, false);
        _fnInitComplete(settings);
      }
    }
  }
  function _fnInitComplete(settings, json) {
    settings._bInitComplete = true;
    if (json || settings.oInit.aaData) {
      _fnAdjustColumnSizing(settings);
    }
    _fnCallbackFire(settings, null, "plugin-init", [settings, json]);
    _fnCallbackFire(settings, "aoInitComplete", "init", [settings, json]);
  }
  function _fnLengthChange(settings, val) {
    var len = parseInt(val, 10);
    settings._iDisplayLength = len;
    _fnLengthOverflow(settings);
    _fnCallbackFire(settings, null, "length", [settings, len]);
  }
  function _fnFeatureHtmlLength(settings) {
    var classes = settings.oClasses, tableId = settings.sTableId, menu = settings.aLengthMenu, d2 = Array.isArray(menu[0]), lengths = d2 ? menu[0] : menu, language = d2 ? menu[1] : menu;
    var select = $2("<select/>", {
      "name": tableId + "_length",
      "aria-controls": tableId,
      "class": classes.sLengthSelect
    });
    for (var i = 0, ien = lengths.length; i < ien; i++) {
      select[0][i] = new Option(
        typeof language[i] === "number" ? settings.fnFormatNumber(language[i]) : language[i],
        lengths[i]
      );
    }
    var div = $2("<div><label/></div>").addClass(classes.sLength);
    if (!settings.aanFeatures.l) {
      div[0].id = tableId + "_length";
    }
    div.children().append(
      settings.oLanguage.sLengthMenu.replace("_MENU_", select[0].outerHTML)
    );
    $2("select", div).val(settings._iDisplayLength).on("change.DT", function(e) {
      _fnLengthChange(settings, $2(this).val());
      _fnDraw(settings);
    });
    $2(settings.nTable).on("length.dt.DT", function(e, s, len) {
      if (settings === s) {
        $2("select", div).val(len);
      }
    });
    return div[0];
  }
  function _fnFeatureHtmlPaginate(settings) {
    var type = settings.sPaginationType, plugin = DataTable.ext.pager[type], modern = typeof plugin === "function", redraw = function(settings2) {
      _fnDraw(settings2);
    }, node = $2("<div/>").addClass(settings.oClasses.sPaging + type)[0], features = settings.aanFeatures;
    if (!modern) {
      plugin.fnInit(settings, node, redraw);
    }
    if (!features.p) {
      node.id = settings.sTableId + "_paginate";
      settings.aoDrawCallback.push({
        "fn": function(settings2) {
          if (modern) {
            var start2 = settings2._iDisplayStart, len = settings2._iDisplayLength, visRecords = settings2.fnRecordsDisplay(), all = len === -1, page = all ? 0 : Math.ceil(start2 / len), pages = all ? 1 : Math.ceil(visRecords / len), buttons = plugin(page, pages), i, ien;
            for (i = 0, ien = features.p.length; i < ien; i++) {
              _fnRenderer(settings2, "pageButton")(
                settings2,
                features.p[i],
                i,
                buttons,
                page,
                pages
              );
            }
          } else {
            plugin.fnUpdate(settings2, redraw);
          }
        },
        "sName": "pagination"
      });
    }
    return node;
  }
  function _fnPageChange(settings, action, redraw) {
    var start2 = settings._iDisplayStart, len = settings._iDisplayLength, records = settings.fnRecordsDisplay();
    if (records === 0 || len === -1) {
      start2 = 0;
    } else if (typeof action === "number") {
      start2 = action * len;
      if (start2 > records) {
        start2 = 0;
      }
    } else if (action == "first") {
      start2 = 0;
    } else if (action == "previous") {
      start2 = len >= 0 ? start2 - len : 0;
      if (start2 < 0) {
        start2 = 0;
      }
    } else if (action == "next") {
      if (start2 + len < records) {
        start2 += len;
      }
    } else if (action == "last") {
      start2 = Math.floor((records - 1) / len) * len;
    } else {
      _fnLog(settings, 0, "Unknown paging action: " + action, 5);
    }
    var changed = settings._iDisplayStart !== start2;
    settings._iDisplayStart = start2;
    if (changed) {
      _fnCallbackFire(settings, null, "page", [settings]);
      if (redraw) {
        _fnDraw(settings);
      }
    } else {
      _fnCallbackFire(settings, null, "page-nc", [settings]);
    }
    return changed;
  }
  function _fnFeatureHtmlProcessing(settings) {
    return $2("<div/>", {
      "id": !settings.aanFeatures.r ? settings.sTableId + "_processing" : null,
      "class": settings.oClasses.sProcessing,
      "role": "status"
    }).html(settings.oLanguage.sProcessing).append("<div><div></div><div></div><div></div><div></div></div>").insertBefore(settings.nTable)[0];
  }
  function _fnProcessingDisplay(settings, show) {
    if (settings.oFeatures.bProcessing) {
      $2(settings.aanFeatures.r).css("display", show ? "block" : "none");
    }
    _fnCallbackFire(settings, null, "processing", [settings, show]);
  }
  function _fnFeatureHtmlTable(settings) {
    var table = $2(settings.nTable);
    var scroll = settings.oScroll;
    if (scroll.sX === "" && scroll.sY === "") {
      return settings.nTable;
    }
    var scrollX = scroll.sX;
    var scrollY = scroll.sY;
    var classes = settings.oClasses;
    var caption = table.children("caption");
    var captionSide = caption.length ? caption[0]._captionSide : null;
    var headerClone = $2(table[0].cloneNode(false));
    var footerClone = $2(table[0].cloneNode(false));
    var footer = table.children("tfoot");
    var _div = "<div/>";
    var size2 = function(s) {
      return !s ? null : _fnStringToCss(s);
    };
    if (!footer.length) {
      footer = null;
    }
    var scroller = $2(_div, { "class": classes.sScrollWrapper }).append(
      $2(_div, { "class": classes.sScrollHead }).css({
        overflow: "hidden",
        position: "relative",
        border: 0,
        width: scrollX ? size2(scrollX) : "100%"
      }).append(
        $2(_div, { "class": classes.sScrollHeadInner }).css({
          "box-sizing": "content-box",
          width: scroll.sXInner || "100%"
        }).append(
          headerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "top" ? caption : null).append(
            table.children("thead")
          )
        )
      )
    ).append(
      $2(_div, { "class": classes.sScrollBody }).css({
        position: "relative",
        overflow: "auto",
        width: size2(scrollX)
      }).append(table)
    );
    if (footer) {
      scroller.append(
        $2(_div, { "class": classes.sScrollFoot }).css({
          overflow: "hidden",
          border: 0,
          width: scrollX ? size2(scrollX) : "100%"
        }).append(
          $2(_div, { "class": classes.sScrollFootInner }).append(
            footerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "bottom" ? caption : null).append(
              table.children("tfoot")
            )
          )
        )
      );
    }
    var children = scroller.children();
    var scrollHead = children[0];
    var scrollBody = children[1];
    var scrollFoot = footer ? children[2] : null;
    if (scrollX) {
      $2(scrollBody).on("scroll.DT", function(e) {
        var scrollLeft = this.scrollLeft;
        scrollHead.scrollLeft = scrollLeft;
        if (footer) {
          scrollFoot.scrollLeft = scrollLeft;
        }
      });
    }
    $2(scrollBody).css("max-height", scrollY);
    if (!scroll.bCollapse) {
      $2(scrollBody).css("height", scrollY);
    }
    settings.nScrollHead = scrollHead;
    settings.nScrollBody = scrollBody;
    settings.nScrollFoot = scrollFoot;
    settings.aoDrawCallback.push({
      "fn": _fnScrollDraw,
      "sName": "scrolling"
    });
    return scroller[0];
  }
  function _fnScrollDraw(settings) {
    var scroll = settings.oScroll, scrollX = scroll.sX, scrollXInner = scroll.sXInner, scrollY = scroll.sY, barWidth = scroll.iBarWidth, divHeader = $2(settings.nScrollHead), divHeaderStyle = divHeader[0].style, divHeaderInner = divHeader.children("div"), divHeaderInnerStyle = divHeaderInner[0].style, divHeaderTable = divHeaderInner.children("table"), divBodyEl = settings.nScrollBody, divBody = $2(divBodyEl), divBodyStyle = divBodyEl.style, divFooter = $2(settings.nScrollFoot), divFooterInner = divFooter.children("div"), divFooterTable = divFooterInner.children("table"), header = $2(settings.nTHead), table = $2(settings.nTable), tableEl = table[0], tableStyle = tableEl.style, footer = settings.nTFoot ? $2(settings.nTFoot) : null, browser = settings.oBrowser, ie67 = browser.bScrollOversize, dtHeaderCells = _pluck(settings.aoColumns, "nTh"), headerTrgEls, footerTrgEls, headerSrcEls, footerSrcEls, headerCopy, footerCopy, headerWidths = [], footerWidths = [], headerContent = [], footerContent = [], idx, correction, sanityWidth, zeroOut = function(nSizer) {
      var style = nSizer.style;
      style.paddingTop = "0";
      style.paddingBottom = "0";
      style.borderTopWidth = "0";
      style.borderBottomWidth = "0";
      style.height = 0;
    };
    var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
    if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== void 0) {
      settings.scrollBarVis = scrollBarVis;
      _fnAdjustColumnSizing(settings);
      return;
    } else {
      settings.scrollBarVis = scrollBarVis;
    }
    table.children("thead, tfoot").remove();
    if (footer) {
      footerCopy = footer.clone().prependTo(table);
      footerTrgEls = footer.find("tr");
      footerSrcEls = footerCopy.find("tr");
      footerCopy.find("[id]").removeAttr("id");
    }
    headerCopy = header.clone().prependTo(table);
    headerTrgEls = header.find("tr");
    headerSrcEls = headerCopy.find("tr");
    headerCopy.find("th, td").removeAttr("tabindex");
    headerCopy.find("[id]").removeAttr("id");
    if (!scrollX) {
      divBodyStyle.width = "100%";
      divHeader[0].style.width = "100%";
    }
    $2.each(_fnGetUniqueThs(settings, headerCopy), function(i, el) {
      idx = _fnVisibleToColumnIndex(settings, i);
      el.style.width = settings.aoColumns[idx].sWidth;
    });
    if (footer) {
      _fnApplyToChildren(function(n) {
        n.style.width = "";
      }, footerSrcEls);
    }
    sanityWidth = table.outerWidth();
    if (scrollX === "") {
      tableStyle.width = "100%";
      if (ie67 && (table.find("tbody").height() > divBodyEl.offsetHeight || divBody.css("overflow-y") == "scroll")) {
        tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth);
      }
      sanityWidth = table.outerWidth();
    } else if (scrollXInner !== "") {
      tableStyle.width = _fnStringToCss(scrollXInner);
      sanityWidth = table.outerWidth();
    }
    _fnApplyToChildren(zeroOut, headerSrcEls);
    _fnApplyToChildren(function(nSizer) {
      var style = window.getComputedStyle ? window.getComputedStyle(nSizer).width : _fnStringToCss($2(nSizer).width());
      headerContent.push(nSizer.innerHTML);
      headerWidths.push(style);
    }, headerSrcEls);
    _fnApplyToChildren(function(nToSize, i) {
      nToSize.style.width = headerWidths[i];
    }, headerTrgEls);
    $2(headerSrcEls).css("height", 0);
    if (footer) {
      _fnApplyToChildren(zeroOut, footerSrcEls);
      _fnApplyToChildren(function(nSizer) {
        footerContent.push(nSizer.innerHTML);
        footerWidths.push(_fnStringToCss($2(nSizer).css("width")));
      }, footerSrcEls);
      _fnApplyToChildren(function(nToSize, i) {
        nToSize.style.width = footerWidths[i];
      }, footerTrgEls);
      $2(footerSrcEls).height(0);
    }
    _fnApplyToChildren(function(nSizer, i) {
      nSizer.innerHTML = '<div class="dataTables_sizing">' + headerContent[i] + "</div>";
      nSizer.childNodes[0].style.height = "0";
      nSizer.childNodes[0].style.overflow = "hidden";
      nSizer.style.width = headerWidths[i];
    }, headerSrcEls);
    if (footer) {
      _fnApplyToChildren(function(nSizer, i) {
        nSizer.innerHTML = '<div class="dataTables_sizing">' + footerContent[i] + "</div>";
        nSizer.childNodes[0].style.height = "0";
        nSizer.childNodes[0].style.overflow = "hidden";
        nSizer.style.width = footerWidths[i];
      }, footerSrcEls);
    }
    if (Math.round(table.outerWidth()) < Math.round(sanityWidth)) {
      correction = divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css("overflow-y") == "scroll" ? sanityWidth + barWidth : sanityWidth;
      if (ie67 && (divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css("overflow-y") == "scroll")) {
        tableStyle.width = _fnStringToCss(correction - barWidth);
      }
      if (scrollX === "" || scrollXInner !== "") {
        _fnLog(settings, 1, "Possible column misalignment", 6);
      }
    } else {
      correction = "100%";
    }
    divBodyStyle.width = _fnStringToCss(correction);
    divHeaderStyle.width = _fnStringToCss(correction);
    if (footer) {
      settings.nScrollFoot.style.width = _fnStringToCss(correction);
    }
    if (!scrollY) {
      if (ie67) {
        divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth);
      }
    }
    var iOuterWidth = table.outerWidth();
    divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth);
    divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth);
    var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css("overflow-y") == "scroll";
    var padding = "padding" + (browser.bScrollbarLeft ? "Left" : "Right");
    divHeaderInnerStyle[padding] = bScrolling ? barWidth + "px" : "0px";
    if (footer) {
      divFooterTable[0].style.width = _fnStringToCss(iOuterWidth);
      divFooterInner[0].style.width = _fnStringToCss(iOuterWidth);
      divFooterInner[0].style[padding] = bScrolling ? barWidth + "px" : "0px";
    }
    table.children("colgroup").insertBefore(table.children("thead"));
    divBody.trigger("scroll");
    if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
      divBodyEl.scrollTop = 0;
    }
  }
  function _fnApplyToChildren(fn, an1, an2) {
    var index = 0, i = 0, iLen = an1.length;
    var nNode1, nNode2;
    while (i < iLen) {
      nNode1 = an1[i].firstChild;
      nNode2 = an2 ? an2[i].firstChild : null;
      while (nNode1) {
        if (nNode1.nodeType === 1) {
          if (an2) {
            fn(nNode1, nNode2, index);
          } else {
            fn(nNode1, index);
          }
          index++;
        }
        nNode1 = nNode1.nextSibling;
        nNode2 = an2 ? nNode2.nextSibling : null;
      }
      i++;
    }
  }
  var __re_html_remove = /<.*?>/g;
  function _fnCalculateColumnWidths(oSettings) {
    var table = oSettings.nTable, columns = oSettings.aoColumns, scroll = oSettings.oScroll, scrollY = scroll.sY, scrollX = scroll.sX, scrollXInner = scroll.sXInner, columnCount = columns.length, visibleColumns = _fnGetColumns(oSettings, "bVisible"), headerCells = $2("th", oSettings.nTHead), tableWidthAttr = table.getAttribute("width"), tableContainer = table.parentNode, userInputs = false, i, column, columnIdx, width, outerWidth, browser = oSettings.oBrowser, ie67 = browser.bScrollOversize;
    var styleWidth = table.style.width;
    if (styleWidth && styleWidth.indexOf("%") !== -1) {
      tableWidthAttr = styleWidth;
    }
    var sizes = _fnConvertToWidth(_pluck(columns, "sWidthOrig"), tableContainer);
    for (i = 0; i < visibleColumns.length; i++) {
      column = columns[visibleColumns[i]];
      if (column.sWidth !== null) {
        column.sWidth = sizes[i];
        userInputs = true;
      }
    }
    if (ie67 || !userInputs && !scrollX && !scrollY && columnCount == _fnVisbleColumns(oSettings) && columnCount == headerCells.length) {
      for (i = 0; i < columnCount; i++) {
        var colIdx = _fnVisibleToColumnIndex(oSettings, i);
        if (colIdx !== null) {
          columns[colIdx].sWidth = _fnStringToCss(headerCells.eq(i).width());
        }
      }
    } else {
      var tmpTable = $2(table).clone().css("visibility", "hidden").removeAttr("id");
      tmpTable.find("tbody tr").remove();
      var tr = $2("<tr/>").appendTo(tmpTable.find("tbody"));
      tmpTable.find("thead, tfoot").remove();
      tmpTable.append($2(oSettings.nTHead).clone()).append($2(oSettings.nTFoot).clone());
      tmpTable.find("tfoot th, tfoot td").css("width", "");
      headerCells = _fnGetUniqueThs(oSettings, tmpTable.find("thead")[0]);
      for (i = 0; i < visibleColumns.length; i++) {
        column = columns[visibleColumns[i]];
        headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== "" ? _fnStringToCss(column.sWidthOrig) : "";
        if (column.sWidthOrig && scrollX) {
          $2(headerCells[i]).append($2("<div/>").css({
            width: column.sWidthOrig,
            margin: 0,
            padding: 0,
            border: 0,
            height: 1
          }));
        }
      }
      if (oSettings.aoData.length) {
        for (i = 0; i < visibleColumns.length; i++) {
          columnIdx = visibleColumns[i];
          column = columns[columnIdx];
          $2(_fnGetWidestNode(oSettings, columnIdx)).clone(false).append(column.sContentPadding).appendTo(tr);
        }
      }
      $2("[name]", tmpTable).removeAttr("name");
      var holder = $2("<div/>").css(
        scrollX || scrollY ? {
          position: "absolute",
          top: 0,
          left: 0,
          height: 1,
          right: 0,
          overflow: "hidden"
        } : {}
      ).append(tmpTable).appendTo(tableContainer);
      if (scrollX && scrollXInner) {
        tmpTable.width(scrollXInner);
      } else if (scrollX) {
        tmpTable.css("width", "auto");
        tmpTable.removeAttr("width");
        if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
          tmpTable.width(tableContainer.clientWidth);
        }
      } else if (scrollY) {
        tmpTable.width(tableContainer.clientWidth);
      } else if (tableWidthAttr) {
        tmpTable.width(tableWidthAttr);
      }
      var total = 0;
      for (i = 0; i < visibleColumns.length; i++) {
        var cell = $2(headerCells[i]);
        var border = cell.outerWidth() - cell.width();
        var bounding = browser.bBounding ? Math.ceil(headerCells[i].getBoundingClientRect().width) : cell.outerWidth();
        total += bounding;
        columns[visibleColumns[i]].sWidth = _fnStringToCss(bounding - border);
      }
      table.style.width = _fnStringToCss(total);
      holder.remove();
    }
    if (tableWidthAttr) {
      table.style.width = _fnStringToCss(tableWidthAttr);
    }
    if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {
      var bindResize = function() {
        $2(window).on("resize.DT-" + oSettings.sInstance, _fnThrottle(function() {
          _fnAdjustColumnSizing(oSettings);
        }));
      };
      if (ie67) {
        setTimeout(bindResize, 1e3);
      } else {
        bindResize();
      }
      oSettings._reszEvt = true;
    }
  }
  var _fnThrottle = DataTable.util.throttle;
  function _fnConvertToWidth(widths, parent) {
    var els = [];
    var results = [];
    for (var i = 0; i < widths.length; i++) {
      if (widths[i]) {
        els.push(
          $2("<div/>").css("width", _fnStringToCss(widths[i])).appendTo(parent || document.body)
        );
      } else {
        els.push(null);
      }
    }
    for (var i = 0; i < widths.length; i++) {
      results.push(els[i] ? els[i][0].offsetWidth : null);
    }
    $2(els).remove();
    return results;
  }
  function _fnGetWidestNode(settings, colIdx) {
    var idx = _fnGetMaxLenString(settings, colIdx);
    if (idx < 0) {
      return null;
    }
    var data = settings.aoData[idx];
    return !data.nTr ? (
      // Might not have been created when deferred rendering
      $2("<td/>").html(_fnGetCellData(settings, idx, colIdx, "display"))[0]
    ) : data.anCells[colIdx];
  }
  function _fnGetMaxLenString(settings, colIdx) {
    var s, max = -1, maxIdx = -1;
    for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
      s = _fnGetCellData(settings, i, colIdx, "display") + "";
      s = s.replace(__re_html_remove, "");
      s = s.replace(/&nbsp;/g, " ");
      if (s.length > max) {
        max = s.length;
        maxIdx = i;
      }
    }
    return maxIdx;
  }
  function _fnStringToCss(s) {
    if (s === null) {
      return "0px";
    }
    if (typeof s == "number") {
      return s < 0 ? "0px" : s + "px";
    }
    return s.match(/\d$/) ? s + "px" : s;
  }
  function _fnSortFlatten(settings) {
    var i, iLen, k, kLen, aSort = [], aiOrig = [], aoColumns = settings.aoColumns, aDataSort, iCol, sType, srcCol, fixed = settings.aaSortingFixed, fixedObj = $2.isPlainObject(fixed), nestedSort = [], add3 = function(a) {
      if (a.length && !Array.isArray(a[0])) {
        nestedSort.push(a);
      } else {
        $2.merge(nestedSort, a);
      }
    };
    if (Array.isArray(fixed)) {
      add3(fixed);
    }
    if (fixedObj && fixed.pre) {
      add3(fixed.pre);
    }
    add3(settings.aaSorting);
    if (fixedObj && fixed.post) {
      add3(fixed.post);
    }
    for (i = 0; i < nestedSort.length; i++) {
      srcCol = nestedSort[i][0];
      aDataSort = aoColumns[srcCol].aDataSort;
      for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
        iCol = aDataSort[k];
        sType = aoColumns[iCol].sType || "string";
        if (nestedSort[i]._idx === void 0) {
          nestedSort[i]._idx = $2.inArray(nestedSort[i][1], aoColumns[iCol].asSorting);
        }
        aSort.push({
          src: srcCol,
          col: iCol,
          dir: nestedSort[i][1],
          index: nestedSort[i]._idx,
          type: sType,
          formatter: DataTable.ext.type.order[sType + "-pre"]
        });
      }
    }
    return aSort;
  }
  function _fnSort(oSettings) {
    var i, ien, iLen, j, jLen, k, kLen, sDataType, nTh, aiOrig = [], oExtSort = DataTable.ext.type.order, aoData = oSettings.aoData, aoColumns = oSettings.aoColumns, aDataSort, data, iCol, sType, oSort, formatters = 0, sortCol, displayMaster = oSettings.aiDisplayMaster, aSort;
    _fnColumnTypes(oSettings);
    aSort = _fnSortFlatten(oSettings);
    for (i = 0, ien = aSort.length; i < ien; i++) {
      sortCol = aSort[i];
      if (sortCol.formatter) {
        formatters++;
      }
      _fnSortData(oSettings, sortCol.col);
    }
    if (_fnDataSource(oSettings) != "ssp" && aSort.length !== 0) {
      for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
        aiOrig[displayMaster[i]] = i;
      }
      if (formatters === aSort.length) {
        displayMaster.sort(function(a, b) {
          var x, y, k2, test, sort, len = aSort.length, dataA = aoData[a]._aSortData, dataB = aoData[b]._aSortData;
          for (k2 = 0; k2 < len; k2++) {
            sort = aSort[k2];
            x = dataA[sort.col];
            y = dataB[sort.col];
            test = x < y ? -1 : x > y ? 1 : 0;
            if (test !== 0) {
              return sort.dir === "asc" ? test : -test;
            }
          }
          x = aiOrig[a];
          y = aiOrig[b];
          return x < y ? -1 : x > y ? 1 : 0;
        });
      } else {
        displayMaster.sort(function(a, b) {
          var x, y, k2, l, test, sort, fn, len = aSort.length, dataA = aoData[a]._aSortData, dataB = aoData[b]._aSortData;
          for (k2 = 0; k2 < len; k2++) {
            sort = aSort[k2];
            x = dataA[sort.col];
            y = dataB[sort.col];
            fn = oExtSort[sort.type + "-" + sort.dir] || oExtSort["string-" + sort.dir];
            test = fn(x, y);
            if (test !== 0) {
              return test;
            }
          }
          x = aiOrig[a];
          y = aiOrig[b];
          return x < y ? -1 : x > y ? 1 : 0;
        });
      }
    }
    oSettings.bSorted = true;
  }
  function _fnSortAria(settings) {
    var label;
    var nextSort;
    var columns = settings.aoColumns;
    var aSort = _fnSortFlatten(settings);
    var oAria = settings.oLanguage.oAria;
    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      var col = columns[i];
      var asSorting = col.asSorting;
      var sTitle = col.ariaTitle || col.sTitle.replace(/<.*?>/g, "");
      var th = col.nTh;
      th.removeAttribute("aria-sort");
      if (col.bSortable) {
        if (aSort.length > 0 && aSort[0].col == i) {
          th.setAttribute("aria-sort", aSort[0].dir == "asc" ? "ascending" : "descending");
          nextSort = asSorting[aSort[0].index + 1] || asSorting[0];
        } else {
          nextSort = asSorting[0];
        }
        label = sTitle + (nextSort === "asc" ? oAria.sSortAscending : oAria.sSortDescending);
      } else {
        label = sTitle;
      }
      th.setAttribute("aria-label", label);
    }
  }
  function _fnSortListener(settings, colIdx, append, callback) {
    var col = settings.aoColumns[colIdx];
    var sorting = settings.aaSorting;
    var asSorting = col.asSorting;
    var nextSortIdx;
    var next = function(a, overflow) {
      var idx = a._idx;
      if (idx === void 0) {
        idx = $2.inArray(a[1], asSorting);
      }
      return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
    };
    if (typeof sorting[0] === "number") {
      sorting = settings.aaSorting = [sorting];
    }
    if (append && settings.oFeatures.bSortMulti) {
      var sortIdx = $2.inArray(colIdx, _pluck(sorting, "0"));
      if (sortIdx !== -1) {
        nextSortIdx = next(sorting[sortIdx], true);
        if (nextSortIdx === null && sorting.length === 1) {
          nextSortIdx = 0;
        }
        if (nextSortIdx === null) {
          sorting.splice(sortIdx, 1);
        } else {
          sorting[sortIdx][1] = asSorting[nextSortIdx];
          sorting[sortIdx]._idx = nextSortIdx;
        }
      } else {
        sorting.push([colIdx, asSorting[0], 0]);
        sorting[sorting.length - 1]._idx = 0;
      }
    } else if (sorting.length && sorting[0][0] == colIdx) {
      nextSortIdx = next(sorting[0]);
      sorting.length = 1;
      sorting[0][1] = asSorting[nextSortIdx];
      sorting[0]._idx = nextSortIdx;
    } else {
      sorting.length = 0;
      sorting.push([colIdx, asSorting[0]]);
      sorting[0]._idx = 0;
    }
    _fnReDraw(settings);
    if (typeof callback == "function") {
      callback(settings);
    }
  }
  function _fnSortAttachListener(settings, attachTo, colIdx, callback) {
    var col = settings.aoColumns[colIdx];
    _fnBindAction(attachTo, {}, function(e) {
      if (col.bSortable === false) {
        return;
      }
      if (settings.oFeatures.bProcessing) {
        _fnProcessingDisplay(settings, true);
        setTimeout(function() {
          _fnSortListener(settings, colIdx, e.shiftKey, callback);
          if (_fnDataSource(settings) !== "ssp") {
            _fnProcessingDisplay(settings, false);
          }
        }, 0);
      } else {
        _fnSortListener(settings, colIdx, e.shiftKey, callback);
      }
    });
  }
  function _fnSortingClasses(settings) {
    var oldSort = settings.aLastSort;
    var sortClass = settings.oClasses.sSortColumn;
    var sort = _fnSortFlatten(settings);
    var features = settings.oFeatures;
    var i, ien, colIdx;
    if (features.bSort && features.bSortClasses) {
      for (i = 0, ien = oldSort.length; i < ien; i++) {
        colIdx = oldSort[i].src;
        $2(_pluck(settings.aoData, "anCells", colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
      }
      for (i = 0, ien = sort.length; i < ien; i++) {
        colIdx = sort[i].src;
        $2(_pluck(settings.aoData, "anCells", colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
      }
    }
    settings.aLastSort = sort;
  }
  function _fnSortData(settings, idx) {
    var column = settings.aoColumns[idx];
    var customSort = DataTable.ext.order[column.sSortDataType];
    var customData;
    if (customSort) {
      customData = customSort.call(
        settings.oInstance,
        settings,
        idx,
        _fnColumnIndexToVisible(settings, idx)
      );
    }
    var row, cellData;
    var formatter = DataTable.ext.type.order[column.sType + "-pre"];
    for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
      row = settings.aoData[i];
      if (!row._aSortData) {
        row._aSortData = [];
      }
      if (!row._aSortData[idx] || customSort) {
        cellData = customSort ? customData[i] : (
          // If there was a custom sort function, use data from there
          _fnGetCellData(settings, i, idx, "sort")
        );
        row._aSortData[idx] = formatter ? formatter(cellData) : cellData;
      }
    }
  }
  function _fnSaveState(settings) {
    if (settings._bLoadingState) {
      return;
    }
    var state = {
      time: +/* @__PURE__ */ new Date(),
      start: settings._iDisplayStart,
      length: settings._iDisplayLength,
      order: $2.extend(true, [], settings.aaSorting),
      search: _fnSearchToCamel(settings.oPreviousSearch),
      columns: $2.map(settings.aoColumns, function(col, i) {
        return {
          visible: col.bVisible,
          search: _fnSearchToCamel(settings.aoPreSearchCols[i])
        };
      })
    };
    settings.oSavedState = state;
    _fnCallbackFire(settings, "aoStateSaveParams", "stateSaveParams", [settings, state]);
    if (settings.oFeatures.bStateSave && !settings.bDestroying) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
    }
  }
  function _fnLoadState(settings, oInit, callback) {
    if (!settings.oFeatures.bStateSave) {
      callback();
      return;
    }
    var loaded = function(state2) {
      _fnImplementState(settings, state2, callback);
    };
    var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);
    if (state !== void 0) {
      _fnImplementState(settings, state, callback);
    }
    return true;
  }
  function _fnImplementState(settings, s, callback) {
    var i, ien;
    var columns = settings.aoColumns;
    settings._bLoadingState = true;
    var api = settings._bInitComplete ? new DataTable.Api(settings) : null;
    if (!s || !s.time) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var abStateLoad = _fnCallbackFire(settings, "aoStateLoadParams", "stateLoadParams", [settings, s]);
    if ($2.inArray(false, abStateLoad) !== -1) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var duration = settings.iStateDuration;
    if (duration > 0 && s.time < +/* @__PURE__ */ new Date() - duration * 1e3) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    if (s.columns && columns.length !== s.columns.length) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    settings.oLoadedState = $2.extend(true, {}, s);
    if (s.length !== void 0) {
      if (api) {
        api.page.len(s.length);
      } else {
        settings._iDisplayLength = s.length;
      }
    }
    if (s.start !== void 0) {
      if (api === null) {
        settings._iDisplayStart = s.start;
        settings.iInitDisplayStart = s.start;
      } else {
        _fnPageChange(settings, s.start / settings._iDisplayLength);
      }
    }
    if (s.order !== void 0) {
      settings.aaSorting = [];
      $2.each(s.order, function(i2, col2) {
        settings.aaSorting.push(
          col2[0] >= columns.length ? [0, col2[1]] : col2
        );
      });
    }
    if (s.search !== void 0) {
      $2.extend(settings.oPreviousSearch, _fnSearchToHung(s.search));
    }
    if (s.columns) {
      for (i = 0, ien = s.columns.length; i < ien; i++) {
        var col = s.columns[i];
        if (col.visible !== void 0) {
          if (api) {
            api.column(i).visible(col.visible, false);
          } else {
            columns[i].bVisible = col.visible;
          }
        }
        if (col.search !== void 0) {
          $2.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search));
        }
      }
      if (api) {
        api.columns.adjust();
      }
    }
    settings._bLoadingState = false;
    _fnCallbackFire(settings, "aoStateLoaded", "stateLoaded", [settings, s]);
    callback();
  }
  function _fnSettingsFromNode(table) {
    var settings = DataTable.settings;
    var idx = $2.inArray(table, _pluck(settings, "nTable"));
    return idx !== -1 ? settings[idx] : null;
  }
  function _fnLog(settings, level, msg, tn) {
    msg = "DataTables warning: " + (settings ? "table id=" + settings.sTableId + " - " : "") + msg;
    if (tn) {
      msg += ". For more information about this error, please see https://datatables.net/tn/" + tn;
    }
    if (!level) {
      var ext = DataTable.ext;
      var type = ext.sErrMode || ext.errMode;
      if (settings) {
        _fnCallbackFire(settings, null, "error", [settings, tn, msg]);
      }
      if (type == "alert") {
        alert(msg);
      } else if (type == "throw") {
        throw new Error(msg);
      } else if (typeof type == "function") {
        type(settings, tn, msg);
      }
    } else if (window.console && console.log) {
      console.log(msg);
    }
  }
  function _fnMap(ret, src, name, mappedName) {
    if (Array.isArray(name)) {
      $2.each(name, function(i, val) {
        if (Array.isArray(val)) {
          _fnMap(ret, src, val[0], val[1]);
        } else {
          _fnMap(ret, src, val);
        }
      });
      return;
    }
    if (mappedName === void 0) {
      mappedName = name;
    }
    if (src[name] !== void 0) {
      ret[mappedName] = src[name];
    }
  }
  function _fnExtend(out, extender, breakRefs) {
    var val;
    for (var prop in extender) {
      if (extender.hasOwnProperty(prop)) {
        val = extender[prop];
        if ($2.isPlainObject(val)) {
          if (!$2.isPlainObject(out[prop])) {
            out[prop] = {};
          }
          $2.extend(true, out[prop], val);
        } else if (breakRefs && prop !== "data" && prop !== "aaData" && Array.isArray(val)) {
          out[prop] = val.slice();
        } else {
          out[prop] = val;
        }
      }
    }
    return out;
  }
  function _fnBindAction(n, oData, fn) {
    $2(n).on("click.DT", oData, function(e) {
      $2(n).trigger("blur");
      fn(e);
    }).on("keypress.DT", oData, function(e) {
      if (e.which === 13) {
        e.preventDefault();
        fn(e);
      }
    }).on("selectstart.DT", function() {
      return false;
    });
  }
  function _fnCallbackReg(oSettings, sStore, fn, sName) {
    if (fn) {
      oSettings[sStore].push({
        "fn": fn,
        "sName": sName
      });
    }
  }
  function _fnCallbackFire(settings, callbackArr, eventName, args) {
    var ret = [];
    if (callbackArr) {
      ret = $2.map(settings[callbackArr].slice().reverse(), function(val, i) {
        return val.fn.apply(settings.oInstance, args);
      });
    }
    if (eventName !== null) {
      var e = $2.Event(eventName + ".dt");
      var table = $2(settings.nTable);
      table.trigger(e, args);
      if (table.parents("body").length === 0) {
        $2("body").trigger(e, args);
      }
      ret.push(e.result);
    }
    return ret;
  }
  function _fnLengthOverflow(settings) {
    var start2 = settings._iDisplayStart, end = settings.fnDisplayEnd(), len = settings._iDisplayLength;
    if (start2 >= end) {
      start2 = end - len;
    }
    start2 -= start2 % len;
    if (len === -1 || start2 < 0) {
      start2 = 0;
    }
    settings._iDisplayStart = start2;
  }
  function _fnRenderer(settings, type) {
    var renderer2 = settings.renderer;
    var host = DataTable.ext.renderer[type];
    if ($2.isPlainObject(renderer2) && renderer2[type]) {
      return host[renderer2[type]] || host._;
    } else if (typeof renderer2 === "string") {
      return host[renderer2] || host._;
    }
    return host._;
  }
  function _fnDataSource(settings) {
    if (settings.oFeatures.bServerSide) {
      return "ssp";
    } else if (settings.ajax || settings.sAjaxSource) {
      return "ajax";
    }
    return "dom";
  }
  var __apiStruct = [];
  var __arrayProto = Array.prototype;
  var _toSettings = function(mixed) {
    var idx, jq;
    var settings = DataTable.settings;
    var tables = $2.map(settings, function(el, i) {
      return el.nTable;
    });
    if (!mixed) {
      return [];
    } else if (mixed.nTable && mixed.oApi) {
      return [mixed];
    } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === "table") {
      idx = $2.inArray(mixed, tables);
      return idx !== -1 ? [settings[idx]] : null;
    } else if (mixed && typeof mixed.settings === "function") {
      return mixed.settings().toArray();
    } else if (typeof mixed === "string") {
      jq = $2(mixed);
    } else if (mixed instanceof $2) {
      jq = mixed;
    }
    if (jq) {
      return jq.map(function(i) {
        idx = $2.inArray(this, tables);
        return idx !== -1 ? settings[idx] : null;
      }).toArray();
    }
  };
  _Api = function(context, data) {
    if (!(this instanceof _Api)) {
      return new _Api(context, data);
    }
    var settings = [];
    var ctxSettings = function(o) {
      var a = _toSettings(o);
      if (a) {
        settings.push.apply(settings, a);
      }
    };
    if (Array.isArray(context)) {
      for (var i = 0, ien = context.length; i < ien; i++) {
        ctxSettings(context[i]);
      }
    } else {
      ctxSettings(context);
    }
    this.context = _unique(settings);
    if (data) {
      $2.merge(this, data);
    }
    this.selector = {
      rows: null,
      cols: null,
      opts: null
    };
    _Api.extend(this, this, __apiStruct);
  };
  DataTable.Api = _Api;
  $2.extend(_Api.prototype, {
    any: function() {
      return this.count() !== 0;
    },
    concat: __arrayProto.concat,
    context: [],
    // array of table settings objects
    count: function() {
      return this.flatten().length;
    },
    each: function(fn) {
      for (var i = 0, ien = this.length; i < ien; i++) {
        fn.call(this, this[i], i, this);
      }
      return this;
    },
    eq: function(idx) {
      var ctx = this.context;
      return ctx.length > idx ? new _Api(ctx[idx], this[idx]) : null;
    },
    filter: function(fn) {
      var a = [];
      if (__arrayProto.filter) {
        a = __arrayProto.filter.call(this, fn, this);
      } else {
        for (var i = 0, ien = this.length; i < ien; i++) {
          if (fn.call(this, this[i], i, this)) {
            a.push(this[i]);
          }
        }
      }
      return new _Api(this.context, a);
    },
    flatten: function() {
      var a = [];
      return new _Api(this.context, a.concat.apply(a, this.toArray()));
    },
    join: __arrayProto.join,
    indexOf: __arrayProto.indexOf || function(obj, start2) {
      for (var i = start2 || 0, ien = this.length; i < ien; i++) {
        if (this[i] === obj) {
          return i;
        }
      }
      return -1;
    },
    iterator: function(flatten2, type, fn, alwaysNew) {
      var a = [], ret, i, ien, j, jen, context = this.context, rows, items, item, selector = this.selector;
      if (typeof flatten2 === "string") {
        alwaysNew = fn;
        fn = type;
        type = flatten2;
        flatten2 = false;
      }
      for (i = 0, ien = context.length; i < ien; i++) {
        var apiInst = new _Api(context[i]);
        if (type === "table") {
          ret = fn.call(apiInst, context[i], i);
          if (ret !== void 0) {
            a.push(ret);
          }
        } else if (type === "columns" || type === "rows") {
          ret = fn.call(apiInst, context[i], this[i], i);
          if (ret !== void 0) {
            a.push(ret);
          }
        } else if (type === "column" || type === "column-rows" || type === "row" || type === "cell") {
          items = this[i];
          if (type === "column-rows") {
            rows = _selector_row_indexes(context[i], selector.opts);
          }
          for (j = 0, jen = items.length; j < jen; j++) {
            item = items[j];
            if (type === "cell") {
              ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
            } else {
              ret = fn.call(apiInst, context[i], item, i, j, rows);
            }
            if (ret !== void 0) {
              a.push(ret);
            }
          }
        }
      }
      if (a.length || alwaysNew) {
        var api = new _Api(context, flatten2 ? a.concat.apply([], a) : a);
        var apiSelector = api.selector;
        apiSelector.rows = selector.rows;
        apiSelector.cols = selector.cols;
        apiSelector.opts = selector.opts;
        return api;
      }
      return this;
    },
    lastIndexOf: __arrayProto.lastIndexOf || function(obj, start2) {
      return this.indexOf.apply(this.toArray.reverse(), arguments);
    },
    length: 0,
    map: function(fn) {
      var a = [];
      if (__arrayProto.map) {
        a = __arrayProto.map.call(this, fn, this);
      } else {
        for (var i = 0, ien = this.length; i < ien; i++) {
          a.push(fn.call(this, this[i], i));
        }
      }
      return new _Api(this.context, a);
    },
    pluck: function(prop) {
      var fn = DataTable.util.get(prop);
      return this.map(function(el) {
        return fn(el);
      });
    },
    pop: __arrayProto.pop,
    push: __arrayProto.push,
    // Does not return an API instance
    reduce: __arrayProto.reduce || function(fn, init) {
      return _fnReduce(this, fn, init, 0, this.length, 1);
    },
    reduceRight: __arrayProto.reduceRight || function(fn, init) {
      return _fnReduce(this, fn, init, this.length - 1, -1, -1);
    },
    reverse: __arrayProto.reverse,
    // Object with rows, columns and opts
    selector: null,
    shift: __arrayProto.shift,
    slice: function() {
      return new _Api(this.context, this);
    },
    sort: __arrayProto.sort,
    // ? name - order?
    splice: __arrayProto.splice,
    toArray: function() {
      return __arrayProto.slice.call(this);
    },
    to$: function() {
      return $2(this);
    },
    toJQuery: function() {
      return $2(this);
    },
    unique: function() {
      return new _Api(this.context, _unique(this));
    },
    unshift: __arrayProto.unshift
  });
  _Api.extend = function(scope, obj, ext) {
    if (!ext.length || !obj || !(obj instanceof _Api) && !obj.__dt_wrapper) {
      return;
    }
    var i, ien, struct, methodScoping = function(scope2, fn, struc) {
      return function() {
        var ret = fn.apply(scope2, arguments);
        _Api.extend(ret, ret, struc.methodExt);
        return ret;
      };
    };
    for (i = 0, ien = ext.length; i < ien; i++) {
      struct = ext[i];
      obj[struct.name] = struct.type === "function" ? methodScoping(scope, struct.val, struct) : struct.type === "object" ? {} : struct.val;
      obj[struct.name].__dt_wrapper = true;
      _Api.extend(scope, obj[struct.name], struct.propExt);
    }
  };
  _Api.register = _api_register = function(name, val) {
    if (Array.isArray(name)) {
      for (var j = 0, jen = name.length; j < jen; j++) {
        _Api.register(name[j], val);
      }
      return;
    }
    var i, ien, heir = name.split("."), struct = __apiStruct, key, method;
    var find = function(src2, name2) {
      for (var i2 = 0, ien2 = src2.length; i2 < ien2; i2++) {
        if (src2[i2].name === name2) {
          return src2[i2];
        }
      }
      return null;
    };
    for (i = 0, ien = heir.length; i < ien; i++) {
      method = heir[i].indexOf("()") !== -1;
      key = method ? heir[i].replace("()", "") : heir[i];
      var src = find(struct, key);
      if (!src) {
        src = {
          name: key,
          val: {},
          methodExt: [],
          propExt: [],
          type: "object"
        };
        struct.push(src);
      }
      if (i === ien - 1) {
        src.val = val;
        src.type = typeof val === "function" ? "function" : $2.isPlainObject(val) ? "object" : "other";
      } else {
        struct = method ? src.methodExt : src.propExt;
      }
    }
  };
  _Api.registerPlural = _api_registerPlural = function(pluralName, singularName, val) {
    _Api.register(pluralName, val);
    _Api.register(singularName, function() {
      var ret = val.apply(this, arguments);
      if (ret === this) {
        return this;
      } else if (ret instanceof _Api) {
        return ret.length ? Array.isArray(ret[0]) ? new _Api(ret.context, ret[0]) : (
          // Array results are 'enhanced'
          ret[0]
        ) : void 0;
      }
      return ret;
    });
  };
  var __table_selector = function(selector, a) {
    if (Array.isArray(selector)) {
      return $2.map(selector, function(item) {
        return __table_selector(item, a);
      });
    }
    if (typeof selector === "number") {
      return [a[selector]];
    }
    var nodes = $2.map(a, function(el, i) {
      return el.nTable;
    });
    return $2(nodes).filter(selector).map(function(i) {
      var idx = $2.inArray(this, nodes);
      return a[idx];
    }).toArray();
  };
  _api_register("tables()", function(selector) {
    return selector !== void 0 && selector !== null ? new _Api(__table_selector(selector, this.context)) : this;
  });
  _api_register("table()", function(selector) {
    var tables = this.tables(selector);
    var ctx = tables.context;
    return ctx.length ? new _Api(ctx[0]) : tables;
  });
  _api_registerPlural("tables().nodes()", "table().node()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTable;
    }, 1);
  });
  _api_registerPlural("tables().body()", "table().body()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTBody;
    }, 1);
  });
  _api_registerPlural("tables().header()", "table().header()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTHead;
    }, 1);
  });
  _api_registerPlural("tables().footer()", "table().footer()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTFoot;
    }, 1);
  });
  _api_registerPlural("tables().containers()", "table().container()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTableWrapper;
    }, 1);
  });
  _api_register("draw()", function(paging) {
    return this.iterator("table", function(settings) {
      if (paging === "page") {
        _fnDraw(settings);
      } else {
        if (typeof paging === "string") {
          paging = paging === "full-hold" ? false : true;
        }
        _fnReDraw(settings, paging === false);
      }
    });
  });
  _api_register("page()", function(action) {
    if (action === void 0) {
      return this.page.info().page;
    }
    return this.iterator("table", function(settings) {
      _fnPageChange(settings, action);
    });
  });
  _api_register("page.info()", function(action) {
    if (this.context.length === 0) {
      return void 0;
    }
    var settings = this.context[0], start2 = settings._iDisplayStart, len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1, visRecords = settings.fnRecordsDisplay(), all = len === -1;
    return {
      "page": all ? 0 : Math.floor(start2 / len),
      "pages": all ? 1 : Math.ceil(visRecords / len),
      "start": start2,
      "end": settings.fnDisplayEnd(),
      "length": len,
      "recordsTotal": settings.fnRecordsTotal(),
      "recordsDisplay": visRecords,
      "serverSide": _fnDataSource(settings) === "ssp"
    };
  });
  _api_register("page.len()", function(len) {
    if (len === void 0) {
      return this.context.length !== 0 ? this.context[0]._iDisplayLength : void 0;
    }
    return this.iterator("table", function(settings) {
      _fnLengthChange(settings, len);
    });
  });
  var __reload = function(settings, holdPosition, callback) {
    if (callback) {
      var api = new _Api(settings);
      api.one("draw", function() {
        callback(api.ajax.json());
      });
    }
    if (_fnDataSource(settings) == "ssp") {
      _fnReDraw(settings, holdPosition);
    } else {
      _fnProcessingDisplay(settings, true);
      var xhr = settings.jqXHR;
      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      }
      _fnBuildAjax(settings, [], function(json) {
        _fnClearTable(settings);
        var data = _fnAjaxDataSrc(settings, json);
        for (var i = 0, ien = data.length; i < ien; i++) {
          _fnAddData(settings, data[i]);
        }
        _fnReDraw(settings, holdPosition);
        _fnProcessingDisplay(settings, false);
      });
    }
  };
  _api_register("ajax.json()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].json;
    }
  });
  _api_register("ajax.params()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].oAjaxData;
    }
  });
  _api_register("ajax.reload()", function(callback, resetPaging) {
    return this.iterator("table", function(settings) {
      __reload(settings, resetPaging === false, callback);
    });
  });
  _api_register("ajax.url()", function(url) {
    var ctx = this.context;
    if (url === void 0) {
      if (ctx.length === 0) {
        return void 0;
      }
      ctx = ctx[0];
      return ctx.ajax ? $2.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax : ctx.sAjaxSource;
    }
    return this.iterator("table", function(settings) {
      if ($2.isPlainObject(settings.ajax)) {
        settings.ajax.url = url;
      } else {
        settings.ajax = url;
      }
    });
  });
  _api_register("ajax.url().load()", function(callback, resetPaging) {
    return this.iterator("table", function(ctx) {
      __reload(ctx, resetPaging === false, callback);
    });
  });
  var _selector_run = function(type, selector, selectFn, settings, opts) {
    var out = [], res, a, i, ien, j, jen, selectorType = typeof selector;
    if (!selector || selectorType === "string" || selectorType === "function" || selector.length === void 0) {
      selector = [selector];
    }
    for (i = 0, ien = selector.length; i < ien; i++) {
      a = selector[i] && selector[i].split && !selector[i].match(/[\[\(:]/) ? selector[i].split(",") : [selector[i]];
      for (j = 0, jen = a.length; j < jen; j++) {
        res = selectFn(typeof a[j] === "string" ? a[j].trim() : a[j]);
        if (res && res.length) {
          out = out.concat(res);
        }
      }
    }
    var ext = _ext.selector[type];
    if (ext.length) {
      for (i = 0, ien = ext.length; i < ien; i++) {
        out = ext[i](settings, opts, out);
      }
    }
    return _unique(out);
  };
  var _selector_opts = function(opts) {
    if (!opts) {
      opts = {};
    }
    if (opts.filter && opts.search === void 0) {
      opts.search = opts.filter;
    }
    return $2.extend({
      search: "none",
      order: "current",
      page: "all"
    }, opts);
  };
  var _selector_first = function(inst) {
    for (var i = 0, ien = inst.length; i < ien; i++) {
      if (inst[i].length > 0) {
        inst[0] = inst[i];
        inst[0].length = 1;
        inst.length = 1;
        inst.context = [inst.context[i]];
        return inst;
      }
    }
    inst.length = 0;
    return inst;
  };
  var _selector_row_indexes = function(settings, opts) {
    var i, ien, tmp, a = [], displayFiltered = settings.aiDisplay, displayMaster = settings.aiDisplayMaster;
    var search = opts.search, order = opts.order, page = opts.page;
    if (_fnDataSource(settings) == "ssp") {
      return search === "removed" ? [] : _range(0, displayMaster.length);
    } else if (page == "current") {
      for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
        a.push(displayFiltered[i]);
      }
    } else if (order == "current" || order == "applied") {
      if (search == "none") {
        a = displayMaster.slice();
      } else if (search == "applied") {
        a = displayFiltered.slice();
      } else if (search == "removed") {
        var displayFilteredMap = {};
        for (var i = 0, ien = displayFiltered.length; i < ien; i++) {
          displayFilteredMap[displayFiltered[i]] = null;
        }
        a = $2.map(displayMaster, function(el) {
          return !displayFilteredMap.hasOwnProperty(el) ? el : null;
        });
      }
    } else if (order == "index" || order == "original") {
      for (i = 0, ien = settings.aoData.length; i < ien; i++) {
        if (search == "none") {
          a.push(i);
        } else {
          tmp = $2.inArray(i, displayFiltered);
          if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
            a.push(i);
          }
        }
      }
    }
    return a;
  };
  var __row_selector = function(settings, selector, opts) {
    var rows;
    var run = function(sel) {
      var selInt = _intVal(sel);
      var i, ien;
      var aoData = settings.aoData;
      if (selInt !== null && !opts) {
        return [selInt];
      }
      if (!rows) {
        rows = _selector_row_indexes(settings, opts);
      }
      if (selInt !== null && $2.inArray(selInt, rows) !== -1) {
        return [selInt];
      } else if (sel === null || sel === void 0 || sel === "") {
        return rows;
      }
      if (typeof sel === "function") {
        return $2.map(rows, function(idx) {
          var row = aoData[idx];
          return sel(idx, row._aData, row.nTr) ? idx : null;
        });
      }
      if (sel.nodeName) {
        var rowIdx = sel._DT_RowIndex;
        var cellIdx = sel._DT_CellIndex;
        if (rowIdx !== void 0) {
          return aoData[rowIdx] && aoData[rowIdx].nTr === sel ? [rowIdx] : [];
        } else if (cellIdx) {
          return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel.parentNode ? [cellIdx.row] : [];
        } else {
          var host = $2(sel).closest("*[data-dt-row]");
          return host.length ? [host.data("dt-row")] : [];
        }
      }
      if (typeof sel === "string" && sel.charAt(0) === "#") {
        var rowObj = settings.aIds[sel.replace(/^#/, "")];
        if (rowObj !== void 0) {
          return [rowObj.idx];
        }
      }
      var nodes = _removeEmpty(
        _pluck_order(settings.aoData, rows, "nTr")
      );
      return $2(nodes).filter(sel).map(function() {
        return this._DT_RowIndex;
      }).toArray();
    };
    return _selector_run("row", selector, run, settings, opts);
  };
  _api_register("rows()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($2.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts(opts);
    var inst = this.iterator("table", function(settings) {
      return __row_selector(settings, selector, opts);
    }, 1);
    inst.selector.rows = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_register("rows().nodes()", function() {
    return this.iterator("row", function(settings, row) {
      return settings.aoData[row].nTr || void 0;
    }, 1);
  });
  _api_register("rows().data()", function() {
    return this.iterator(true, "rows", function(settings, rows) {
      return _pluck_order(settings.aoData, rows, "_aData");
    }, 1);
  });
  _api_registerPlural("rows().cache()", "row().cache()", function(type) {
    return this.iterator("row", function(settings, row) {
      var r = settings.aoData[row];
      return type === "search" ? r._aFilterData : r._aSortData;
    }, 1);
  });
  _api_registerPlural("rows().invalidate()", "row().invalidate()", function(src) {
    return this.iterator("row", function(settings, row) {
      _fnInvalidate(settings, row, src);
    });
  });
  _api_registerPlural("rows().indexes()", "row().index()", function() {
    return this.iterator("row", function(settings, row) {
      return row;
    }, 1);
  });
  _api_registerPlural("rows().ids()", "row().id()", function(hash) {
    var a = [];
    var context = this.context;
    for (var i = 0, ien = context.length; i < ien; i++) {
      for (var j = 0, jen = this[i].length; j < jen; j++) {
        var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
        a.push((hash === true ? "#" : "") + id);
      }
    }
    return new _Api(context, a);
  });
  _api_registerPlural("rows().remove()", "row().remove()", function() {
    var that = this;
    this.iterator("row", function(settings, row, thatIdx) {
      var data = settings.aoData;
      var rowData = data[row];
      var i, ien, j, jen;
      var loopRow, loopCells;
      data.splice(row, 1);
      for (i = 0, ien = data.length; i < ien; i++) {
        loopRow = data[i];
        loopCells = loopRow.anCells;
        if (loopRow.nTr !== null) {
          loopRow.nTr._DT_RowIndex = i;
        }
        if (loopCells !== null) {
          for (j = 0, jen = loopCells.length; j < jen; j++) {
            loopCells[j]._DT_CellIndex.row = i;
          }
        }
      }
      _fnDeleteIndex(settings.aiDisplayMaster, row);
      _fnDeleteIndex(settings.aiDisplay, row);
      _fnDeleteIndex(that[thatIdx], row, false);
      if (settings._iRecordsDisplay > 0) {
        settings._iRecordsDisplay--;
      }
      _fnLengthOverflow(settings);
      var id = settings.rowIdFn(rowData._aData);
      if (id !== void 0) {
        delete settings.aIds[id];
      }
    });
    this.iterator("table", function(settings) {
      for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
        settings.aoData[i].idx = i;
      }
    });
    return this;
  });
  _api_register("rows.add()", function(rows) {
    var newRows = this.iterator("table", function(settings) {
      var row, i, ien;
      var out = [];
      for (i = 0, ien = rows.length; i < ien; i++) {
        row = rows[i];
        if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
          out.push(_fnAddTr(settings, row)[0]);
        } else {
          out.push(_fnAddData(settings, row));
        }
      }
      return out;
    }, 1);
    var modRows = this.rows(-1);
    modRows.pop();
    $2.merge(modRows, newRows);
    return modRows;
  });
  _api_register("row()", function(selector, opts) {
    return _selector_first(this.rows(selector, opts));
  });
  _api_register("row().data()", function(data) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length ? ctx[0].aoData[this[0]]._aData : void 0;
    }
    var row = ctx[0].aoData[this[0]];
    row._aData = data;
    if (Array.isArray(data) && row.nTr && row.nTr.id) {
      _fnSetObjectDataFn(ctx[0].rowId)(data, row.nTr.id);
    }
    _fnInvalidate(ctx[0], this[0], "data");
    return this;
  });
  _api_register("row().node()", function() {
    var ctx = this.context;
    return ctx.length && this.length ? ctx[0].aoData[this[0]].nTr || null : null;
  });
  _api_register("row.add()", function(row) {
    if (row instanceof $2 && row.length) {
      row = row[0];
    }
    var rows = this.iterator("table", function(settings) {
      if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
        return _fnAddTr(settings, row)[0];
      }
      return _fnAddData(settings, row);
    });
    return this.row(rows[0]);
  });
  $2(document).on("plugin-init.dt", function(e, context) {
    var api = new _Api(context);
    var namespace = "on-plugin-init";
    var stateSaveParamsEvent = "stateSaveParams." + namespace;
    var destroyEvent = "destroy. " + namespace;
    api.on(stateSaveParamsEvent, function(e2, settings, d) {
      var idFn = settings.rowIdFn;
      var data = settings.aoData;
      var ids = [];
      for (var i = 0; i < data.length; i++) {
        if (data[i]._detailsShow) {
          ids.push("#" + idFn(data[i]._aData));
        }
      }
      d.childRows = ids;
    });
    api.on(destroyEvent, function() {
      api.off(stateSaveParamsEvent + " " + destroyEvent);
    });
    var loaded = api.state.loaded();
    if (loaded && loaded.childRows) {
      api.rows($2.map(loaded.childRows, function(id) {
        return id.replace(/:/g, "\\:");
      })).every(function() {
        _fnCallbackFire(context, null, "requestChild", [this]);
      });
    }
  });
  var __details_add = function(ctx, row, data, klass) {
    var rows = [];
    var addRow = function(r, k) {
      if (Array.isArray(r) || r instanceof $2) {
        for (var i = 0, ien = r.length; i < ien; i++) {
          addRow(r[i], k);
        }
        return;
      }
      if (r.nodeName && r.nodeName.toLowerCase() === "tr") {
        rows.push(r);
      } else {
        var created = $2("<tr><td></td></tr>").addClass(k);
        $2("td", created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns(ctx);
        rows.push(created[0]);
      }
    };
    addRow(data, klass);
    if (row._details) {
      row._details.detach();
    }
    row._details = $2(rows);
    if (row._detailsShow) {
      row._details.insertAfter(row.nTr);
    }
  };
  var __details_state = DataTable.util.throttle(
    function(ctx) {
      _fnSaveState(ctx[0]);
    },
    500
  );
  var __details_remove = function(api, idx) {
    var ctx = api.context;
    if (ctx.length) {
      var row = ctx[0].aoData[idx !== void 0 ? idx : api[0]];
      if (row && row._details) {
        row._details.remove();
        row._detailsShow = void 0;
        row._details = void 0;
        $2(row.nTr).removeClass("dt-hasChild");
        __details_state(ctx);
      }
    }
  };
  var __details_display = function(api, show) {
    var ctx = api.context;
    if (ctx.length && api.length) {
      var row = ctx[0].aoData[api[0]];
      if (row._details) {
        row._detailsShow = show;
        if (show) {
          row._details.insertAfter(row.nTr);
          $2(row.nTr).addClass("dt-hasChild");
        } else {
          row._details.detach();
          $2(row.nTr).removeClass("dt-hasChild");
        }
        _fnCallbackFire(ctx[0], null, "childRow", [show, api.row(api[0])]);
        __details_events(ctx[0]);
        __details_state(ctx);
      }
    }
  };
  var __details_events = function(settings) {
    var api = new _Api(settings);
    var namespace = ".dt.DT_details";
    var drawEvent = "draw" + namespace;
    var colvisEvent = "column-sizing" + namespace;
    var destroyEvent = "destroy" + namespace;
    var data = settings.aoData;
    api.off(drawEvent + " " + colvisEvent + " " + destroyEvent);
    if (_pluck(data, "_details").length > 0) {
      api.on(drawEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        api.rows({ page: "current" }).eq(0).each(function(idx) {
          var row = data[idx];
          if (row._detailsShow) {
            row._details.insertAfter(row.nTr);
          }
        });
      });
      api.on(colvisEvent, function(e, ctx, idx, vis) {
        if (settings !== ctx) {
          return;
        }
        var row, visible = _fnVisbleColumns(ctx);
        for (var i = 0, ien = data.length; i < ien; i++) {
          row = data[i];
          if (row._details) {
            row._details.each(function() {
              var el = $2(this).children("td");
              if (el.length == 1) {
                el.attr("colspan", visible);
              }
            });
          }
        }
      });
      api.on(destroyEvent, function(e, ctx) {
        if (settings !== ctx) {
          return;
        }
        for (var i = 0, ien = data.length; i < ien; i++) {
          if (data[i]._details) {
            __details_remove(api, i);
          }
        }
      });
    }
  };
  var _emp = "";
  var _child_obj = _emp + "row().child";
  var _child_mth = _child_obj + "()";
  _api_register(_child_mth, function(data, klass) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length ? ctx[0].aoData[this[0]]._details : void 0;
    } else if (data === true) {
      this.child.show();
    } else if (data === false) {
      __details_remove(this);
    } else if (ctx.length && this.length) {
      __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);
    }
    return this;
  });
  _api_register([
    _child_obj + ".show()",
    _child_mth + ".show()"
    // only when `child()` was called with parameters (without
  ], function(show) {
    __details_display(this, true);
    return this;
  });
  _api_register([
    _child_obj + ".hide()",
    _child_mth + ".hide()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_display(this, false);
    return this;
  });
  _api_register([
    _child_obj + ".remove()",
    _child_mth + ".remove()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_remove(this);
    return this;
  });
  _api_register(_child_obj + ".isShown()", function() {
    var ctx = this.context;
    if (ctx.length && this.length) {
      return ctx[0].aoData[this[0]]._detailsShow || false;
    }
    return false;
  });
  var __re_column_selector = /^([^:]+):(name|visIdx|visible)$/;
  var __columnData = function(settings, column, r1, r2, rows) {
    var a = [];
    for (var row = 0, ien = rows.length; row < ien; row++) {
      a.push(_fnGetCellData(settings, rows[row], column));
    }
    return a;
  };
  var __column_selector = function(settings, selector, opts) {
    var columns = settings.aoColumns, names = _pluck(columns, "sName"), nodes = _pluck(columns, "nTh");
    var run = function(s) {
      var selInt = _intVal(s);
      if (s === "") {
        return _range(columns.length);
      }
      if (selInt !== null) {
        return [
          selInt >= 0 ? selInt : (
            // Count from left
            columns.length + selInt
          )
          // Count from right (+ because its a negative value)
        ];
      }
      if (typeof s === "function") {
        var rows = _selector_row_indexes(settings, opts);
        return $2.map(columns, function(col, idx2) {
          return s(
            idx2,
            __columnData(settings, idx2, 0, 0, rows),
            nodes[idx2]
          ) ? idx2 : null;
        });
      }
      var match = typeof s === "string" ? s.match(__re_column_selector) : "";
      if (match) {
        switch (match[2]) {
          case "visIdx":
          case "visible":
            var idx = parseInt(match[1], 10);
            if (idx < 0) {
              var visColumns = $2.map(columns, function(col, i) {
                return col.bVisible ? i : null;
              });
              return [visColumns[visColumns.length + idx]];
            }
            return [_fnVisibleToColumnIndex(settings, idx)];
          case "name":
            return $2.map(names, function(name, i) {
              return name === match[1] ? i : null;
            });
          default:
            return [];
        }
      }
      if (s.nodeName && s._DT_CellIndex) {
        return [s._DT_CellIndex.column];
      }
      var jqResult = $2(nodes).filter(s).map(function() {
        return $2.inArray(this, nodes);
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      var host = $2(s).closest("*[data-dt-column]");
      return host.length ? [host.data("dt-column")] : [];
    };
    return _selector_run("column", selector, run, settings, opts);
  };
  var __setColumnVis = function(settings, column, vis) {
    var cols = settings.aoColumns, col = cols[column], data = settings.aoData, row, cells, i, ien, tr;
    if (vis === void 0) {
      return col.bVisible;
    }
    if (col.bVisible === vis) {
      return;
    }
    if (vis) {
      var insertBefore = $2.inArray(true, _pluck(cols, "bVisible"), column + 1);
      for (i = 0, ien = data.length; i < ien; i++) {
        tr = data[i].nTr;
        cells = data[i].anCells;
        if (tr) {
          tr.insertBefore(cells[column], cells[insertBefore] || null);
        }
      }
    } else {
      $2(_pluck(settings.aoData, "anCells", column)).detach();
    }
    col.bVisible = vis;
  };
  _api_register("columns()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($2.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts(opts);
    var inst = this.iterator("table", function(settings) {
      return __column_selector(settings, selector, opts);
    }, 1);
    inst.selector.cols = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_registerPlural("columns().header()", "column().header()", function(selector, opts) {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column].nTh;
    }, 1);
  });
  _api_registerPlural("columns().footer()", "column().footer()", function(selector, opts) {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column].nTf;
    }, 1);
  });
  _api_registerPlural("columns().data()", "column().data()", function() {
    return this.iterator("column-rows", __columnData, 1);
  });
  _api_registerPlural("columns().dataSrc()", "column().dataSrc()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column].mData;
    }, 1);
  });
  _api_registerPlural("columns().cache()", "column().cache()", function(type) {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order(
        settings.aoData,
        rows,
        type === "search" ? "_aFilterData" : "_aSortData",
        column
      );
    }, 1);
  });
  _api_registerPlural("columns().nodes()", "column().nodes()", function() {
    return this.iterator("column-rows", function(settings, column, i, j, rows) {
      return _pluck_order(settings.aoData, rows, "anCells", column);
    }, 1);
  });
  _api_registerPlural("columns().visible()", "column().visible()", function(vis, calc) {
    var that = this;
    var ret = this.iterator("column", function(settings, column) {
      if (vis === void 0) {
        return settings.aoColumns[column].bVisible;
      }
      __setColumnVis(settings, column, vis);
    });
    if (vis !== void 0) {
      this.iterator("table", function(settings) {
        _fnDrawHead(settings, settings.aoHeader);
        _fnDrawHead(settings, settings.aoFooter);
        if (!settings.aiDisplay.length) {
          $2(settings.nTBody).find("td[colspan]").attr("colspan", _fnVisbleColumns(settings));
        }
        _fnSaveState(settings);
        that.iterator("column", function(settings2, column) {
          _fnCallbackFire(settings2, null, "column-visibility", [settings2, column, vis, calc]);
        });
        if (calc === void 0 || calc) {
          that.columns.adjust();
        }
      });
    }
    return ret;
  });
  _api_registerPlural("columns().indexes()", "column().index()", function(type) {
    return this.iterator("column", function(settings, column) {
      return type === "visible" ? _fnColumnIndexToVisible(settings, column) : column;
    }, 1);
  });
  _api_register("columns.adjust()", function() {
    return this.iterator("table", function(settings) {
      _fnAdjustColumnSizing(settings);
    }, 1);
  });
  _api_register("column.index()", function(type, idx) {
    if (this.context.length !== 0) {
      var ctx = this.context[0];
      if (type === "fromVisible" || type === "toData") {
        return _fnVisibleToColumnIndex(ctx, idx);
      } else if (type === "fromData" || type === "toVisible") {
        return _fnColumnIndexToVisible(ctx, idx);
      }
    }
  });
  _api_register("column()", function(selector, opts) {
    return _selector_first(this.columns(selector, opts));
  });
  var __cell_selector = function(settings, selector, opts) {
    var data = settings.aoData;
    var rows = _selector_row_indexes(settings, opts);
    var cells = _removeEmpty(_pluck_order(data, rows, "anCells"));
    var allCells = $2(_flatten([], cells));
    var row;
    var columns = settings.aoColumns.length;
    var a, i, ien, j, o, host;
    var run = function(s) {
      var fnSelector = typeof s === "function";
      if (s === null || s === void 0 || fnSelector) {
        a = [];
        for (i = 0, ien = rows.length; i < ien; i++) {
          row = rows[i];
          for (j = 0; j < columns; j++) {
            o = {
              row,
              column: j
            };
            if (fnSelector) {
              host = data[row];
              if (s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null)) {
                a.push(o);
              }
            } else {
              a.push(o);
            }
          }
        }
        return a;
      }
      if ($2.isPlainObject(s)) {
        return s.column !== void 0 && s.row !== void 0 && $2.inArray(s.row, rows) !== -1 ? [s] : [];
      }
      var jqResult = allCells.filter(s).map(function(i2, el) {
        return {
          // use a new object, in case someone changes the values
          row: el._DT_CellIndex.row,
          column: el._DT_CellIndex.column
        };
      }).toArray();
      if (jqResult.length || !s.nodeName) {
        return jqResult;
      }
      host = $2(s).closest("*[data-dt-row]");
      return host.length ? [{
        row: host.data("dt-row"),
        column: host.data("dt-column")
      }] : [];
    };
    return _selector_run("cell", selector, run, settings, opts);
  };
  _api_register("cells()", function(rowSelector, columnSelector, opts) {
    if ($2.isPlainObject(rowSelector)) {
      if (rowSelector.row === void 0) {
        opts = rowSelector;
        rowSelector = null;
      } else {
        opts = columnSelector;
        columnSelector = null;
      }
    }
    if ($2.isPlainObject(columnSelector)) {
      opts = columnSelector;
      columnSelector = null;
    }
    if (columnSelector === null || columnSelector === void 0) {
      return this.iterator("table", function(settings) {
        return __cell_selector(settings, rowSelector, _selector_opts(opts));
      });
    }
    var internalOpts = opts ? {
      page: opts.page,
      order: opts.order,
      search: opts.search
    } : {};
    var columns = this.columns(columnSelector, internalOpts);
    var rows = this.rows(rowSelector, internalOpts);
    var i, ien, j, jen;
    var cellsNoOpts = this.iterator("table", function(settings, idx) {
      var a = [];
      for (i = 0, ien = rows[idx].length; i < ien; i++) {
        for (j = 0, jen = columns[idx].length; j < jen; j++) {
          a.push({
            row: rows[idx][i],
            column: columns[idx][j]
          });
        }
      }
      return a;
    }, 1);
    var cells = opts && opts.selected ? this.cells(cellsNoOpts, opts) : cellsNoOpts;
    $2.extend(cells.selector, {
      cols: columnSelector,
      rows: rowSelector,
      opts
    });
    return cells;
  });
  _api_registerPlural("cells().nodes()", "cell().node()", function() {
    return this.iterator("cell", function(settings, row, column) {
      var data = settings.aoData[row];
      return data && data.anCells ? data.anCells[column] : void 0;
    }, 1);
  });
  _api_register("cells().data()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData(settings, row, column);
    }, 1);
  });
  _api_registerPlural("cells().cache()", "cell().cache()", function(type) {
    type = type === "search" ? "_aFilterData" : "_aSortData";
    return this.iterator("cell", function(settings, row, column) {
      return settings.aoData[row][type][column];
    }, 1);
  });
  _api_registerPlural("cells().render()", "cell().render()", function(type) {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData(settings, row, column, type);
    }, 1);
  });
  _api_registerPlural("cells().indexes()", "cell().index()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return {
        row,
        column,
        columnVisible: _fnColumnIndexToVisible(settings, column)
      };
    }, 1);
  });
  _api_registerPlural("cells().invalidate()", "cell().invalidate()", function(src) {
    return this.iterator("cell", function(settings, row, column) {
      _fnInvalidate(settings, row, src, column);
    });
  });
  _api_register("cell()", function(rowSelector, columnSelector, opts) {
    return _selector_first(this.cells(rowSelector, columnSelector, opts));
  });
  _api_register("cell().data()", function(data) {
    var ctx = this.context;
    var cell = this[0];
    if (data === void 0) {
      return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : void 0;
    }
    _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);
    _fnInvalidate(ctx[0], cell[0].row, "data", cell[0].column);
    return this;
  });
  _api_register("order()", function(order, dir) {
    var ctx = this.context;
    if (order === void 0) {
      return ctx.length !== 0 ? ctx[0].aaSorting : void 0;
    }
    if (typeof order === "number") {
      order = [[order, dir]];
    } else if (order.length && !Array.isArray(order[0])) {
      order = Array.prototype.slice.call(arguments);
    }
    return this.iterator("table", function(settings) {
      settings.aaSorting = order.slice();
    });
  });
  _api_register("order.listener()", function(node, column, callback) {
    return this.iterator("table", function(settings) {
      _fnSortAttachListener(settings, node, column, callback);
    });
  });
  _api_register("order.fixed()", function(set2) {
    if (!set2) {
      var ctx = this.context;
      var fixed = ctx.length ? ctx[0].aaSortingFixed : void 0;
      return Array.isArray(fixed) ? { pre: fixed } : fixed;
    }
    return this.iterator("table", function(settings) {
      settings.aaSortingFixed = $2.extend(true, {}, set2);
    });
  });
  _api_register([
    "columns().order()",
    "column().order()"
  ], function(dir) {
    var that = this;
    return this.iterator("table", function(settings, i) {
      var sort = [];
      $2.each(that[i], function(j, col) {
        sort.push([col, dir]);
      });
      settings.aaSorting = sort;
    });
  });
  _api_register("search()", function(input, regex, smart, caseInsen) {
    var ctx = this.context;
    if (input === void 0) {
      return ctx.length !== 0 ? ctx[0].oPreviousSearch.sSearch : void 0;
    }
    return this.iterator("table", function(settings) {
      if (!settings.oFeatures.bFilter) {
        return;
      }
      _fnFilterComplete(settings, $2.extend({}, settings.oPreviousSearch, {
        "sSearch": input + "",
        "bRegex": regex === null ? false : regex,
        "bSmart": smart === null ? true : smart,
        "bCaseInsensitive": caseInsen === null ? true : caseInsen
      }), 1);
    });
  });
  _api_registerPlural(
    "columns().search()",
    "column().search()",
    function(input, regex, smart, caseInsen) {
      return this.iterator("column", function(settings, column) {
        var preSearch = settings.aoPreSearchCols;
        if (input === void 0) {
          return preSearch[column].sSearch;
        }
        if (!settings.oFeatures.bFilter) {
          return;
        }
        $2.extend(preSearch[column], {
          "sSearch": input + "",
          "bRegex": regex === null ? false : regex,
          "bSmart": smart === null ? true : smart,
          "bCaseInsensitive": caseInsen === null ? true : caseInsen
        });
        _fnFilterComplete(settings, settings.oPreviousSearch, 1);
      });
    }
  );
  _api_register("state()", function() {
    return this.context.length ? this.context[0].oSavedState : null;
  });
  _api_register("state.clear()", function() {
    return this.iterator("table", function(settings) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
    });
  });
  _api_register("state.loaded()", function() {
    return this.context.length ? this.context[0].oLoadedState : null;
  });
  _api_register("state.save()", function() {
    return this.iterator("table", function(settings) {
      _fnSaveState(settings);
    });
  });
  DataTable.use = function(module, type) {
    if (type === "lib" || module.fn) {
      $2 = module;
    } else if (type == "win" || module.document) {
      window = module;
      document = module.document;
    } else if (type === "datetime" || module.type === "DateTime") {
      DataTable.DateTime = module;
    }
  };
  DataTable.factory = function(root, jq) {
    var is = false;
    if (root && root.document) {
      window = root;
      document = root.document;
    }
    if (jq && jq.fn && jq.fn.jquery) {
      $2 = jq;
      is = true;
    }
    return is;
  };
  DataTable.versionCheck = DataTable.fnVersionCheck = function(version2) {
    var aThis = DataTable.version.split(".");
    var aThat = version2.split(".");
    var iThis, iThat;
    for (var i = 0, iLen = aThat.length; i < iLen; i++) {
      iThis = parseInt(aThis[i], 10) || 0;
      iThat = parseInt(aThat[i], 10) || 0;
      if (iThis === iThat) {
        continue;
      }
      return iThis > iThat;
    }
    return true;
  };
  DataTable.isDataTable = DataTable.fnIsDataTable = function(table) {
    var t = $2(table).get(0);
    var is = false;
    if (table instanceof DataTable.Api) {
      return true;
    }
    $2.each(DataTable.settings, function(i, o) {
      var head = o.nScrollHead ? $2("table", o.nScrollHead)[0] : null;
      var foot = o.nScrollFoot ? $2("table", o.nScrollFoot)[0] : null;
      if (o.nTable === t || head === t || foot === t) {
        is = true;
      }
    });
    return is;
  };
  DataTable.tables = DataTable.fnTables = function(visible) {
    var api = false;
    if ($2.isPlainObject(visible)) {
      api = visible.api;
      visible = visible.visible;
    }
    var a = $2.map(DataTable.settings, function(o) {
      if (!visible || visible && $2(o.nTable).is(":visible")) {
        return o.nTable;
      }
    });
    return api ? new _Api(a) : a;
  };
  DataTable.camelToHungarian = _fnCamelToHungarian;
  _api_register("$()", function(selector, opts) {
    var rows = this.rows(opts).nodes(), jqRows = $2(rows);
    return $2([].concat(
      jqRows.filter(selector).toArray(),
      jqRows.find(selector).toArray()
    ));
  });
  $2.each(["on", "one", "off"], function(i, key) {
    _api_register(key + "()", function() {
      var args = Array.prototype.slice.call(arguments);
      args[0] = $2.map(args[0].split(/\s/), function(e) {
        return !e.match(/\.dt\b/) ? e + ".dt" : e;
      }).join(" ");
      var inst = $2(this.tables().nodes());
      inst[key].apply(inst, args);
      return this;
    });
  });
  _api_register("clear()", function() {
    return this.iterator("table", function(settings) {
      _fnClearTable(settings);
    });
  });
  _api_register("settings()", function() {
    return new _Api(this.context, this.context);
  });
  _api_register("init()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].oInit : null;
  });
  _api_register("data()", function() {
    return this.iterator("table", function(settings) {
      return _pluck(settings.aoData, "_aData");
    }).flatten();
  });
  _api_register("destroy()", function(remove2) {
    remove2 = remove2 || false;
    return this.iterator("table", function(settings) {
      var classes = settings.oClasses;
      var table = settings.nTable;
      var tbody = settings.nTBody;
      var thead = settings.nTHead;
      var tfoot = settings.nTFoot;
      var jqTable = $2(table);
      var jqTbody = $2(tbody);
      var jqWrapper = $2(settings.nTableWrapper);
      var rows = $2.map(settings.aoData, function(r) {
        return r.nTr;
      });
      var i, ien;
      settings.bDestroying = true;
      _fnCallbackFire(settings, "aoDestroyCallback", "destroy", [settings]);
      if (!remove2) {
        new _Api(settings).columns().visible(true);
      }
      jqWrapper.off(".DT").find(":not(tbody *)").off(".DT");
      $2(window).off(".DT-" + settings.sInstance);
      if (table != thead.parentNode) {
        jqTable.children("thead").detach();
        jqTable.append(thead);
      }
      if (tfoot && table != tfoot.parentNode) {
        jqTable.children("tfoot").detach();
        jqTable.append(tfoot);
      }
      settings.aaSorting = [];
      settings.aaSortingFixed = [];
      _fnSortingClasses(settings);
      $2(rows).removeClass(settings.asStripeClasses.join(" "));
      $2("th, td", thead).removeClass(
        classes.sSortable + " " + classes.sSortableAsc + " " + classes.sSortableDesc + " " + classes.sSortableNone
      );
      jqTbody.children().detach();
      jqTbody.append(rows);
      var orig = settings.nTableWrapper.parentNode;
      var removedMethod = remove2 ? "remove" : "detach";
      jqTable[removedMethod]();
      jqWrapper[removedMethod]();
      if (!remove2 && orig) {
        orig.insertBefore(table, settings.nTableReinsertBefore);
        jqTable.css("width", settings.sDestroyWidth).removeClass(classes.sTable);
        ien = settings.asDestroyStripes.length;
        if (ien) {
          jqTbody.children().each(function(i2) {
            $2(this).addClass(settings.asDestroyStripes[i2 % ien]);
          });
        }
      }
      var idx = $2.inArray(settings, DataTable.settings);
      if (idx !== -1) {
        DataTable.settings.splice(idx, 1);
      }
    });
  });
  $2.each(["column", "row", "cell"], function(i, type) {
    _api_register(type + "s().every()", function(fn) {
      var opts = this.selector.opts;
      var api = this;
      return this.iterator(type, function(settings, arg1, arg2, arg3, arg4) {
        fn.call(
          api[type](
            arg1,
            type === "cell" ? arg2 : opts,
            type === "cell" ? opts : void 0
          ),
          arg1,
          arg2,
          arg3,
          arg4
        );
      });
    });
  });
  _api_register("i18n()", function(token, def2, plural) {
    var ctx = this.context[0];
    var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);
    if (resolved === void 0) {
      resolved = def2;
    }
    if (plural !== void 0 && $2.isPlainObject(resolved)) {
      resolved = resolved[plural] !== void 0 ? resolved[plural] : resolved._;
    }
    return typeof resolved === "string" ? resolved.replace("%d", plural) : resolved;
  });
  DataTable.version = "1.13.11";
  DataTable.settings = [];
  DataTable.models = {};
  DataTable.models.oSearch = {
    /**
     * Flag to indicate if the filtering should be case insensitive or not
     *  @type boolean
     *  @default true
     */
    "bCaseInsensitive": true,
    /**
     * Applied search term
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sSearch": "",
    /**
     * Flag to indicate if the search term should be interpreted as a
     * regular expression (true) or not (false) and therefore and special
     * regex characters escaped.
     *  @type boolean
     *  @default false
     */
    "bRegex": false,
    /**
     * Flag to indicate if DataTables is to use its smart filtering or not.
     *  @type boolean
     *  @default true
     */
    "bSmart": true,
    /**
     * Flag to indicate if DataTables should only trigger a search when
     * the return key is pressed.
     *  @type boolean
     *  @default false
     */
    "return": false
  };
  DataTable.models.oRow = {
    /**
     * TR element for the row
     *  @type node
     *  @default null
     */
    "nTr": null,
    /**
     * Array of TD elements for each row. This is null until the row has been
     * created.
     *  @type array nodes
     *  @default []
     */
    "anCells": null,
    /**
     * Data object from the original data source for the row. This is either
     * an array if using the traditional form of DataTables, or an object if
     * using mData options. The exact type will depend on the passed in
     * data from the data source, or will be an array if using DOM a data
     * source.
     *  @type array|object
     *  @default []
     */
    "_aData": [],
    /**
     * Sorting data cache - this array is ostensibly the same length as the
     * number of columns (although each index is generated only as it is
     * needed), and holds the data that is used for sorting each column in the
     * row. We do this cache generation at the start of the sort in order that
     * the formatting of the sort data need be done only once for each cell
     * per sort. This array should not be read from or written to by anything
     * other than the master sorting methods.
     *  @type array
     *  @default null
     *  @private
     */
    "_aSortData": null,
    /**
     * Per cell filtering data cache. As per the sort data cache, used to
     * increase the performance of the filtering in DataTables
     *  @type array
     *  @default null
     *  @private
     */
    "_aFilterData": null,
    /**
     * Filtering data cache. This is the same as the cell filtering cache, but
     * in this case a string rather than an array. This is easily computed with
     * a join on `_aFilterData`, but is provided as a cache so the join isn't
     * needed on every search (memory traded for performance)
     *  @type array
     *  @default null
     *  @private
     */
    "_sFilterRow": null,
    /**
     * Cache of the class name that DataTables has applied to the row, so we
     * can quickly look at this variable rather than needing to do a DOM check
     * on className for the nTr property.
     *  @type string
     *  @default <i>Empty string</i>
     *  @private
     */
    "_sRowStripe": "",
    /**
     * Denote if the original data source was from the DOM, or the data source
     * object. This is used for invalidating data, so DataTables can
     * automatically read data from the original source, unless uninstructed
     * otherwise.
     *  @type string
     *  @default null
     *  @private
     */
    "src": null,
    /**
     * Index in the aoData array. This saves an indexOf lookup when we have the
     * object, but want to know the index
     *  @type integer
     *  @default -1
     *  @private
     */
    "idx": -1
  };
  DataTable.models.oColumn = {
    /**
     * Column index. This could be worked out on-the-fly with $.inArray, but it
     * is faster to just hold it as a variable
     *  @type integer
     *  @default null
     */
    "idx": null,
    /**
     * A list of the columns that sorting should occur on when this column
     * is sorted. That this property is an array allows multi-column sorting
     * to be defined for a column (for example first name / last name columns
     * would benefit from this). The values are integers pointing to the
     * columns to be sorted on (typically it will be a single integer pointing
     * at itself, but that doesn't need to be the case).
     *  @type array
     */
    "aDataSort": null,
    /**
     * Define the sorting directions that are applied to the column, in sequence
     * as the column is repeatedly sorted upon - i.e. the first value is used
     * as the sorting direction when the column if first sorted (clicked on).
     * Sort it again (click again) and it will move on to the next index.
     * Repeat until loop.
     *  @type array
     */
    "asSorting": null,
    /**
     * Flag to indicate if the column is searchable, and thus should be included
     * in the filtering or not.
     *  @type boolean
     */
    "bSearchable": null,
    /**
     * Flag to indicate if the column is sortable or not.
     *  @type boolean
     */
    "bSortable": null,
    /**
     * Flag to indicate if the column is currently visible in the table or not
     *  @type boolean
     */
    "bVisible": null,
    /**
     * Store for manual type assignment using the `column.type` option. This
     * is held in store so we can manipulate the column's `sType` property.
     *  @type string
     *  @default null
     *  @private
     */
    "_sManualType": null,
    /**
     * Flag to indicate if HTML5 data attributes should be used as the data
     * source for filtering or sorting. True is either are.
     *  @type boolean
     *  @default false
     *  @private
     */
    "_bAttrSrc": false,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     *  @type function
     *  @param {element} nTd The TD node that has been created
     *  @param {*} sData The Data for the cell
     *  @param {array|object} oData The data for the whole row
     *  @param {int} iRow The row index for the aoData data store
     *  @default null
     */
    "fnCreatedCell": null,
    /**
     * Function to get data from a cell in a column. You should <b>never</b>
     * access data directly through _aData internally in DataTables - always use
     * the method attached to this property. It allows mData to function as
     * required. This function is automatically assigned by the column
     * initialisation method
     *  @type function
     *  @param {array|object} oData The data array/object for the array
     *    (i.e. aoData[]._aData)
     *  @param {string} sSpecific The specific data type you want to get -
     *    'display', 'type' 'filter' 'sort'
     *  @returns {*} The data for the cell from the given row's data
     *  @default null
     */
    "fnGetData": null,
    /**
     * Function to set data for a cell in the column. You should <b>never</b>
     * set the data directly to _aData internally in DataTables - always use
     * this method. It allows mData to function as required. This function
     * is automatically assigned by the column initialisation method
     *  @type function
     *  @param {array|object} oData The data array/object for the array
     *    (i.e. aoData[]._aData)
     *  @param {*} sValue Value to set
     *  @default null
     */
    "fnSetData": null,
    /**
     * Property to read the value for the cells in the column from the data
     * source array / object. If null, then the default content is used, if a
     * function is given then the return from the function is used.
     *  @type function|int|string|null
     *  @default null
     */
    "mData": null,
    /**
     * Partner property to mData which is used (only when defined) to get
     * the data - i.e. it is basically the same as mData, but without the
     * 'set' option, and also the data fed to it is the result from mData.
     * This is the rendering method to match the data method of mData.
     *  @type function|int|string|null
     *  @default null
     */
    "mRender": null,
    /**
     * Unique header TH/TD element for this column - this is what the sorting
     * listener is attached to (if sorting is enabled.)
     *  @type node
     *  @default null
     */
    "nTh": null,
    /**
     * Unique footer TH/TD element for this column (if there is one). Not used
     * in DataTables as such, but can be used for plug-ins to reference the
     * footer for each column.
     *  @type node
     *  @default null
     */
    "nTf": null,
    /**
     * The class to apply to all TD elements in the table's TBODY for the column
     *  @type string
     *  @default null
     */
    "sClass": null,
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     *  @type string
     */
    "sContentPadding": null,
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because mData
     * is set to null, or because the data source itself is null).
     *  @type string
     *  @default null
     */
    "sDefaultContent": null,
    /**
     * Name for the column, allowing reference to the column by name as well as
     * by index (needs a lookup to work by name).
     *  @type string
     */
    "sName": null,
    /**
     * Custom sorting data type - defines which of the available plug-ins in
     * afnSortData the custom sorting will use - if any is defined.
     *  @type string
     *  @default std
     */
    "sSortDataType": "std",
    /**
     * Class to be applied to the header element when sorting on this column
     *  @type string
     *  @default null
     */
    "sSortingClass": null,
    /**
     * Class to be applied to the header element when sorting on this column -
     * when jQuery UI theming is used.
     *  @type string
     *  @default null
     */
    "sSortingClassJUI": null,
    /**
     * Title of the column - what is seen in the TH element (nTh).
     *  @type string
     */
    "sTitle": null,
    /**
     * Column sorting and filtering type
     *  @type string
     *  @default null
     */
    "sType": null,
    /**
     * Width of the column
     *  @type string
     *  @default null
     */
    "sWidth": null,
    /**
     * Width of the column when it was first "encountered"
     *  @type string
     *  @default null
     */
    "sWidthOrig": null
  };
  DataTable.defaults = {
    /**
     * An array of data to use for the table, passed in at initialisation which
     * will be used in preference to any data which is already in the DOM. This is
     * particularly useful for constructing tables purely in Javascript, for
     * example with a custom Ajax call.
     *  @type array
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.data
     *
     *  @example
     *    // Using a 2D array data source
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "data": [
     *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
     *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
     *        ],
     *        "columns": [
     *          { "title": "Engine" },
     *          { "title": "Browser" },
     *          { "title": "Platform" },
     *          { "title": "Version" },
     *          { "title": "Grade" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using an array of objects as a data source (`data`)
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "data": [
     *          {
     *            "engine":   "Trident",
     *            "browser":  "Internet Explorer 4.0",
     *            "platform": "Win 95+",
     *            "version":  4,
     *            "grade":    "X"
     *          },
     *          {
     *            "engine":   "Trident",
     *            "browser":  "Internet Explorer 5.0",
     *            "platform": "Win 95+",
     *            "version":  5,
     *            "grade":    "C"
     *          }
     *        ],
     *        "columns": [
     *          { "title": "Engine",   "data": "engine" },
     *          { "title": "Browser",  "data": "browser" },
     *          { "title": "Platform", "data": "platform" },
     *          { "title": "Version",  "data": "version" },
     *          { "title": "Grade",    "data": "grade" }
     *        ]
     *      } );
     *    } );
     */
    "aaData": null,
    /**
     * If ordering is enabled, then DataTables will perform a first pass sort on
     * initialisation. You can define which column(s) the sort is performed
     * upon, and the sorting direction, with this variable. The `sorting` array
     * should contain an array for each column to be sorted initially containing
     * the column's index and a direction string ('asc' or 'desc').
     *  @type array
     *  @default [[0,'asc']]
     *
     *  @dtopt Option
     *  @name DataTable.defaults.order
     *
     *  @example
     *    // Sort by 3rd column first, and then 4th column
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "order": [[2,'asc'], [3,'desc']]
     *      } );
     *    } );
     *
     *    // No initial sorting
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "order": []
     *      } );
     *    } );
     */
    "aaSorting": [[0, "asc"]],
    /**
     * This parameter is basically identical to the `sorting` parameter, but
     * cannot be overridden by user interaction with the table. What this means
     * is that you could have a column (visible or hidden) which the sorting
     * will always be forced on first - any sorting after that (from the user)
     * will then be performed as required. This can be useful for grouping rows
     * together.
     *  @type array
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.orderFixed
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "orderFixed": [[0,'asc']]
     *      } );
     *    } )
     */
    "aaSortingFixed": [],
    /**
     * DataTables can be instructed to load data to display in the table from a
     * Ajax source. This option defines how that Ajax call is made and where to.
     *
     * The `ajax` property has three different modes of operation, depending on
     * how it is defined. These are:
     *
     * * `string` - Set the URL from where the data should be loaded from.
     * * `object` - Define properties for `jQuery.ajax`.
     * * `function` - Custom data get function
     *
     * `string`
     * --------
     *
     * As a string, the `ajax` property simply defines the URL from which
     * DataTables will load data.
     *
     * `object`
     * --------
     *
     * As an object, the parameters in the object are passed to
     * [jQuery.ajax](https://api.jquery.com/jQuery.ajax/) allowing fine control
     * of the Ajax request. DataTables has a number of default parameters which
     * you can override using this option. Please refer to the jQuery
     * documentation for a full description of the options available, although
     * the following parameters provide additional options in DataTables or
     * require special consideration:
     *
     * * `data` - As with jQuery, `data` can be provided as an object, but it
     *   can also be used as a function to manipulate the data DataTables sends
     *   to the server. The function takes a single parameter, an object of
     *   parameters with the values that DataTables has readied for sending. An
     *   object may be returned which will be merged into the DataTables
     *   defaults, or you can add the items to the object that was passed in and
     *   not return anything from the function. This supersedes `fnServerParams`
     *   from DataTables 1.9-.
     *
     * * `dataSrc` - By default DataTables will look for the property `data` (or
     *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
     *   from an Ajax source or for server-side processing - this parameter
     *   allows that property to be changed. You can use Javascript dotted
     *   object notation to get a data source for multiple levels of nesting, or
     *   it my be used as a function. As a function it takes a single parameter,
     *   the JSON returned from the server, which can be manipulated as
     *   required, with the returned value being that used by DataTables as the
     *   data source for the table. This supersedes `sAjaxDataProp` from
     *   DataTables 1.9-.
     *
     * * `success` - Should not be overridden it is used internally in
     *   DataTables. To manipulate / transform the data returned by the server
     *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
     *
     * `function`
     * ----------
     *
     * As a function, making the Ajax call is left up to yourself allowing
     * complete control of the Ajax request. Indeed, if desired, a method other
     * than Ajax could be used to obtain the required data, such as Web storage
     * or an AIR database.
     *
     * The function is given four parameters and no return is required. The
     * parameters are:
     *
     * 1. _object_ - Data to send to the server
     * 2. _function_ - Callback function that must be executed when the required
     *    data has been obtained. That data should be passed into the callback
     *    as the only parameter
     * 3. _object_ - DataTables settings object for the table
     *
     * Note that this supersedes `fnServerData` from DataTables 1.9-.
     *
     *  @type string|object|function
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.ajax
     *  @since 1.10.0
     *
     * @example
     *   // Get JSON data from a file via Ajax.
     *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
     *   $('#example').dataTable( {
     *     "ajax": "data.json"
     *   } );
     *
     * @example
     *   // Get JSON data from a file via Ajax, using `dataSrc` to change
     *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": "tableData"
     *     }
     *   } );
     *
     * @example
     *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
     *   // from a plain array rather than an array in an object
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": ""
     *     }
     *   } );
     *
     * @example
     *   // Manipulate the data returned from the server - add a link to data
     *   // (note this can, should, be done using `render` for the column - this
     *   // is just a simple example of how the data can be manipulated).
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": function ( json ) {
     *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
     *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
     *         }
     *         return json;
     *       }
     *     }
     *   } );
     *
     * @example
     *   // Add data to the request
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "data": function ( d ) {
     *         return {
     *           "extra_search": $('#extra').val()
     *         };
     *       }
     *     }
     *   } );
     *
     * @example
     *   // Send request as POST
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "type": "POST"
     *     }
     *   } );
     *
     * @example
     *   // Get the data from localStorage (could interface with a form for
     *   // adding, editing and removing rows).
     *   $('#example').dataTable( {
     *     "ajax": function (data, callback, settings) {
     *       callback(
     *         JSON.parse( localStorage.getItem('dataTablesData') )
     *       );
     *     }
     *   } );
     */
    "ajax": null,
    /**
     * This parameter allows you to readily specify the entries in the length drop
     * down menu that DataTables shows when pagination is enabled. It can be
     * either a 1D array of options which will be used for both the displayed
     * option and the value, or a 2D array which will use the array in the first
     * position as the value, and the array in the second position as the
     * displayed options (useful for language strings such as 'All').
     *
     * Note that the `pageLength` property will be automatically set to the
     * first value given in this array, unless `pageLength` is also provided.
     *  @type array
     *  @default [ 10, 25, 50, 100 ]
     *
     *  @dtopt Option
     *  @name DataTable.defaults.lengthMenu
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
     *      } );
     *    } );
     */
    "aLengthMenu": [10, 25, 50, 100],
    /**
     * The `columns` option in the initialisation parameter allows you to define
     * details about the way individual columns behave. For a full list of
     * column options that can be set, please see
     * {@link DataTable.defaults.column}. Note that if you use `columns` to
     * define your columns, you must have an entry in the array for every single
     * column that you have in your table (these can be null if you don't which
     * to specify any options).
     *  @member
     *
     *  @name DataTable.defaults.column
     */
    "aoColumns": null,
    /**
     * Very similar to `columns`, `columnDefs` allows you to target a specific
     * column, multiple columns, or all columns, using the `targets` property of
     * each object in the array. This allows great flexibility when creating
     * tables, as the `columnDefs` arrays can be of any length, targeting the
     * columns you specifically want. `columnDefs` may use any of the column
     * options available: {@link DataTable.defaults.column}, but it _must_
     * have `targets` defined in each object in the array. Values in the `targets`
     * array may be:
     *   <ul>
     *     <li>a string - class name will be matched on the TH for the column</li>
     *     <li>0 or a positive integer - column index counting from the left</li>
     *     <li>a negative integer - column index counting from the right</li>
     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
     *   </ul>
     *  @member
     *
     *  @name DataTable.defaults.columnDefs
     */
    "aoColumnDefs": null,
    /**
     * Basically the same as `search`, this parameter defines the individual column
     * filtering state at initialisation time. The array must be of the same size
     * as the number of columns, and each element be an object with the parameters
     * `search` and `escapeRegex` (the latter is optional). 'null' is also
     * accepted and the default will be used.
     *  @type array
     *  @default []
     *
     *  @dtopt Option
     *  @name DataTable.defaults.searchCols
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "searchCols": [
     *          null,
     *          { "search": "My filter" },
     *          null,
     *          { "search": "^[0-9]", "escapeRegex": false }
     *        ]
     *      } );
     *    } )
     */
    "aoSearchCols": [],
    /**
     * An array of CSS classes that should be applied to displayed rows. This
     * array may be of any length, and DataTables will apply each class
     * sequentially, looping when required.
     *  @type array
     *  @default null <i>Will take the values determined by the `oClasses.stripe*`
     *    options</i>
     *
     *  @dtopt Option
     *  @name DataTable.defaults.stripeClasses
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
     *      } );
     *    } )
     */
    "asStripeClasses": null,
    /**
     * Enable or disable automatic column width calculation. This can be disabled
     * as an optimisation (it takes some time to calculate the widths) if the
     * tables widths are passed in using `columns`.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.autoWidth
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "autoWidth": false
     *      } );
     *    } );
     */
    "bAutoWidth": true,
    /**
     * Deferred rendering can provide DataTables with a huge speed boost when you
     * are using an Ajax or JS data source for the table. This option, when set to
     * true, will cause DataTables to defer the creation of the table elements for
     * each row until they are needed for a draw - saving a significant amount of
     * time.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.deferRender
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajax": "sources/arrays.txt",
     *        "deferRender": true
     *      } );
     *    } );
     */
    "bDeferRender": false,
    /**
     * Replace a DataTable which matches the given selector and replace it with
     * one which has the properties of the new initialisation object passed. If no
     * table matches the selector, then the new DataTable will be constructed as
     * per normal.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.destroy
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "srollY": "200px",
     *        "paginate": false
     *      } );
     *
     *      // Some time later....
     *      $('#example').dataTable( {
     *        "filter": false,
     *        "destroy": true
     *      } );
     *    } );
     */
    "bDestroy": false,
    /**
     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
     * that it allows the end user to input multiple words (space separated) and
     * will match a row containing those words, even if not in the order that was
     * specified (this allow matching across multiple columns). Note that if you
     * wish to use filtering in DataTables this must remain 'true' - to remove the
     * default filtering input box and retain filtering abilities, please use
     * {@link DataTable.defaults.dom}.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.searching
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "searching": false
     *      } );
     *    } );
     */
    "bFilter": true,
    /**
     * Enable or disable the table information display. This shows information
     * about the data that is currently visible on the page, including information
     * about filtered data if that action is being performed.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.info
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "info": false
     *      } );
     *    } );
     */
    "bInfo": true,
    /**
     * Allows the end user to select the size of a formatted page from a select
     * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.lengthChange
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "lengthChange": false
     *      } );
     *    } );
     */
    "bLengthChange": true,
    /**
     * Enable or disable pagination.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.paging
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "paging": false
     *      } );
     *    } );
     */
    "bPaginate": true,
    /**
     * Enable or disable the display of a 'processing' indicator when the table is
     * being processed (e.g. a sort). This is particularly useful for tables with
     * large amounts of data where it can take a noticeable amount of time to sort
     * the entries.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.processing
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "processing": true
     *      } );
     *    } );
     */
    "bProcessing": false,
    /**
     * Retrieve the DataTables object for the given selector. Note that if the
     * table has already been initialised, this parameter will cause DataTables
     * to simply return the object that has already been set up - it will not take
     * account of any changes you might have made to the initialisation object
     * passed to DataTables (setting this parameter to true is an acknowledgement
     * that you understand this). `destroy` can be used to reinitialise a table if
     * you need.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.retrieve
     *
     *  @example
     *    $(document).ready( function() {
     *      initTable();
     *      tableActions();
     *    } );
     *
     *    function initTable ()
     *    {
     *      return $('#example').dataTable( {
     *        "scrollY": "200px",
     *        "paginate": false,
     *        "retrieve": true
     *      } );
     *    }
     *
     *    function tableActions ()
     *    {
     *      var table = initTable();
     *      // perform API operations with oTable
     *    }
     */
    "bRetrieve": false,
    /**
     * When vertical (y) scrolling is enabled, DataTables will force the height of
     * the table's viewport to the given height at all times (useful for layout).
     * However, this can look odd when filtering data down to a small data set,
     * and the footer is left "floating" further down. This parameter (when
     * enabled) will cause DataTables to collapse the table's viewport down when
     * the result set will fit within the given Y height.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.scrollCollapse
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollY": "200",
     *        "scrollCollapse": true
     *      } );
     *    } );
     */
    "bScrollCollapse": false,
    /**
     * Configure DataTables to use server-side processing. Note that the
     * `ajax` parameter must also be given in order to give DataTables a
     * source to obtain the required data for each draw.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverSide
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "xhr.php"
     *      } );
     *    } );
     */
    "bServerSide": false,
    /**
     * Enable or disable sorting of columns. Sorting of individual columns can be
     * disabled by the `sortable` option for each column.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.ordering
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "ordering": false
     *      } );
     *    } );
     */
    "bSort": true,
    /**
     * Enable or display DataTables' ability to sort multiple columns at the
     * same time (activated by shift-click by the user).
     *  @type boolean
     *  @default true
     *
     *  @dtopt Options
     *  @name DataTable.defaults.orderMulti
     *
     *  @example
     *    // Disable multiple column sorting ability
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "orderMulti": false
     *      } );
     *    } );
     */
    "bSortMulti": true,
    /**
     * Allows control over whether DataTables should use the top (true) unique
     * cell that is found for a single column, or the bottom (false - default).
     * This is useful when using complex headers.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.orderCellsTop
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "orderCellsTop": true
     *      } );
     *    } );
     */
    "bSortCellsTop": false,
    /**
     * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
     * `sorting\_3` to the columns which are currently being sorted on. This is
     * presented as a feature switch as it can increase processing time (while
     * classes are removed and added) so for large data sets you might want to
     * turn this off.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.orderClasses
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "orderClasses": false
     *      } );
     *    } );
     */
    "bSortClasses": true,
    /**
     * Enable or disable state saving. When enabled HTML5 `localStorage` will be
     * used to save table display information such as pagination information,
     * display length, filtering and sorting. As such when the end user reloads
     * the page the display display will match what thy had previously set up.
     *
     * Due to the use of `localStorage` the default state saving is not supported
     * in IE6 or 7. If state saving is required in those browsers, use
     * `stateSaveCallback` to provide a storage solution such as cookies.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.stateSave
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "stateSave": true
     *      } );
     *    } );
     */
    "bStateSave": false,
    /**
     * This function is called when a TR element is created (and all TD child
     * elements have been inserted), or registered if using a DOM source, allowing
     * manipulation of the TR element (adding classes etc).
     *  @type function
     *  @param {node} row "TR" element for the current row
     *  @param {array} data Raw data array for this row
     *  @param {int} dataIndex The index of this row in the internal aoData array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.createdRow
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "createdRow": function( row, data, dataIndex ) {
     *          // Bold the grade for all 'A' grade browsers
     *          if ( data[4] == "A" )
     *          {
     *            $('td:eq(4)', row).html( '<b>A</b>' );
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnCreatedRow": null,
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify any aspect you want about the created DOM.
     *  @type function
     *  @param {object} settings DataTables settings object
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.drawCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "drawCallback": function( settings ) {
     *          alert( 'DataTables has redrawn the table' );
     *        }
     *      } );
     *    } );
     */
    "fnDrawCallback": null,
    /**
     * Identical to fnHeaderCallback() but for the table footer this function
     * allows you to modify the table footer on every 'draw' event.
     *  @type function
     *  @param {node} foot "TR" element for the footer
     *  @param {array} data Full table data (as derived from the original HTML)
     *  @param {int} start Index for the current display starting point in the
     *    display array
     *  @param {int} end Index for the current display ending point in the
     *    display array
     *  @param {array int} display Index array to translate the visual position
     *    to the full data array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.footerCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "footerCallback": function( tfoot, data, start, end, display ) {
     *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
     *        }
     *      } );
     *    } )
     */
    "fnFooterCallback": null,
    /**
     * When rendering large numbers in the information element for the table
     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
     * to have a comma separator for the 'thousands' units (e.g. 1 million is
     * rendered as "1,000,000") to help readability for the end user. This
     * function will override the default method DataTables uses.
     *  @type function
     *  @member
     *  @param {int} toFormat number to be formatted
     *  @returns {string} formatted string for DataTables to show the number
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.formatNumber
     *
     *  @example
     *    // Format a number using a single quote for the separator (note that
     *    // this can also be done with the language.thousands option)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "formatNumber": function ( toFormat ) {
     *          return toFormat.toString().replace(
     *            /\B(?=(\d{3})+(?!\d))/g, "'"
     *          );
     *        };
     *      } );
     *    } );
     */
    "fnFormatNumber": function(toFormat) {
      return toFormat.toString().replace(
        /\B(?=(\d{3})+(?!\d))/g,
        this.oLanguage.sThousands
      );
    },
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify the header row. This can be used to calculate and
     * display useful information about the table.
     *  @type function
     *  @param {node} head "TR" element for the header
     *  @param {array} data Full table data (as derived from the original HTML)
     *  @param {int} start Index for the current display starting point in the
     *    display array
     *  @param {int} end Index for the current display ending point in the
     *    display array
     *  @param {array int} display Index array to translate the visual position
     *    to the full data array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.headerCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "fheaderCallback": function( head, data, start, end, display ) {
     *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
     *        }
     *      } );
     *    } )
     */
    "fnHeaderCallback": null,
    /**
     * The information element can be used to convey information about the current
     * state of the table. Although the internationalisation options presented by
     * DataTables are quite capable of dealing with most customisations, there may
     * be times where you wish to customise the string further. This callback
     * allows you to do exactly that.
     *  @type function
     *  @param {object} oSettings DataTables settings object
     *  @param {int} start Starting position in data for the draw
     *  @param {int} end End position in data for the draw
     *  @param {int} max Total number of rows in the table (regardless of
     *    filtering)
     *  @param {int} total Total number of rows in the data set, after filtering
     *  @param {string} pre The string that DataTables has formatted using it's
     *    own rules
     *  @returns {string} The string to be displayed in the information element.
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.infoCallback
     *
     *  @example
     *    $('#example').dataTable( {
     *      "infoCallback": function( settings, start, end, max, total, pre ) {
     *        return start +" to "+ end;
     *      }
     *    } );
     */
    "fnInfoCallback": null,
    /**
     * Called when the table has been initialised. Normally DataTables will
     * initialise sequentially and there will be no need for this function,
     * however, this does not hold true when using external language information
     * since that is obtained using an async XHR call.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} json The JSON object request from the server - only
     *    present if client-side Ajax sourced data is used
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.initComplete
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "initComplete": function(settings, json) {
     *          alert( 'DataTables has finished its initialisation.' );
     *        }
     *      } );
     *    } )
     */
    "fnInitComplete": null,
    /**
     * Called at the very start of each table draw and can be used to cancel the
     * draw by returning false, any other return (including undefined) results in
     * the full draw occurring).
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @returns {boolean} False will cancel the draw, anything else (including no
     *    return) will allow it to complete.
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.preDrawCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "preDrawCallback": function( settings ) {
     *          if ( $('#test').val() == 1 ) {
     *            return false;
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnPreDrawCallback": null,
    /**
     * This function allows you to 'post process' each row after it have been
     * generated for each table draw, but before it is rendered on screen. This
     * function might be used for setting the row class name etc.
     *  @type function
     *  @param {node} row "TR" element for the current row
     *  @param {array} data Raw data array for this row
     *  @param {int} displayIndex The display index for the current table draw
     *  @param {int} displayIndexFull The index of the data in the full list of
     *    rows (after filtering)
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.rowCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
     *          // Bold the grade for all 'A' grade browsers
     *          if ( data[4] == "A" ) {
     *            $('td:eq(4)', row).html( '<b>A</b>' );
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnRowCallback": null,
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * This parameter allows you to override the default function which obtains
     * the data from the server so something more suitable for your application.
     * For example you could use POST data, or pull information from a Gears or
     * AIR database.
     *  @type function
     *  @member
     *  @param {string} source HTTP source to obtain the data from (`ajax`)
     *  @param {array} data A key/value pair object containing the data to send
     *    to the server
     *  @param {function} callback to be called on completion of the data get
     *    process that will draw the data on the page.
     *  @param {object} settings DataTables settings object
     *
     *  @dtopt Callbacks
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverData
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "fnServerData": null,
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     *  It is often useful to send extra data to the server when making an Ajax
     * request - for example custom filtering information, and this callback
     * function makes it trivial to send extra information to the server. The
     * passed in parameter is the data set that has been constructed by
     * DataTables, and you can add to this or modify it as you require.
     *  @type function
     *  @param {array} data Data array (array of objects which are name/value
     *    pairs) that has been constructed by DataTables and will be sent to the
     *    server. In the case of Ajax sourced data with server-side processing
     *    this will be an empty array, for server-side processing there will be a
     *    significant number of parameters!
     *  @returns {undefined} Ensure that you modify the data array passed in,
     *    as this is passed by reference.
     *
     *  @dtopt Callbacks
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverParams
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "fnServerParams": null,
    /**
     * Load the table state. With this function you can define from where, and how, the
     * state of a table is loaded. By default DataTables will load from `localStorage`
     * but you might wish to use a server-side database or cookies.
     *  @type function
     *  @member
     *  @param {object} settings DataTables settings object
     *  @param {object} callback Callback that can be executed when done. It
     *    should be passed the loaded state object.
     *  @return {object} The DataTables state object to be loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoadCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadCallback": function (settings, callback) {
     *          $.ajax( {
     *            "url": "/state_load",
     *            "dataType": "json",
     *            "success": function (json) {
     *              callback( json );
     *            }
     *          } );
     *        }
     *      } );
     *    } );
     */
    "fnStateLoadCallback": function(settings) {
      try {
        return JSON.parse(
          (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
            "DataTables_" + settings.sInstance + "_" + location.pathname
          )
        );
      } catch (e) {
        return {};
      }
    },
    /**
     * Callback which allows modification of the saved state prior to loading that state.
     * This callback is called when the table is loading state from the stored data, but
     * prior to the settings object being modified by the saved state. Note that for
     * plug-in authors, you should use the `stateLoadParams` event to load parameters for
     * a plug-in.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object that is to be loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoadParams
     *
     *  @example
     *    // Remove a saved filter, so filtering is never loaded
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadParams": function (settings, data) {
     *          data.oSearch.sSearch = "";
     *        }
     *      } );
     *    } );
     *
     *  @example
     *    // Disallow state loading by returning false
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadParams": function (settings, data) {
     *          return false;
     *        }
     *      } );
     *    } );
     */
    "fnStateLoadParams": null,
    /**
     * Callback that is called when the state has been loaded from the state saving method
     * and the DataTables settings object has been modified as a result of the loaded state.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object that was loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoaded
     *
     *  @example
     *    // Show an alert with the filtering value that was saved
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoaded": function (settings, data) {
     *          alert( 'Saved filter was: '+data.oSearch.sSearch );
     *        }
     *      } );
     *    } );
     */
    "fnStateLoaded": null,
    /**
     * Save the table state. This function allows you to define where and how the state
     * information for the table is stored By default DataTables will use `localStorage`
     * but you might wish to use a server-side database or cookies.
     *  @type function
     *  @member
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object to be saved
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateSaveCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateSaveCallback": function (settings, data) {
     *          // Send an Ajax request to the server with the state object
     *          $.ajax( {
     *            "url": "/state_save",
     *            "data": data,
     *            "dataType": "json",
     *            "method": "POST"
     *            "success": function () {}
     *          } );
     *        }
     *      } );
     *    } );
     */
    "fnStateSaveCallback": function(settings, data) {
      try {
        (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
          "DataTables_" + settings.sInstance + "_" + location.pathname,
          JSON.stringify(data)
        );
      } catch (e) {
      }
    },
    /**
     * Callback which allows modification of the state to be saved. Called when the table
     * has changed state a new state save is required. This method allows modification of
     * the state saving object prior to actually doing the save, including addition or
     * other state properties or modification. Note that for plug-in authors, you should
     * use the `stateSaveParams` event to save parameters for a plug-in.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object to be saved
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateSaveParams
     *
     *  @example
     *    // Remove a saved filter, so filtering is never saved
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateSaveParams": function (settings, data) {
     *          data.oSearch.sSearch = "";
     *        }
     *      } );
     *    } );
     */
    "fnStateSaveParams": null,
    /**
     * Duration for which the saved state information is considered valid. After this period
     * has elapsed the state will be returned to the default.
     * Value is given in seconds.
     *  @type int
     *  @default 7200 <i>(2 hours)</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.stateDuration
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateDuration": 60*60*24; // 1 day
     *      } );
     *    } )
     */
    "iStateDuration": 7200,
    /**
     * When enabled DataTables will not make a request to the server for the first
     * page draw - rather it will use the data already on the page (no sorting etc
     * will be applied to it), thus saving on an XHR at load time. `deferLoading`
     * is used to indicate that deferred loading is required, but it is also used
     * to tell DataTables how many records there are in the full table (allowing
     * the information element and pagination to be displayed correctly). In the case
     * where a filtering is applied to the table on initial load, this can be
     * indicated by giving the parameter as an array, where the first element is
     * the number of records available after filtering and the second element is the
     * number of records without filtering (allowing the table information element
     * to be shown correctly).
     *  @type int | array
     *  @default null
     *
     *  @dtopt Options
     *  @name DataTable.defaults.deferLoading
     *
     *  @example
     *    // 57 records available in the table, no filtering applied
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "scripts/server_processing.php",
     *        "deferLoading": 57
     *      } );
     *    } );
     *
     *  @example
     *    // 57 records after filtering, 100 without filtering (an initial filter applied)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "scripts/server_processing.php",
     *        "deferLoading": [ 57, 100 ],
     *        "search": {
     *          "search": "my_filter"
     *        }
     *      } );
     *    } );
     */
    "iDeferLoading": null,
    /**
     * Number of rows to display on a single page when using pagination. If
     * feature enabled (`lengthChange`) then the end user will be able to override
     * this to a custom setting using a pop-up menu.
     *  @type int
     *  @default 10
     *
     *  @dtopt Options
     *  @name DataTable.defaults.pageLength
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "pageLength": 50
     *      } );
     *    } )
     */
    "iDisplayLength": 10,
    /**
     * Define the starting point for data display when using DataTables with
     * pagination. Note that this parameter is the number of records, rather than
     * the page number, so if you have 10 records per page and want to start on
     * the third page, it should be "20".
     *  @type int
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.displayStart
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "displayStart": 20
     *      } );
     *    } )
     */
    "iDisplayStart": 0,
    /**
     * By default DataTables allows keyboard navigation of the table (sorting, paging,
     * and filtering) by adding a `tabindex` attribute to the required elements. This
     * allows you to tab through the controls and press the enter key to activate them.
     * The tabindex is default 0, meaning that the tab follows the flow of the document.
     * You can overrule this using this parameter if you wish. Use a value of -1 to
     * disable built-in keyboard navigation.
     *  @type int
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.tabIndex
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "tabIndex": 1
     *      } );
     *    } );
     */
    "iTabIndex": 0,
    /**
     * Classes that DataTables assigns to the various components and features
     * that it adds to the HTML table. This allows classes to be configured
     * during initialisation in addition to through the static
     * {@link DataTable.ext.oStdClasses} object).
     *  @namespace
     *  @name DataTable.defaults.classes
     */
    "oClasses": {},
    /**
     * All strings that DataTables uses in the user interface that it creates
     * are defined in this object, allowing you to modified them individually or
     * completely replace them all as required.
     *  @namespace
     *  @name DataTable.defaults.language
     */
    "oLanguage": {
      /**
       * Strings that are used for WAI-ARIA labels and controls only (these are not
       * actually visible on the page, but will be read by screenreaders, and thus
       * must be internationalised as well).
       *  @namespace
       *  @name DataTable.defaults.language.aria
       */
      "oAria": {
        /**
         * ARIA label that is added to the table headers when the column may be
         * sorted ascending by activing the column (click or return when focused).
         * Note that the column header is prefixed to this string.
         *  @type string
         *  @default : activate to sort column ascending
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.aria.sortAscending
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "aria": {
         *            "sortAscending": " - click/return to sort ascending"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sSortAscending": ": activate to sort column ascending",
        /**
         * ARIA label that is added to the table headers when the column may be
         * sorted descending by activing the column (click or return when focused).
         * Note that the column header is prefixed to this string.
         *  @type string
         *  @default : activate to sort column ascending
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.aria.sortDescending
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "aria": {
         *            "sortDescending": " - click/return to sort descending"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sSortDescending": ": activate to sort column descending"
      },
      /**
       * Pagination string used by DataTables for the built-in pagination
       * control types.
       *  @namespace
       *  @name DataTable.defaults.language.paginate
       */
      "oPaginate": {
        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the first page.
         *  @type string
         *  @default First
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.first
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "first": "First page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sFirst": "First",
        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the last page.
         *  @type string
         *  @default Last
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.last
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "last": "Last page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sLast": "Last",
        /**
         * Text to use for the 'next' pagination button (to take the user to the
         * next page).
         *  @type string
         *  @default Next
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.next
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "next": "Next page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sNext": "Next",
        /**
         * Text to use for the 'previous' pagination button (to take the user to
         * the previous page).
         *  @type string
         *  @default Previous
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.previous
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "previous": "Previous page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sPrevious": "Previous"
      },
      /**
       * This string is shown in preference to `zeroRecords` when the table is
       * empty of data (regardless of filtering). Note that this is an optional
       * parameter - if it is not given, the value of `zeroRecords` will be used
       * instead (either the default or given value).
       *  @type string
       *  @default No data available in table
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.emptyTable
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "emptyTable": "No data available in table"
       *        }
       *      } );
       *    } );
       */
      "sEmptyTable": "No data available in table",
      /**
       * This string gives information to the end user about the information
       * that is current on display on the page. The following tokens can be
       * used in the string and will be dynamically replaced as the table
       * display updates. This tokens can be placed anywhere in the string, or
       * removed as needed by the language requires:
       *
       * * `\_START\_` - Display index of the first record on the current page
       * * `\_END\_` - Display index of the last record on the current page
       * * `\_TOTAL\_` - Number of records in the table after filtering
       * * `\_MAX\_` - Number of records in the table without filtering
       * * `\_PAGE\_` - Current page number
       * * `\_PAGES\_` - Total number of pages of data in the table
       *
       *  @type string
       *  @default Showing _START_ to _END_ of _TOTAL_ entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.info
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "info": "Showing page _PAGE_ of _PAGES_"
       *        }
       *      } );
       *    } );
       */
      "sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",
      /**
       * Display information string for when the table is empty. Typically the
       * format of this string should match `info`.
       *  @type string
       *  @default Showing 0 to 0 of 0 entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoEmpty
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoEmpty": "No entries to show"
       *        }
       *      } );
       *    } );
       */
      "sInfoEmpty": "Showing 0 to 0 of 0 entries",
      /**
       * When a user filters the information in a table, this string is appended
       * to the information (`info`) to give an idea of how strong the filtering
       * is. The variable _MAX_ is dynamically updated.
       *  @type string
       *  @default (filtered from _MAX_ total entries)
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoFiltered
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoFiltered": " - filtering from _MAX_ records"
       *        }
       *      } );
       *    } );
       */
      "sInfoFiltered": "(filtered from _MAX_ total entries)",
      /**
       * If can be useful to append extra information to the info string at times,
       * and this variable does exactly that. This information will be appended to
       * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
       * being used) at all times.
       *  @type string
       *  @default <i>Empty string</i>
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoPostFix
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoPostFix": "All records shown are derived from real information."
       *        }
       *      } );
       *    } );
       */
      "sInfoPostFix": "",
      /**
       * This decimal place operator is a little different from the other
       * language options since DataTables doesn't output floating point
       * numbers, so it won't ever use this for display of a number. Rather,
       * what this parameter does is modify the sort methods of the table so
       * that numbers which are in a format which has a character other than
       * a period (`.`) as a decimal place will be sorted numerically.
       *
       * Note that numbers with different decimal places cannot be shown in
       * the same table and still be sortable, the table must be consistent.
       * However, multiple different tables on the page can use different
       * decimal place characters.
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.decimal
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "decimal": ","
       *          "thousands": "."
       *        }
       *      } );
       *    } );
       */
      "sDecimal": "",
      /**
       * DataTables has a build in number formatter (`formatNumber`) which is
       * used to format large numbers that are used in the table information.
       * By default a comma is used, but this can be trivially changed to any
       * character you wish with this parameter.
       *  @type string
       *  @default ,
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.thousands
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "thousands": "'"
       *        }
       *      } );
       *    } );
       */
      "sThousands": ",",
      /**
       * Detail the action that will be taken when the drop down menu for the
       * pagination length option is changed. The '_MENU_' variable is replaced
       * with a default select list of 10, 25, 50 and 100, and can be replaced
       * with a custom select box if required.
       *  @type string
       *  @default Show _MENU_ entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.lengthMenu
       *
       *  @example
       *    // Language change only
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "lengthMenu": "Display _MENU_ records"
       *        }
       *      } );
       *    } );
       *
       *  @example
       *    // Language and options change
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "lengthMenu": 'Display <select>'+
       *            '<option value="10">10</option>'+
       *            '<option value="20">20</option>'+
       *            '<option value="30">30</option>'+
       *            '<option value="40">40</option>'+
       *            '<option value="50">50</option>'+
       *            '<option value="-1">All</option>'+
       *            '</select> records'
       *        }
       *      } );
       *    } );
       */
      "sLengthMenu": "Show _MENU_ entries",
      /**
       * When using Ajax sourced data and during the first draw when DataTables is
       * gathering the data, this message is shown in an empty row in the table to
       * indicate to the end user the the data is being loaded. Note that this
       * parameter is not used when loading data by server-side processing, just
       * Ajax sourced data with client-side processing.
       *  @type string
       *  @default Loading...
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.loadingRecords
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "loadingRecords": "Please wait - loading..."
       *        }
       *      } );
       *    } );
       */
      "sLoadingRecords": "Loading...",
      /**
       * Text which is displayed when the table is processing a user action
       * (usually a sort command or similar).
       *  @type string
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.processing
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "processing": "DataTables is currently busy"
       *        }
       *      } );
       *    } );
       */
      "sProcessing": "",
      /**
       * Details the actions that will be taken when the user types into the
       * filtering input text box. The variable "_INPUT_", if used in the string,
       * is replaced with the HTML text box for the filtering input allowing
       * control over where it appears in the string. If "_INPUT_" is not given
       * then the input box is appended to the string automatically.
       *  @type string
       *  @default Search:
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.search
       *
       *  @example
       *    // Input text box will be appended at the end automatically
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "search": "Filter records:"
       *        }
       *      } );
       *    } );
       *
       *  @example
       *    // Specify where the filter should appear
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "search": "Apply filter _INPUT_ to table"
       *        }
       *      } );
       *    } );
       */
      "sSearch": "Search:",
      /**
       * Assign a `placeholder` attribute to the search `input` element
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.searchPlaceholder
       */
      "sSearchPlaceholder": "",
      /**
       * All of the language information can be stored in a file on the
       * server-side, which DataTables will look up if this parameter is passed.
       * It must store the URL of the language file, which is in a JSON format,
       * and the object has the same properties as the oLanguage object in the
       * initialiser object (i.e. the above parameters). Please refer to one of
       * the example language files to see how this works in action.
       *  @type string
       *  @default <i>Empty string - i.e. disabled</i>
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.url
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "url": "https://www.sprymedia.co.uk/dataTables/lang.txt"
       *        }
       *      } );
       *    } );
       */
      "sUrl": "",
      /**
       * Text shown inside the table records when the is no information to be
       * displayed after filtering. `emptyTable` is shown when there is simply no
       * information in the table at all (regardless of filtering).
       *  @type string
       *  @default No matching records found
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.zeroRecords
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "zeroRecords": "No records to display"
       *        }
       *      } );
       *    } );
       */
      "sZeroRecords": "No matching records found"
    },
    /**
     * This parameter allows you to have define the global filtering state at
     * initialisation time. As an object the `search` parameter must be
     * defined, but all other parameters are optional. When `regex` is true,
     * the search string will be treated as a regular expression, when false
     * (default) it will be treated as a straight string. When `smart`
     * DataTables will use it's smart filtering methods (to word match at
     * any point in the data), when false this will not be done.
     *  @namespace
     *  @extends DataTable.models.oSearch
     *
     *  @dtopt Options
     *  @name DataTable.defaults.search
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "search": {"search": "Initial search"}
     *      } );
     *    } )
     */
    "oSearch": $2.extend({}, DataTable.models.oSearch),
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * By default DataTables will look for the property `data` (or `aaData` for
     * compatibility with DataTables 1.9-) when obtaining data from an Ajax
     * source or for server-side processing - this parameter allows that
     * property to be changed. You can use Javascript dotted object notation to
     * get a data source for multiple levels of nesting.
     *  @type string
     *  @default data
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.ajaxDataProp
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sAjaxDataProp": "data",
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * You can instruct DataTables to load data from an external
     * source using this parameter (use aData if you want to pass data in you
     * already have). Simply provide a url a JSON object can be obtained from.
     *  @type string
     *  @default null
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.ajaxSource
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sAjaxSource": null,
    /**
     * This initialisation variable allows you to specify exactly where in the
     * DOM you want DataTables to inject the various controls it adds to the page
     * (for example you might want the pagination controls at the top of the
     * table). DIV elements (with or without a custom class) can also be added to
     * aid styling. The follow syntax is used:
     *   <ul>
     *     <li>The following options are allowed:
     *       <ul>
     *         <li>'l' - Length changing</li>
     *         <li>'f' - Filtering input</li>
     *         <li>'t' - The table!</li>
     *         <li>'i' - Information</li>
     *         <li>'p' - Pagination</li>
     *         <li>'r' - pRocessing</li>
     *       </ul>
     *     </li>
     *     <li>The following constants are allowed:
     *       <ul>
     *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
     *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
     *       </ul>
     *     </li>
     *     <li>The following syntax is expected:
     *       <ul>
     *         <li>'&lt;' and '&gt;' - div elements</li>
     *         <li>'&lt;"class" and '&gt;' - div with a class</li>
     *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
     *       </ul>
     *     </li>
     *     <li>Examples:
     *       <ul>
     *         <li>'&lt;"wrapper"flipt&gt;'</li>
     *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
     *       </ul>
     *     </li>
     *   </ul>
     *  @type string
     *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
     *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.dom
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
     *      } );
     *    } );
     */
    "sDom": "lfrtip",
    /**
     * Search delay option. This will throttle full table searches that use the
     * DataTables provided search input element (it does not effect calls to
     * `dt-api search()`, providing a delay before the search is made.
     *  @type integer
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.searchDelay
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "searchDelay": 200
     *      } );
     *    } )
     */
    "searchDelay": null,
    /**
     * DataTables features six different built-in options for the buttons to
     * display for pagination control:
     *
     * * `numbers` - Page number buttons only
     * * `simple` - 'Previous' and 'Next' buttons only
     * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
     * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
     * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
     * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
     *  
     * Further methods can be added using {@link DataTable.ext.oPagination}.
     *  @type string
     *  @default simple_numbers
     *
     *  @dtopt Options
     *  @name DataTable.defaults.pagingType
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "pagingType": "full_numbers"
     *      } );
     *    } )
     */
    "sPaginationType": "simple_numbers",
    /**
     * Enable horizontal scrolling. When a table is too wide to fit into a
     * certain layout, or you have a large number of columns in the table, you
     * can enable x-scrolling to show the table in a viewport, which can be
     * scrolled. This property can be `true` which will allow the table to
     * scroll horizontally when needed, or any CSS unit, or a number (in which
     * case it will be treated as a pixel measurement). Setting as simply `true`
     * is recommended.
     *  @type boolean|string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Features
     *  @name DataTable.defaults.scrollX
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollX": true,
     *        "scrollCollapse": true
     *      } );
     *    } );
     */
    "sScrollX": "",
    /**
     * This property can be used to force a DataTable to use more width than it
     * might otherwise do when x-scrolling is enabled. For example if you have a
     * table which requires to be well spaced, this parameter is useful for
     * "over-sizing" the table, and thus forcing scrolling. This property can by
     * any CSS unit, or a number (in which case it will be treated as a pixel
     * measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.scrollXInner
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollX": "100%",
     *        "scrollXInner": "110%"
     *      } );
     *    } );
     */
    "sScrollXInner": "",
    /**
     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
     * to the given height, and enable scrolling for any data which overflows the
     * current viewport. This can be used as an alternative to paging to display
     * a lot of data in a small area (although paging and scrolling can both be
     * enabled at the same time). This property can be any CSS unit, or a number
     * (in which case it will be treated as a pixel measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Features
     *  @name DataTable.defaults.scrollY
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollY": "200px",
     *        "paginate": false
     *      } );
     *    } );
     */
    "sScrollY": "",
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * Set the HTTP method that is used to make the Ajax call for server-side
     * processing or Ajax sourced data.
     *  @type string
     *  @default GET
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverMethod
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sServerMethod": "GET",
    /**
     * DataTables makes use of renderers when displaying HTML elements for
     * a table. These renderers can be added or modified by plug-ins to
     * generate suitable mark-up for a site. For example the Bootstrap
     * integration plug-in for DataTables uses a paging button renderer to
     * display pagination buttons in the mark-up required by Bootstrap.
     *
     * For further information about the renderers available see
     * DataTable.ext.renderer
     *  @type string|object
     *  @default null
     *
     *  @name DataTable.defaults.renderer
     *
     */
    "renderer": null,
    /**
     * Set the data property name that DataTables should use to get a row's id
     * to set as the `id` property in the node.
     *  @type string
     *  @default DT_RowId
     *
     *  @name DataTable.defaults.rowId
     */
    "rowId": "DT_RowId"
  };
  _fnHungarianMap(DataTable.defaults);
  DataTable.defaults.column = {
    /**
     * Define which column(s) an order will occur on for this column. This
     * allows a column's ordering to take multiple columns into account when
     * doing a sort or use the data from a different column. For example first
     * name / last name columns make sense to do a multi-column sort over the
     * two columns.
     *  @type array|int
     *  @default null <i>Takes the value of the column index automatically</i>
     *
     *  @name DataTable.defaults.column.orderData
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
     *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
     *          { "orderData": 2, "targets": [ 2 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "orderData": [ 0, 1 ] },
     *          { "orderData": [ 1, 0 ] },
     *          { "orderData": 2 },
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "aDataSort": null,
    "iDataSort": -1,
    /**
     * You can control the default ordering direction, and even alter the
     * behaviour of the sort handler (i.e. only allow ascending ordering etc)
     * using this parameter.
     *  @type array
     *  @default [ 'asc', 'desc' ]
     *
     *  @name DataTable.defaults.column.orderSequence
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
     *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
     *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          { "orderSequence": [ "asc" ] },
     *          { "orderSequence": [ "desc", "asc", "asc" ] },
     *          { "orderSequence": [ "desc" ] },
     *          null
     *        ]
     *      } );
     *    } );
     */
    "asSorting": ["asc", "desc"],
    /**
     * Enable or disable filtering on the data in this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.searchable
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "searchable": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "searchable": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bSearchable": true,
    /**
     * Enable or disable ordering on this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.orderable
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderable": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "orderable": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bSortable": true,
    /**
     * Enable or disable the display of this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.visible
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "visible": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "visible": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bVisible": true,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     *  @type function
     *  @param {element} td The TD node that has been created
     *  @param {*} cellData The Data for the cell
     *  @param {array|object} rowData The data for the whole row
     *  @param {int} row The row index for the aoData data store
     *  @param {int} col The column index for aoColumns
     *
     *  @name DataTable.defaults.column.createdCell
     *  @dtopt Columns
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [3],
     *          "createdCell": function (td, cellData, rowData, row, col) {
     *            if ( cellData == "1.7" ) {
     *              $(td).css('color', 'blue')
     *            }
     *          }
     *        } ]
     *      });
     *    } );
     */
    "fnCreatedCell": null,
    /**
     * This parameter has been replaced by `data` in DataTables to ensure naming
     * consistency. `dataProp` can still be used, as there is backwards
     * compatibility in DataTables for this option, but it is strongly
     * recommended that you use `data` in preference to `dataProp`.
     *  @name DataTable.defaults.column.dataProp
     */
    /**
     * This property can be used to read data from any data source property,
     * including deeply nested objects / properties. `data` can be given in a
     * number of different ways which effect its behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object. Note that
     *      function notation is recommended for use in `render` rather than
     *      `data` as it is much simpler to use as a renderer.
     * * `null` - use the original data source for the row rather than plucking
     *   data directly from it. This action has effects on two other
     *   initialisation options:
     *    * `defaultContent` - When null is given as the `data` option and
     *      `defaultContent` is specified for the column, the value defined by
     *      `defaultContent` will be used for the cell.
     *    * `render` - When null is used for the `data` option and the `render`
     *      option is specified for the column, the whole data source for the
     *      row is used for the renderer.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * `{array|object}` The data source for the row
     *      * `{string}` The type call data requested - this will be 'set' when
     *        setting data or 'filter', 'display', 'type', 'sort' or undefined
     *        when gathering data. Note that when `undefined` is given for the
     *        type DataTables expects to get the raw data for the object back<
     *      * `{*}` Data to set when the second parameter is 'set'.
     *    * Return:
     *      * The return value from the function is not required when 'set' is
     *        the type of call, but otherwise the return is what will be used
     *        for the data requested.
     *
     * Note that `data` is a getter and setter option. If you just require
     * formatting of data for output, you will likely want to use `render` which
     * is simply a getter and thus simpler to use.
     *
     * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
     * name change reflects the flexibility of this property and is consistent
     * with the naming of mRender. If 'mDataProp' is given, then it will still
     * be used by DataTables, as it automatically maps the old name to the new
     * if required.
     *
     *  @type string|int|function|null
     *  @default null <i>Use automatically calculated column index</i>
     *
     *  @name DataTable.defaults.column.data
     *  @dtopt Columns
     *
     *  @example
     *    // Read table data from objects
     *    // JSON structure for each row:
     *    //   {
     *    //      "engine": {value},
     *    //      "browser": {value},
     *    //      "platform": {value},
     *    //      "version": {value},
     *    //      "grade": {value}
     *    //   }
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/objects.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          { "data": "platform" },
     *          { "data": "version" },
     *          { "data": "grade" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Read information from deeply nested objects
     *    // JSON structure for each row:
     *    //   {
     *    //      "engine": {value},
     *    //      "browser": {value},
     *    //      "platform": {
     *    //         "inner": {value}
     *    //      },
     *    //      "details": [
     *    //         {value}, {value}
     *    //      ]
     *    //   }
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/deep.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          { "data": "platform.inner" },
     *          { "data": "details.0" },
     *          { "data": "details.1" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `data` as a function to provide different information for
     *    // sorting, filtering and display. In this case, currency (price)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": function ( source, type, val ) {
     *            if (type === 'set') {
     *              source.price = val;
     *              // Store the computed display and filter values for efficiency
     *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
     *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
     *              return;
     *            }
     *            else if (type === 'display') {
     *              return source.price_display;
     *            }
     *            else if (type === 'filter') {
     *              return source.price_filter;
     *            }
     *            // 'sort', 'type' and undefined all just use the integer
     *            return source.price;
     *          }
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using default content
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null,
     *          "defaultContent": "Click to edit"
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using array notation - outputting a list from an array
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": "name[, ]"
     *        } ]
     *      } );
     *    } );
     *
     */
    "mData": null,
    /**
     * This property is the rendering partner to `data` and it is suggested that
     * when you want to manipulate data for display (including filtering,
     * sorting etc) without altering the underlying data for the table, use this
     * property. `render` can be considered to be the the read only companion to
     * `data` which is read / write (then as such more complex). Like `data`
     * this option can be given in a number of different ways to effect its
     * behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object.
     * * `object` - use different data for the different data types requested by
     *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
     *   of the object is the data type the property refers to and the value can
     *   defined using an integer, string or function using the same rules as
     *   `render` normally does. Note that an `_` option _must_ be specified.
     *   This is the default value to use if you haven't specified a value for
     *   the data type requested by DataTables.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * {array|object} The data source for the row (based on `data`)
     *      * {string} The type call data requested - this will be 'filter',
     *        'display', 'type' or 'sort'.
     *      * {array|object} The full data source for the row (not based on
     *        `data`)
     *    * Return:
     *      * The return value from the function is what will be used for the
     *        data requested.
     *
     *  @type string|int|function|object|null
     *  @default null Use the data source value.
     *
     *  @name DataTable.defaults.column.render
     *  @dtopt Columns
     *
     *  @example
     *    // Create a comma separated list from an array of objects
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/deep.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          {
     *            "data": "platform",
     *            "render": "[, ].name"
     *          }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Execute a function to obtain data
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null, // Use the full data source object for the renderer's source
     *          "render": "browserName()"
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // As an object, extracting different data for the different types
     *    // This would be used with a data source such as:
     *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
     *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
     *    // (which has both forms) is used for filtering for if a user inputs either format, while
     *    // the formatted phone number is the one that is shown in the table.
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null, // Use the full data source object for the renderer's source
     *          "render": {
     *            "_": "phone",
     *            "filter": "phone_filter",
     *            "display": "phone_display"
     *          }
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Use as a function to create a link from the data source
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": "download_link",
     *          "render": function ( data, type, full ) {
     *            return '<a href="'+data+'">Download</a>';
     *          }
     *        } ]
     *      } );
     *    } );
     */
    "mRender": null,
    /**
     * Change the cell type created for the column - either TD cells or TH cells. This
     * can be useful as TH cells have semantic meaning in the table body, allowing them
     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
     *  @type string
     *  @default td
     *
     *  @name DataTable.defaults.column.cellType
     *  @dtopt Columns
     *
     *  @example
     *    // Make the first column use TH cells
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "cellType": "th"
     *        } ]
     *      } );
     *    } );
     */
    "sCellType": "td",
    /**
     * Class to give to each cell in this column.
     *  @type string
     *  @default <i>Empty string</i>
     *
     *  @name DataTable.defaults.column.class
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "class": "my_class", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "class": "my_class" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sClass": "",
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     * Generally you shouldn't need this!
     *  @type string
     *  @default <i>Empty string<i>
     *
     *  @name DataTable.defaults.column.contentPadding
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          null,
     *          {
     *            "contentPadding": "mmm"
     *          }
     *        ]
     *      } );
     *    } );
     */
    "sContentPadding": "",
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because `data`
     * is set to null, or because the data source itself is null).
     *  @type string
     *  @default null
     *
     *  @name DataTable.defaults.column.defaultContent
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          {
     *            "data": null,
     *            "defaultContent": "Edit",
     *            "targets": [ -1 ]
     *          }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          null,
     *          {
     *            "data": null,
     *            "defaultContent": "Edit"
     *          }
     *        ]
     *      } );
     *    } );
     */
    "sDefaultContent": null,
    /**
     * This parameter is only used in DataTables' server-side processing. It can
     * be exceptionally useful to know what columns are being displayed on the
     * client side, and to map these to database fields. When defined, the names
     * also allow DataTables to reorder information from the server if it comes
     * back in an unexpected order (i.e. if you switch your columns around on the
     * client-side, your server-side code does not also need updating).
     *  @type string
     *  @default <i>Empty string</i>
     *
     *  @name DataTable.defaults.column.name
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "name": "engine", "targets": [ 0 ] },
     *          { "name": "browser", "targets": [ 1 ] },
     *          { "name": "platform", "targets": [ 2 ] },
     *          { "name": "version", "targets": [ 3 ] },
     *          { "name": "grade", "targets": [ 4 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "name": "engine" },
     *          { "name": "browser" },
     *          { "name": "platform" },
     *          { "name": "version" },
     *          { "name": "grade" }
     *        ]
     *      } );
     *    } );
     */
    "sName": "",
    /**
     * Defines a data source type for the ordering which can be used to read
     * real-time information from the table (updating the internally cached
     * version) prior to ordering. This allows ordering to occur on user
     * editable elements such as form inputs.
     *  @type string
     *  @default std
     *
     *  @name DataTable.defaults.column.orderDataType
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
     *          { "type": "numeric", "targets": [ 3 ] },
     *          { "orderDataType": "dom-select", "targets": [ 4 ] },
     *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          { "orderDataType": "dom-text" },
     *          { "orderDataType": "dom-text", "type": "numeric" },
     *          { "orderDataType": "dom-select" },
     *          { "orderDataType": "dom-checkbox" }
     *        ]
     *      } );
     *    } );
     */
    "sSortDataType": "std",
    /**
     * The title of this column.
     *  @type string
     *  @default null <i>Derived from the 'TH' value for this column in the
     *    original HTML table.</i>
     *
     *  @name DataTable.defaults.column.title
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "title": "My column title", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "title": "My column title" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sTitle": null,
    /**
     * The type allows you to specify how the data for this column will be
     * ordered. Four types (string, numeric, date and html (which will strip
     * HTML tags before ordering)) are currently available. Note that only date
     * formats understood by Javascript's Date() object will be accepted as type
     * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
     * 'numeric', 'date' or 'html' (by default). Further types can be adding
     * through plug-ins.
     *  @type string
     *  @default null <i>Auto-detected from raw data</i>
     *
     *  @name DataTable.defaults.column.type
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "type": "html", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "type": "html" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sType": null,
    /**
     * Defining the width of the column, this parameter may take any CSS value
     * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
     * been given a specific width through this interface ensuring that the table
     * remains readable.
     *  @type string
     *  @default null <i>Automatic</i>
     *
     *  @name DataTable.defaults.column.width
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "width": "20%", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "width": "20%" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sWidth": null
  };
  _fnHungarianMap(DataTable.defaults.column);
  DataTable.models.oSettings = {
    /**
     * Primary features of DataTables and their enablement state.
     *  @namespace
     */
    "oFeatures": {
      /**
       * Flag to say if DataTables should automatically try to calculate the
       * optimum table and columns widths (true) or not (false).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bAutoWidth": null,
      /**
       * Delay the creation of TR and TD elements until they are actually
       * needed by a driven page draw. This can give a significant speed
       * increase for Ajax source and Javascript source data, but makes no
       * difference at all for DOM and server-side processing tables.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bDeferRender": null,
      /**
       * Enable filtering on the table or not. Note that if this is disabled
       * then there is no filtering at all on the table, including fnFilter.
       * To just remove the filtering input use sDom and remove the 'f' option.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bFilter": null,
      /**
       * Table information element (the 'Showing x of y records' div) enable
       * flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bInfo": null,
      /**
       * Present a user control allowing the end user to change the page size
       * when pagination is enabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bLengthChange": null,
      /**
       * Pagination enabled or not. Note that if this is disabled then length
       * changing must also be disabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bPaginate": null,
      /**
       * Processing indicator enable flag whenever DataTables is enacting a
       * user request - typically an Ajax request for server-side processing.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bProcessing": null,
      /**
       * Server-side processing enabled flag - when enabled DataTables will
       * get all data from the server for every draw - there is no filtering,
       * sorting or paging done on the client-side.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bServerSide": null,
      /**
       * Sorting enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSort": null,
      /**
       * Multi-column sorting
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSortMulti": null,
      /**
       * Apply a class to the columns which are being sorted to provide a
       * visual highlight or not. This can slow things down when enabled since
       * there is a lot of DOM interaction.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSortClasses": null,
      /**
       * State saving enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bStateSave": null
    },
    /**
     * Scrolling settings for a table.
     *  @namespace
     */
    "oScroll": {
      /**
       * When the table is shorter in height than sScrollY, collapse the
       * table container down to the height of the table (when true).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bCollapse": null,
      /**
       * Width of the scrollbar for the web-browser's platform. Calculated
       * during table initialisation.
       *  @type int
       *  @default 0
       */
      "iBarWidth": 0,
      /**
       * Viewport width for horizontal scrolling. Horizontal scrolling is
       * disabled if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sX": null,
      /**
       * Width to expand the table to when using x-scrolling. Typically you
       * should not need to use this.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       *  @deprecated
       */
      "sXInner": null,
      /**
       * Viewport height for vertical scrolling. Vertical scrolling is disabled
       * if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sY": null
    },
    /**
     * Language information for the table.
     *  @namespace
     *  @extends DataTable.defaults.oLanguage
     */
    "oLanguage": {
      /**
       * Information callback function. See
       * {@link DataTable.defaults.fnInfoCallback}
       *  @type function
       *  @default null
       */
      "fnInfoCallback": null
    },
    /**
     * Browser support parameters
     *  @namespace
     */
    "oBrowser": {
      /**
       * Indicate if the browser incorrectly calculates width:100% inside a
       * scrolling element (IE6/7)
       *  @type boolean
       *  @default false
       */
      "bScrollOversize": false,
      /**
       * Determine if the vertical scrollbar is on the right or left of the
       * scrolling container - needed for rtl language layout, although not
       * all browsers move the scrollbar (Safari).
       *  @type boolean
       *  @default false
       */
      "bScrollbarLeft": false,
      /**
       * Flag for if `getBoundingClientRect` is fully supported or not
       *  @type boolean
       *  @default false
       */
      "bBounding": false,
      /**
       * Browser scrollbar width
       *  @type integer
       *  @default 0
       */
      "barWidth": 0
    },
    "ajax": null,
    /**
     * Array referencing the nodes which are used for the features. The
     * parameters of this object match what is allowed by sDom - i.e.
     *   <ul>
     *     <li>'l' - Length changing</li>
     *     <li>'f' - Filtering input</li>
     *     <li>'t' - The table!</li>
     *     <li>'i' - Information</li>
     *     <li>'p' - Pagination</li>
     *     <li>'r' - pRocessing</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aanFeatures": [],
    /**
     * Store data information - see {@link DataTable.models.oRow} for detailed
     * information.
     *  @type array
     *  @default []
     */
    "aoData": [],
    /**
     * Array of indexes which are in the current display (after filtering etc)
     *  @type array
     *  @default []
     */
    "aiDisplay": [],
    /**
     * Array of indexes for display - no filtering
     *  @type array
     *  @default []
     */
    "aiDisplayMaster": [],
    /**
     * Map of row ids to data indexes
     *  @type object
     *  @default {}
     */
    "aIds": {},
    /**
     * Store information about each column that is in use
     *  @type array
     *  @default []
     */
    "aoColumns": [],
    /**
     * Store information about the table's header
     *  @type array
     *  @default []
     */
    "aoHeader": [],
    /**
     * Store information about the table's footer
     *  @type array
     *  @default []
     */
    "aoFooter": [],
    /**
     * Store the applied global search information in case we want to force a
     * research or compare the old search to a new one.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @namespace
     *  @extends DataTable.models.oSearch
     */
    "oPreviousSearch": {},
    /**
     * Store the applied search for each column - see
     * {@link DataTable.models.oSearch} for the format that is used for the
     * filtering information for each column.
     *  @type array
     *  @default []
     */
    "aoPreSearchCols": [],
    /**
     * Sorting that is applied to the table. Note that the inner arrays are
     * used in the following manner:
     * <ul>
     *   <li>Index 0 - column number</li>
     *   <li>Index 1 - current sorting direction</li>
     * </ul>
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @todo These inner arrays should really be objects
     */
    "aaSorting": null,
    /**
     * Sorting that is always applied to the table (i.e. prefixed in front of
     * aaSorting).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "aaSortingFixed": [],
    /**
     * Classes to use for the striping of a table.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "asStripeClasses": null,
    /**
     * If restoring a table - we should restore its striping classes as well
     *  @type array
     *  @default []
     */
    "asDestroyStripes": [],
    /**
     * If restoring a table - we should restore its width
     *  @type int
     *  @default 0
     */
    "sDestroyWidth": 0,
    /**
     * Callback functions array for every time a row is inserted (i.e. on a draw).
     *  @type array
     *  @default []
     */
    "aoRowCallback": [],
    /**
     * Callback functions for the header on each draw.
     *  @type array
     *  @default []
     */
    "aoHeaderCallback": [],
    /**
     * Callback function for the footer on each draw.
     *  @type array
     *  @default []
     */
    "aoFooterCallback": [],
    /**
     * Array of callback functions for draw callback functions
     *  @type array
     *  @default []
     */
    "aoDrawCallback": [],
    /**
     * Array of callback functions for row created function
     *  @type array
     *  @default []
     */
    "aoRowCreatedCallback": [],
    /**
     * Callback functions for just before the table is redrawn. A return of
     * false will be used to cancel the draw.
     *  @type array
     *  @default []
     */
    "aoPreDrawCallback": [],
    /**
     * Callback functions for when the table has been initialised.
     *  @type array
     *  @default []
     */
    "aoInitComplete": [],
    /**
     * Callbacks for modifying the settings to be stored for state saving, prior to
     * saving state.
     *  @type array
     *  @default []
     */
    "aoStateSaveParams": [],
    /**
     * Callbacks for modifying the settings that have been stored for state saving
     * prior to using the stored values to restore the state.
     *  @type array
     *  @default []
     */
    "aoStateLoadParams": [],
    /**
     * Callbacks for operating on the settings object once the saved state has been
     * loaded
     *  @type array
     *  @default []
     */
    "aoStateLoaded": [],
    /**
     * Cache the table ID for quick access
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sTableId": "",
    /**
     * The TABLE node for the main table
     *  @type node
     *  @default null
     */
    "nTable": null,
    /**
     * Permanent ref to the thead element
     *  @type node
     *  @default null
     */
    "nTHead": null,
    /**
     * Permanent ref to the tfoot element - if it exists
     *  @type node
     *  @default null
     */
    "nTFoot": null,
    /**
     * Permanent ref to the tbody element
     *  @type node
     *  @default null
     */
    "nTBody": null,
    /**
     * Cache the wrapper node (contains all DataTables controlled elements)
     *  @type node
     *  @default null
     */
    "nTableWrapper": null,
    /**
     * Indicate if when using server-side processing the loading of data
     * should be deferred until the second draw.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     *  @default false
     */
    "bDeferLoading": false,
    /**
     * Indicate if all required information has been read in
     *  @type boolean
     *  @default false
     */
    "bInitialised": false,
    /**
     * Information about open rows. Each object in the array has the parameters
     * 'nTr' and 'nParent'
     *  @type array
     *  @default []
     */
    "aoOpenRows": [],
    /**
     * Dictate the positioning of DataTables' control elements - see
     * {@link DataTable.model.oInit.sDom}.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default null
     */
    "sDom": null,
    /**
     * Search delay (in mS)
     *  @type integer
     *  @default null
     */
    "searchDelay": null,
    /**
     * Which type of pagination should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default two_button
     */
    "sPaginationType": "two_button",
    /**
     * The state duration (for `stateSave`) in seconds.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type int
     *  @default 0
     */
    "iStateDuration": 0,
    /**
     * Array of callback functions for state saving. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the JSON string to save that has been thus far created. Returns
     *       a JSON string to be inserted into a json object
     *       (i.e. '"param": [ 0, 1, 2]')</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aoStateSave": [],
    /**
     * Array of callback functions for state loading. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the object stored. May return false to cancel state loading</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aoStateLoad": [],
    /**
     * State that was saved. Useful for back reference
     *  @type object
     *  @default null
     */
    "oSavedState": null,
    /**
     * State that was loaded. Useful for back reference
     *  @type object
     *  @default null
     */
    "oLoadedState": null,
    /**
     * Source url for AJAX data for the table.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default null
     */
    "sAjaxSource": null,
    /**
     * Property from a given object from which to read the table data from. This
     * can be an empty string (when not server-side processing), in which case
     * it is  assumed an an array is given directly.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     */
    "sAjaxDataProp": null,
    /**
     * The last jQuery XHR object that was used for server-side data gathering.
     * This can be used for working with the XHR information in one of the
     * callbacks
     *  @type object
     *  @default null
     */
    "jqXHR": null,
    /**
     * JSON returned from the server in the last Ajax request
     *  @type object
     *  @default undefined
     */
    "json": void 0,
    /**
     * Data submitted as part of the last Ajax request
     *  @type object
     *  @default undefined
     */
    "oAjaxData": void 0,
    /**
     * Function to get the server-side data.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     */
    "fnServerData": null,
    /**
     * Functions which are called prior to sending an Ajax request so extra
     * parameters can easily be sent to the server
     *  @type array
     *  @default []
     */
    "aoServerParams": [],
    /**
     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
     * required).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     */
    "sServerMethod": null,
    /**
     * Format numbers for display.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     */
    "fnFormatNumber": null,
    /**
     * List of options that can be used for the user selectable length menu.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "aLengthMenu": null,
    /**
     * Counter for the draws that the table does. Also used as a tracker for
     * server-side processing
     *  @type int
     *  @default 0
     */
    "iDraw": 0,
    /**
     * Indicate if a redraw is being done - useful for Ajax
     *  @type boolean
     *  @default false
     */
    "bDrawing": false,
    /**
     * Draw index (iDraw) of the last error when parsing the returned data
     *  @type int
     *  @default -1
     */
    "iDrawError": -1,
    /**
     * Paging display length
     *  @type int
     *  @default 10
     */
    "_iDisplayLength": 10,
    /**
     * Paging start point - aiDisplay index
     *  @type int
     *  @default 0
     */
    "_iDisplayStart": 0,
    /**
     * Server-side processing - number of records in the result set
     * (i.e. before filtering), Use fnRecordsTotal rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     *  @type int
     *  @default 0
     *  @private
     */
    "_iRecordsTotal": 0,
    /**
     * Server-side processing - number of records in the current display set
     * (i.e. after filtering). Use fnRecordsDisplay rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     *  @type boolean
     *  @default 0
     *  @private
     */
    "_iRecordsDisplay": 0,
    /**
     * The classes to use for the table
     *  @type object
     *  @default {}
     */
    "oClasses": {},
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if filtering has been done in the draw. Deprecated in favour of
     * events.
     *  @type boolean
     *  @default false
     *  @deprecated
     */
    "bFiltered": false,
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if sorting has been done in the draw. Deprecated in favour of
     * events.
     *  @type boolean
     *  @default false
     *  @deprecated
     */
    "bSorted": false,
    /**
     * Indicate that if multiple rows are in the header and there is more than
     * one unique cell per column, if the top one (true) or bottom one (false)
     * should be used for sorting / title by DataTables.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     */
    "bSortCellsTop": null,
    /**
     * Initialisation object that is used for the table
     *  @type object
     *  @default null
     */
    "oInit": null,
    /**
     * Destroy callback functions - for plug-ins to attach themselves to the
     * destroy so they can clean up markup and events.
     *  @type array
     *  @default []
     */
    "aoDestroyCallback": [],
    /**
     * Get the number of records in the current record set, before filtering
     *  @type function
     */
    "fnRecordsTotal": function() {
      return _fnDataSource(this) == "ssp" ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
    },
    /**
     * Get the number of records in the current record set, after filtering
     *  @type function
     */
    "fnRecordsDisplay": function() {
      return _fnDataSource(this) == "ssp" ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
    },
    /**
     * Get the display end point - aiDisplay index
     *  @type function
     */
    "fnDisplayEnd": function() {
      var len = this._iDisplayLength, start2 = this._iDisplayStart, calc = start2 + len, records = this.aiDisplay.length, features = this.oFeatures, paginate = features.bPaginate;
      if (features.bServerSide) {
        return paginate === false || len === -1 ? start2 + records : Math.min(start2 + len, this._iRecordsDisplay);
      } else {
        return !paginate || calc > records || len === -1 ? records : calc;
      }
    },
    /**
     * The DataTables object for this table
     *  @type object
     *  @default null
     */
    "oInstance": null,
    /**
     * Unique identifier for each instance of the DataTables object. If there
     * is an ID on the table node, then it takes that value, otherwise an
     * incrementing internal counter is used.
     *  @type string
     *  @default null
     */
    "sInstance": null,
    /**
     * tabindex attribute value that is added to DataTables control elements, allowing
     * keyboard navigation of the table and its controls.
     */
    "iTabIndex": 0,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollHead": null,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollFoot": null,
    /**
     * Last applied sort
     *  @type array
     *  @default []
     */
    "aLastSort": [],
    /**
     * Stored plug-in instances
     *  @type object
     *  @default {}
     */
    "oPlugins": {},
    /**
     * Function used to get a row's id from the row's data
     *  @type function
     *  @default null
     */
    "rowIdFn": null,
    /**
     * Data location where to store a row's id
     *  @type string
     *  @default null
     */
    "rowId": null
  };
  DataTable.ext = _ext = {
    /**
     * Buttons. For use with the Buttons extension for DataTables. This is
     * defined here so other extensions can define buttons regardless of load
     * order. It is _not_ used by DataTables core.
     *
     *  @type object
     *  @default {}
     */
    buttons: {},
    /**
     * Element class names
     *
     *  @type object
     *  @default {}
     */
    classes: {},
    /**
     * DataTables build type (expanded by the download builder)
     *
     *  @type string
     */
    builder: "-source-",
    /**
     * Error reporting.
     * 
     * How should DataTables report an error. Can take the value 'alert',
     * 'throw', 'none' or a function.
     *
     *  @type string|function
     *  @default alert
     */
    errMode: "alert",
    /**
     * Feature plug-ins.
     * 
     * This is an array of objects which describe the feature plug-ins that are
     * available to DataTables. These feature plug-ins are then available for
     * use through the `dom` initialisation option.
     * 
     * Each feature plug-in is described by an object which must have the
     * following properties:
     * 
     * * `fnInit` - function that is used to initialise the plug-in,
     * * `cFeature` - a character so the feature can be enabled by the `dom`
     *   instillation option. This is case sensitive.
     *
     * The `fnInit` function has the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     *
     * And the following return is expected:
     * 
     * * {node|null} The element which contains your feature. Note that the
     *   return may also be void if your plug-in does not require to inject any
     *   DOM elements into DataTables control (`dom`) - for example this might
     *   be useful when developing a plug-in which allows table control via
     *   keyboard entry
     *
     *  @type array
     *
     *  @example
     *    $.fn.dataTable.ext.features.push( {
     *      "fnInit": function( oSettings ) {
     *        return new TableTools( { "oDTSettings": oSettings } );
     *      },
     *      "cFeature": "T"
     *    } );
     */
    feature: [],
    /**
     * Row searching.
     * 
     * This method of searching is complimentary to the default type based
     * searching, and a lot more comprehensive as it allows you complete control
     * over the searching logic. Each element in this array is a function
     * (parameters described below) that is called for every row in the table,
     * and your logic decides if it should be included in the searching data set
     * or not.
     *
     * Searching functions have the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{array|object}` Data for the row to be processed (same as the
     *    original format that was passed in as the data source, or an array
     *    from a DOM data source
     * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
     *    can be useful to retrieve the `TR` element if you need DOM interaction.
     *
     * And the following return is expected:
     *
     * * {boolean} Include the row in the searched result set (true) or not
     *   (false)
     *
     * Note that as with the main search ability in DataTables, technically this
     * is "filtering", since it is subtractive. However, for consistency in
     * naming we call it searching here.
     *
     *  @type array
     *  @default []
     *
     *  @example
     *    // The following example shows custom search being applied to the
     *    // fourth column (i.e. the data[3] index) based on two input values
     *    // from the end-user, matching the data in a certain range.
     *    $.fn.dataTable.ext.search.push(
     *      function( settings, data, dataIndex ) {
     *        var min = document.getElementById('min').value * 1;
     *        var max = document.getElementById('max').value * 1;
     *        var version = data[3] == "-" ? 0 : data[3]*1;
     *
     *        if ( min == "" && max == "" ) {
     *          return true;
     *        }
     *        else if ( min == "" && version < max ) {
     *          return true;
     *        }
     *        else if ( min < version && "" == max ) {
     *          return true;
     *        }
     *        else if ( min < version && version < max ) {
     *          return true;
     *        }
     *        return false;
     *      }
     *    );
     */
    search: [],
    /**
     * Selector extensions
     *
     * The `selector` option can be used to extend the options available for the
     * selector modifier options (`selector-modifier` object data type) that
     * each of the three built in selector types offer (row, column and cell +
     * their plural counterparts). For example the Select extension uses this
     * mechanism to provide an option to select only rows, columns and cells
     * that have been marked as selected by the end user (`{selected: true}`),
     * which can be used in conjunction with the existing built in selector
     * options.
     *
     * Each property is an array to which functions can be pushed. The functions
     * take three attributes:
     *
     * * Settings object for the host table
     * * Options object (`selector-modifier` object type)
     * * Array of selected item indexes
     *
     * The return is an array of the resulting item indexes after the custom
     * selector has been applied.
     *
     *  @type object
     */
    selector: {
      cell: [],
      column: [],
      row: []
    },
    /**
     * Internal functions, exposed for used in plug-ins.
     * 
     * Please note that you should not need to use the internal methods for
     * anything other than a plug-in (and even then, try to avoid if possible).
     * The internal function may change between releases.
     *
     *  @type object
     *  @default {}
     */
    internal: {},
    /**
     * Legacy configuration options. Enable and disable legacy options that
     * are available in DataTables.
     *
     *  @type object
     */
    legacy: {
      /**
       * Enable / disable DataTables 1.9 compatible server-side processing
       * requests
       *
       *  @type boolean
       *  @default null
       */
      ajax: null
    },
    /**
     * Pagination plug-in methods.
     * 
     * Each entry in this object is a function and defines which buttons should
     * be shown by the pagination rendering method that is used for the table:
     * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
     * buttons are displayed in the document, while the functions here tell it
     * what buttons to display. This is done by returning an array of button
     * descriptions (what each button will do).
     *
     * Pagination types (the four built in options and any additional plug-in
     * options defined here) can be used through the `paginationType`
     * initialisation parameter.
     *
     * The functions defined take two parameters:
     *
     * 1. `{int} page` The current page index
     * 2. `{int} pages` The number of pages in the table
     *
     * Each function is expected to return an array where each element of the
     * array can be one of:
     *
     * * `first` - Jump to first page when activated
     * * `last` - Jump to last page when activated
     * * `previous` - Show previous page when activated
     * * `next` - Show next page when activated
     * * `{int}` - Show page of the index given
     * * `{array}` - A nested array containing the above elements to add a
     *   containing 'DIV' element (might be useful for styling).
     *
     * Note that DataTables v1.9- used this object slightly differently whereby
     * an object with two functions would be defined for each plug-in. That
     * ability is still supported by DataTables 1.10+ to provide backwards
     * compatibility, but this option of use is now decremented and no longer
     * documented in DataTables 1.10+.
     *
     *  @type object
     *  @default {}
     *
     *  @example
     *    // Show previous, next and current page buttons only
     *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
     *      return [ 'previous', page, 'next' ];
     *    };
     */
    pager: {},
    renderer: {
      pageButton: {},
      header: {}
    },
    /**
     * Ordering plug-ins - custom data source
     * 
     * The extension options for ordering of data available here is complimentary
     * to the default type based ordering that DataTables typically uses. It
     * allows much greater control over the the data that is being used to
     * order a column, but is necessarily therefore more complex.
     * 
     * This type of ordering is useful if you want to do ordering based on data
     * live from the DOM (for example the contents of an 'input' element) rather
     * than just the static string that DataTables knows of.
     * 
     * The way these plug-ins work is that you create an array of the values you
     * wish to be ordering for the column in question and then return that
     * array. The data in the array much be in the index order of the rows in
     * the table (not the currently ordering order!). Which order data gathering
     * function is run here depends on the `dt-init columns.orderDataType`
     * parameter that is used for the column (if any).
     *
     * The functions defined take two parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{int}` Target column index
     *
     * Each function is expected to return an array:
     *
     * * `{array}` Data for the column to be ordering upon
     *
     *  @type array
     *
     *  @example
     *    // Ordering using `input` node values
     *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
     *    {
     *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
     *        return $('input', td).val();
     *      } );
     *    }
     */
    order: {},
    /**
     * Type based plug-ins.
     *
     * Each column in DataTables has a type assigned to it, either by automatic
     * detection or by direct assignment using the `type` option for the column.
     * The type of a column will effect how it is ordering and search (plug-ins
     * can also make use of the column type if required).
     *
     * @namespace
     */
    type: {
      /**
       * Type detection functions.
       *
       * The functions defined in this object are used to automatically detect
       * a column's type, making initialisation of DataTables super easy, even
       * when complex data is in the table.
       *
       * The functions defined take two parameters:
       *
          *  1. `{*}` Data from the column cell to be analysed
          *  2. `{settings}` DataTables settings object. This can be used to
          *     perform context specific type detection - for example detection
          *     based on language settings such as using a comma for a decimal
          *     place. Generally speaking the options from the settings will not
          *     be required
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Data type detected, or null if unknown (and thus
       *   pass it on to the other type detection functions.
       *
       *  @type array
       *
       *  @example
       *    // Currency type detection plug-in:
       *    $.fn.dataTable.ext.type.detect.push(
       *      function ( data, settings ) {
       *        // Check the numeric part
       *        if ( ! data.substring(1).match(/[0-9]/) ) {
       *          return null;
       *        }
       *
       *        // Check prefixed by currency
       *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
       *          return 'currency';
       *        }
       *        return null;
       *      }
       *    );
       */
      detect: [],
      /**
       * Type based search formatting.
       *
       * The type based searching functions can be used to pre-format the
       * data to be search on. For example, it can be used to strip HTML
       * tags or to de-format telephone numbers for numeric only searching.
       *
       * Note that is a search is not defined for a column of a given type,
       * no search formatting will be performed.
       * 
       * Pre-processing of searching data plug-ins - When you assign the sType
       * for a column (or have it automatically detected for you by DataTables
       * or a type detection plug-in), you will typically be using this for
       * custom sorting, but it can also be used to provide custom searching
       * by allowing you to pre-processing the data and returning the data in
       * the format that should be searched upon. This is done by adding
       * functions this object with a parameter name which matches the sType
       * for that target column. This is the corollary of <i>afnSortData</i>
       * for searching data.
       *
       * The functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for searching
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Formatted string that will be used for the searching.
       *
       *  @type object
       *  @default {}
       *
       *  @example
       *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
       *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
       *    }
       */
      search: {},
      /**
       * Type based ordering.
       *
       * The column type tells DataTables what ordering to apply to the table
       * when a column is sorted upon. The order for each type that is defined,
       * is defined by the functions available in this object.
       *
       * Each ordering option can be described by three properties added to
       * this object:
       *
       * * `{type}-pre` - Pre-formatting function
       * * `{type}-asc` - Ascending order function
       * * `{type}-desc` - Descending order function
       *
       * All three can be used together, only `{type}-pre` or only
       * `{type}-asc` and `{type}-desc` together. It is generally recommended
       * that only `{type}-pre` is used, as this provides the optimal
       * implementation in terms of speed, although the others are provided
       * for compatibility with existing Javascript sort functions.
       *
       * `{type}-pre`: Functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for ordering
       *
       * And return:
       *
       * * `{*}` Data to be sorted upon
       *
       * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
       * functions, taking two parameters:
       *
          *  1. `{*}` Data to compare to the second parameter
          *  2. `{*}` Data to compare to the first parameter
       *
       * And returning:
       *
       * * `{*}` Ordering match: <0 if first parameter should be sorted lower
       *   than the second parameter, ===0 if the two parameters are equal and
       *   >0 if the first parameter should be sorted height than the second
       *   parameter.
       * 
       *  @type object
       *  @default {}
       *
       *  @example
       *    // Numeric ordering of formatted numbers with a pre-formatter
       *    $.extend( $.fn.dataTable.ext.type.order, {
       *      "string-pre": function(x) {
       *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
       *        return parseFloat( a );
       *      }
       *    } );
       *
       *  @example
       *    // Case-sensitive string ordering, with no pre-formatting method
       *    $.extend( $.fn.dataTable.ext.order, {
       *      "string-case-asc": function(x,y) {
       *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
       *      },
       *      "string-case-desc": function(x,y) {
       *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
       *      }
       *    } );
       */
      order: {}
    },
    /**
     * Unique DataTables instance counter
     *
     * @type int
     * @private
     */
    _unique: 0,
    //
    // Depreciated
    // The following properties are retained for backwards compatibility only.
    // The should not be used in new projects and will be removed in a future
    // version
    //
    /**
     * Version check function.
     *  @type function
     *  @depreciated Since 1.10
     */
    fnVersionCheck: DataTable.fnVersionCheck,
    /**
     * Index for what 'this' index API functions should use
     *  @type int
     *  @deprecated Since v1.10
     */
    iApiIndex: 0,
    /**
     * jQuery UI class container
     *  @type object
     *  @deprecated Since v1.10
     */
    oJUIClasses: {},
    /**
     * Software version
     *  @type string
     *  @deprecated Since v1.10
     */
    sVersion: DataTable.version
  };
  $2.extend(_ext, {
    afnFiltering: _ext.search,
    aTypes: _ext.type.detect,
    ofnSearch: _ext.type.search,
    oSort: _ext.type.order,
    afnSortData: _ext.order,
    aoFeatures: _ext.feature,
    oApi: _ext.internal,
    oStdClasses: _ext.classes,
    oPagination: _ext.pager
  });
  $2.extend(DataTable.ext.classes, {
    "sTable": "dataTable",
    "sNoFooter": "no-footer",
    /* Paging buttons */
    "sPageButton": "paginate_button",
    "sPageButtonActive": "current",
    "sPageButtonDisabled": "disabled",
    /* Striping classes */
    "sStripeOdd": "odd",
    "sStripeEven": "even",
    /* Empty row */
    "sRowEmpty": "dataTables_empty",
    /* Features */
    "sWrapper": "dataTables_wrapper",
    "sFilter": "dataTables_filter",
    "sInfo": "dataTables_info",
    "sPaging": "dataTables_paginate paging_",
    /* Note that the type is postfixed */
    "sLength": "dataTables_length",
    "sProcessing": "dataTables_processing",
    /* Sorting */
    "sSortAsc": "sorting_asc",
    "sSortDesc": "sorting_desc",
    "sSortable": "sorting",
    /* Sortable in both directions */
    "sSortableAsc": "sorting_desc_disabled",
    "sSortableDesc": "sorting_asc_disabled",
    "sSortableNone": "sorting_disabled",
    "sSortColumn": "sorting_",
    /* Note that an int is postfixed for the sorting order */
    /* Filtering */
    "sFilterInput": "",
    /* Page length */
    "sLengthSelect": "",
    /* Scrolling */
    "sScrollWrapper": "dataTables_scroll",
    "sScrollHead": "dataTables_scrollHead",
    "sScrollHeadInner": "dataTables_scrollHeadInner",
    "sScrollBody": "dataTables_scrollBody",
    "sScrollFoot": "dataTables_scrollFoot",
    "sScrollFootInner": "dataTables_scrollFootInner",
    /* Misc */
    "sHeaderTH": "",
    "sFooterTH": "",
    // Deprecated
    "sSortJUIAsc": "",
    "sSortJUIDesc": "",
    "sSortJUI": "",
    "sSortJUIAscAllowed": "",
    "sSortJUIDescAllowed": "",
    "sSortJUIWrapper": "",
    "sSortIcon": "",
    "sJUIHeader": "",
    "sJUIFooter": ""
  });
  var extPagination = DataTable.ext.pager;
  function _numbers(page, pages) {
    var numbers = [], buttons = extPagination.numbers_length, half = Math.floor(buttons / 2), i = 1;
    if (pages <= buttons) {
      numbers = _range(0, pages);
    } else if (page <= half) {
      numbers = _range(0, buttons - 2);
      numbers.push("ellipsis");
      numbers.push(pages - 1);
    } else if (page >= pages - 1 - half) {
      numbers = _range(pages - (buttons - 2), pages);
      numbers.splice(0, 0, "ellipsis");
      numbers.splice(0, 0, 0);
    } else {
      numbers = _range(page - half + 2, page + half - 1);
      numbers.push("ellipsis");
      numbers.push(pages - 1);
      numbers.splice(0, 0, "ellipsis");
      numbers.splice(0, 0, 0);
    }
    numbers.DT_el = "span";
    return numbers;
  }
  $2.extend(extPagination, {
    simple: function(page, pages) {
      return ["previous", "next"];
    },
    full: function(page, pages) {
      return ["first", "previous", "next", "last"];
    },
    numbers: function(page, pages) {
      return [_numbers(page, pages)];
    },
    simple_numbers: function(page, pages) {
      return ["previous", _numbers(page, pages), "next"];
    },
    full_numbers: function(page, pages) {
      return ["first", "previous", _numbers(page, pages), "next", "last"];
    },
    first_last_numbers: function(page, pages) {
      return ["first", _numbers(page, pages), "last"];
    },
    // For testing and plug-ins to use
    _numbers,
    // Number of number buttons (including ellipsis) to show. _Must be odd!_
    numbers_length: 7
  });
  $2.extend(true, DataTable.ext.renderer, {
    pageButton: {
      _: function(settings, host, idx, buttons, page, pages) {
        var classes = settings.oClasses;
        var lang = settings.oLanguage.oPaginate;
        var aria = settings.oLanguage.oAria.paginate || {};
        var btnDisplay, btnClass;
        var attach = function(container, buttons2) {
          var i, ien, node, button;
          var disabledClass = classes.sPageButtonDisabled;
          var clickHandler = function(e) {
            _fnPageChange(settings, e.data.action, true);
          };
          for (i = 0, ien = buttons2.length; i < ien; i++) {
            button = buttons2[i];
            if (Array.isArray(button)) {
              var inner = $2("<" + (button.DT_el || "div") + "/>").appendTo(container);
              attach(inner, button);
            } else {
              var disabled = false;
              btnDisplay = null;
              btnClass = button;
              switch (button) {
                case "ellipsis":
                  container.append('<span class="ellipsis">&#x2026;</span>');
                  break;
                case "first":
                  btnDisplay = lang.sFirst;
                  if (page === 0) {
                    disabled = true;
                  }
                  break;
                case "previous":
                  btnDisplay = lang.sPrevious;
                  if (page === 0) {
                    disabled = true;
                  }
                  break;
                case "next":
                  btnDisplay = lang.sNext;
                  if (pages === 0 || page === pages - 1) {
                    disabled = true;
                  }
                  break;
                case "last":
                  btnDisplay = lang.sLast;
                  if (pages === 0 || page === pages - 1) {
                    disabled = true;
                  }
                  break;
                default:
                  btnDisplay = settings.fnFormatNumber(button + 1);
                  btnClass = page === button ? classes.sPageButtonActive : "";
                  break;
              }
              if (btnDisplay !== null) {
                var tag = settings.oInit.pagingTag || "a";
                if (disabled) {
                  btnClass += " " + disabledClass;
                }
                node = $2("<" + tag + ">", {
                  "class": classes.sPageButton + " " + btnClass,
                  "aria-controls": settings.sTableId,
                  "aria-disabled": disabled ? "true" : null,
                  "aria-label": aria[button],
                  "role": "link",
                  "aria-current": btnClass === classes.sPageButtonActive ? "page" : null,
                  "data-dt-idx": button,
                  "tabindex": disabled ? -1 : settings.iTabIndex,
                  "id": idx === 0 && typeof button === "string" ? settings.sTableId + "_" + button : null
                }).html(btnDisplay).appendTo(container);
                _fnBindAction(
                  node,
                  { action: button },
                  clickHandler
                );
              }
            }
          }
        };
        var activeEl;
        try {
          activeEl = $2(host).find(document.activeElement).data("dt-idx");
        } catch (e) {
        }
        attach($2(host).empty(), buttons);
        if (activeEl !== void 0) {
          $2(host).find("[data-dt-idx=" + activeEl + "]").trigger("focus");
        }
      }
    }
  });
  $2.extend(DataTable.ext.type.detect, [
    // Plain numbers - first since V8 detects some plain numbers as dates
    // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
    function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber(d, decimal) ? "num" + decimal : null;
    },
    // Dates (only those recognised by the browser's Date.parse)
    function(d, settings) {
      if (d && !(d instanceof Date) && !_re_date.test(d)) {
        return null;
      }
      var parsed = Date.parse(d);
      return parsed !== null && !isNaN(parsed) || _empty(d) ? "date" : null;
    },
    // Formatted numbers
    function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber(d, decimal, true) ? "num-fmt" + decimal : null;
    },
    // HTML numeric
    function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric(d, decimal) ? "html-num" + decimal : null;
    },
    // HTML numeric, formatted
    function(d, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric(d, decimal, true) ? "html-num-fmt" + decimal : null;
    },
    // HTML (this is strict checking - there must be html)
    function(d, settings) {
      return _empty(d) || typeof d === "string" && d.indexOf("<") !== -1 ? "html" : null;
    }
  ]);
  $2.extend(DataTable.ext.type.search, {
    html: function(data) {
      return _empty(data) ? data : typeof data === "string" ? data.replace(_re_new_lines, " ").replace(_re_html, "") : "";
    },
    string: function(data) {
      return _empty(data) ? data : typeof data === "string" ? data.replace(_re_new_lines, " ") : data;
    }
  });
  var __numericReplace = function(d, decimalPlace, re1, re2) {
    if (d !== 0 && (!d || d === "-")) {
      return -Infinity;
    }
    var type = typeof d;
    if (type === "number" || type === "bigint") {
      return d;
    }
    if (decimalPlace) {
      d = _numToDecimal(d, decimalPlace);
    }
    if (d.replace) {
      if (re1) {
        d = d.replace(re1, "");
      }
      if (re2) {
        d = d.replace(re2, "");
      }
    }
    return d * 1;
  };
  function _addNumericSort(decimalPlace) {
    $2.each(
      {
        // Plain numbers
        "num": function(d) {
          return __numericReplace(d, decimalPlace);
        },
        // Formatted numbers
        "num-fmt": function(d) {
          return __numericReplace(d, decimalPlace, _re_formatted_numeric);
        },
        // HTML numeric
        "html-num": function(d) {
          return __numericReplace(d, decimalPlace, _re_html);
        },
        // HTML numeric, formatted
        "html-num-fmt": function(d) {
          return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric);
        }
      },
      function(key, fn) {
        _ext.type.order[key + decimalPlace + "-pre"] = fn;
        if (key.match(/^html\-/)) {
          _ext.type.search[key + decimalPlace] = _ext.type.search.html;
        }
      }
    );
  }
  $2.extend(_ext.type.order, {
    // Dates
    "date-pre": function(d) {
      var ts = Date.parse(d);
      return isNaN(ts) ? -Infinity : ts;
    },
    // html
    "html-pre": function(a) {
      return _empty(a) ? "" : a.replace ? a.replace(/<.*?>/g, "").toLowerCase() : a + "";
    },
    // string
    "string-pre": function(a) {
      return _empty(a) ? "" : typeof a === "string" ? a.toLowerCase() : !a.toString ? "" : a.toString();
    },
    // string-asc and -desc are retained only for compatibility with the old
    // sort methods
    "string-asc": function(x, y) {
      return x < y ? -1 : x > y ? 1 : 0;
    },
    "string-desc": function(x, y) {
      return x < y ? 1 : x > y ? -1 : 0;
    }
  });
  _addNumericSort("");
  $2.extend(true, DataTable.ext.renderer, {
    header: {
      _: function(settings, cell, column, classes) {
        $2(settings.nTable).on("order.dt.DT", function(e, ctx, sorting, columns) {
          if (settings !== ctx) {
            return;
          }
          var colIdx = column.idx;
          cell.removeClass(
            classes.sSortAsc + " " + classes.sSortDesc
          ).addClass(
            columns[colIdx] == "asc" ? classes.sSortAsc : columns[colIdx] == "desc" ? classes.sSortDesc : column.sSortingClass
          );
        });
      },
      jqueryui: function(settings, cell, column, classes) {
        $2("<div/>").addClass(classes.sSortJUIWrapper).append(cell.contents()).append(
          $2("<span/>").addClass(classes.sSortIcon + " " + column.sSortingClassJUI)
        ).appendTo(cell);
        $2(settings.nTable).on("order.dt.DT", function(e, ctx, sorting, columns) {
          if (settings !== ctx) {
            return;
          }
          var colIdx = column.idx;
          cell.removeClass(classes.sSortAsc + " " + classes.sSortDesc).addClass(
            columns[colIdx] == "asc" ? classes.sSortAsc : columns[colIdx] == "desc" ? classes.sSortDesc : column.sSortingClass
          );
          cell.find("span." + classes.sSortIcon).removeClass(
            classes.sSortJUIAsc + " " + classes.sSortJUIDesc + " " + classes.sSortJUI + " " + classes.sSortJUIAscAllowed + " " + classes.sSortJUIDescAllowed
          ).addClass(
            columns[colIdx] == "asc" ? classes.sSortJUIAsc : columns[colIdx] == "desc" ? classes.sSortJUIDesc : column.sSortingClassJUI
          );
        });
      }
    }
  });
  var __htmlEscapeEntities = function(d) {
    if (Array.isArray(d)) {
      d = d.join(",");
    }
    return typeof d === "string" ? d.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;") : d;
  };
  function __mld(dt, momentFn, luxonFn, dateFn, arg1) {
    if (window.moment) {
      return dt[momentFn](arg1);
    } else if (window.luxon) {
      return dt[luxonFn](arg1);
    }
    return dateFn ? dt[dateFn](arg1) : dt;
  }
  var __mlWarning = false;
  function __mldObj(d, format, locale) {
    var dt;
    if (window.moment) {
      dt = window.moment.utc(d, format, locale, true);
      if (!dt.isValid()) {
        return null;
      }
    } else if (window.luxon) {
      dt = format && typeof d === "string" ? window.luxon.DateTime.fromFormat(d, format) : window.luxon.DateTime.fromISO(d);
      if (!dt.isValid) {
        return null;
      }
      dt.setLocale(locale);
    } else if (!format) {
      dt = new Date(d);
    } else {
      if (!__mlWarning) {
        alert("DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17");
      }
      __mlWarning = true;
    }
    return dt;
  }
  function __mlHelper(localeString) {
    return function(from, to, locale, def2) {
      if (arguments.length === 0) {
        locale = "en";
        to = null;
        from = null;
      } else if (arguments.length === 1) {
        locale = "en";
        to = from;
        from = null;
      } else if (arguments.length === 2) {
        locale = to;
        to = from;
        from = null;
      }
      var typeName = "datetime-" + to;
      if (!DataTable.ext.type.order[typeName]) {
        DataTable.ext.type.detect.unshift(function(d) {
          return d === typeName ? typeName : false;
        });
        DataTable.ext.type.order[typeName + "-asc"] = function(a, b) {
          var x = a.valueOf();
          var y = b.valueOf();
          return x === y ? 0 : x < y ? -1 : 1;
        };
        DataTable.ext.type.order[typeName + "-desc"] = function(a, b) {
          var x = a.valueOf();
          var y = b.valueOf();
          return x === y ? 0 : x > y ? -1 : 1;
        };
      }
      return function(d, type) {
        if (d === null || d === void 0) {
          if (def2 === "--now") {
            var local = /* @__PURE__ */ new Date();
            d = new Date(Date.UTC(
              local.getFullYear(),
              local.getMonth(),
              local.getDate(),
              local.getHours(),
              local.getMinutes(),
              local.getSeconds()
            ));
          } else {
            d = "";
          }
        }
        if (type === "type") {
          return typeName;
        }
        if (d === "") {
          return type !== "sort" ? "" : __mldObj("0000-01-01 00:00:00", null, locale);
        }
        if (to !== null && from === to && type !== "sort" && type !== "type" && !(d instanceof Date)) {
          return d;
        }
        var dt = __mldObj(d, from, locale);
        if (dt === null) {
          return d;
        }
        if (type === "sort") {
          return dt;
        }
        var formatted = to === null ? __mld(dt, "toDate", "toJSDate", "")[localeString]() : __mld(dt, "format", "toFormat", "toISOString", to);
        return type === "display" ? __htmlEscapeEntities(formatted) : formatted;
      };
    };
  }
  var __thousands = ",";
  var __decimal = ".";
  if (window.Intl !== void 0) {
    try {
      num = new Intl.NumberFormat().formatToParts(100000.1);
      for (i = 0; i < num.length; i++) {
        if (num[i].type === "group") {
          __thousands = num[i].value;
        } else if (num[i].type === "decimal") {
          __decimal = num[i].value;
        }
      }
    } catch (e) {
    }
  }
  var num;
  var i;
  DataTable.datetime = function(format, locale) {
    var typeName = "datetime-detect-" + format;
    if (!locale) {
      locale = "en";
    }
    if (!DataTable.ext.type.order[typeName]) {
      DataTable.ext.type.detect.unshift(function(d) {
        var dt = __mldObj(d, format, locale);
        return d === "" || dt ? typeName : false;
      });
      DataTable.ext.type.order[typeName + "-pre"] = function(d) {
        return __mldObj(d, format, locale) || 0;
      };
    }
  };
  DataTable.render = {
    date: __mlHelper("toLocaleDateString"),
    datetime: __mlHelper("toLocaleString"),
    time: __mlHelper("toLocaleTimeString"),
    number: function(thousands, decimal, precision, prefix, postfix) {
      if (thousands === null || thousands === void 0) {
        thousands = __thousands;
      }
      if (decimal === null || decimal === void 0) {
        decimal = __decimal;
      }
      return {
        display: function(d) {
          if (typeof d !== "number" && typeof d !== "string") {
            return d;
          }
          if (d === "" || d === null) {
            return d;
          }
          var negative = d < 0 ? "-" : "";
          var flo = parseFloat(d);
          if (isNaN(flo)) {
            return __htmlEscapeEntities(d);
          }
          flo = flo.toFixed(precision);
          d = Math.abs(flo);
          var intPart = parseInt(d, 10);
          var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : "";
          if (intPart === 0 && parseFloat(floatPart) === 0) {
            negative = "";
          }
          return negative + (prefix || "") + intPart.toString().replace(
            /\B(?=(\d{3})+(?!\d))/g,
            thousands
          ) + floatPart + (postfix || "");
        }
      };
    },
    text: function() {
      return {
        display: __htmlEscapeEntities,
        filter: __htmlEscapeEntities
      };
    }
  };
  function _fnExternApiFunc(fn) {
    return function() {
      var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(
        Array.prototype.slice.call(arguments)
      );
      return DataTable.ext.internal[fn].apply(this, args);
    };
  }
  $2.extend(DataTable.ext.internal, {
    _fnExternApiFunc,
    _fnBuildAjax,
    _fnAjaxUpdate,
    _fnAjaxParameters,
    _fnAjaxUpdateDraw,
    _fnAjaxDataSrc,
    _fnAddColumn,
    _fnColumnOptions,
    _fnAdjustColumnSizing,
    _fnVisibleToColumnIndex,
    _fnColumnIndexToVisible,
    _fnVisbleColumns,
    _fnGetColumns,
    _fnColumnTypes,
    _fnApplyColumnDefs,
    _fnHungarianMap,
    _fnCamelToHungarian,
    _fnLanguageCompat,
    _fnBrowserDetect,
    _fnAddData,
    _fnAddTr,
    _fnNodeToDataIndex,
    _fnNodeToColumnIndex,
    _fnGetCellData,
    _fnSetCellData,
    _fnSplitObjNotation,
    _fnGetObjectDataFn,
    _fnSetObjectDataFn,
    _fnGetDataMaster,
    _fnClearTable,
    _fnDeleteIndex,
    _fnInvalidate,
    _fnGetRowElements,
    _fnCreateTr,
    _fnBuildHead,
    _fnDrawHead,
    _fnDraw,
    _fnReDraw,
    _fnAddOptionsHtml,
    _fnDetectHeader,
    _fnGetUniqueThs,
    _fnFeatureHtmlFilter,
    _fnFilterComplete,
    _fnFilterCustom,
    _fnFilterColumn,
    _fnFilter,
    _fnFilterCreateSearch,
    _fnEscapeRegex,
    _fnFilterData,
    _fnFeatureHtmlInfo,
    _fnUpdateInfo,
    _fnInfoMacros,
    _fnInitialise,
    _fnInitComplete,
    _fnLengthChange,
    _fnFeatureHtmlLength,
    _fnFeatureHtmlPaginate,
    _fnPageChange,
    _fnFeatureHtmlProcessing,
    _fnProcessingDisplay,
    _fnFeatureHtmlTable,
    _fnScrollDraw,
    _fnApplyToChildren,
    _fnCalculateColumnWidths,
    _fnThrottle,
    _fnConvertToWidth,
    _fnGetWidestNode,
    _fnGetMaxLenString,
    _fnStringToCss,
    _fnSortFlatten,
    _fnSort,
    _fnSortAria,
    _fnSortListener,
    _fnSortAttachListener,
    _fnSortingClasses,
    _fnSortData,
    _fnSaveState,
    _fnLoadState,
    _fnImplementState,
    _fnSettingsFromNode,
    _fnLog,
    _fnMap,
    _fnBindAction,
    _fnCallbackReg,
    _fnCallbackFire,
    _fnLengthOverflow,
    _fnRenderer,
    _fnDataSource,
    _fnRowAttributes,
    _fnExtend,
    _fnCalculateEnd: function() {
    }
    // Used by a lot of plug-ins, but redundant
    // in 1.10, so this dead-end function is
    // added to prevent errors
  });
  $2.fn.dataTable = DataTable;
  DataTable.$ = $2;
  $2.fn.dataTableSettings = DataTable.settings;
  $2.fn.dataTableExt = DataTable.ext;
  $2.fn.DataTable = function(opts) {
    return $2(this).dataTable(opts).api();
  };
  $2.each(DataTable, function(prop, val) {
    $2.fn.DataTable[prop] = val;
  });

  // app/javascript/application.js
  var import_flowbite_turbo = __toESM(require_flowbite_turbo());

  // node_modules/ag-grid-community/dist/package/main.esm.mjs
  var main_esm_exports = {};
  __export(main_esm_exports, {
    ALWAYS_SYNC_GLOBAL_EVENTS: () => ALWAYS_SYNC_GLOBAL_EVENTS,
    AbstractHeaderCellCtrl: () => AbstractHeaderCellCtrl,
    AgAbstractField: () => AgAbstractField,
    AgAbstractLabel: () => AgAbstractLabel,
    AgAutocomplete: () => AgAutocomplete,
    AgCheckbox: () => AgCheckbox,
    AgDialog: () => AgDialog,
    AgGroupComponent: () => AgGroupComponent,
    AgInputDateField: () => AgInputDateField,
    AgInputNumberField: () => AgInputNumberField,
    AgInputRange: () => AgInputRange,
    AgInputTextArea: () => AgInputTextArea,
    AgInputTextField: () => AgInputTextField,
    AgMenuItemComponent: () => AgMenuItemComponent,
    AgMenuItemRenderer: () => AgMenuItemRenderer,
    AgMenuList: () => AgMenuList,
    AgMenuPanel: () => AgMenuPanel,
    AgPanel: () => AgPanel,
    AgPickerField: () => AgPickerField,
    AgPromise: () => AgPromise,
    AgPromiseStatus: () => AgPromiseStatus,
    AgRadioButton: () => AgRadioButton,
    AgRichSelect: () => AgRichSelect,
    AgSelect: () => AgSelect,
    AgSlider: () => AgSlider,
    AgStackComponentsRegistry: () => AgStackComponentsRegistry,
    AgToggleButton: () => AgToggleButton,
    AlignedGridsService: () => AlignedGridsService,
    AnimateShowChangeCellRenderer: () => AnimateShowChangeCellRenderer,
    AnimateSlideCellRenderer: () => AnimateSlideCellRenderer,
    AnimationFrameService: () => AnimationFrameService,
    AutoScrollService: () => AutoScrollService,
    AutoWidthCalculator: () => AutoWidthCalculator,
    Autowired: () => Autowired,
    BarColumnLabelPlacement: () => BarColumnLabelPlacement,
    BaseComponentWrapper: () => BaseComponentWrapper,
    BaseCreator: () => BaseCreator,
    BaseGridSerializingSession: () => BaseGridSerializingSession,
    Bean: () => Bean,
    BeanStub: () => BeanStub,
    Beans: () => Beans,
    BodyDropPivotTarget: () => BodyDropPivotTarget,
    BodyDropTarget: () => BodyDropTarget,
    CellComp: () => CellComp,
    CellCtrl: () => CellCtrl,
    CellNavigationService: () => CellNavigationService,
    CellPositionUtils: () => CellPositionUtils,
    CellRangeType: () => CellRangeType,
    ChangedPath: () => ChangedPath,
    ChartMappings: () => ChartMappings,
    CheckboxCellEditor: () => CheckboxCellEditor,
    CheckboxCellRenderer: () => CheckboxCellRenderer,
    CheckboxSelectionComponent: () => CheckboxSelectionComponent,
    ClientSideRowModelModule: () => ClientSideRowModelModule,
    ClientSideRowModelSteps: () => ClientSideRowModelSteps,
    Column: () => Column,
    ColumnApi: () => ColumnApi,
    ColumnFactory: () => ColumnFactory,
    ColumnGroup: () => ColumnGroup,
    ColumnKeyCreator: () => ColumnKeyCreator,
    ColumnModel: () => ColumnModel,
    Component: () => Component,
    ComponentUtil: () => ComponentUtil,
    Context: () => Context2,
    CssClassApplier: () => CssClassApplier,
    CssClassManager: () => CssClassManager,
    CsvCreator: () => CsvCreator,
    CsvExportModule: () => CsvExportModule,
    CtrlsService: () => CtrlsService,
    DataTypeService: () => DataTypeService,
    DateCellEditor: () => DateCellEditor,
    DateFilter: () => DateFilter,
    DateStringCellEditor: () => DateStringCellEditor,
    DisplayedGroupCreator: () => DisplayedGroupCreator,
    Downloader: () => Downloader,
    DragAndDropService: () => DragAndDropService,
    DragService: () => DragService,
    DragSourceType: () => DragSourceType,
    Environment: () => Environment,
    EventService: () => EventService,
    Events: () => Events,
    ExcelFactoryMode: () => ExcelFactoryMode,
    ExpansionService: () => ExpansionService,
    ExpressionService: () => ExpressionService,
    FilterManager: () => FilterManager,
    FilterWrapperComp: () => FilterWrapperComp,
    FloatingFilterMapper: () => FloatingFilterMapper,
    FocusService: () => FocusService,
    GROUP_AUTO_COLUMN_ID: () => GROUP_AUTO_COLUMN_ID,
    Grid: () => Grid,
    GridApi: () => GridApi,
    GridBodyComp: () => GridBodyComp,
    GridBodyCtrl: () => GridBodyCtrl,
    GridComp: () => GridComp,
    GridCoreCreator: () => GridCoreCreator,
    GridCtrl: () => GridCtrl,
    GridHeaderComp: () => GridHeaderComp,
    GridHeaderCtrl: () => GridHeaderCtrl,
    GridOptionsService: () => GridOptionsService,
    GridSerializer: () => GridSerializer,
    GroupCellRenderer: () => GroupCellRenderer,
    GroupCellRendererCtrl: () => GroupCellRendererCtrl,
    GroupInstanceIdCreator: () => GroupInstanceIdCreator,
    HeaderCellCtrl: () => HeaderCellCtrl,
    HeaderFilterCellComp: () => HeaderFilterCellComp,
    HeaderFilterCellCtrl: () => HeaderFilterCellCtrl,
    HeaderGroupCellCtrl: () => HeaderGroupCellCtrl,
    HeaderNavigationDirection: () => HeaderNavigationDirection,
    HeaderNavigationService: () => HeaderNavigationService,
    HeaderPositionUtils: () => HeaderPositionUtils,
    HeaderRowComp: () => HeaderRowComp,
    HeaderRowContainerComp: () => HeaderRowContainerComp,
    HeaderRowContainerCtrl: () => HeaderRowContainerCtrl,
    HeaderRowCtrl: () => HeaderRowCtrl,
    HeaderRowType: () => HeaderRowType,
    HorizontalDirection: () => HorizontalDirection,
    HorizontalResizeService: () => HorizontalResizeService,
    InfiniteRowModelModule: () => InfiniteRowModelModule,
    KeyCode: () => KeyCode,
    LargeTextCellEditor: () => LargeTextCellEditor,
    LayoutCssClasses: () => LayoutCssClasses,
    LocaleService: () => LocaleService,
    Logger: () => Logger,
    LoggerFactory: () => LoggerFactory,
    ManagedFocusFeature: () => ManagedFocusFeature,
    MenuService: () => MenuService,
    ModuleNames: () => ModuleNames,
    ModuleRegistry: () => ModuleRegistry,
    MouseEventService: () => MouseEventService,
    MoveColumnFeature: () => MoveColumnFeature,
    NavigationService: () => NavigationService,
    NumberCellEditor: () => NumberCellEditor,
    NumberFilter: () => NumberFilter,
    NumberSequence: () => NumberSequence,
    Optional: () => Optional,
    PaginationProxy: () => PaginationProxy,
    PillDragComp: () => PillDragComp,
    PillDropZonePanel: () => PillDropZonePanel,
    PinnedRowModel: () => PinnedRowModel,
    PopupComponent: () => PopupComponent,
    PopupEditorWrapper: () => PopupEditorWrapper,
    PopupService: () => PopupService,
    PositionableFeature: () => PositionableFeature,
    PostConstruct: () => PostConstruct,
    PreConstruct: () => PreConstruct,
    PreDestroy: () => PreDestroy,
    PropertyKeys: () => PropertyKeys,
    ProvidedColumnGroup: () => ProvidedColumnGroup,
    ProvidedFilter: () => ProvidedFilter,
    Qualifier: () => Qualifier,
    QuerySelector: () => QuerySelector,
    RefSelector: () => RefSelector,
    ResizeObserverService: () => ResizeObserverService,
    RowAnimationCssClasses: () => RowAnimationCssClasses,
    RowContainerComp: () => RowContainerComp,
    RowContainerCtrl: () => RowContainerCtrl,
    RowContainerName: () => RowContainerName,
    RowContainerType: () => RowContainerType,
    RowCtrl: () => RowCtrl,
    RowHighlightPosition: () => RowHighlightPosition,
    RowNode: () => RowNode,
    RowNodeBlock: () => RowNodeBlock,
    RowNodeBlockLoader: () => RowNodeBlockLoader,
    RowNodeSorter: () => RowNodeSorter,
    RowPositionUtils: () => RowPositionUtils,
    RowRenderer: () => RowRenderer,
    RowType: () => RowType,
    ScalarFilter: () => ScalarFilter,
    ScrollVisibleService: () => ScrollVisibleService,
    SelectCellEditor: () => SelectCellEditor,
    SelectableService: () => SelectableService,
    SelectionHandleType: () => SelectionHandleType,
    ServerSideTransactionResultStatus: () => ServerSideTransactionResultStatus,
    SetLeftFeature: () => SetLeftFeature,
    SimpleFilter: () => SimpleFilter,
    SortController: () => SortController,
    SortIndicatorComp: () => SortIndicatorComp,
    StandardMenuFactory: () => StandardMenuFactory,
    StylingService: () => StylingService,
    TabGuardClassNames: () => TabGuardClassNames,
    TabGuardComp: () => TabGuardComp,
    TabGuardCtrl: () => TabGuardCtrl,
    TabbedLayout: () => TabbedLayout,
    TextCellEditor: () => TextCellEditor,
    TextFilter: () => TextFilter,
    TextFloatingFilter: () => TextFloatingFilter,
    Timer: () => Timer,
    TooltipFeature: () => TooltipFeature,
    TooltipStateManager: () => TooltipStateManager,
    TouchListener: () => TouchListener,
    UserComponentFactory: () => UserComponentFactory,
    UserComponentRegistry: () => UserComponentRegistry,
    ValueCache: () => ValueCache,
    ValueService: () => ValueService,
    VanillaFrameworkOverrides: () => VanillaFrameworkOverrides,
    VerticalDirection: () => VerticalDirection,
    VirtualList: () => VirtualList,
    VirtualListDragFeature: () => VirtualListDragFeature,
    XmlFactory: () => XmlFactory,
    ZipContainer: () => ZipContainer,
    _: () => _,
    createGrid: () => createGrid,
    getRowContainerTypeForName: () => getRowContainerTypeForName,
    provideGlobalGridOptions: () => provideGlobalGridOptions
  });
  var __defProp2 = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp2.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp2.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc2(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp2(target, key, result);
    return result;
  };
  var __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);
  var generic_exports = {};
  __export2(generic_exports, {
    attrToBoolean: () => attrToBoolean,
    attrToNumber: () => attrToNumber,
    attrToString: () => attrToString,
    defaultComparator: () => defaultComparator,
    exists: () => exists,
    jsonEquals: () => jsonEquals,
    makeNull: () => makeNull,
    missing: () => missing,
    missingOrEmpty: () => missingOrEmpty,
    toStringOrNull: () => toStringOrNull,
    values: () => values
  });
  function makeNull(value) {
    if (value == null || value === "") {
      return null;
    }
    return value;
  }
  function exists(value, allowEmptyString = false) {
    return value != null && (value !== "" || allowEmptyString);
  }
  function missing(value) {
    return !exists(value);
  }
  function missingOrEmpty(value) {
    return value == null || value.length === 0;
  }
  function toStringOrNull(value) {
    return value != null && typeof value.toString === "function" ? value.toString() : null;
  }
  function attrToNumber(value) {
    if (value === void 0) {
      return;
    }
    if (value === null || value === "") {
      return null;
    }
    if (typeof value === "number") {
      return isNaN(value) ? void 0 : value;
    }
    const valueParsed = parseInt(value, 10);
    return isNaN(valueParsed) ? void 0 : valueParsed;
  }
  function attrToBoolean(value) {
    if (value === void 0) {
      return;
    }
    if (value === null || value === "") {
      return false;
    }
    if (typeof value === "boolean") {
      return value;
    }
    return /true/i.test(value);
  }
  function attrToString(value) {
    if (value == null || value === "") {
      return;
    }
    return value;
  }
  function jsonEquals(val1, val2) {
    const val1Json = val1 ? JSON.stringify(val1) : null;
    const val2Json = val2 ? JSON.stringify(val2) : null;
    return val1Json === val2Json;
  }
  function defaultComparator(valueA, valueB, accentedCompare = false) {
    const valueAMissing = valueA == null;
    const valueBMissing = valueB == null;
    if (valueA && valueA.toNumber) {
      valueA = valueA.toNumber();
    }
    if (valueB && valueB.toNumber) {
      valueB = valueB.toNumber();
    }
    if (valueAMissing && valueBMissing) {
      return 0;
    }
    if (valueAMissing) {
      return -1;
    }
    if (valueBMissing) {
      return 1;
    }
    function doQuickCompare(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    }
    if (typeof valueA !== "string") {
      return doQuickCompare(valueA, valueB);
    }
    if (!accentedCompare) {
      return doQuickCompare(valueA, valueB);
    }
    try {
      return valueA.localeCompare(valueB);
    } catch (e) {
      return doQuickCompare(valueA, valueB);
    }
  }
  function values(object) {
    if (object instanceof Set || object instanceof Map) {
      const arr = [];
      object.forEach((value) => arr.push(value));
      return arr;
    }
    return Object.values(object);
  }
  var ColumnKeyCreator = class {
    constructor() {
      this.existingKeys = {};
    }
    addExistingKeys(keys2) {
      for (let i = 0; i < keys2.length; i++) {
        this.existingKeys[keys2[i]] = true;
      }
    }
    getUniqueKey(colId, colField) {
      colId = toStringOrNull(colId);
      let count = 0;
      while (true) {
        let idToTry;
        if (colId) {
          idToTry = colId;
          if (count !== 0) {
            idToTry += "_" + count;
          }
        } else if (colField) {
          idToTry = colField;
          if (count !== 0) {
            idToTry += "_" + count;
          }
        } else {
          idToTry = count;
        }
        if (!this.existingKeys[idToTry]) {
          this.existingKeys[idToTry] = true;
          return String(idToTry);
        }
        count++;
      }
    }
  };
  var object_exports = {};
  __export2(object_exports, {
    cloneObject: () => cloneObject,
    deepCloneDefinition: () => deepCloneDefinition,
    getAllValuesInObject: () => getAllValuesInObject,
    getValueUsingField: () => getValueUsingField,
    isNonNullObject: () => isNonNullObject,
    iterateObject: () => iterateObject,
    mergeDeep: () => mergeDeep,
    removeAllReferences: () => removeAllReferences
  });
  function iterateObject(object, callback) {
    if (object == null) {
      return;
    }
    if (Array.isArray(object)) {
      for (let i = 0; i < object.length; i++) {
        callback(i.toString(), object[i]);
      }
      return;
    }
    for (const [key, value] of Object.entries(object)) {
      callback(key, value);
    }
  }
  function cloneObject(object) {
    const copy = {};
    const keys2 = Object.keys(object);
    for (let i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      const value = object[key];
      copy[key] = value;
    }
    return copy;
  }
  function deepCloneDefinition(object, keysToSkip) {
    if (!object) {
      return;
    }
    const obj = object;
    const res = {};
    Object.keys(obj).forEach((key) => {
      if (keysToSkip && keysToSkip.indexOf(key) >= 0) {
        return;
      }
      const value = obj[key];
      const sourceIsSimpleObject = isNonNullObject(value) && value.constructor === Object;
      if (sourceIsSimpleObject) {
        res[key] = deepCloneDefinition(value);
      } else {
        res[key] = value;
      }
    });
    return res;
  }
  function getAllValuesInObject(obj) {
    if (!obj) {
      return [];
    }
    const anyObject = Object;
    if (typeof anyObject.values === "function") {
      return anyObject.values(obj);
    }
    const ret = [];
    for (const key in obj) {
      if (obj.hasOwnProperty(key) && obj.propertyIsEnumerable(key)) {
        ret.push(obj[key]);
      }
    }
    return ret;
  }
  function mergeDeep(dest, source, copyUndefined = true, makeCopyOfSimpleObjects = false) {
    if (!exists(source)) {
      return;
    }
    iterateObject(source, (key, sourceValue) => {
      let destValue = dest[key];
      if (destValue === sourceValue) {
        return;
      }
      if (makeCopyOfSimpleObjects) {
        const objectIsDueToBeCopied = destValue == null && sourceValue != null;
        if (objectIsDueToBeCopied) {
          const sourceIsSimpleObject = typeof sourceValue === "object" && sourceValue.constructor === Object;
          const dontCopy = sourceIsSimpleObject;
          if (dontCopy) {
            destValue = {};
            dest[key] = destValue;
          }
        }
      }
      if (isNonNullObject(sourceValue) && isNonNullObject(destValue) && !Array.isArray(destValue)) {
        mergeDeep(destValue, sourceValue, copyUndefined, makeCopyOfSimpleObjects);
      } else if (copyUndefined || sourceValue !== void 0) {
        dest[key] = sourceValue;
      }
    });
  }
  function getValueUsingField(data, field, fieldContainsDots) {
    if (!field || !data) {
      return;
    }
    if (!fieldContainsDots) {
      return data[field];
    }
    const fields = field.split(".");
    let currentObject = data;
    for (let i = 0; i < fields.length; i++) {
      if (currentObject == null) {
        return void 0;
      }
      currentObject = currentObject[fields[i]];
    }
    return currentObject;
  }
  function removeAllReferences(obj, preserveKeys = [], preDestroyLink) {
    Object.keys(obj).forEach((key) => {
      const value = obj[key];
      if (typeof value === "object" && !preserveKeys.includes(key)) {
        obj[key] = void 0;
      }
    });
    const proto = Object.getPrototypeOf(obj);
    const properties = {};
    const msgFunc = (key) => `AG Grid: Grid API function ${key}() cannot be called as the grid has been destroyed.
    It is recommended to remove local references to the grid api. Alternatively, check gridApi.isDestroyed() to avoid calling methods against a destroyed grid.
    To run logic when the grid is about to be destroyed use the gridPreDestroy event. See: ${preDestroyLink}`;
    Object.getOwnPropertyNames(proto).forEach((key) => {
      const value = proto[key];
      if (typeof value === "function" && !preserveKeys.includes(key)) {
        const func = () => {
          console.warn(msgFunc(key));
        };
        properties[key] = { value: func, writable: true };
      }
    });
    Object.defineProperties(obj, properties);
  }
  function isNonNullObject(value) {
    return typeof value === "object" && value !== null;
  }
  var function_exports = {};
  __export2(function_exports, {
    compose: () => compose,
    debounce: () => debounce2,
    doOnce: () => doOnce,
    errorOnce: () => errorOnce,
    executeAfter: () => executeAfter,
    executeInAWhile: () => executeInAWhile,
    executeNextVMTurn: () => executeNextVMTurn,
    getFunctionName: () => getFunctionName,
    isFunction: () => isFunction,
    noop: () => noop,
    throttle: () => throttle,
    waitUntil: () => waitUntil,
    warnOnce: () => warnOnce
  });
  var doOnceFlags = {};
  function doOnce(func, key) {
    if (doOnceFlags[key]) {
      return;
    }
    func();
    doOnceFlags[key] = true;
  }
  function warnOnce(msg) {
    doOnce(() => console.warn("AG Grid: " + msg), msg);
  }
  function errorOnce(msg) {
    doOnce(() => console.error("AG Grid: " + msg), msg);
  }
  function getFunctionName(funcConstructor) {
    if (funcConstructor.name) {
      return funcConstructor.name;
    }
    const matches2 = /function\s+([^\(]+)/.exec(funcConstructor.toString());
    return matches2 && matches2.length === 2 ? matches2[1].trim() : null;
  }
  function isFunction(val) {
    return !!(val && val.constructor && val.call && val.apply);
  }
  function executeInAWhile(funcs) {
    executeAfter(funcs, 400);
  }
  var executeNextVMTurnFuncs = [];
  var executeNextVMTurnPending = false;
  function executeNextVMTurn(func) {
    executeNextVMTurnFuncs.push(func);
    if (executeNextVMTurnPending) {
      return;
    }
    executeNextVMTurnPending = true;
    window.setTimeout(() => {
      const funcsCopy = executeNextVMTurnFuncs.slice();
      executeNextVMTurnFuncs.length = 0;
      executeNextVMTurnPending = false;
      funcsCopy.forEach((func2) => func2());
    }, 0);
  }
  function executeAfter(funcs, milliseconds = 0) {
    if (funcs.length > 0) {
      window.setTimeout(() => funcs.forEach((func) => func()), milliseconds);
    }
  }
  function debounce2(func, delay) {
    let timeout;
    return function(...args) {
      const context = this;
      window.clearTimeout(timeout);
      timeout = window.setTimeout(function() {
        func.apply(context, args);
      }, delay);
    };
  }
  function throttle(func, wait) {
    let previousCall = 0;
    return function(...args) {
      const context = this;
      const currentCall = (/* @__PURE__ */ new Date()).getTime();
      if (currentCall - previousCall < wait) {
        return;
      }
      previousCall = currentCall;
      func.apply(context, args);
    };
  }
  function waitUntil(condition, callback, timeout = 100, timeoutMessage) {
    const timeStamp = (/* @__PURE__ */ new Date()).getTime();
    let interval = null;
    let executed = false;
    const internalCallback = () => {
      const reachedTimeout = (/* @__PURE__ */ new Date()).getTime() - timeStamp > timeout;
      if (condition() || reachedTimeout) {
        callback();
        executed = true;
        if (interval != null) {
          window.clearInterval(interval);
          interval = null;
        }
        if (reachedTimeout && timeoutMessage) {
          console.warn(timeoutMessage);
        }
      }
    };
    internalCallback();
    if (!executed) {
      interval = window.setInterval(internalCallback, 10);
    }
  }
  function compose(...fns) {
    return (arg) => fns.reduce((composed, f) => f(composed), arg);
  }
  var noop = () => {
    return;
  };
  var ModuleNames = /* @__PURE__ */ ((ModuleNames2) => {
    ModuleNames2["CommunityCoreModule"] = "@ag-grid-community/core";
    ModuleNames2["InfiniteRowModelModule"] = "@ag-grid-community/infinite-row-model";
    ModuleNames2["ClientSideRowModelModule"] = "@ag-grid-community/client-side-row-model";
    ModuleNames2["CsvExportModule"] = "@ag-grid-community/csv-export";
    ModuleNames2["EnterpriseCoreModule"] = "@ag-grid-enterprise/core";
    ModuleNames2["RowGroupingModule"] = "@ag-grid-enterprise/row-grouping";
    ModuleNames2["ColumnsToolPanelModule"] = "@ag-grid-enterprise/column-tool-panel";
    ModuleNames2["FiltersToolPanelModule"] = "@ag-grid-enterprise/filter-tool-panel";
    ModuleNames2["MenuModule"] = "@ag-grid-enterprise/menu";
    ModuleNames2["SetFilterModule"] = "@ag-grid-enterprise/set-filter";
    ModuleNames2["MultiFilterModule"] = "@ag-grid-enterprise/multi-filter";
    ModuleNames2["StatusBarModule"] = "@ag-grid-enterprise/status-bar";
    ModuleNames2["SideBarModule"] = "@ag-grid-enterprise/side-bar";
    ModuleNames2["RangeSelectionModule"] = "@ag-grid-enterprise/range-selection";
    ModuleNames2["MasterDetailModule"] = "@ag-grid-enterprise/master-detail";
    ModuleNames2["RichSelectModule"] = "@ag-grid-enterprise/rich-select";
    ModuleNames2["GridChartsModule"] = "@ag-grid-enterprise/charts";
    ModuleNames2["ViewportRowModelModule"] = "@ag-grid-enterprise/viewport-row-model";
    ModuleNames2["ServerSideRowModelModule"] = "@ag-grid-enterprise/server-side-row-model";
    ModuleNames2["ExcelExportModule"] = "@ag-grid-enterprise/excel-export";
    ModuleNames2["ClipboardModule"] = "@ag-grid-enterprise/clipboard";
    ModuleNames2["SparklinesModule"] = "@ag-grid-enterprise/sparklines";
    ModuleNames2["AdvancedFilterModule"] = "@ag-grid-enterprise/advanced-filter";
    ModuleNames2["AngularModule"] = "@ag-grid-community/angular";
    ModuleNames2["ReactModule"] = "@ag-grid-community/react";
    ModuleNames2["VueModule"] = "@ag-grid-community/vue";
    return ModuleNames2;
  })(ModuleNames || {});
  var _ModuleRegistry = class _ModuleRegistry2 {
    /**
     * Globally register the given module for all grids.
     * @param module - module to register
     */
    static register(module) {
      _ModuleRegistry2.__register(module, true, void 0);
    }
    /**
     * Globally register the given modules for all grids.
     * @param modules - modules to register
     */
    static registerModules(modules) {
      _ModuleRegistry2.__registerModules(modules, true, void 0);
    }
    /** AG GRID INTERNAL - Module registration helper. */
    static __register(module, moduleBased, gridId) {
      _ModuleRegistry2.runVersionChecks(module);
      if (gridId !== void 0) {
        _ModuleRegistry2.areGridScopedModules = true;
        if (_ModuleRegistry2.gridModulesMap[gridId] === void 0) {
          _ModuleRegistry2.gridModulesMap[gridId] = {};
        }
        _ModuleRegistry2.gridModulesMap[gridId][module.moduleName] = module;
      } else {
        _ModuleRegistry2.globalModulesMap[module.moduleName] = module;
      }
      _ModuleRegistry2.setModuleBased(moduleBased);
    }
    /** AG GRID INTERNAL - Unregister grid scoped module. */
    static __unRegisterGridModules(gridId) {
      delete _ModuleRegistry2.gridModulesMap[gridId];
    }
    /** AG GRID INTERNAL - Module registration helper. */
    static __registerModules(modules, moduleBased, gridId) {
      _ModuleRegistry2.setModuleBased(moduleBased);
      if (!modules) {
        return;
      }
      modules.forEach((module) => _ModuleRegistry2.__register(module, moduleBased, gridId));
    }
    static isValidModuleVersion(module) {
      const [moduleMajor, moduleMinor] = module.version.split(".") || [];
      const [currentModuleMajor, currentModuleMinor] = _ModuleRegistry2.currentModuleVersion.split(".") || [];
      return moduleMajor === currentModuleMajor && moduleMinor === currentModuleMinor;
    }
    static runVersionChecks(module) {
      if (!_ModuleRegistry2.currentModuleVersion) {
        _ModuleRegistry2.currentModuleVersion = module.version;
      }
      if (!module.version) {
        console.error(`AG Grid: You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. '${module.moduleName}' is incompatible. Please update all modules to the same version.`);
      } else if (!_ModuleRegistry2.isValidModuleVersion(module)) {
        console.error(`AG Grid: You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. '${module.moduleName}' is version ${module.version} but the other modules are version ${this.currentModuleVersion}. Please update all modules to the same version.`);
      }
      if (module.validate) {
        const result = module.validate();
        if (!result.isValid) {
          const errorResult = result;
          console.error(`AG Grid: ${errorResult.message}`);
        }
      }
    }
    static setModuleBased(moduleBased) {
      if (_ModuleRegistry2.moduleBased === void 0) {
        _ModuleRegistry2.moduleBased = moduleBased;
      } else {
        if (_ModuleRegistry2.moduleBased !== moduleBased) {
          doOnce(
            () => {
              console.warn(`AG Grid: You are mixing modules (i.e. @ag-grid-community/core) and packages (ag-grid-community) - you can only use one or the other of these mechanisms.`);
              console.warn("Please see https://www.ag-grid.com/javascript-grid/modules/ for more information.");
            },
            "ModulePackageCheck"
          );
        }
      }
    }
    /**
     * AG GRID INTERNAL - Set if files are being served from a single UMD bundle to provide accurate enterprise upgrade steps.
     */
    static __setIsBundled() {
      _ModuleRegistry2.isBundled = true;
    }
    /** AG GRID INTERNAL - Assert a given module has been register, globally or individually with this grid. */
    static __assertRegistered(moduleName, reason, gridId) {
      var _a;
      if (this.__isRegistered(moduleName, gridId)) {
        return true;
      }
      const warningKey = reason + moduleName;
      let warningMessage;
      if (_ModuleRegistry2.isBundled) {
        {
          warningMessage = `AG Grid: unable to use ${reason} as 'ag-grid-enterprise' has not been loaded. Check you are using the Enterprise bundle:
        
        <script src="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@AG_GRID_VERSION/dist/ag-grid-enterprise.min.js"><\/script>
        
For more info see: https://ag-grid.com/javascript-data-grid/getting-started/#getting-started-with-ag-grid-enterprise`;
        }
      } else if (_ModuleRegistry2.moduleBased || _ModuleRegistry2.moduleBased === void 0) {
        let modName = (_a = Object.entries(ModuleNames).find(([k, v]) => v === moduleName)) == null ? void 0 : _a[0];
        warningMessage = `AG Grid: unable to use ${reason} as the ${modName} is not registered${_ModuleRegistry2.areGridScopedModules ? ` for gridId: ${gridId}` : ""}. Check if you have registered the module:
           
    import { ModuleRegistry } from '@ag-grid-community/core';
    import { ${modName} } from '${moduleName}';
    
    ModuleRegistry.registerModules([ ${modName} ]);

For more info see: https://www.ag-grid.com/javascript-grid/modules/`;
      } else {
        warningMessage = `AG Grid: unable to use ${reason} as package 'ag-grid-enterprise' has not been imported. Check that you have imported the package:
            
    import 'ag-grid-enterprise';`;
      }
      doOnce(() => {
        console.warn(warningMessage);
      }, warningKey);
      return false;
    }
    /** AG GRID INTERNAL - Is the given module registered, globally or individually with this grid. */
    static __isRegistered(moduleName, gridId) {
      var _a;
      return !!_ModuleRegistry2.globalModulesMap[moduleName] || !!((_a = _ModuleRegistry2.gridModulesMap[gridId]) == null ? void 0 : _a[moduleName]);
    }
    /** AG GRID INTERNAL - Get all registered modules globally / individually for this grid. */
    static __getRegisteredModules(gridId) {
      return [...values(_ModuleRegistry2.globalModulesMap), ...values(_ModuleRegistry2.gridModulesMap[gridId] || {})];
    }
    /** AG GRID INTERNAL - Get the list of modules registered individually for this grid. */
    static __getGridRegisteredModules(gridId) {
      var _a;
      return values((_a = _ModuleRegistry2.gridModulesMap[gridId]) != null ? _a : {}) || [];
    }
    /** INTERNAL */
    static __isPackageBased() {
      return !_ModuleRegistry2.moduleBased;
    }
  };
  _ModuleRegistry.globalModulesMap = {};
  _ModuleRegistry.gridModulesMap = {};
  _ModuleRegistry.areGridScopedModules = false;
  var ModuleRegistry = _ModuleRegistry;
  var Context2 = class {
    constructor(params, logger) {
      this.beanWrappers = {};
      this.destroyed = false;
      if (!params || !params.beanClasses) {
        return;
      }
      this.contextParams = params;
      this.logger = logger;
      this.logger.log(">> creating ag-Application Context");
      this.createBeans();
      const beanInstances = this.getBeanInstances();
      this.wireBeans(beanInstances);
      this.logger.log(">> ag-Application Context ready - component is alive");
    }
    getBeanInstances() {
      return values(this.beanWrappers).map((beanEntry) => beanEntry.beanInstance);
    }
    createBean(bean, afterPreCreateCallback) {
      if (!bean) {
        throw Error(`Can't wire to bean since it is null`);
      }
      this.wireBeans([bean], afterPreCreateCallback);
      return bean;
    }
    wireBeans(beanInstances, afterPreCreateCallback) {
      this.autoWireBeans(beanInstances);
      this.methodWireBeans(beanInstances);
      this.callLifeCycleMethods(beanInstances, "preConstructMethods");
      if (exists(afterPreCreateCallback)) {
        beanInstances.forEach(afterPreCreateCallback);
      }
      this.callLifeCycleMethods(beanInstances, "postConstructMethods");
    }
    createBeans() {
      this.contextParams.beanClasses.forEach(this.createBeanWrapper.bind(this));
      iterateObject(this.beanWrappers, (key, beanEntry) => {
        let constructorParamsMeta;
        if (beanEntry.bean.__agBeanMetaData && beanEntry.bean.__agBeanMetaData.autowireMethods && beanEntry.bean.__agBeanMetaData.autowireMethods.agConstructor) {
          constructorParamsMeta = beanEntry.bean.__agBeanMetaData.autowireMethods.agConstructor;
        }
        const constructorParams = this.getBeansForParameters(constructorParamsMeta, beanEntry.bean.name);
        const newInstance = new (beanEntry.bean.bind.apply(beanEntry.bean, [null, ...constructorParams]))();
        beanEntry.beanInstance = newInstance;
      });
      const createdBeanNames = Object.keys(this.beanWrappers).join(", ");
      this.logger.log(`created beans: ${createdBeanNames}`);
    }
    // tslint:disable-next-line
    createBeanWrapper(BeanClass) {
      const metaData = BeanClass.__agBeanMetaData;
      if (!metaData) {
        let beanName;
        if (BeanClass.prototype.constructor) {
          beanName = getFunctionName(BeanClass.prototype.constructor);
        } else {
          beanName = "" + BeanClass;
        }
        console.error(`Context item ${beanName} is not a bean`);
        return;
      }
      const beanEntry = {
        bean: BeanClass,
        beanInstance: null,
        beanName: metaData.beanName
      };
      this.beanWrappers[metaData.beanName] = beanEntry;
    }
    autoWireBeans(beanInstances) {
      beanInstances.forEach((beanInstance) => {
        this.forEachMetaDataInHierarchy(beanInstance, (metaData, beanName) => {
          const attributes = metaData.agClassAttributes;
          if (!attributes) {
            return;
          }
          attributes.forEach((attribute) => {
            const otherBean = this.lookupBeanInstance(beanName, attribute.beanName, attribute.optional);
            beanInstance[attribute.attributeName] = otherBean;
          });
        });
      });
    }
    methodWireBeans(beanInstances) {
      beanInstances.forEach((beanInstance) => {
        this.forEachMetaDataInHierarchy(beanInstance, (metaData, beanName) => {
          iterateObject(metaData.autowireMethods, (methodName, wireParams) => {
            if (methodName === "agConstructor") {
              return;
            }
            const initParams = this.getBeansForParameters(wireParams, beanName);
            beanInstance[methodName].apply(beanInstance, initParams);
          });
        });
      });
    }
    forEachMetaDataInHierarchy(beanInstance, callback) {
      let prototype = Object.getPrototypeOf(beanInstance);
      while (prototype != null) {
        const constructor = prototype.constructor;
        if (constructor.hasOwnProperty("__agBeanMetaData")) {
          const metaData = constructor.__agBeanMetaData;
          const beanName = this.getBeanName(constructor);
          callback(metaData, beanName);
        }
        prototype = Object.getPrototypeOf(prototype);
      }
    }
    getBeanName(constructor) {
      if (constructor.__agBeanMetaData && constructor.__agBeanMetaData.beanName) {
        return constructor.__agBeanMetaData.beanName;
      }
      const constructorString = constructor.toString();
      const beanName = constructorString.substring(9, constructorString.indexOf("("));
      return beanName;
    }
    getBeansForParameters(parameters, beanName) {
      const beansList = [];
      if (parameters) {
        iterateObject(parameters, (paramIndex, otherBeanName) => {
          const otherBean = this.lookupBeanInstance(beanName, otherBeanName);
          beansList[Number(paramIndex)] = otherBean;
        });
      }
      return beansList;
    }
    lookupBeanInstance(wiringBean, beanName, optional = false) {
      if (this.destroyed) {
        this.logger.log(`AG Grid: bean reference ${beanName} is used after the grid is destroyed!`);
        return null;
      }
      if (beanName === "context") {
        return this;
      }
      if (this.contextParams.providedBeanInstances && this.contextParams.providedBeanInstances.hasOwnProperty(beanName)) {
        return this.contextParams.providedBeanInstances[beanName];
      }
      const beanEntry = this.beanWrappers[beanName];
      if (beanEntry) {
        return beanEntry.beanInstance;
      }
      if (!optional) {
        console.error(`AG Grid: unable to find bean reference ${beanName} while initialising ${wiringBean}`);
      }
      return null;
    }
    callLifeCycleMethods(beanInstances, lifeCycleMethod) {
      beanInstances.forEach((beanInstance) => this.callLifeCycleMethodsOnBean(beanInstance, lifeCycleMethod));
    }
    callLifeCycleMethodsOnBean(beanInstance, lifeCycleMethod, methodToIgnore) {
      const allMethods = {};
      this.forEachMetaDataInHierarchy(beanInstance, (metaData) => {
        const methods = metaData[lifeCycleMethod];
        if (methods) {
          methods.forEach((methodName) => {
            if (methodName != methodToIgnore) {
              allMethods[methodName] = true;
            }
          });
        }
      });
      const allMethodsList = Object.keys(allMethods);
      allMethodsList.forEach((methodName) => beanInstance[methodName]());
    }
    getBean(name) {
      return this.lookupBeanInstance("getBean", name, true);
    }
    destroy() {
      if (this.destroyed) {
        return;
      }
      this.destroyed = true;
      this.logger.log(">> Shutting down ag-Application Context");
      const beanInstances = this.getBeanInstances();
      this.destroyBeans(beanInstances);
      this.contextParams.providedBeanInstances = null;
      ModuleRegistry.__unRegisterGridModules(this.contextParams.gridId);
      this.logger.log(">> ag-Application Context shut down - component is dead");
    }
    destroyBean(bean) {
      if (!bean) {
        return;
      }
      this.destroyBeans([bean]);
    }
    destroyBeans(beans) {
      if (!beans) {
        return [];
      }
      beans.forEach((bean) => {
        this.callLifeCycleMethodsOnBean(bean, "preDestroyMethods", "destroy");
        const beanAny = bean;
        if (typeof beanAny.destroy === "function") {
          beanAny.destroy();
        }
      });
      return [];
    }
    isDestroyed() {
      return this.destroyed;
    }
    getGridId() {
      return this.contextParams.gridId;
    }
  };
  function PreConstruct(target, methodName, descriptor) {
    const props = getOrCreateProps(target.constructor);
    if (!props.preConstructMethods) {
      props.preConstructMethods = [];
    }
    props.preConstructMethods.push(methodName);
  }
  function PostConstruct(target, methodName, descriptor) {
    const props = getOrCreateProps(target.constructor);
    if (!props.postConstructMethods) {
      props.postConstructMethods = [];
    }
    props.postConstructMethods.push(methodName);
  }
  function PreDestroy(target, methodName, descriptor) {
    const props = getOrCreateProps(target.constructor);
    if (!props.preDestroyMethods) {
      props.preDestroyMethods = [];
    }
    props.preDestroyMethods.push(methodName);
  }
  function Bean(beanName) {
    return (classConstructor) => {
      const props = getOrCreateProps(classConstructor);
      props.beanName = beanName;
    };
  }
  function Autowired(name) {
    return (target, propertyKey, descriptor) => {
      autowiredFunc(target, name, false, target, propertyKey, null);
    };
  }
  function Optional(name) {
    return (target, propertyKey, descriptor) => {
      autowiredFunc(target, name, true, target, propertyKey, null);
    };
  }
  function autowiredFunc(target, name, optional, classPrototype, methodOrAttributeName, index) {
    if (name === null) {
      console.error("AG Grid: Autowired name should not be null");
      return;
    }
    if (typeof index === "number") {
      console.error("AG Grid: Autowired should be on an attribute");
      return;
    }
    const props = getOrCreateProps(target.constructor);
    if (!props.agClassAttributes) {
      props.agClassAttributes = [];
    }
    props.agClassAttributes.push({
      attributeName: methodOrAttributeName,
      beanName: name,
      optional
    });
  }
  function Qualifier(name) {
    return (classPrototype, methodOrAttributeName, index) => {
      const constructor = typeof classPrototype == "function" ? classPrototype : classPrototype.constructor;
      let props;
      if (typeof index === "number") {
        let methodName;
        if (methodOrAttributeName) {
          props = getOrCreateProps(constructor);
          methodName = methodOrAttributeName;
        } else {
          props = getOrCreateProps(constructor);
          methodName = "agConstructor";
        }
        if (!props.autowireMethods) {
          props.autowireMethods = {};
        }
        if (!props.autowireMethods[methodName]) {
          props.autowireMethods[methodName] = {};
        }
        props.autowireMethods[methodName][index] = name;
      }
    };
  }
  function getOrCreateProps(target) {
    if (!target.hasOwnProperty("__agBeanMetaData")) {
      target.__agBeanMetaData = {};
    }
    return target.__agBeanMetaData;
  }
  var EventService = class {
    constructor() {
      this.allSyncListeners = /* @__PURE__ */ new Map();
      this.allAsyncListeners = /* @__PURE__ */ new Map();
      this.globalSyncListeners = /* @__PURE__ */ new Set();
      this.globalAsyncListeners = /* @__PURE__ */ new Set();
      this.asyncFunctionsQueue = [];
      this.scheduled = false;
      this.firedEvents = {};
    }
    // because this class is used both inside the context and outside the context, we do not
    // use autowired attributes, as that would be confusing, as sometimes the attributes
    // would be wired, and sometimes not.
    //
    // the global event servers used by AG Grid is autowired by the context once, and this
    // setBeans method gets called once.
    //
    // the times when this class is used outside of the context (eg RowNode has an instance of this
    // class) then it is not a bean, and this setBeans method is not called.
    setBeans(gos, frameworkOverrides, globalEventListener = null, globalSyncEventListener = null) {
      this.frameworkOverrides = frameworkOverrides;
      this.gos = gos;
      if (globalEventListener) {
        const async = gos.useAsyncEvents();
        this.addGlobalListener(globalEventListener, async);
      }
      if (globalSyncEventListener) {
        this.addGlobalListener(globalSyncEventListener, false);
      }
    }
    setFrameworkOverrides(frameworkOverrides) {
      this.frameworkOverrides = frameworkOverrides;
    }
    getListeners(eventType, async, autoCreateListenerCollection) {
      const listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;
      let listeners = listenerMap.get(eventType);
      if (!listeners && autoCreateListenerCollection) {
        listeners = /* @__PURE__ */ new Set();
        listenerMap.set(eventType, listeners);
      }
      return listeners;
    }
    noRegisteredListenersExist() {
      return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
    }
    addEventListener(eventType, listener, async = false) {
      this.getListeners(eventType, async, true).add(listener);
    }
    removeEventListener(eventType, listener, async = false) {
      const listeners = this.getListeners(eventType, async, false);
      if (!listeners) {
        return;
      }
      listeners.delete(listener);
      if (listeners.size === 0) {
        const listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;
        listenerMap.delete(eventType);
      }
    }
    addGlobalListener(listener, async = false) {
      (async ? this.globalAsyncListeners : this.globalSyncListeners).add(listener);
    }
    removeGlobalListener(listener, async = false) {
      (async ? this.globalAsyncListeners : this.globalSyncListeners).delete(listener);
    }
    dispatchEvent(event) {
      let agEvent = event;
      if (this.gos) {
        this.gos.addGridCommonParams(agEvent);
      }
      this.dispatchToListeners(agEvent, true);
      this.dispatchToListeners(agEvent, false);
      this.firedEvents[agEvent.type] = true;
    }
    dispatchEventOnce(event) {
      if (!this.firedEvents[event.type]) {
        this.dispatchEvent(event);
      }
    }
    dispatchToListeners(event, async) {
      var _a;
      const eventType = event.type;
      if (async && "event" in event) {
        const browserEvent = event.event;
        if (browserEvent instanceof Event) {
          event.eventPath = browserEvent.composedPath();
        }
      }
      const processEventListeners = (listeners2, originalListeners2) => listeners2.forEach((listener) => {
        if (!originalListeners2.has(listener)) {
          return;
        }
        const callback = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => listener(event)) : () => listener(event);
        if (async) {
          this.dispatchAsync(callback);
        } else {
          callback();
        }
      });
      const originalListeners = (_a = this.getListeners(eventType, async, false)) != null ? _a : /* @__PURE__ */ new Set();
      const listeners = new Set(originalListeners);
      if (listeners.size > 0) {
        processEventListeners(listeners, originalListeners);
      }
      const globalListeners = new Set(async ? this.globalAsyncListeners : this.globalSyncListeners);
      globalListeners.forEach((listener) => {
        const callback = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => listener(eventType, event)) : () => listener(eventType, event);
        if (async) {
          this.dispatchAsync(callback);
        } else {
          callback();
        }
      });
    }
    // this gets called inside the grid's thread, for each event that it
    // wants to set async. the grid then batches the events into one setTimeout()
    // because setTimeout() is an expensive operation. ideally we would have
    // each event in it's own setTimeout(), but we batch for performance.
    dispatchAsync(func) {
      this.asyncFunctionsQueue.push(func);
      if (!this.scheduled) {
        this.frameworkOverrides.wrapIncoming(() => {
          window.setTimeout(this.flushAsyncQueue.bind(this), 0);
        });
        this.scheduled = true;
      }
    }
    // this happens in the next VM turn only, and empties the queue of events
    flushAsyncQueue() {
      this.scheduled = false;
      const queueCopy = this.asyncFunctionsQueue.slice();
      this.asyncFunctionsQueue = [];
      queueCopy.forEach((func) => func());
    }
  };
  __decorateClass([
    __decorateParam(0, Qualifier("gridOptionsService")),
    __decorateParam(1, Qualifier("frameworkOverrides")),
    __decorateParam(2, Qualifier("globalEventListener")),
    __decorateParam(3, Qualifier("globalSyncEventListener"))
  ], EventService.prototype, "setBeans", 1);
  EventService = __decorateClass([
    Bean("eventService")
  ], EventService);
  var FrameworkEventListenerService = class {
    constructor(frameworkOverrides) {
      this.frameworkOverrides = frameworkOverrides;
      this.wrappedListeners = /* @__PURE__ */ new Map();
      this.wrappedGlobalListeners = /* @__PURE__ */ new Map();
    }
    wrap(userListener) {
      let listener = userListener;
      if (this.frameworkOverrides.shouldWrapOutgoing) {
        listener = (event) => {
          this.frameworkOverrides.wrapOutgoing(() => userListener(event));
        };
        this.wrappedListeners.set(userListener, listener);
      }
      return listener;
    }
    wrapGlobal(userListener) {
      let listener = userListener;
      if (this.frameworkOverrides.shouldWrapOutgoing) {
        listener = (eventType, event) => {
          this.frameworkOverrides.wrapOutgoing(() => userListener(eventType, event));
        };
        this.wrappedGlobalListeners.set(userListener, listener);
      }
      return listener;
    }
    unwrap(userListener) {
      var _a;
      return (_a = this.wrappedListeners.get(userListener)) != null ? _a : userListener;
    }
    unwrapGlobal(userListener) {
      var _a;
      return (_a = this.wrappedGlobalListeners.get(userListener)) != null ? _a : userListener;
    }
  };
  var COL_DEF_DEFAULTS = {
    resizable: true,
    sortable: true
  };
  var instanceIdSequence = 0;
  function getNextColInstanceId() {
    return instanceIdSequence++;
  }
  var _Column = class _Column2 {
    constructor(colDef, userProvidedColDef, colId, primary) {
      this.instanceId = getNextColInstanceId();
      this.autoHeaderHeight = null;
      this.moving = false;
      this.menuVisible = false;
      this.lastLeftPinned = false;
      this.firstRightPinned = false;
      this.filterActive = false;
      this.eventService = new EventService();
      this.tooltipEnabled = false;
      this.rowGroupActive = false;
      this.pivotActive = false;
      this.aggregationActive = false;
      this.colDef = colDef;
      this.userProvidedColDef = userProvidedColDef;
      this.colId = colId;
      this.primary = primary;
      this.setState(colDef);
    }
    getInstanceId() {
      return this.instanceId;
    }
    setState(colDef) {
      if (colDef.sort !== void 0) {
        if (colDef.sort === "asc" || colDef.sort === "desc") {
          this.sort = colDef.sort;
        }
      } else {
        if (colDef.initialSort === "asc" || colDef.initialSort === "desc") {
          this.sort = colDef.initialSort;
        }
      }
      const sortIndex = colDef.sortIndex;
      const initialSortIndex = colDef.initialSortIndex;
      if (sortIndex !== void 0) {
        if (sortIndex !== null) {
          this.sortIndex = sortIndex;
        }
      } else {
        if (initialSortIndex !== null) {
          this.sortIndex = initialSortIndex;
        }
      }
      const hide = colDef.hide;
      const initialHide = colDef.initialHide;
      if (hide !== void 0) {
        this.visible = !hide;
      } else {
        this.visible = !initialHide;
      }
      if (colDef.pinned !== void 0) {
        this.setPinned(colDef.pinned);
      } else {
        this.setPinned(colDef.initialPinned);
      }
      const flex = colDef.flex;
      const initialFlex = colDef.initialFlex;
      if (flex !== void 0) {
        this.flex = flex;
      } else if (initialFlex !== void 0) {
        this.flex = initialFlex;
      }
    }
    // gets called when user provides an alternative colDef, eg
    setColDef(colDef, userProvidedColDef, source) {
      this.colDef = colDef;
      this.userProvidedColDef = userProvidedColDef;
      this.initMinAndMaxWidths();
      this.initDotNotation();
      this.initTooltip();
      this.eventService.dispatchEvent(this.createColumnEvent("colDefChanged", source));
    }
    /**
     * Returns the column definition provided by the application.
     * This may not be correct, as items can be superseded by default column options.
     * However it's useful for comparison, eg to know which application column definition matches that column.
     */
    getUserProvidedColDef() {
      return this.userProvidedColDef;
    }
    setParent(parent) {
      this.parent = parent;
    }
    /** Returns the parent column group, if column grouping is active. */
    getParent() {
      return this.parent;
    }
    setOriginalParent(originalParent) {
      this.originalParent = originalParent;
    }
    /**
     * Used for marryChildren, helps with comparing when duplicate groups have been created to manage split groups.
     * 
     * Parent may contain a duplicate but not identical group when the group is split.
     */
    getOriginalParent() {
      return this.originalParent;
    }
    initialise() {
      this.initMinAndMaxWidths();
      this.resetActualWidth("gridInitializing");
      this.initDotNotation();
      this.initTooltip();
    }
    initDotNotation() {
      const suppressDotNotation = this.gos.get("suppressFieldDotNotation");
      this.fieldContainsDots = exists(this.colDef.field) && this.colDef.field.indexOf(".") >= 0 && !suppressDotNotation;
      this.tooltipFieldContainsDots = exists(this.colDef.tooltipField) && this.colDef.tooltipField.indexOf(".") >= 0 && !suppressDotNotation;
    }
    initMinAndMaxWidths() {
      var _a, _b;
      const colDef = this.colDef;
      this.minWidth = (_a = colDef.minWidth) != null ? _a : this.environment.getMinColWidth();
      this.maxWidth = (_b = colDef.maxWidth) != null ? _b : Number.MAX_SAFE_INTEGER;
    }
    initTooltip() {
      this.tooltipEnabled = exists(this.colDef.tooltipField) || exists(this.colDef.tooltipValueGetter) || exists(this.colDef.tooltipComponent);
    }
    resetActualWidth(source) {
      const initialWidth = this.calculateColInitialWidth(this.colDef);
      this.setActualWidth(initialWidth, source, true);
    }
    calculateColInitialWidth(colDef) {
      var _a, _b;
      const minColWidth = (_a = colDef.minWidth) != null ? _a : this.environment.getMinColWidth();
      const maxColWidth = (_b = colDef.maxWidth) != null ? _b : Number.MAX_SAFE_INTEGER;
      let width;
      const colDefWidth = attrToNumber(colDef.width);
      const colDefInitialWidth = attrToNumber(colDef.initialWidth);
      if (colDefWidth != null) {
        width = colDefWidth;
      } else if (colDefInitialWidth != null) {
        width = colDefInitialWidth;
      } else {
        width = 200;
      }
      return Math.max(Math.min(width, maxColWidth), minColWidth);
    }
    isEmptyGroup() {
      return false;
    }
    isRowGroupDisplayed(colId) {
      if (missing(this.colDef) || missing(this.colDef.showRowGroup)) {
        return false;
      }
      const showingAllGroups = this.colDef.showRowGroup === true;
      const showingThisGroup = this.colDef.showRowGroup === colId;
      return showingAllGroups || showingThisGroup;
    }
    /** Returns `true` if column is a primary column, `false` if secondary. Secondary columns are used for pivoting. */
    isPrimary() {
      return this.primary;
    }
    /** Returns `true` if column filtering is allowed. */
    isFilterAllowed() {
      const filterDefined = !!this.colDef.filter;
      return filterDefined;
    }
    isFieldContainsDots() {
      return this.fieldContainsDots;
    }
    isTooltipEnabled() {
      return this.tooltipEnabled;
    }
    isTooltipFieldContainsDots() {
      return this.tooltipFieldContainsDots;
    }
    /** Add an event listener to the column. */
    addEventListener(eventType, userListener) {
      var _a, _b;
      if (this.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService) {
        this.eventService.setFrameworkOverrides(this.frameworkOverrides);
        this.frameworkEventListenerService = new FrameworkEventListenerService(this.frameworkOverrides);
      }
      const listener = (_b = (_a = this.frameworkEventListenerService) == null ? void 0 : _a.wrap(userListener)) != null ? _b : userListener;
      this.eventService.addEventListener(eventType, listener);
    }
    /** Remove event listener from the column. */
    removeEventListener(eventType, userListener) {
      var _a, _b;
      const listener = (_b = (_a = this.frameworkEventListenerService) == null ? void 0 : _a.unwrap(userListener)) != null ? _b : userListener;
      this.eventService.removeEventListener(eventType, listener);
    }
    createColumnFunctionCallbackParams(rowNode) {
      return this.gos.addGridCommonParams({
        node: rowNode,
        data: rowNode.data,
        column: this,
        colDef: this.colDef
      });
    }
    isSuppressNavigable(rowNode) {
      if (typeof this.colDef.suppressNavigable === "boolean") {
        return this.colDef.suppressNavigable;
      }
      if (typeof this.colDef.suppressNavigable === "function") {
        const params = this.createColumnFunctionCallbackParams(rowNode);
        const userFunc = this.colDef.suppressNavigable;
        return userFunc(params);
      }
      return false;
    }
    /**
     * Returns `true` if the cell for this column is editable for the given `rowNode`, otherwise `false`.
     */
    isCellEditable(rowNode) {
      if (rowNode.group && !this.gos.get("enableGroupEdit")) {
        return false;
      }
      return this.isColumnFunc(rowNode, this.colDef.editable);
    }
    isSuppressFillHandle() {
      return !!this.colDef.suppressFillHandle;
    }
    isAutoHeight() {
      return !!this.colDef.autoHeight;
    }
    isAutoHeaderHeight() {
      return !!this.colDef.autoHeaderHeight;
    }
    isRowDrag(rowNode) {
      return this.isColumnFunc(rowNode, this.colDef.rowDrag);
    }
    isDndSource(rowNode) {
      return this.isColumnFunc(rowNode, this.colDef.dndSource);
    }
    isCellCheckboxSelection(rowNode) {
      return this.isColumnFunc(rowNode, this.colDef.checkboxSelection);
    }
    isSuppressPaste(rowNode) {
      return this.isColumnFunc(rowNode, this.colDef ? this.colDef.suppressPaste : null);
    }
    isResizable() {
      return !!this.getColDefValue("resizable");
    }
    /** Get value from ColDef or default if it exists. */
    getColDefValue(key) {
      var _a;
      return (_a = this.colDef[key]) != null ? _a : COL_DEF_DEFAULTS[key];
    }
    isColumnFunc(rowNode, value) {
      if (typeof value === "boolean") {
        return value;
      }
      if (typeof value === "function") {
        const params = this.createColumnFunctionCallbackParams(rowNode);
        const editableFunc = value;
        return editableFunc(params);
      }
      return false;
    }
    setMoving(moving, source) {
      this.moving = moving;
      this.eventService.dispatchEvent(this.createColumnEvent("movingChanged", source));
    }
    createColumnEvent(type, source) {
      return this.gos.addGridCommonParams({
        type,
        column: this,
        columns: [this],
        source
      });
    }
    isMoving() {
      return this.moving;
    }
    /** If sorting is active, returns the sort direction e.g. `'asc'` or `'desc'`. */
    getSort() {
      return this.sort;
    }
    setSort(sort, source) {
      if (this.sort !== sort) {
        this.sort = sort;
        this.eventService.dispatchEvent(this.createColumnEvent("sortChanged", source));
      }
      this.dispatchStateUpdatedEvent("sort");
    }
    setMenuVisible(visible, source) {
      if (this.menuVisible !== visible) {
        this.menuVisible = visible;
        this.eventService.dispatchEvent(this.createColumnEvent("menuVisibleChanged", source));
      }
    }
    isMenuVisible() {
      return this.menuVisible;
    }
    isSortable() {
      return !!this.getColDefValue("sortable");
    }
    isSortAscending() {
      return this.sort === "asc";
    }
    isSortDescending() {
      return this.sort === "desc";
    }
    isSortNone() {
      return missing(this.sort);
    }
    isSorting() {
      return exists(this.sort);
    }
    getSortIndex() {
      return this.sortIndex;
    }
    setSortIndex(sortOrder) {
      this.sortIndex = sortOrder;
      this.dispatchStateUpdatedEvent("sortIndex");
    }
    setAggFunc(aggFunc) {
      this.aggFunc = aggFunc;
      this.dispatchStateUpdatedEvent("aggFunc");
    }
    /** If aggregation is set for the column, returns the aggregation function. */
    getAggFunc() {
      return this.aggFunc;
    }
    getLeft() {
      return this.left;
    }
    getOldLeft() {
      return this.oldLeft;
    }
    getRight() {
      return this.left + this.actualWidth;
    }
    setLeft(left, source) {
      this.oldLeft = this.left;
      if (this.left !== left) {
        this.left = left;
        this.eventService.dispatchEvent(this.createColumnEvent("leftChanged", source));
      }
    }
    /** Returns `true` if filter is active on the column. */
    isFilterActive() {
      return this.filterActive;
    }
    // additionalEventAttributes is used by provided simple floating filter, so it can add 'floatingFilter=true' to the event
    setFilterActive(active, source, additionalEventAttributes) {
      if (this.filterActive !== active) {
        this.filterActive = active;
        this.eventService.dispatchEvent(this.createColumnEvent("filterActiveChanged", source));
      }
      const filterChangedEvent = this.createColumnEvent("filterChanged", source);
      if (additionalEventAttributes) {
        mergeDeep(filterChangedEvent, additionalEventAttributes);
      }
      this.eventService.dispatchEvent(filterChangedEvent);
    }
    /** Returns `true` when this `Column` is hovered, otherwise `false` */
    isHovered() {
      return this.columnHoverService.isHovered(this);
    }
    setPinned(pinned) {
      if (pinned === true || pinned === "left") {
        this.pinned = "left";
      } else if (pinned === "right") {
        this.pinned = "right";
      } else {
        this.pinned = null;
      }
      this.dispatchStateUpdatedEvent("pinned");
    }
    setFirstRightPinned(firstRightPinned, source) {
      if (this.firstRightPinned !== firstRightPinned) {
        this.firstRightPinned = firstRightPinned;
        this.eventService.dispatchEvent(this.createColumnEvent("firstRightPinnedChanged", source));
      }
    }
    setLastLeftPinned(lastLeftPinned, source) {
      if (this.lastLeftPinned !== lastLeftPinned) {
        this.lastLeftPinned = lastLeftPinned;
        this.eventService.dispatchEvent(this.createColumnEvent("lastLeftPinnedChanged", source));
      }
    }
    isFirstRightPinned() {
      return this.firstRightPinned;
    }
    isLastLeftPinned() {
      return this.lastLeftPinned;
    }
    isPinned() {
      return this.pinned === "left" || this.pinned === "right";
    }
    isPinnedLeft() {
      return this.pinned === "left";
    }
    isPinnedRight() {
      return this.pinned === "right";
    }
    getPinned() {
      return this.pinned;
    }
    setVisible(visible, source) {
      const newValue = visible === true;
      if (this.visible !== newValue) {
        this.visible = newValue;
        this.eventService.dispatchEvent(this.createColumnEvent("visibleChanged", source));
      }
      this.dispatchStateUpdatedEvent("hide");
    }
    isVisible() {
      return this.visible;
    }
    isSpanHeaderHeight() {
      const colDef = this.getColDef();
      return !colDef.suppressSpanHeaderHeight && !colDef.autoHeaderHeight;
    }
    getColumnGroupPaddingInfo() {
      let parent = this.getParent();
      if (!parent || !parent.isPadding()) {
        return { numberOfParents: 0, isSpanningTotal: false };
      }
      const numberOfParents = parent.getPaddingLevel() + 1;
      let isSpanningTotal = true;
      while (parent) {
        if (!parent.isPadding()) {
          isSpanningTotal = false;
          break;
        }
        parent = parent.getParent();
      }
      return { numberOfParents, isSpanningTotal };
    }
    /** Returns the column definition for this column.
     * The column definition will be the result of merging the application provided column definition with any provided defaults
     * (e.g. `defaultColDef` grid option, or column types.
     *
     * Equivalent: `getDefinition` */
    getColDef() {
      return this.colDef;
    }
    getColumnGroupShow() {
      return this.colDef.columnGroupShow;
    }
    /**
     * Returns the unique ID for the column.
     *
     * Equivalent: `getId`, `getUniqueId` */
    getColId() {
      return this.colId;
    }
    /**
     * Returns the unique ID for the column.
     *
     * Equivalent: `getColId`, `getUniqueId` */
    getId() {
      return this.colId;
    }
    /**
     * Returns the unique ID for the column.
     *
     * Equivalent: `getColId`, `getId` */
    getUniqueId() {
      return this.colId;
    }
    getDefinition() {
      return this.colDef;
    }
    /** Returns the current width of the column. If the column is resized, the actual width is the new size. */
    getActualWidth() {
      return this.actualWidth;
    }
    getAutoHeaderHeight() {
      return this.autoHeaderHeight;
    }
    /** Returns true if the header height has changed */
    setAutoHeaderHeight(height) {
      const changed = height !== this.autoHeaderHeight;
      this.autoHeaderHeight = height;
      return changed;
    }
    createBaseColDefParams(rowNode) {
      const params = this.gos.addGridCommonParams({
        node: rowNode,
        data: rowNode.data,
        colDef: this.colDef,
        column: this
      });
      return params;
    }
    getColSpan(rowNode) {
      if (missing(this.colDef.colSpan)) {
        return 1;
      }
      const params = this.createBaseColDefParams(rowNode);
      const colSpan = this.colDef.colSpan(params);
      return Math.max(colSpan, 1);
    }
    getRowSpan(rowNode) {
      if (missing(this.colDef.rowSpan)) {
        return 1;
      }
      const params = this.createBaseColDefParams(rowNode);
      const rowSpan = this.colDef.rowSpan(params);
      return Math.max(rowSpan, 1);
    }
    setActualWidth(actualWidth, source, silent = false) {
      if (this.minWidth != null) {
        actualWidth = Math.max(actualWidth, this.minWidth);
      }
      if (this.maxWidth != null) {
        actualWidth = Math.min(actualWidth, this.maxWidth);
      }
      if (this.actualWidth !== actualWidth) {
        this.actualWidth = actualWidth;
        if (this.flex && source !== "flex" && source !== "gridInitializing") {
          this.flex = null;
        }
        if (!silent) {
          this.fireColumnWidthChangedEvent(source);
        }
      }
      this.dispatchStateUpdatedEvent("width");
    }
    fireColumnWidthChangedEvent(source) {
      this.eventService.dispatchEvent(this.createColumnEvent("widthChanged", source));
    }
    isGreaterThanMax(width) {
      if (this.maxWidth != null) {
        return width > this.maxWidth;
      }
      return false;
    }
    getMinWidth() {
      return this.minWidth;
    }
    getMaxWidth() {
      return this.maxWidth;
    }
    getFlex() {
      return this.flex || 0;
    }
    // this method should only be used by the columnModel to
    // change flex when required by the applyColumnState method.
    setFlex(flex) {
      if (this.flex !== flex) {
        this.flex = flex;
      }
      this.dispatchStateUpdatedEvent("flex");
    }
    setMinimum(source) {
      if (exists(this.minWidth)) {
        this.setActualWidth(this.minWidth, source);
      }
    }
    setRowGroupActive(rowGroup, source) {
      if (this.rowGroupActive !== rowGroup) {
        this.rowGroupActive = rowGroup;
        this.eventService.dispatchEvent(this.createColumnEvent("columnRowGroupChanged", source));
      }
      this.dispatchStateUpdatedEvent("rowGroup");
    }
    /** Returns `true` if row group is currently active for this column. */
    isRowGroupActive() {
      return this.rowGroupActive;
    }
    setPivotActive(pivot, source) {
      if (this.pivotActive !== pivot) {
        this.pivotActive = pivot;
        this.eventService.dispatchEvent(this.createColumnEvent("columnPivotChanged", source));
      }
      this.dispatchStateUpdatedEvent("pivot");
    }
    /** Returns `true` if pivot is currently active for this column. */
    isPivotActive() {
      return this.pivotActive;
    }
    isAnyFunctionActive() {
      return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
    }
    isAnyFunctionAllowed() {
      return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
    }
    setValueActive(value, source) {
      if (this.aggregationActive !== value) {
        this.aggregationActive = value;
        this.eventService.dispatchEvent(this.createColumnEvent("columnValueChanged", source));
      }
    }
    /** Returns `true` if value (aggregation) is currently active for this column. */
    isValueActive() {
      return this.aggregationActive;
    }
    isAllowPivot() {
      return this.colDef.enablePivot === true;
    }
    isAllowValue() {
      return this.colDef.enableValue === true;
    }
    isAllowRowGroup() {
      return this.colDef.enableRowGroup === true;
    }
    /**
     * @deprecated v31.1 Use `getColDef().menuTabs ?? defaultValues` instead.
     */
    getMenuTabs(defaultValues) {
      warnOnce(`As of v31.1, 'getMenuTabs' is deprecated. Use 'getColDef().menuTabs ?? defaultValues' instead.`);
      let menuTabs = this.getColDef().menuTabs;
      if (menuTabs == null) {
        menuTabs = defaultValues;
      }
      return menuTabs;
    }
    dispatchStateUpdatedEvent(key) {
      this.eventService.dispatchEvent({
        type: _Column2.EVENT_STATE_UPDATED,
        key
      });
    }
  };
  _Column.EVENT_MOVING_CHANGED = "movingChanged";
  _Column.EVENT_LEFT_CHANGED = "leftChanged";
  _Column.EVENT_WIDTH_CHANGED = "widthChanged";
  _Column.EVENT_LAST_LEFT_PINNED_CHANGED = "lastLeftPinnedChanged";
  _Column.EVENT_FIRST_RIGHT_PINNED_CHANGED = "firstRightPinnedChanged";
  _Column.EVENT_VISIBLE_CHANGED = "visibleChanged";
  _Column.EVENT_FILTER_CHANGED = "filterChanged";
  _Column.EVENT_FILTER_ACTIVE_CHANGED = "filterActiveChanged";
  _Column.EVENT_SORT_CHANGED = "sortChanged";
  _Column.EVENT_COL_DEF_CHANGED = "colDefChanged";
  _Column.EVENT_MENU_VISIBLE_CHANGED = "menuVisibleChanged";
  _Column.EVENT_ROW_GROUP_CHANGED = "columnRowGroupChanged";
  _Column.EVENT_PIVOT_CHANGED = "columnPivotChanged";
  _Column.EVENT_VALUE_CHANGED = "columnValueChanged";
  _Column.EVENT_STATE_UPDATED = "columnStateUpdated";
  __decorateClass([
    Autowired("gridOptionsService")
  ], _Column.prototype, "gos", 2);
  __decorateClass([
    Autowired("environment")
  ], _Column.prototype, "environment", 2);
  __decorateClass([
    Autowired("columnHoverService")
  ], _Column.prototype, "columnHoverService", 2);
  __decorateClass([
    Autowired("frameworkOverrides")
  ], _Column.prototype, "frameworkOverrides", 2);
  __decorateClass([
    PostConstruct
  ], _Column.prototype, "initialise", 1);
  var Column = _Column;
  var _ProvidedColumnGroup = class _ProvidedColumnGroup2 {
    constructor(colGroupDef, groupId, padding, level) {
      this.localEventService = new EventService();
      this.expandable = false;
      this.instanceId = getNextColInstanceId();
      this.expandableListenerRemoveCallback = null;
      this.colGroupDef = colGroupDef;
      this.groupId = groupId;
      this.expanded = !!colGroupDef && !!colGroupDef.openByDefault;
      this.padding = padding;
      this.level = level;
    }
    destroy() {
      if (this.expandableListenerRemoveCallback) {
        this.reset(null, void 0);
      }
    }
    reset(colGroupDef, level) {
      this.colGroupDef = colGroupDef;
      this.level = level;
      this.originalParent = null;
      if (this.expandableListenerRemoveCallback) {
        this.expandableListenerRemoveCallback();
      }
      this.children = void 0;
      this.expandable = void 0;
    }
    getInstanceId() {
      return this.instanceId;
    }
    setOriginalParent(originalParent) {
      this.originalParent = originalParent;
    }
    getOriginalParent() {
      return this.originalParent;
    }
    getLevel() {
      return this.level;
    }
    isVisible() {
      if (this.children) {
        return this.children.some((child) => child.isVisible());
      }
      return false;
    }
    isPadding() {
      return this.padding;
    }
    setExpanded(expanded) {
      this.expanded = expanded === void 0 ? false : expanded;
      const event = {
        type: _ProvidedColumnGroup2.EVENT_EXPANDED_CHANGED
      };
      this.localEventService.dispatchEvent(event);
    }
    isExpandable() {
      return this.expandable;
    }
    isExpanded() {
      return this.expanded;
    }
    getGroupId() {
      return this.groupId;
    }
    getId() {
      return this.getGroupId();
    }
    setChildren(children) {
      this.children = children;
    }
    getChildren() {
      return this.children;
    }
    getColGroupDef() {
      return this.colGroupDef;
    }
    getLeafColumns() {
      const result = [];
      this.addLeafColumns(result);
      return result;
    }
    addLeafColumns(leafColumns) {
      if (!this.children) {
        return;
      }
      this.children.forEach((child) => {
        if (child instanceof Column) {
          leafColumns.push(child);
        } else if (child instanceof _ProvidedColumnGroup2) {
          child.addLeafColumns(leafColumns);
        }
      });
    }
    getColumnGroupShow() {
      const colGroupDef = this.colGroupDef;
      if (!colGroupDef) {
        return;
      }
      return colGroupDef.columnGroupShow;
    }
    // need to check that this group has at least one col showing when both expanded and contracted.
    // if not, then we don't allow expanding and contracting on this group
    setupExpandable() {
      this.setExpandable();
      if (this.expandableListenerRemoveCallback) {
        this.expandableListenerRemoveCallback();
      }
      const listener = this.onColumnVisibilityChanged.bind(this);
      this.getLeafColumns().forEach((col) => col.addEventListener("visibleChanged", listener));
      this.expandableListenerRemoveCallback = () => {
        this.getLeafColumns().forEach((col) => col.removeEventListener("visibleChanged", listener));
        this.expandableListenerRemoveCallback = null;
      };
    }
    setExpandable() {
      if (this.isPadding()) {
        return;
      }
      let atLeastOneShowingWhenOpen = false;
      let atLeastOneShowingWhenClosed = false;
      let atLeastOneChangeable = false;
      const children = this.findChildrenRemovingPadding();
      for (let i = 0, j = children.length; i < j; i++) {
        const abstractColumn = children[i];
        if (!abstractColumn.isVisible()) {
          continue;
        }
        const headerGroupShow = abstractColumn.getColumnGroupShow();
        if (headerGroupShow === "open") {
          atLeastOneShowingWhenOpen = true;
          atLeastOneChangeable = true;
        } else if (headerGroupShow === "closed") {
          atLeastOneShowingWhenClosed = true;
          atLeastOneChangeable = true;
        } else {
          atLeastOneShowingWhenOpen = true;
          atLeastOneShowingWhenClosed = true;
        }
      }
      const expandable = atLeastOneShowingWhenOpen && atLeastOneShowingWhenClosed && atLeastOneChangeable;
      if (this.expandable !== expandable) {
        this.expandable = expandable;
        const event = {
          type: _ProvidedColumnGroup2.EVENT_EXPANDABLE_CHANGED
        };
        this.localEventService.dispatchEvent(event);
      }
    }
    findChildrenRemovingPadding() {
      const res = [];
      const process2 = (items) => {
        items.forEach((item) => {
          const skipBecausePadding = item instanceof _ProvidedColumnGroup2 && item.isPadding();
          if (skipBecausePadding) {
            process2(item.children);
          } else {
            res.push(item);
          }
        });
      };
      process2(this.children);
      return res;
    }
    onColumnVisibilityChanged() {
      this.setExpandable();
    }
    addEventListener(eventType, listener) {
      this.localEventService.addEventListener(eventType, listener);
    }
    removeEventListener(eventType, listener) {
      this.localEventService.removeEventListener(eventType, listener);
    }
  };
  _ProvidedColumnGroup.EVENT_EXPANDED_CHANGED = "expandedChanged";
  _ProvidedColumnGroup.EVENT_EXPANDABLE_CHANGED = "expandableChanged";
  __decorateClass([
    PreDestroy
  ], _ProvidedColumnGroup.prototype, "destroy", 1);
  var ProvidedColumnGroup = _ProvidedColumnGroup;
  var DefaultColumnTypes = {
    numericColumn: {
      headerClass: "ag-right-aligned-header",
      cellClass: "ag-right-aligned-cell"
    },
    rightAligned: {
      headerClass: "ag-right-aligned-header",
      cellClass: "ag-right-aligned-cell"
    }
  };
  var event_exports = {};
  __export2(event_exports, {
    addSafePassiveEventListener: () => addSafePassiveEventListener,
    createEventPath: () => createEventPath,
    getCtrlForEventTarget: () => getCtrlForEventTarget,
    getEventPath: () => getEventPath,
    isElementInEventPath: () => isElementInEventPath,
    isEventSupported: () => isEventSupported,
    isStopPropagationForAgGrid: () => isStopPropagationForAgGrid,
    stopPropagationForAgGrid: () => stopPropagationForAgGrid
  });
  var array_exports = {};
  __export2(array_exports, {
    areEqual: () => areEqual,
    existsAndNotEmpty: () => existsAndNotEmpty,
    flatten: () => flatten,
    forEachReverse: () => forEachReverse,
    includes: () => includes,
    insertArrayIntoArray: () => insertArrayIntoArray,
    insertIntoArray: () => insertIntoArray,
    last: () => last,
    moveInArray: () => moveInArray,
    pushAll: () => pushAll,
    removeAllFromArray: () => removeAllFromArray,
    removeAllFromUnorderedArray: () => removeAllFromUnorderedArray,
    removeFromArray: () => removeFromArray,
    removeFromUnorderedArray: () => removeFromUnorderedArray,
    removeRepeatsFromArray: () => removeRepeatsFromArray,
    shallowCompare: () => shallowCompare,
    sortNumerically: () => sortNumerically,
    toStrings: () => toStrings
  });
  function existsAndNotEmpty(value) {
    return value != null && value.length > 0;
  }
  function last(arr) {
    if (!arr || !arr.length) {
      return;
    }
    return arr[arr.length - 1];
  }
  function areEqual(a, b, comparator2) {
    if (a == null && b == null) {
      return true;
    }
    return a != null && b != null && a.length === b.length && a.every((value, index) => comparator2 ? comparator2(value, b[index]) : b[index] === value);
  }
  function shallowCompare(arr1, arr2) {
    return areEqual(arr1, arr2);
  }
  function sortNumerically(array) {
    return array.sort((a, b) => a - b);
  }
  function removeRepeatsFromArray(array, object) {
    if (!array) {
      return;
    }
    for (let index = array.length - 2; index >= 0; index--) {
      const thisOneMatches = array[index] === object;
      const nextOneMatches = array[index + 1] === object;
      if (thisOneMatches && nextOneMatches) {
        array.splice(index + 1, 1);
      }
    }
  }
  function removeFromUnorderedArray(array, object) {
    const index = array.indexOf(object);
    if (index >= 0) {
      array[index] = array[array.length - 1];
      array.pop();
    }
  }
  function removeFromArray(array, object) {
    const index = array.indexOf(object);
    if (index >= 0) {
      array.splice(index, 1);
    }
  }
  function removeAllFromUnorderedArray(array, toRemove) {
    for (let i = 0; i < toRemove.length; i++) {
      removeFromUnorderedArray(array, toRemove[i]);
    }
  }
  function removeAllFromArray(array, toRemove) {
    for (let i = 0; i < toRemove.length; i++) {
      removeFromArray(array, toRemove[i]);
    }
  }
  function insertIntoArray(array, object, toIndex) {
    array.splice(toIndex, 0, object);
  }
  function insertArrayIntoArray(dest, src, toIndex) {
    if (dest == null || src == null) {
      return;
    }
    for (let i = src.length - 1; i >= 0; i--) {
      const item = src[i];
      insertIntoArray(dest, item, toIndex);
    }
  }
  function moveInArray(array, objectsToMove, toIndex) {
    removeAllFromArray(array, objectsToMove);
    objectsToMove.slice().reverse().forEach((obj) => insertIntoArray(array, obj, toIndex));
  }
  function includes(array, value) {
    return array.indexOf(value) > -1;
  }
  function flatten(arrayOfArrays) {
    return [].concat.apply([], arrayOfArrays);
  }
  function pushAll(target, source) {
    if (source == null || target == null) {
      return;
    }
    source.forEach((value) => target.push(value));
  }
  function toStrings(array) {
    return array.map(toStringOrNull);
  }
  function forEachReverse(list, action) {
    if (list == null) {
      return;
    }
    for (let i = list.length - 1; i >= 0; i--) {
      action(list[i], i);
    }
  }
  var AG_GRID_STOP_PROPAGATION = "__ag_Grid_Stop_Propagation";
  var PASSIVE_EVENTS = ["touchstart", "touchend", "touchmove", "touchcancel", "scroll"];
  var supports = {};
  function stopPropagationForAgGrid(event) {
    event[AG_GRID_STOP_PROPAGATION] = true;
  }
  function isStopPropagationForAgGrid(event) {
    return event[AG_GRID_STOP_PROPAGATION] === true;
  }
  var isEventSupported = /* @__PURE__ */ (() => {
    const tags = {
      select: "input",
      change: "input",
      submit: "form",
      reset: "form",
      error: "img",
      load: "img",
      abort: "img"
    };
    const eventChecker = (eventName) => {
      if (typeof supports[eventName] === "boolean") {
        return supports[eventName];
      }
      const el = document.createElement(tags[eventName] || "div");
      eventName = "on" + eventName;
      return supports[eventName] = eventName in el;
    };
    return eventChecker;
  })();
  function getCtrlForEventTarget(gos, eventTarget, type) {
    let sourceElement = eventTarget;
    while (sourceElement) {
      const renderedComp = gos.getDomData(sourceElement, type);
      if (renderedComp) {
        return renderedComp;
      }
      sourceElement = sourceElement.parentElement;
    }
    return null;
  }
  function isElementInEventPath(element, event) {
    if (!event || !element) {
      return false;
    }
    return getEventPath(event).indexOf(element) >= 0;
  }
  function createEventPath(event) {
    const res = [];
    let pointer = event.target;
    while (pointer) {
      res.push(pointer);
      pointer = pointer.parentElement;
    }
    return res;
  }
  function getEventPath(event) {
    const eventNoType = event;
    if (eventNoType.path) {
      return eventNoType.path;
    }
    if (eventNoType.composedPath) {
      return eventNoType.composedPath();
    }
    return createEventPath(eventNoType);
  }
  function addSafePassiveEventListener(frameworkOverrides, eElement, event, listener) {
    const isPassive = includes(PASSIVE_EVENTS, event);
    const options = isPassive ? { passive: true } : void 0;
    if (frameworkOverrides && frameworkOverrides.addEventListener) {
      frameworkOverrides.addEventListener(eElement, event, listener, options);
    }
  }
  var _BeanStub = class _BeanStub2 {
    constructor() {
      this.destroyFunctions = [];
      this.destroyed = false;
      this.__v_skip = true;
      this.lastChangeSetIdLookup = {};
      this.propertyListenerId = 0;
      this.isAlive = () => !this.destroyed;
    }
    // CellComp and GridComp and override this because they get the FrameworkOverrides from the Beans bean
    getFrameworkOverrides() {
      return this.frameworkOverrides;
    }
    getContext() {
      return this.context;
    }
    destroy() {
      for (let i = 0; i < this.destroyFunctions.length; i++) {
        this.destroyFunctions[i]();
      }
      this.destroyFunctions.length = 0;
      this.destroyed = true;
      this.dispatchEvent({ type: _BeanStub2.EVENT_DESTROYED });
    }
    addEventListener(eventType, listener) {
      if (!this.localEventService) {
        this.localEventService = new EventService();
      }
      this.localEventService.addEventListener(eventType, listener);
    }
    removeEventListener(eventType, listener) {
      if (this.localEventService) {
        this.localEventService.removeEventListener(eventType, listener);
      }
    }
    dispatchEvent(event) {
      if (this.localEventService) {
        this.localEventService.dispatchEvent(event);
      }
    }
    addManagedListener(object, event, listener) {
      if (this.destroyed) {
        return;
      }
      if (object instanceof HTMLElement) {
        addSafePassiveEventListener(this.getFrameworkOverrides(), object, event, listener);
      } else {
        object.addEventListener(event, listener);
      }
      const destroyFunc = () => {
        object.removeEventListener(event, listener);
        return null;
      };
      this.destroyFunctions.push(destroyFunc);
      return () => {
        destroyFunc();
        this.destroyFunctions = this.destroyFunctions.filter((fn) => fn !== destroyFunc);
        return null;
      };
    }
    setupGridOptionListener(event, listener) {
      this.gos.addEventListener(event, listener);
      const destroyFunc = () => {
        this.gos.removeEventListener(event, listener);
        return null;
      };
      this.destroyFunctions.push(destroyFunc);
      return () => {
        destroyFunc();
        this.destroyFunctions = this.destroyFunctions.filter((fn) => fn !== destroyFunc);
        return null;
      };
    }
    /**
     * Setup a managed property listener for the given GridOption property.
     * @param event GridOption property to listen to changes for.
     * @param listener Listener to run when property value changes
     */
    addManagedPropertyListener(event, listener) {
      if (this.destroyed) {
        return () => null;
      }
      return this.setupGridOptionListener(event, listener);
    }
    /**
     * Setup managed property listeners for the given set of GridOption properties.
     * The listener will be run if any of the property changes but will only run once if
     * multiple of the properties change within the same framework lifecycle event.
     * Works on the basis that GridOptionsService updates all properties *before* any property change events are fired.
     * @param events Array of GridOption properties to listen for changes too.
     * @param listener Shared listener to run if any of the properties change
     */
    addManagedPropertyListeners(events, listener) {
      if (this.destroyed) {
        return;
      }
      const eventsKey = events.join("-") + this.propertyListenerId++;
      const wrappedListener = (event) => {
        if (event.changeSet) {
          if (event.changeSet && event.changeSet.id === this.lastChangeSetIdLookup[eventsKey]) {
            return;
          }
          this.lastChangeSetIdLookup[eventsKey] = event.changeSet.id;
        }
        const propertiesChangeEvent = {
          type: "gridPropertyChanged",
          changeSet: event.changeSet,
          source: event.source
        };
        listener(propertiesChangeEvent);
      };
      events.forEach((event) => this.setupGridOptionListener(event, wrappedListener));
    }
    addDestroyFunc(func) {
      if (this.isAlive()) {
        this.destroyFunctions.push(func);
      } else {
        func();
      }
    }
    createManagedBean(bean, context) {
      const res = this.createBean(bean, context);
      this.addDestroyFunc(this.destroyBean.bind(this, bean, context));
      return res;
    }
    createBean(bean, context, afterPreCreateCallback) {
      return (context || this.getContext()).createBean(bean, afterPreCreateCallback);
    }
    destroyBean(bean, context) {
      return (context || this.getContext()).destroyBean(bean);
    }
    destroyBeans(beans, context) {
      if (beans) {
        for (let i = 0; i < beans.length; i++) {
          this.destroyBean(beans[i], context);
        }
      }
      return [];
    }
  };
  _BeanStub.EVENT_DESTROYED = "destroyed";
  __decorateClass([
    Autowired("frameworkOverrides")
  ], _BeanStub.prototype, "frameworkOverrides", 2);
  __decorateClass([
    Autowired("context")
  ], _BeanStub.prototype, "context", 2);
  __decorateClass([
    Autowired("eventService")
  ], _BeanStub.prototype, "eventService", 2);
  __decorateClass([
    Autowired("gridOptionsService")
  ], _BeanStub.prototype, "gos", 2);
  __decorateClass([
    Autowired("localeService")
  ], _BeanStub.prototype, "localeService", 2);
  __decorateClass([
    Autowired("environment")
  ], _BeanStub.prototype, "environment", 2);
  __decorateClass([
    PreDestroy
  ], _BeanStub.prototype, "destroy", 1);
  var BeanStub = _BeanStub;
  var ColumnFactory = class extends BeanStub {
    setBeans(loggerFactory) {
      this.logger = loggerFactory.create("ColumnFactory");
    }
    createColumnTree(defs, primaryColumns, existingTree, source) {
      const columnKeyCreator = new ColumnKeyCreator();
      const { existingCols, existingGroups, existingColKeys } = this.extractExistingTreeData(existingTree);
      columnKeyCreator.addExistingKeys(existingColKeys);
      const unbalancedTree = this.recursivelyCreateColumns(
        defs,
        0,
        primaryColumns,
        existingCols,
        columnKeyCreator,
        existingGroups,
        source
      );
      const treeDept = this.findMaxDept(unbalancedTree, 0);
      this.logger.log("Number of levels for grouped columns is " + treeDept);
      const columnTree = this.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator);
      const deptFirstCallback = (child, parent) => {
        if (child instanceof ProvidedColumnGroup) {
          child.setupExpandable();
        }
        child.setOriginalParent(parent);
      };
      depthFirstOriginalTreeSearch(null, columnTree, deptFirstCallback);
      return {
        columnTree,
        treeDept
      };
    }
    extractExistingTreeData(existingTree) {
      const existingCols = [];
      const existingGroups = [];
      const existingColKeys = [];
      if (existingTree) {
        depthFirstOriginalTreeSearch(null, existingTree, (item) => {
          if (item instanceof ProvidedColumnGroup) {
            const group = item;
            existingGroups.push(group);
          } else {
            const col = item;
            existingColKeys.push(col.getId());
            existingCols.push(col);
          }
        });
      }
      return { existingCols, existingGroups, existingColKeys };
    }
    createForAutoGroups(autoGroupCols, gridBalancedTree) {
      return autoGroupCols.map((col) => this.createAutoGroupTreeItem(gridBalancedTree, col));
    }
    createAutoGroupTreeItem(balancedColumnTree, column) {
      const dept = this.findDepth(balancedColumnTree);
      let nextChild = column;
      for (let i = dept - 1; i >= 0; i--) {
        const autoGroup = new ProvidedColumnGroup(
          null,
          `FAKE_PATH_${column.getId()}}_${i}`,
          true,
          i
        );
        this.createBean(autoGroup);
        autoGroup.setChildren([nextChild]);
        nextChild.setOriginalParent(autoGroup);
        nextChild = autoGroup;
      }
      if (dept === 0) {
        column.setOriginalParent(null);
      }
      return nextChild;
    }
    findDepth(balancedColumnTree) {
      let dept = 0;
      let pointer = balancedColumnTree;
      while (pointer && pointer[0] && pointer[0] instanceof ProvidedColumnGroup) {
        dept++;
        pointer = pointer[0].getChildren();
      }
      return dept;
    }
    balanceColumnTree(unbalancedTree, currentDept, columnDept, columnKeyCreator) {
      const result = [];
      for (let i = 0; i < unbalancedTree.length; i++) {
        const child = unbalancedTree[i];
        if (child instanceof ProvidedColumnGroup) {
          const originalGroup = child;
          const newChildren = this.balanceColumnTree(
            originalGroup.getChildren(),
            currentDept + 1,
            columnDept,
            columnKeyCreator
          );
          originalGroup.setChildren(newChildren);
          result.push(originalGroup);
        } else {
          let firstPaddedGroup;
          let currentPaddedGroup;
          for (let j = columnDept - 1; j >= currentDept; j--) {
            const newColId = columnKeyCreator.getUniqueKey(null, null);
            const colGroupDefMerged = this.createMergedColGroupDef(null);
            const paddedGroup = new ProvidedColumnGroup(colGroupDefMerged, newColId, true, currentDept);
            this.createBean(paddedGroup);
            if (currentPaddedGroup) {
              currentPaddedGroup.setChildren([paddedGroup]);
            }
            currentPaddedGroup = paddedGroup;
            if (!firstPaddedGroup) {
              firstPaddedGroup = currentPaddedGroup;
            }
          }
          if (firstPaddedGroup && currentPaddedGroup) {
            result.push(firstPaddedGroup);
            const hasGroups = unbalancedTree.some((leaf) => leaf instanceof ProvidedColumnGroup);
            if (hasGroups) {
              currentPaddedGroup.setChildren([child]);
              continue;
            } else {
              currentPaddedGroup.setChildren(unbalancedTree);
              break;
            }
          }
          result.push(child);
        }
      }
      return result;
    }
    findMaxDept(treeChildren, dept) {
      let maxDeptThisLevel = dept;
      for (let i = 0; i < treeChildren.length; i++) {
        const abstractColumn = treeChildren[i];
        if (abstractColumn instanceof ProvidedColumnGroup) {
          const originalGroup = abstractColumn;
          const newDept = this.findMaxDept(originalGroup.getChildren(), dept + 1);
          if (maxDeptThisLevel < newDept) {
            maxDeptThisLevel = newDept;
          }
        }
      }
      return maxDeptThisLevel;
    }
    recursivelyCreateColumns(defs, level, primaryColumns, existingColsCopy, columnKeyCreator, existingGroups, source) {
      if (!defs)
        return [];
      const result = new Array(defs.length);
      for (let i = 0; i < result.length; i++) {
        const def2 = defs[i];
        if (this.isColumnGroup(def2)) {
          result[i] = this.createColumnGroup(
            primaryColumns,
            def2,
            level,
            existingColsCopy,
            columnKeyCreator,
            existingGroups,
            source
          );
        } else {
          result[i] = this.createColumn(primaryColumns, def2, existingColsCopy, columnKeyCreator, source);
        }
      }
      return result;
    }
    createColumnGroup(primaryColumns, colGroupDef, level, existingColumns, columnKeyCreator, existingGroups, source) {
      const colGroupDefMerged = this.createMergedColGroupDef(colGroupDef);
      const groupId = columnKeyCreator.getUniqueKey(colGroupDefMerged.groupId || null, null);
      const providedGroup = new ProvidedColumnGroup(colGroupDefMerged, groupId, false, level);
      this.createBean(providedGroup);
      const existingGroupAndIndex = this.findExistingGroup(colGroupDef, existingGroups);
      if (existingGroupAndIndex) {
        existingGroups.splice(existingGroupAndIndex.idx, 1);
      }
      let existingGroup = existingGroupAndIndex == null ? void 0 : existingGroupAndIndex.group;
      if (existingGroup) {
        providedGroup.setExpanded(existingGroup.isExpanded());
      }
      const children = this.recursivelyCreateColumns(
        colGroupDefMerged.children,
        level + 1,
        primaryColumns,
        existingColumns,
        columnKeyCreator,
        existingGroups,
        source
      );
      providedGroup.setChildren(children);
      return providedGroup;
    }
    createMergedColGroupDef(colGroupDef) {
      const colGroupDefMerged = {};
      Object.assign(colGroupDefMerged, this.gos.get("defaultColGroupDef"));
      Object.assign(colGroupDefMerged, colGroupDef);
      return colGroupDefMerged;
    }
    createColumn(primaryColumns, colDef, existingColsCopy, columnKeyCreator, source) {
      const existingColAndIndex = this.findExistingColumn(colDef, existingColsCopy);
      if (existingColAndIndex) {
        existingColsCopy == null ? void 0 : existingColsCopy.splice(existingColAndIndex.idx, 1);
      }
      let column = existingColAndIndex == null ? void 0 : existingColAndIndex.column;
      if (!column) {
        const colId = columnKeyCreator.getUniqueKey(colDef.colId, colDef.field);
        const colDefMerged = this.addColumnDefaultAndTypes(colDef, colId);
        column = new Column(colDefMerged, colDef, colId, primaryColumns);
        this.context.createBean(column);
      } else {
        const colDefMerged = this.addColumnDefaultAndTypes(colDef, column.getColId());
        column.setColDef(colDefMerged, colDef, source);
        this.applyColumnState(column, colDefMerged, source);
      }
      this.dataTypeService.addColumnListeners(column);
      return column;
    }
    applyColumnState(column, colDef, source) {
      const flex = attrToNumber(colDef.flex);
      if (flex !== void 0) {
        column.setFlex(flex);
      }
      const noFlexThisCol = column.getFlex() <= 0;
      if (noFlexThisCol) {
        const width = attrToNumber(colDef.width);
        if (width != null) {
          column.setActualWidth(width, source);
        } else {
          const widthBeforeUpdate = column.getActualWidth();
          column.setActualWidth(widthBeforeUpdate, source);
        }
      }
      if (colDef.sort !== void 0) {
        if (colDef.sort == "asc" || colDef.sort == "desc") {
          column.setSort(colDef.sort, source);
        } else {
          column.setSort(void 0, source);
        }
      }
      const sortIndex = attrToNumber(colDef.sortIndex);
      if (sortIndex !== void 0) {
        column.setSortIndex(sortIndex);
      }
      const hide = attrToBoolean(colDef.hide);
      if (hide !== void 0) {
        column.setVisible(!hide, source);
      }
      if (colDef.pinned !== void 0) {
        column.setPinned(colDef.pinned);
      }
    }
    findExistingColumn(newColDef, existingColsCopy) {
      if (!existingColsCopy)
        return void 0;
      for (let i = 0; i < existingColsCopy.length; i++) {
        const def2 = existingColsCopy[i].getUserProvidedColDef();
        if (!def2)
          continue;
        const newHasId = newColDef.colId != null;
        if (newHasId) {
          if (existingColsCopy[i].getId() === newColDef.colId) {
            return { idx: i, column: existingColsCopy[i] };
          }
          continue;
        }
        const newHasField = newColDef.field != null;
        if (newHasField) {
          if (def2.field === newColDef.field) {
            return { idx: i, column: existingColsCopy[i] };
          }
          continue;
        }
        if (def2 === newColDef) {
          return { idx: i, column: existingColsCopy[i] };
        }
      }
      return void 0;
    }
    findExistingGroup(newGroupDef, existingGroups) {
      const newHasId = newGroupDef.groupId != null;
      if (!newHasId) {
        return void 0;
      }
      for (let i = 0; i < existingGroups.length; i++) {
        const existingGroup = existingGroups[i];
        const existingDef = existingGroup.getColGroupDef();
        if (!existingDef) {
          continue;
        }
        if (existingGroup.getId() === newGroupDef.groupId) {
          return { idx: i, group: existingGroup };
        }
      }
      return void 0;
    }
    addColumnDefaultAndTypes(colDef, colId) {
      const res = {};
      const defaultColDef = this.gos.get("defaultColDef");
      mergeDeep(res, defaultColDef, false, true);
      const columnType = this.dataTypeService.updateColDefAndGetColumnType(res, colDef, colId);
      if (columnType) {
        this.assignColumnTypes(columnType, res);
      }
      mergeDeep(res, colDef, false, true);
      const autoGroupColDef = this.gos.get("autoGroupColumnDef");
      const isSortingCoupled = this.gos.isColumnsSortingCoupledToGroup();
      if (colDef.rowGroup && autoGroupColDef && isSortingCoupled) {
        mergeDeep(res, { sort: autoGroupColDef.sort, initialSort: autoGroupColDef.initialSort }, false, true);
      }
      this.dataTypeService.validateColDef(res);
      return res;
    }
    assignColumnTypes(typeKeys, colDefMerged) {
      if (!typeKeys.length) {
        return;
      }
      const allColumnTypes = Object.assign({}, DefaultColumnTypes);
      const userTypes = this.gos.get("columnTypes") || {};
      iterateObject(userTypes, (key, value) => {
        if (key in allColumnTypes) {
          console.warn(`AG Grid: the column type '${key}' is a default column type and cannot be overridden.`);
        } else {
          const colType = value;
          if (colType.type) {
            warnOnce(`Column type definitions 'columnTypes' with a 'type' attribute are not supported because a column type cannot refer to another column type. Only column definitions 'columnDefs' can use the 'type' attribute to refer to a column type.`);
          }
          allColumnTypes[key] = value;
        }
      });
      typeKeys.forEach((t) => {
        const typeColDef = allColumnTypes[t.trim()];
        if (typeColDef) {
          mergeDeep(colDefMerged, typeColDef, false, true);
        } else {
          console.warn("AG Grid: colDef.type '" + t + "' does not correspond to defined gridOptions.columnTypes");
        }
      });
    }
    // if object has children, we assume it's a group
    isColumnGroup(abstractColDef) {
      return abstractColDef.children !== void 0;
    }
  };
  __decorateClass([
    Autowired("dataTypeService")
  ], ColumnFactory.prototype, "dataTypeService", 2);
  __decorateClass([
    __decorateParam(0, Qualifier("loggerFactory"))
  ], ColumnFactory.prototype, "setBeans", 1);
  ColumnFactory = __decorateClass([
    Bean("columnFactory")
  ], ColumnFactory);
  function depthFirstOriginalTreeSearch(parent, tree, callback) {
    if (!tree) {
      return;
    }
    for (let i = 0; i < tree.length; i++) {
      const child = tree[i];
      if (child instanceof ProvidedColumnGroup) {
        depthFirstOriginalTreeSearch(child, child.getChildren(), callback);
      }
      callback(child, parent);
    }
  }
  var _ColumnGroup = class _ColumnGroup2 {
    constructor(providedColumnGroup, groupId, partId, pinned) {
      this.displayedChildren = [];
      this.localEventService = new EventService();
      this.groupId = groupId;
      this.partId = partId;
      this.providedColumnGroup = providedColumnGroup;
      this.pinned = pinned;
    }
    // this is static, a it is used outside of this class
    static createUniqueId(groupId, instanceId) {
      return groupId + "_" + instanceId;
    }
    // as the user is adding and removing columns, the groups are recalculated.
    // this reset clears out all children, ready for children to be added again
    reset() {
      this.parent = null;
      this.children = null;
      this.displayedChildren = null;
    }
    getParent() {
      return this.parent;
    }
    setParent(parent) {
      this.parent = parent;
    }
    getUniqueId() {
      return _ColumnGroup2.createUniqueId(this.groupId, this.partId);
    }
    isEmptyGroup() {
      return this.displayedChildren.length === 0;
    }
    isMoving() {
      const allLeafColumns = this.getProvidedColumnGroup().getLeafColumns();
      if (!allLeafColumns || allLeafColumns.length === 0) {
        return false;
      }
      return allLeafColumns.every((col) => col.isMoving());
    }
    checkLeft() {
      this.displayedChildren.forEach((child) => {
        if (child instanceof _ColumnGroup2) {
          child.checkLeft();
        }
      });
      if (this.displayedChildren.length > 0) {
        if (this.gos.get("enableRtl")) {
          const lastChild = last(this.displayedChildren);
          const lastChildLeft = lastChild.getLeft();
          this.setLeft(lastChildLeft);
        } else {
          const firstChildLeft = this.displayedChildren[0].getLeft();
          this.setLeft(firstChildLeft);
        }
      } else {
        this.setLeft(null);
      }
    }
    getLeft() {
      return this.left;
    }
    getOldLeft() {
      return this.oldLeft;
    }
    setLeft(left) {
      this.oldLeft = this.left;
      if (this.left !== left) {
        this.left = left;
        this.localEventService.dispatchEvent(this.createAgEvent(_ColumnGroup2.EVENT_LEFT_CHANGED));
      }
    }
    getPinned() {
      return this.pinned;
    }
    createAgEvent(type) {
      return { type };
    }
    addEventListener(eventType, listener) {
      this.localEventService.addEventListener(eventType, listener);
    }
    removeEventListener(eventType, listener) {
      this.localEventService.removeEventListener(eventType, listener);
    }
    getGroupId() {
      return this.groupId;
    }
    getPartId() {
      return this.partId;
    }
    isChildInThisGroupDeepSearch(wantedChild) {
      let result = false;
      this.children.forEach((foundChild) => {
        if (wantedChild === foundChild) {
          result = true;
        }
        if (foundChild instanceof _ColumnGroup2) {
          if (foundChild.isChildInThisGroupDeepSearch(wantedChild)) {
            result = true;
          }
        }
      });
      return result;
    }
    getActualWidth() {
      let groupActualWidth = 0;
      if (this.displayedChildren) {
        this.displayedChildren.forEach((child) => {
          groupActualWidth += child.getActualWidth();
        });
      }
      return groupActualWidth;
    }
    isResizable() {
      if (!this.displayedChildren) {
        return false;
      }
      let result = false;
      this.displayedChildren.forEach((child) => {
        if (child.isResizable()) {
          result = true;
        }
      });
      return result;
    }
    getMinWidth() {
      let result = 0;
      this.displayedChildren.forEach((groupChild) => {
        result += groupChild.getMinWidth() || 0;
      });
      return result;
    }
    addChild(child) {
      if (!this.children) {
        this.children = [];
      }
      this.children.push(child);
    }
    getDisplayedChildren() {
      return this.displayedChildren;
    }
    getLeafColumns() {
      const result = [];
      this.addLeafColumns(result);
      return result;
    }
    getDisplayedLeafColumns() {
      const result = [];
      this.addDisplayedLeafColumns(result);
      return result;
    }
    getDefinition() {
      return this.providedColumnGroup.getColGroupDef();
    }
    getColGroupDef() {
      return this.providedColumnGroup.getColGroupDef();
    }
    isPadding() {
      return this.providedColumnGroup.isPadding();
    }
    isExpandable() {
      return this.providedColumnGroup.isExpandable();
    }
    isExpanded() {
      return this.providedColumnGroup.isExpanded();
    }
    setExpanded(expanded) {
      this.providedColumnGroup.setExpanded(expanded);
    }
    addDisplayedLeafColumns(leafColumns) {
      this.displayedChildren.forEach((child) => {
        if (child instanceof Column) {
          leafColumns.push(child);
        } else if (child instanceof _ColumnGroup2) {
          child.addDisplayedLeafColumns(leafColumns);
        }
      });
    }
    addLeafColumns(leafColumns) {
      this.children.forEach((child) => {
        if (child instanceof Column) {
          leafColumns.push(child);
        } else if (child instanceof _ColumnGroup2) {
          child.addLeafColumns(leafColumns);
        }
      });
    }
    getChildren() {
      return this.children;
    }
    getColumnGroupShow() {
      return this.providedColumnGroup.getColumnGroupShow();
    }
    getProvidedColumnGroup() {
      return this.providedColumnGroup;
    }
    getPaddingLevel() {
      const parent = this.getParent();
      if (!this.isPadding() || !parent || !parent.isPadding()) {
        return 0;
      }
      return 1 + parent.getPaddingLevel();
    }
    calculateDisplayedColumns() {
      this.displayedChildren = [];
      let parentWithExpansion = this;
      while (parentWithExpansion != null && parentWithExpansion.isPadding()) {
        parentWithExpansion = parentWithExpansion.getParent();
      }
      const isExpandable = parentWithExpansion ? parentWithExpansion.providedColumnGroup.isExpandable() : false;
      if (!isExpandable) {
        this.displayedChildren = this.children;
        this.localEventService.dispatchEvent(this.createAgEvent(_ColumnGroup2.EVENT_DISPLAYED_CHILDREN_CHANGED));
        return;
      }
      this.children.forEach((child) => {
        const emptyGroup = child instanceof _ColumnGroup2 && (!child.displayedChildren || !child.displayedChildren.length);
        if (emptyGroup) {
          return;
        }
        const headerGroupShow = child.getColumnGroupShow();
        switch (headerGroupShow) {
          case "open":
            if (parentWithExpansion.providedColumnGroup.isExpanded()) {
              this.displayedChildren.push(child);
            }
            break;
          case "closed":
            if (!parentWithExpansion.providedColumnGroup.isExpanded()) {
              this.displayedChildren.push(child);
            }
            break;
          default:
            this.displayedChildren.push(child);
            break;
        }
      });
      this.localEventService.dispatchEvent(this.createAgEvent(_ColumnGroup2.EVENT_DISPLAYED_CHILDREN_CHANGED));
    }
  };
  _ColumnGroup.EVENT_LEFT_CHANGED = "leftChanged";
  _ColumnGroup.EVENT_DISPLAYED_CHILDREN_CHANGED = "displayedChildrenChanged";
  __decorateClass([
    Autowired("gridOptionsService")
  ], _ColumnGroup.prototype, "gos", 2);
  var ColumnGroup = _ColumnGroup;
  var Events = class {
    /*****************************  INTERNAL EVENTS: END ******************************************* */
  };
  Events.EVENT_COLUMN_EVERYTHING_CHANGED = "columnEverythingChanged";
  Events.EVENT_NEW_COLUMNS_LOADED = "newColumnsLoaded";
  Events.EVENT_COLUMN_PIVOT_MODE_CHANGED = "columnPivotModeChanged";
  Events.EVENT_PIVOT_MAX_COLUMNS_EXCEEDED = "pivotMaxColumnsExceeded";
  Events.EVENT_COLUMN_ROW_GROUP_CHANGED = "columnRowGroupChanged";
  Events.EVENT_EXPAND_COLLAPSE_ALL = "expandOrCollapseAll";
  Events.EVENT_COLUMN_PIVOT_CHANGED = "columnPivotChanged";
  Events.EVENT_GRID_COLUMNS_CHANGED = "gridColumnsChanged";
  Events.EVENT_COLUMN_VALUE_CHANGED = "columnValueChanged";
  Events.EVENT_COLUMN_MOVED = "columnMoved";
  Events.EVENT_COLUMN_VISIBLE = "columnVisible";
  Events.EVENT_COLUMN_PINNED = "columnPinned";
  Events.EVENT_COLUMN_GROUP_OPENED = "columnGroupOpened";
  Events.EVENT_COLUMN_RESIZED = "columnResized";
  Events.EVENT_DISPLAYED_COLUMNS_CHANGED = "displayedColumnsChanged";
  Events.EVENT_SUPPRESS_COLUMN_MOVE_CHANGED = "suppressMovableColumns";
  Events.EVENT_SUPPRESS_MENU_HIDE_CHANGED = "suppressMenuHide";
  Events.EVENT_SUPPRESS_FIELD_DOT_NOTATION = "suppressFieldDotNotation";
  Events.EVENT_VIRTUAL_COLUMNS_CHANGED = "virtualColumnsChanged";
  Events.EVENT_COLUMN_HEADER_MOUSE_OVER = "columnHeaderMouseOver";
  Events.EVENT_COLUMN_HEADER_MOUSE_LEAVE = "columnHeaderMouseLeave";
  Events.EVENT_COLUMN_HEADER_CLICKED = "columnHeaderClicked";
  Events.EVENT_COLUMN_HEADER_CONTEXT_MENU = "columnHeaderContextMenu";
  Events.EVENT_ASYNC_TRANSACTIONS_FLUSHED = "asyncTransactionsFlushed";
  Events.EVENT_ROW_GROUP_OPENED = "rowGroupOpened";
  Events.EVENT_ROW_DATA_UPDATED = "rowDataUpdated";
  Events.EVENT_PINNED_ROW_DATA_CHANGED = "pinnedRowDataChanged";
  Events.EVENT_RANGE_SELECTION_CHANGED = "rangeSelectionChanged";
  Events.EVENT_CHART_CREATED = "chartCreated";
  Events.EVENT_CHART_RANGE_SELECTION_CHANGED = "chartRangeSelectionChanged";
  Events.EVENT_CHART_OPTIONS_CHANGED = "chartOptionsChanged";
  Events.EVENT_CHART_DESTROYED = "chartDestroyed";
  Events.EVENT_TOOL_PANEL_VISIBLE_CHANGED = "toolPanelVisibleChanged";
  Events.EVENT_TOOL_PANEL_SIZE_CHANGED = "toolPanelSizeChanged";
  Events.EVENT_COLUMN_PANEL_ITEM_DRAG_START = "columnPanelItemDragStart";
  Events.EVENT_COLUMN_PANEL_ITEM_DRAG_END = "columnPanelItemDragEnd";
  Events.EVENT_MODEL_UPDATED = "modelUpdated";
  Events.EVENT_CUT_START = "cutStart";
  Events.EVENT_CUT_END = "cutEnd";
  Events.EVENT_PASTE_START = "pasteStart";
  Events.EVENT_PASTE_END = "pasteEnd";
  Events.EVENT_FILL_START = "fillStart";
  Events.EVENT_FILL_END = "fillEnd";
  Events.EVENT_RANGE_DELETE_START = "rangeDeleteStart";
  Events.EVENT_RANGE_DELETE_END = "rangeDeleteEnd";
  Events.EVENT_UNDO_STARTED = "undoStarted";
  Events.EVENT_UNDO_ENDED = "undoEnded";
  Events.EVENT_REDO_STARTED = "redoStarted";
  Events.EVENT_REDO_ENDED = "redoEnded";
  Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_START = "keyShortcutChangedCellStart";
  Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_END = "keyShortcutChangedCellEnd";
  Events.EVENT_CELL_CLICKED = "cellClicked";
  Events.EVENT_CELL_DOUBLE_CLICKED = "cellDoubleClicked";
  Events.EVENT_CELL_MOUSE_DOWN = "cellMouseDown";
  Events.EVENT_CELL_CONTEXT_MENU = "cellContextMenu";
  Events.EVENT_CELL_VALUE_CHANGED = "cellValueChanged";
  Events.EVENT_CELL_EDIT_REQUEST = "cellEditRequest";
  Events.EVENT_ROW_VALUE_CHANGED = "rowValueChanged";
  Events.EVENT_CELL_FOCUSED = "cellFocused";
  Events.EVENT_CELL_FOCUS_CLEARED = "cellFocusCleared";
  Events.EVENT_FULL_WIDTH_ROW_FOCUSED = "fullWidthRowFocused";
  Events.EVENT_ROW_SELECTED = "rowSelected";
  Events.EVENT_SELECTION_CHANGED = "selectionChanged";
  Events.EVENT_TOOLTIP_SHOW = "tooltipShow";
  Events.EVENT_TOOLTIP_HIDE = "tooltipHide";
  Events.EVENT_CELL_KEY_DOWN = "cellKeyDown";
  Events.EVENT_CELL_MOUSE_OVER = "cellMouseOver";
  Events.EVENT_CELL_MOUSE_OUT = "cellMouseOut";
  Events.EVENT_FILTER_CHANGED = "filterChanged";
  Events.EVENT_FILTER_MODIFIED = "filterModified";
  Events.EVENT_FILTER_OPENED = "filterOpened";
  Events.EVENT_ADVANCED_FILTER_BUILDER_VISIBLE_CHANGED = "advancedFilterBuilderVisibleChanged";
  Events.EVENT_SORT_CHANGED = "sortChanged";
  Events.EVENT_VIRTUAL_ROW_REMOVED = "virtualRowRemoved";
  Events.EVENT_ROW_CLICKED = "rowClicked";
  Events.EVENT_ROW_DOUBLE_CLICKED = "rowDoubleClicked";
  Events.EVENT_GRID_READY = "gridReady";
  Events.EVENT_GRID_PRE_DESTROYED = "gridPreDestroyed";
  Events.EVENT_GRID_SIZE_CHANGED = "gridSizeChanged";
  Events.EVENT_VIEWPORT_CHANGED = "viewportChanged";
  Events.EVENT_SCROLLBAR_WIDTH_CHANGED = "scrollbarWidthChanged";
  Events.EVENT_FIRST_DATA_RENDERED = "firstDataRendered";
  Events.EVENT_DRAG_STARTED = "dragStarted";
  Events.EVENT_DRAG_STOPPED = "dragStopped";
  Events.EVENT_CHECKBOX_CHANGED = "checkboxChanged";
  Events.EVENT_ROW_EDITING_STARTED = "rowEditingStarted";
  Events.EVENT_ROW_EDITING_STOPPED = "rowEditingStopped";
  Events.EVENT_CELL_EDITING_STARTED = "cellEditingStarted";
  Events.EVENT_CELL_EDITING_STOPPED = "cellEditingStopped";
  Events.EVENT_BODY_SCROLL = "bodyScroll";
  Events.EVENT_BODY_SCROLL_END = "bodyScrollEnd";
  Events.EVENT_HEIGHT_SCALE_CHANGED = "heightScaleChanged";
  Events.EVENT_PAGINATION_CHANGED = "paginationChanged";
  Events.EVENT_COMPONENT_STATE_CHANGED = "componentStateChanged";
  Events.EVENT_STORE_REFRESHED = "storeRefreshed";
  Events.EVENT_STATE_UPDATED = "stateUpdated";
  Events.EVENT_COLUMN_MENU_VISIBLE_CHANGED = "columnMenuVisibleChanged";
  Events.EVENT_CONTEXT_MENU_VISIBLE_CHANGED = "contextMenuVisibleChanged";
  Events.EVENT_BODY_HEIGHT_CHANGED = "bodyHeightChanged";
  Events.EVENT_COLUMN_CONTAINER_WIDTH_CHANGED = "columnContainerWidthChanged";
  Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED = "displayedColumnsWidthChanged";
  Events.EVENT_SCROLL_VISIBILITY_CHANGED = "scrollVisibilityChanged";
  Events.EVENT_COLUMN_HOVER_CHANGED = "columnHoverChanged";
  Events.EVENT_FLASH_CELLS = "flashCells";
  Events.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED = "paginationPixelOffsetChanged";
  Events.EVENT_DISPLAYED_ROWS_CHANGED = "displayedRowsChanged";
  Events.EVENT_LEFT_PINNED_WIDTH_CHANGED = "leftPinnedWidthChanged";
  Events.EVENT_RIGHT_PINNED_WIDTH_CHANGED = "rightPinnedWidthChanged";
  Events.EVENT_ROW_CONTAINER_HEIGHT_CHANGED = "rowContainerHeightChanged";
  Events.EVENT_HEADER_HEIGHT_CHANGED = "headerHeightChanged";
  Events.EVENT_COLUMN_HEADER_HEIGHT_CHANGED = "columnHeaderHeightChanged";
  Events.EVENT_ROW_DRAG_ENTER = "rowDragEnter";
  Events.EVENT_ROW_DRAG_MOVE = "rowDragMove";
  Events.EVENT_ROW_DRAG_LEAVE = "rowDragLeave";
  Events.EVENT_ROW_DRAG_END = "rowDragEnd";
  Events.EVENT_GRID_STYLES_CHANGED = "gridStylesChanged";
  Events.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST = "columnRowGroupChangeRequest";
  Events.EVENT_COLUMN_PIVOT_CHANGE_REQUEST = "columnPivotChangeRequest";
  Events.EVENT_COLUMN_VALUE_CHANGE_REQUEST = "columnValueChangeRequest";
  Events.EVENT_COLUMN_AGG_FUNC_CHANGE_REQUEST = "columnAggFuncChangeRequest";
  Events.EVENT_STORE_UPDATED = "storeUpdated";
  Events.EVENT_FILTER_DESTROYED = "filterDestroyed";
  Events.EVENT_ROW_DATA_UPDATE_STARTED = "rowDataUpdateStarted";
  Events.EVENT_ROW_COUNT_READY = "rowCountReady";
  Events.EVENT_ADVANCED_FILTER_ENABLED_CHANGED = "advancedFilterEnabledChanged";
  Events.EVENT_DATA_TYPES_INFERRED = "dataTypesInferred";
  Events.EVENT_FIELD_VALUE_CHANGED = "fieldValueChanged";
  Events.EVENT_FIELD_PICKER_VALUE_SELECTED = "fieldPickerValueSelected";
  Events.EVENT_SIDE_BAR_UPDATED = "sideBarUpdated";
  var ALWAYS_SYNC_GLOBAL_EVENTS = /* @__PURE__ */ new Set([Events.EVENT_GRID_PRE_DESTROYED, Events.EVENT_FILL_START]);
  var GroupInstanceIdCreator = class {
    constructor() {
      this.existingIds = {};
    }
    getInstanceIdForKey(key) {
      const lastResult = this.existingIds[key];
      let result;
      if (typeof lastResult !== "number") {
        result = 0;
      } else {
        result = lastResult + 1;
      }
      this.existingIds[key] = result;
      return result;
    }
  };
  var GROUP_AUTO_COLUMN_ID = "ag-Grid-AutoColumn";
  var AutoGroupColService = class extends BeanStub {
    createAutoGroupColumns(rowGroupColumns) {
      const groupAutoColumns = [];
      const doingTreeData = this.gos.get("treeData");
      let doingMultiAutoColumn = this.gos.isGroupMultiAutoColumn();
      if (doingTreeData && doingMultiAutoColumn) {
        console.warn('AG Grid: you cannot mix groupDisplayType = "multipleColumns" with treeData, only one column can be used to display groups when doing tree data');
        doingMultiAutoColumn = false;
      }
      if (doingMultiAutoColumn) {
        rowGroupColumns.forEach((rowGroupCol, index) => {
          groupAutoColumns.push(this.createOneAutoGroupColumn(rowGroupCol, index));
        });
      } else {
        groupAutoColumns.push(this.createOneAutoGroupColumn());
      }
      return groupAutoColumns;
    }
    updateAutoGroupColumns(autoGroupColumns, source) {
      autoGroupColumns.forEach((column, index) => this.updateOneAutoGroupColumn(column, index, source));
    }
    // rowGroupCol and index are missing if groupDisplayType != "multipleColumns"
    createOneAutoGroupColumn(rowGroupCol, index) {
      let colId;
      if (rowGroupCol) {
        colId = `${GROUP_AUTO_COLUMN_ID}-${rowGroupCol.getId()}`;
      } else {
        colId = GROUP_AUTO_COLUMN_ID;
      }
      const colDef = this.createAutoGroupColDef(colId, rowGroupCol, index);
      colDef.colId = colId;
      const newCol = new Column(colDef, null, colId, true);
      this.context.createBean(newCol);
      return newCol;
    }
    /**
     * Refreshes an auto group col to load changes from defaultColDef or autoGroupColDef
     */
    updateOneAutoGroupColumn(colToUpdate, index, source) {
      const oldColDef = colToUpdate.getColDef();
      const underlyingColId = typeof oldColDef.showRowGroup == "string" ? oldColDef.showRowGroup : void 0;
      const underlyingColumn = underlyingColId != null ? this.columnModel.getPrimaryColumn(underlyingColId) : void 0;
      const colDef = this.createAutoGroupColDef(colToUpdate.getId(), underlyingColumn != null ? underlyingColumn : void 0, index);
      colToUpdate.setColDef(colDef, null, source);
      this.columnFactory.applyColumnState(colToUpdate, colDef, source);
    }
    createAutoGroupColDef(colId, underlyingColumn, index) {
      let res = this.createBaseColDef(underlyingColumn);
      const autoGroupColumnDef = this.gos.get("autoGroupColumnDef");
      mergeDeep(res, autoGroupColumnDef);
      res = this.columnFactory.addColumnDefaultAndTypes(res, colId);
      if (!this.gos.get("treeData")) {
        const noFieldOrValueGetter = missing(res.field) && missing(res.valueGetter) && missing(res.filterValueGetter) && res.filter !== "agGroupColumnFilter";
        if (noFieldOrValueGetter) {
          res.filter = false;
        }
      }
      if (index && index > 0) {
        res.headerCheckboxSelection = false;
      }
      const isSortingCoupled = this.gos.isColumnsSortingCoupledToGroup();
      const hasOwnData = res.valueGetter || res.field != null;
      if (isSortingCoupled && !hasOwnData) {
        res.sortIndex = void 0;
        res.initialSort = void 0;
      }
      return res;
    }
    createBaseColDef(rowGroupCol) {
      const userDef = this.gos.get("autoGroupColumnDef");
      const localeTextFunc = this.localeService.getLocaleTextFunc();
      const res = {
        headerName: localeTextFunc("group", "Group")
      };
      const userHasProvidedGroupCellRenderer = userDef && (userDef.cellRenderer || userDef.cellRendererSelector);
      if (!userHasProvidedGroupCellRenderer) {
        res.cellRenderer = "agGroupCellRenderer";
      }
      if (rowGroupCol) {
        const colDef = rowGroupCol.getColDef();
        Object.assign(res, {
          // cellRendererParams.groupKey: colDefToCopy.field;
          headerName: this.columnModel.getDisplayNameForColumn(rowGroupCol, "header"),
          headerValueGetter: colDef.headerValueGetter
        });
        if (colDef.cellRenderer) {
          Object.assign(res, {
            cellRendererParams: {
              innerRenderer: colDef.cellRenderer,
              innerRendererParams: colDef.cellRendererParams
            }
          });
        }
        res.showRowGroup = rowGroupCol.getColId();
      } else {
        res.showRowGroup = true;
      }
      return res;
    }
  };
  __decorateClass([
    Autowired("columnModel")
  ], AutoGroupColService.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("columnFactory")
  ], AutoGroupColService.prototype, "columnFactory", 2);
  AutoGroupColService = __decorateClass([
    Bean("autoGroupColService")
  ], AutoGroupColService);
  var string_exports = {};
  __export2(string_exports, {
    camelCaseToHumanText: () => camelCaseToHumanText,
    camelCaseToHyphenated: () => camelCaseToHyphenated,
    capitalise: () => capitalise,
    escapeString: () => escapeString,
    utf8_encode: () => utf8_encode
  });
  var reUnescapedHtml = /[&<>"']/g;
  var HTML_ESCAPES = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  function utf8_encode(s) {
    const stringFromCharCode = String.fromCharCode;
    function ucs2decode(string) {
      const output = [];
      if (!string) {
        return [];
      }
      const len = string.length;
      let counter = 0;
      let value;
      let extra;
      while (counter < len) {
        value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < len) {
          extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    function checkScalarValue(point) {
      if (point >= 55296 && point <= 57343) {
        throw Error(
          "Lone surrogate U+" + point.toString(16).toUpperCase() + " is not a scalar value"
        );
      }
    }
    function createByte(point, shift) {
      return stringFromCharCode(point >> shift & 63 | 128);
    }
    function encodeCodePoint(point) {
      if (point >= 0 && point <= 31 && point !== 10) {
        const convertedCode = point.toString(16).toUpperCase();
        const paddedCode = convertedCode.padStart(4, "0");
        return `_x${paddedCode}_`;
      }
      if ((point & 4294967168) == 0) {
        return stringFromCharCode(point);
      }
      let symbol = "";
      if ((point & 4294965248) == 0) {
        symbol = stringFromCharCode(point >> 6 & 31 | 192);
      } else if ((point & 4294901760) == 0) {
        checkScalarValue(point);
        symbol = stringFromCharCode(point >> 12 & 15 | 224);
        symbol += createByte(point, 6);
      } else if ((point & 4292870144) == 0) {
        symbol = stringFromCharCode(point >> 18 & 7 | 240);
        symbol += createByte(point, 12);
        symbol += createByte(point, 6);
      }
      symbol += stringFromCharCode(point & 63 | 128);
      return symbol;
    }
    const codePoints = ucs2decode(s);
    const length = codePoints.length;
    let index = -1;
    let codePoint;
    let byteString = "";
    while (++index < length) {
      codePoint = codePoints[index];
      byteString += encodeCodePoint(codePoint);
    }
    return byteString;
  }
  function capitalise(str) {
    return str[0].toUpperCase() + str.substring(1).toLowerCase();
  }
  function escapeString(toEscape, skipEscapingHtmlChars) {
    if (toEscape == null) {
      return null;
    }
    const stringResult = toEscape.toString().toString();
    if (skipEscapingHtmlChars) {
      return stringResult;
    }
    return stringResult.replace(reUnescapedHtml, (chr) => HTML_ESCAPES[chr]);
  }
  function camelCaseToHumanText(camelCase) {
    if (!camelCase || camelCase == null) {
      return null;
    }
    const rex = /([a-z])([A-Z])/g;
    const rexCaps = /([A-Z]+)([A-Z])([a-z])/g;
    const words = camelCase.replace(rex, "$1 $2").replace(rexCaps, "$1 $2$3").replace(/\./g, " ").split(" ");
    return words.map((word) => word.substring(0, 1).toUpperCase() + (word.length > 1 ? word.substring(1, word.length) : "")).join(" ");
  }
  function camelCaseToHyphenated(camelCase) {
    return camelCase.replace(/[A-Z]/g, (s) => `-${s.toLocaleLowerCase()}`);
  }
  var map_exports = {};
  __export2(map_exports, {
    convertToMap: () => convertToMap,
    keys: () => keys,
    mapById: () => mapById
  });
  function convertToMap(arr) {
    const map2 = /* @__PURE__ */ new Map();
    arr.forEach((pair) => map2.set(pair[0], pair[1]));
    return map2;
  }
  function mapById(arr, callback) {
    const map2 = /* @__PURE__ */ new Map();
    arr.forEach((item) => map2.set(callback(item), item));
    return map2;
  }
  function keys(map2) {
    const arr = [];
    map2.forEach((_2, key) => arr.push(key));
    return arr;
  }
  var ColumnModel = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.primaryHeaderRowCount = 0;
      this.secondaryHeaderRowCount = 0;
      this.gridHeaderRowCount = 0;
      this.displayedColumnsLeft = [];
      this.displayedColumnsRight = [];
      this.displayedColumnsCenter = [];
      this.displayedColumns = [];
      this.displayedColumnsAndGroupsMap = {};
      this.viewportColumns = [];
      this.viewportColumnsHash = "";
      this.headerViewportColumns = [];
      this.viewportColumnsCenter = [];
      this.headerViewportColumnsCenter = [];
      this.viewportRowLeft = {};
      this.viewportRowRight = {};
      this.viewportRowCenter = {};
      this.autoHeightActiveAtLeastOnce = false;
      this.rowGroupColumns = [];
      this.valueColumns = [];
      this.pivotColumns = [];
      this.ready = false;
      this.changeEventsDispatching = false;
      this.autoGroupsNeedBuilding = false;
      this.forceRecreateAutoGroups = false;
      this.pivotMode = false;
      this.bodyWidth = 0;
      this.leftWidth = 0;
      this.rightWidth = 0;
      this.bodyWidthDirty = true;
      this.shouldQueueResizeOperations = false;
      this.resizeOperationQueue = [];
    }
    init() {
      this.suppressColumnVirtualisation = this.gos.get("suppressColumnVirtualisation");
      const pivotMode = this.gos.get("pivotMode");
      if (this.isPivotSettingAllowed(pivotMode)) {
        this.pivotMode = pivotMode;
      }
      this.addManagedPropertyListeners(["groupDisplayType", "treeData", "treeDataDisplayType", "groupHideOpenParents"], (event) => this.buildAutoGroupColumns(convertSourceType(event.source)));
      this.addManagedPropertyListener("autoGroupColumnDef", (event) => this.onAutoGroupColumnDefChanged(convertSourceType(event.source)));
      this.addManagedPropertyListeners(["defaultColDef", "columnTypes", "suppressFieldDotNotation"], (event) => this.onSharedColDefChanged(convertSourceType(event.source)));
      this.addManagedPropertyListener("pivotMode", (event) => this.setPivotMode(this.gos.get("pivotMode"), convertSourceType(event.source)));
      this.addManagedListener(this.eventService, Events.EVENT_FIRST_DATA_RENDERED, () => this.onFirstDataRendered());
    }
    buildAutoGroupColumns(source) {
      if (!this.columnDefs) {
        return;
      }
      this.autoGroupsNeedBuilding = true;
      this.forceRecreateAutoGroups = true;
      this.updateGridColumns();
      this.updateDisplayedColumns(source);
    }
    onAutoGroupColumnDefChanged(source) {
      if (this.groupAutoColumns) {
        this.autoGroupColService.updateAutoGroupColumns(this.groupAutoColumns, source);
      }
    }
    onSharedColDefChanged(source) {
      if (!this.gridColumns) {
        return;
      }
      if (this.groupAutoColumns) {
        this.autoGroupColService.updateAutoGroupColumns(this.groupAutoColumns, source);
      }
      this.createColumnsFromColumnDefs(true, source);
    }
    setColumnDefs(columnDefs, source) {
      const colsPreviouslyExisted = !!this.columnDefs;
      this.columnDefs = columnDefs;
      this.createColumnsFromColumnDefs(colsPreviouslyExisted, source);
    }
    recreateColumnDefs(source) {
      this.onSharedColDefChanged(source);
    }
    destroyOldColumns(oldTree, newTree) {
      const oldObjectsById = {};
      if (!oldTree) {
        return;
      }
      depthFirstOriginalTreeSearch(null, oldTree, (child) => {
        oldObjectsById[child.getInstanceId()] = child;
      });
      if (newTree) {
        depthFirstOriginalTreeSearch(null, newTree, (child) => {
          oldObjectsById[child.getInstanceId()] = null;
        });
      }
      const colsToDestroy = Object.values(oldObjectsById).filter((item) => item != null);
      this.destroyBeans(colsToDestroy);
    }
    destroyColumns() {
      this.destroyOldColumns(this.primaryColumnTree);
      this.destroyOldColumns(this.secondaryBalancedTree);
      this.destroyOldColumns(this.groupAutoColsBalancedTree);
    }
    createColumnsFromColumnDefs(colsPreviouslyExisted, source) {
      const dispatchEventsFunc = colsPreviouslyExisted ? this.compareColumnStatesAndDispatchEvents(source) : void 0;
      this.valueCache.expire();
      this.autoGroupsNeedBuilding = true;
      const oldPrimaryColumns = this.primaryColumns;
      const oldPrimaryTree = this.primaryColumnTree;
      const balancedTreeResult = this.columnFactory.createColumnTree(this.columnDefs, true, oldPrimaryTree, source);
      this.destroyOldColumns(this.primaryColumnTree, balancedTreeResult.columnTree);
      this.primaryColumnTree = balancedTreeResult.columnTree;
      this.primaryHeaderRowCount = balancedTreeResult.treeDept + 1;
      this.primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);
      this.primaryColumnsMap = {};
      this.primaryColumns.forEach((col) => this.primaryColumnsMap[col.getId()] = col);
      this.extractRowGroupColumns(source, oldPrimaryColumns);
      this.extractPivotColumns(source, oldPrimaryColumns);
      this.extractValueColumns(source, oldPrimaryColumns);
      this.ready = true;
      const gridColsNotProcessed = this.gridColsArePrimary === void 0;
      const processGridCols = this.gridColsArePrimary || gridColsNotProcessed || this.autoGroupsNeedBuilding;
      if (processGridCols) {
        this.updateGridColumns();
        if (colsPreviouslyExisted && this.gridColsArePrimary && !this.gos.get("maintainColumnOrder")) {
          this.orderGridColumnsLikePrimary();
        }
        this.updateDisplayedColumns(source);
        this.checkViewportColumns();
      }
      this.dispatchEverythingChanged(source);
      this.changeEventsDispatching = true;
      if (dispatchEventsFunc) {
        dispatchEventsFunc();
      }
      this.changeEventsDispatching = false;
      this.dispatchNewColumnsLoaded(source);
    }
    shouldRowModelIgnoreRefresh() {
      return this.changeEventsDispatching;
    }
    dispatchNewColumnsLoaded(source) {
      const newColumnsLoadedEvent = {
        type: Events.EVENT_NEW_COLUMNS_LOADED,
        source
      };
      this.eventService.dispatchEvent(newColumnsLoadedEvent);
      if (source === "gridInitializing") {
        this.onColumnsReady();
      }
    }
    // this event is legacy, no grid code listens to it. instead the grid listens to New Columns Loaded
    dispatchEverythingChanged(source) {
      const eventEverythingChanged = {
        type: Events.EVENT_COLUMN_EVERYTHING_CHANGED,
        source
      };
      this.eventService.dispatchEvent(eventEverythingChanged);
    }
    orderGridColumnsLikePrimary() {
      const primaryColumns = this.primaryColumns;
      if (!primaryColumns) {
        return;
      }
      const primaryColsOrdered = primaryColumns.filter((col) => this.gridColumns.indexOf(col) >= 0);
      const otherCols = this.gridColumns.filter((col) => primaryColsOrdered.indexOf(col) < 0);
      this.gridColumns = [...otherCols, ...primaryColsOrdered];
      this.gridColumns = this.placeLockedColumns(this.gridColumns);
    }
    getAllDisplayedAutoHeightCols() {
      return this.displayedAutoHeightCols;
    }
    setViewport() {
      if (this.gos.get("enableRtl")) {
        this.viewportLeft = this.bodyWidth - this.scrollPosition - this.scrollWidth;
        this.viewportRight = this.bodyWidth - this.scrollPosition;
      } else {
        this.viewportLeft = this.scrollPosition;
        this.viewportRight = this.scrollWidth + this.scrollPosition;
      }
    }
    // checks what columns are currently displayed due to column virtualisation. dispatches an event
    // if the list of columns has changed.
    // + setColumnWidth(), setViewportPosition(), setColumnDefs(), sizeColumnsToFit()
    checkViewportColumns(afterScroll = false) {
      if (this.displayedColumnsCenter == null) {
        return;
      }
      const viewportColumnsChanged = this.extractViewport();
      if (!viewportColumnsChanged) {
        return;
      }
      const event = {
        type: Events.EVENT_VIRTUAL_COLUMNS_CHANGED,
        afterScroll
      };
      this.eventService.dispatchEvent(event);
    }
    setViewportPosition(scrollWidth, scrollPosition, afterScroll = false) {
      if (scrollWidth !== this.scrollWidth || scrollPosition !== this.scrollPosition || this.bodyWidthDirty) {
        this.scrollWidth = scrollWidth;
        this.scrollPosition = scrollPosition;
        this.bodyWidthDirty = true;
        this.setViewport();
        if (this.ready) {
          this.checkViewportColumns(afterScroll);
        }
      }
    }
    isPivotMode() {
      return this.pivotMode;
    }
    isPivotSettingAllowed(pivot) {
      if (pivot && this.gos.get("treeData")) {
        warnOnce("Pivot mode not available with treeData.");
        return false;
      }
      return true;
    }
    setPivotMode(pivotMode, source) {
      if (pivotMode === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode)) {
        return;
      }
      this.pivotMode = pivotMode;
      if (!this.gridColumns) {
        return;
      }
      this.autoGroupsNeedBuilding = true;
      this.updateGridColumns();
      this.updateDisplayedColumns(source);
      const event = {
        type: Events.EVENT_COLUMN_PIVOT_MODE_CHANGED
      };
      this.eventService.dispatchEvent(event);
    }
    getSecondaryPivotColumn(pivotKeys, valueColKey) {
      if (missing(this.secondaryColumns)) {
        return null;
      }
      const valueColumnToFind = this.getPrimaryColumn(valueColKey);
      let foundColumn = null;
      this.secondaryColumns.forEach((column) => {
        const thisPivotKeys = column.getColDef().pivotKeys;
        const pivotValueColumn = column.getColDef().pivotValueColumn;
        const pivotKeyMatches = areEqual(thisPivotKeys, pivotKeys);
        const pivotValueMatches = pivotValueColumn === valueColumnToFind;
        if (pivotKeyMatches && pivotValueMatches) {
          foundColumn = column;
        }
      });
      return foundColumn;
    }
    setBeans(loggerFactory) {
      this.logger = loggerFactory.create("columnModel");
    }
    setFirstRightAndLastLeftPinned(source) {
      let lastLeft;
      let firstRight;
      if (this.gos.get("enableRtl")) {
        lastLeft = this.displayedColumnsLeft ? this.displayedColumnsLeft[0] : null;
        firstRight = this.displayedColumnsRight ? last(this.displayedColumnsRight) : null;
      } else {
        lastLeft = this.displayedColumnsLeft ? last(this.displayedColumnsLeft) : null;
        firstRight = this.displayedColumnsRight ? this.displayedColumnsRight[0] : null;
      }
      this.gridColumns.forEach((column) => {
        column.setLastLeftPinned(column === lastLeft, source);
        column.setFirstRightPinned(column === firstRight, source);
      });
    }
    autoSizeColumns(params) {
      if (this.shouldQueueResizeOperations) {
        this.resizeOperationQueue.push(() => this.autoSizeColumns(params));
        return;
      }
      const { columns, skipHeader, skipHeaderGroups, stopAtGroup, source = "api" } = params;
      this.animationFrameService.flushAllFrames();
      const columnsAutosized = [];
      let changesThisTimeAround = -1;
      const shouldSkipHeader = skipHeader != null ? skipHeader : this.gos.get("skipHeaderOnAutoSize");
      const shouldSkipHeaderGroups = skipHeaderGroups != null ? skipHeaderGroups : shouldSkipHeader;
      while (changesThisTimeAround !== 0) {
        changesThisTimeAround = 0;
        this.actionOnGridColumns(columns, (column) => {
          if (columnsAutosized.indexOf(column) >= 0) {
            return false;
          }
          const preferredWidth = this.autoWidthCalculator.getPreferredWidthForColumn(column, shouldSkipHeader);
          if (preferredWidth > 0) {
            const newWidth = this.normaliseColumnWidth(column, preferredWidth);
            column.setActualWidth(newWidth, source);
            columnsAutosized.push(column);
            changesThisTimeAround++;
          }
          return true;
        }, source);
      }
      if (!shouldSkipHeaderGroups) {
        this.autoSizeColumnGroupsByColumns(columns, source, stopAtGroup);
      }
      this.dispatchColumnResizedEvent(columnsAutosized, true, "autosizeColumns");
    }
    dispatchColumnResizedEvent(columns, finished, source, flexColumns = null) {
      if (columns && columns.length) {
        const event = {
          type: Events.EVENT_COLUMN_RESIZED,
          columns,
          column: columns.length === 1 ? columns[0] : null,
          flexColumns,
          finished,
          source
        };
        this.eventService.dispatchEvent(event);
      }
    }
    dispatchColumnChangedEvent(type, columns, source) {
      const event = {
        type,
        columns,
        column: columns && columns.length == 1 ? columns[0] : null,
        source
      };
      this.eventService.dispatchEvent(event);
    }
    dispatchColumnMovedEvent(params) {
      const { movedColumns, source, toIndex, finished } = params;
      const event = {
        type: Events.EVENT_COLUMN_MOVED,
        columns: movedColumns,
        column: movedColumns && movedColumns.length === 1 ? movedColumns[0] : null,
        toIndex,
        finished,
        source
      };
      this.eventService.dispatchEvent(event);
    }
    dispatchColumnPinnedEvent(changedColumns, source) {
      if (!changedColumns.length) {
        return;
      }
      const column = changedColumns.length === 1 ? changedColumns[0] : null;
      const pinned = this.getCommonValue(changedColumns, (col) => col.getPinned());
      const event = {
        type: Events.EVENT_COLUMN_PINNED,
        // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'
        pinned: pinned != null ? pinned : null,
        columns: changedColumns,
        column,
        source
      };
      this.eventService.dispatchEvent(event);
    }
    dispatchColumnVisibleEvent(changedColumns, source) {
      if (!changedColumns.length) {
        return;
      }
      const column = changedColumns.length === 1 ? changedColumns[0] : null;
      const visible = this.getCommonValue(changedColumns, (col) => col.isVisible());
      const event = {
        type: Events.EVENT_COLUMN_VISIBLE,
        visible,
        columns: changedColumns,
        column,
        source
      };
      this.eventService.dispatchEvent(event);
    }
    autoSizeColumn(key, source, skipHeader) {
      if (key) {
        this.autoSizeColumns({ columns: [key], skipHeader, skipHeaderGroups: true, source });
      }
    }
    autoSizeColumnGroupsByColumns(keys2, source, stopAtGroup) {
      const columnGroups = /* @__PURE__ */ new Set();
      const columns = this.getGridColumns(keys2);
      columns.forEach((col) => {
        let parent = col.getParent();
        while (parent && parent != stopAtGroup) {
          if (!parent.isPadding()) {
            columnGroups.add(parent);
          }
          parent = parent.getParent();
        }
      });
      let headerGroupCtrl;
      const resizedColumns = [];
      for (const columnGroup of columnGroups) {
        for (const headerContainerCtrl of this.ctrlsService.getHeaderRowContainerCtrls()) {
          headerGroupCtrl = headerContainerCtrl.getHeaderCtrlForColumn(columnGroup);
          if (headerGroupCtrl) {
            break;
          }
        }
        if (headerGroupCtrl) {
          headerGroupCtrl.resizeLeafColumnsToFit(source);
        }
      }
      return resizedColumns;
    }
    autoSizeAllColumns(source, skipHeader) {
      if (this.shouldQueueResizeOperations) {
        this.resizeOperationQueue.push(() => this.autoSizeAllColumns(source, skipHeader));
        return;
      }
      const allDisplayedColumns = this.getAllDisplayedColumns();
      this.autoSizeColumns({ columns: allDisplayedColumns, skipHeader, source });
    }
    // Possible candidate for reuse (alot of recursive traversal duplication)
    getColumnsFromTree(rootColumns) {
      const result = [];
      const recursiveFindColumns = (childColumns) => {
        for (let i = 0; i < childColumns.length; i++) {
          const child = childColumns[i];
          if (child instanceof Column) {
            result.push(child);
          } else if (child instanceof ProvidedColumnGroup) {
            recursiveFindColumns(child.getChildren());
          }
        }
      };
      recursiveFindColumns(rootColumns);
      return result;
    }
    getAllDisplayedTrees() {
      if (this.displayedTreeLeft && this.displayedTreeRight && this.displayedTreeCentre) {
        return this.displayedTreeLeft.concat(this.displayedTreeCentre).concat(this.displayedTreeRight);
      }
      return null;
    }
    // + columnSelectPanel
    getPrimaryColumnTree() {
      return this.primaryColumnTree;
    }
    // + gridPanel -> for resizing the body and setting top margin
    getHeaderRowCount() {
      return this.gridHeaderRowCount;
    }
    // + headerRenderer -> setting pinned body width
    getDisplayedTreeLeft() {
      return this.displayedTreeLeft;
    }
    // + headerRenderer -> setting pinned body width
    getDisplayedTreeRight() {
      return this.displayedTreeRight;
    }
    // + headerRenderer -> setting pinned body width
    getDisplayedTreeCentre() {
      return this.displayedTreeCentre;
    }
    // gridPanel -> ensureColumnVisible
    isColumnDisplayed(column) {
      return this.getAllDisplayedColumns().indexOf(column) >= 0;
    }
    // + csvCreator
    getAllDisplayedColumns() {
      return this.displayedColumns;
    }
    getViewportColumns() {
      return this.viewportColumns;
    }
    getDisplayedLeftColumnsForRow(rowNode) {
      if (!this.colSpanActive) {
        return this.displayedColumnsLeft;
      }
      return this.getDisplayedColumnsForRow(rowNode, this.displayedColumnsLeft);
    }
    getDisplayedRightColumnsForRow(rowNode) {
      if (!this.colSpanActive) {
        return this.displayedColumnsRight;
      }
      return this.getDisplayedColumnsForRow(rowNode, this.displayedColumnsRight);
    }
    isColSpanActive() {
      return this.colSpanActive;
    }
    getDisplayedColumnsForRow(rowNode, displayedColumns, filterCallback, emptySpaceBeforeColumn) {
      const result = [];
      let lastConsideredCol = null;
      for (let i = 0; i < displayedColumns.length; i++) {
        const col = displayedColumns[i];
        const maxAllowedColSpan = displayedColumns.length - i;
        const colSpan = Math.min(col.getColSpan(rowNode), maxAllowedColSpan);
        const columnsToCheckFilter = [col];
        if (colSpan > 1) {
          const colsToRemove = colSpan - 1;
          for (let j = 1; j <= colsToRemove; j++) {
            columnsToCheckFilter.push(displayedColumns[i + j]);
          }
          i += colsToRemove;
        }
        let filterPasses;
        if (filterCallback) {
          filterPasses = false;
          columnsToCheckFilter.forEach((colForFilter) => {
            if (filterCallback(colForFilter)) {
              filterPasses = true;
            }
          });
        } else {
          filterPasses = true;
        }
        if (filterPasses) {
          if (result.length === 0 && lastConsideredCol) {
            const gapBeforeColumn = emptySpaceBeforeColumn ? emptySpaceBeforeColumn(col) : false;
            if (gapBeforeColumn) {
              result.push(lastConsideredCol);
            }
          }
          result.push(col);
        }
        lastConsideredCol = col;
      }
      return result;
    }
    // + rowRenderer
    // if we are not column spanning, this just returns back the virtual centre columns,
    // however if we are column spanning, then different rows can have different virtual
    // columns, so we have to work out the list for each individual row.
    getViewportCenterColumnsForRow(rowNode) {
      if (!this.colSpanActive) {
        return this.viewportColumnsCenter;
      }
      const emptySpaceBeforeColumn = (col) => {
        const left = col.getLeft();
        return exists(left) && left > this.viewportLeft;
      };
      const filterCallback = this.isColumnVirtualisationSuppressed() ? null : this.isColumnInRowViewport.bind(this);
      return this.getDisplayedColumnsForRow(
        rowNode,
        this.displayedColumnsCenter,
        filterCallback,
        emptySpaceBeforeColumn
      );
    }
    isColumnAtEdge(col, edge) {
      const allColumns = this.getAllDisplayedColumns();
      if (!allColumns.length) {
        return false;
      }
      const isFirst = edge === "first";
      let columnToCompare;
      if (col instanceof ColumnGroup) {
        const leafColumns = col.getDisplayedLeafColumns();
        if (!leafColumns.length) {
          return false;
        }
        columnToCompare = isFirst ? leafColumns[0] : last(leafColumns);
      } else {
        columnToCompare = col;
      }
      return (isFirst ? allColumns[0] : last(allColumns)) === columnToCompare;
    }
    getAriaColumnIndex(col) {
      let targetColumn;
      if (col instanceof ColumnGroup) {
        targetColumn = col.getLeafColumns()[0];
      } else {
        targetColumn = col;
      }
      return this.ariaOrderColumns.indexOf(targetColumn) + 1;
    }
    isColumnInHeaderViewport(col) {
      if (col.isAutoHeaderHeight()) {
        return true;
      }
      return this.isColumnInRowViewport(col);
    }
    isColumnInRowViewport(col) {
      if (col.isAutoHeight()) {
        return true;
      }
      const columnLeft = col.getLeft() || 0;
      const columnRight = columnLeft + col.getActualWidth();
      const leftBounds = this.viewportLeft - 200;
      const rightBounds = this.viewportRight + 200;
      const columnToMuchLeft = columnLeft < leftBounds && columnRight < leftBounds;
      const columnToMuchRight = columnLeft > rightBounds && columnRight > rightBounds;
      return !columnToMuchLeft && !columnToMuchRight;
    }
    // used by:
    // + angularGrid -> setting pinned body width
    // note: this should be cached
    getDisplayedColumnsLeftWidth() {
      return this.getWidthOfColsInList(this.displayedColumnsLeft);
    }
    // note: this should be cached
    getDisplayedColumnsRightWidth() {
      return this.getWidthOfColsInList(this.displayedColumnsRight);
    }
    updatePrimaryColumnList(keys2, masterList, actionIsAdd, columnCallback, eventType, source) {
      if (!keys2 || missingOrEmpty(keys2)) {
        return;
      }
      let atLeastOne = false;
      keys2.forEach((key) => {
        if (!key) {
          return;
        }
        const columnToAdd = this.getPrimaryColumn(key);
        if (!columnToAdd) {
          return;
        }
        if (actionIsAdd) {
          if (masterList.indexOf(columnToAdd) >= 0) {
            return;
          }
          masterList.push(columnToAdd);
        } else {
          if (masterList.indexOf(columnToAdd) < 0) {
            return;
          }
          removeFromArray(masterList, columnToAdd);
        }
        columnCallback(columnToAdd);
        atLeastOne = true;
      });
      if (!atLeastOne) {
        return;
      }
      if (this.autoGroupsNeedBuilding) {
        this.updateGridColumns();
      }
      this.updateDisplayedColumns(source);
      const event = {
        type: eventType,
        columns: masterList,
        column: masterList.length === 1 ? masterList[0] : null,
        source
      };
      this.eventService.dispatchEvent(event);
    }
    setRowGroupColumns(colKeys, source) {
      this.autoGroupsNeedBuilding = true;
      this.setPrimaryColumnList(
        colKeys,
        this.rowGroupColumns,
        Events.EVENT_COLUMN_ROW_GROUP_CHANGED,
        true,
        this.setRowGroupActive.bind(this),
        source
      );
    }
    setRowGroupActive(active, column, source) {
      if (active === column.isRowGroupActive()) {
        return;
      }
      column.setRowGroupActive(active, source);
      if (active && !this.gos.get("suppressRowGroupHidesColumns")) {
        this.setColumnsVisible([column], false, source);
      }
      if (!active && !this.gos.get("suppressMakeColumnVisibleAfterUnGroup")) {
        this.setColumnsVisible([column], true, source);
      }
    }
    addRowGroupColumns(keys2, source) {
      this.autoGroupsNeedBuilding = true;
      this.updatePrimaryColumnList(
        keys2,
        this.rowGroupColumns,
        true,
        this.setRowGroupActive.bind(this, true),
        Events.EVENT_COLUMN_ROW_GROUP_CHANGED,
        source
      );
    }
    removeRowGroupColumns(keys2, source) {
      this.autoGroupsNeedBuilding = true;
      this.updatePrimaryColumnList(
        keys2,
        this.rowGroupColumns,
        false,
        this.setRowGroupActive.bind(this, false),
        Events.EVENT_COLUMN_ROW_GROUP_CHANGED,
        source
      );
    }
    addPivotColumns(keys2, source) {
      this.updatePrimaryColumnList(
        keys2,
        this.pivotColumns,
        true,
        (column) => column.setPivotActive(true, source),
        Events.EVENT_COLUMN_PIVOT_CHANGED,
        source
      );
    }
    setPivotColumns(colKeys, source) {
      this.setPrimaryColumnList(
        colKeys,
        this.pivotColumns,
        Events.EVENT_COLUMN_PIVOT_CHANGED,
        true,
        (added, column) => {
          column.setPivotActive(added, source);
        },
        source
      );
    }
    removePivotColumns(keys2, source) {
      this.updatePrimaryColumnList(
        keys2,
        this.pivotColumns,
        false,
        (column) => column.setPivotActive(false, source),
        Events.EVENT_COLUMN_PIVOT_CHANGED,
        source
      );
    }
    setPrimaryColumnList(colKeys, masterList, eventName, detectOrderChange, columnCallback, source) {
      if (!this.gridColumns) {
        return;
      }
      const changes = /* @__PURE__ */ new Map();
      masterList.forEach((col, idx) => changes.set(col, idx));
      masterList.length = 0;
      if (exists(colKeys)) {
        colKeys.forEach((key) => {
          const column = this.getPrimaryColumn(key);
          if (column) {
            masterList.push(column);
          }
        });
      }
      masterList.forEach((col, idx) => {
        const oldIndex = changes.get(col);
        if (oldIndex === void 0) {
          changes.set(col, 0);
          return;
        }
        if (detectOrderChange && oldIndex !== idx) {
          return;
        }
        changes.delete(col);
      });
      (this.primaryColumns || []).forEach((column) => {
        const added = masterList.indexOf(column) >= 0;
        columnCallback(added, column);
      });
      if (this.autoGroupsNeedBuilding) {
        this.updateGridColumns();
      }
      this.updateDisplayedColumns(source);
      this.dispatchColumnChangedEvent(eventName, [...changes.keys()], source);
    }
    setValueColumns(colKeys, source) {
      this.setPrimaryColumnList(
        colKeys,
        this.valueColumns,
        Events.EVENT_COLUMN_VALUE_CHANGED,
        false,
        this.setValueActive.bind(this),
        source
      );
    }
    setValueActive(active, column, source) {
      if (active === column.isValueActive()) {
        return;
      }
      column.setValueActive(active, source);
      if (active && !column.getAggFunc() && this.aggFuncService) {
        const initialAggFunc = this.aggFuncService.getDefaultAggFunc(column);
        column.setAggFunc(initialAggFunc);
      }
    }
    addValueColumns(keys2, source) {
      this.updatePrimaryColumnList(
        keys2,
        this.valueColumns,
        true,
        this.setValueActive.bind(this, true),
        Events.EVENT_COLUMN_VALUE_CHANGED,
        source
      );
    }
    removeValueColumns(keys2, source) {
      this.updatePrimaryColumnList(
        keys2,
        this.valueColumns,
        false,
        this.setValueActive.bind(this, false),
        Events.EVENT_COLUMN_VALUE_CHANGED,
        source
      );
    }
    // returns the width we can set to this col, taking into consideration min and max widths
    normaliseColumnWidth(column, newWidth) {
      const minWidth = column.getMinWidth();
      if (exists(minWidth) && newWidth < minWidth) {
        newWidth = minWidth;
      }
      const maxWidth = column.getMaxWidth();
      if (exists(maxWidth) && column.isGreaterThanMax(newWidth)) {
        newWidth = maxWidth;
      }
      return newWidth;
    }
    getPrimaryOrGridColumn(key) {
      const column = this.getPrimaryColumn(key);
      return column || this.getGridColumn(key);
    }
    setColumnWidths(columnWidths, shiftKey, finished, source) {
      const sets = [];
      columnWidths.forEach((columnWidth) => {
        const col = this.getPrimaryOrGridColumn(columnWidth.key);
        if (!col) {
          return;
        }
        sets.push({
          width: columnWidth.newWidth,
          ratios: [1],
          columns: [col]
        });
        const defaultIsShift = this.gos.get("colResizeDefault") === "shift";
        if (defaultIsShift) {
          shiftKey = !shiftKey;
        }
        if (shiftKey) {
          const otherCol = this.getDisplayedColAfter(col);
          if (!otherCol) {
            return;
          }
          const widthDiff = col.getActualWidth() - columnWidth.newWidth;
          const otherColWidth = otherCol.getActualWidth() + widthDiff;
          sets.push({
            width: otherColWidth,
            ratios: [1],
            columns: [otherCol]
          });
        }
      });
      if (sets.length === 0) {
        return;
      }
      this.resizeColumnSets({
        resizeSets: sets,
        finished,
        source
      });
    }
    checkMinAndMaxWidthsForSet(columnResizeSet) {
      const { columns, width } = columnResizeSet;
      let minWidthAccumulated = 0;
      let maxWidthAccumulated = 0;
      let maxWidthActive = true;
      columns.forEach((col) => {
        const minWidth = col.getMinWidth();
        minWidthAccumulated += minWidth || 0;
        const maxWidth = col.getMaxWidth();
        if (exists(maxWidth) && maxWidth > 0) {
          maxWidthAccumulated += maxWidth;
        } else {
          maxWidthActive = false;
        }
      });
      const minWidthPasses = width >= minWidthAccumulated;
      const maxWidthPasses = !maxWidthActive || width <= maxWidthAccumulated;
      return minWidthPasses && maxWidthPasses;
    }
    // method takes sets of columns and resizes them. either all sets will be resized, or nothing
    // be resized. this is used for example when user tries to resize a group and holds shift key,
    // then both the current group (grows), and the adjacent group (shrinks), will get resized,
    // so that's two sets for this method.
    resizeColumnSets(params) {
      const { resizeSets, finished, source } = params;
      const passMinMaxCheck = !resizeSets || resizeSets.every((columnResizeSet) => this.checkMinAndMaxWidthsForSet(columnResizeSet));
      if (!passMinMaxCheck) {
        if (finished) {
          const columns = resizeSets && resizeSets.length > 0 ? resizeSets[0].columns : null;
          this.dispatchColumnResizedEvent(columns, finished, source);
        }
        return;
      }
      const changedCols = [];
      const allResizedCols = [];
      resizeSets.forEach((set2) => {
        const { width, columns, ratios } = set2;
        const newWidths = {};
        const finishedCols = {};
        columns.forEach((col) => allResizedCols.push(col));
        let finishedColsGrew = true;
        let loopCount = 0;
        while (finishedColsGrew) {
          loopCount++;
          if (loopCount > 1e3) {
            console.error("AG Grid: infinite loop in resizeColumnSets");
            break;
          }
          finishedColsGrew = false;
          const subsetCols = [];
          let subsetRatioTotal = 0;
          let pixelsToDistribute = width;
          columns.forEach((col, index) => {
            const thisColFinished = finishedCols[col.getId()];
            if (thisColFinished) {
              pixelsToDistribute -= newWidths[col.getId()];
            } else {
              subsetCols.push(col);
              const ratioThisCol = ratios[index];
              subsetRatioTotal += ratioThisCol;
            }
          });
          const ratioScale = 1 / subsetRatioTotal;
          subsetCols.forEach((col, index) => {
            const lastCol = index === subsetCols.length - 1;
            let colNewWidth;
            if (lastCol) {
              colNewWidth = pixelsToDistribute;
            } else {
              colNewWidth = Math.round(ratios[index] * width * ratioScale);
              pixelsToDistribute -= colNewWidth;
            }
            const minWidth = col.getMinWidth();
            const maxWidth = col.getMaxWidth();
            if (exists(minWidth) && colNewWidth < minWidth) {
              colNewWidth = minWidth;
              finishedCols[col.getId()] = true;
              finishedColsGrew = true;
            } else if (exists(maxWidth) && maxWidth > 0 && colNewWidth > maxWidth) {
              colNewWidth = maxWidth;
              finishedCols[col.getId()] = true;
              finishedColsGrew = true;
            }
            newWidths[col.getId()] = colNewWidth;
          });
        }
        columns.forEach((col) => {
          const newWidth = newWidths[col.getId()];
          const actualWidth = col.getActualWidth();
          if (actualWidth !== newWidth) {
            col.setActualWidth(newWidth, source);
            changedCols.push(col);
          }
        });
      });
      const atLeastOneColChanged = changedCols.length > 0;
      let flexedCols = [];
      if (atLeastOneColChanged) {
        flexedCols = this.refreshFlexedColumns({ resizingCols: allResizedCols, skipSetLeft: true });
        this.setLeftValues(source);
        this.updateBodyWidths();
        this.checkViewportColumns();
      }
      const colsForEvent = allResizedCols.concat(flexedCols);
      if (atLeastOneColChanged || finished) {
        this.dispatchColumnResizedEvent(colsForEvent, finished, source, flexedCols);
      }
    }
    setColumnAggFunc(key, aggFunc, source) {
      if (!key) {
        return;
      }
      const column = this.getPrimaryColumn(key);
      if (!column) {
        return;
      }
      column.setAggFunc(aggFunc);
      this.dispatchColumnChangedEvent(Events.EVENT_COLUMN_VALUE_CHANGED, [column], source);
    }
    moveRowGroupColumn(fromIndex, toIndex, source) {
      if (this.isRowGroupEmpty()) {
        return;
      }
      const column = this.rowGroupColumns[fromIndex];
      const impactedColumns = this.rowGroupColumns.slice(fromIndex, toIndex);
      this.rowGroupColumns.splice(fromIndex, 1);
      this.rowGroupColumns.splice(toIndex, 0, column);
      const event = {
        type: Events.EVENT_COLUMN_ROW_GROUP_CHANGED,
        columns: impactedColumns,
        column: impactedColumns.length === 1 ? impactedColumns[0] : null,
        source
      };
      this.eventService.dispatchEvent(event);
    }
    moveColumns(columnsToMoveKeys, toIndex, source, finished = true) {
      if (!this.gridColumns) {
        return;
      }
      this.columnAnimationService.start();
      if (toIndex > this.gridColumns.length - columnsToMoveKeys.length) {
        console.warn("AG Grid: tried to insert columns in invalid location, toIndex = " + toIndex);
        console.warn("AG Grid: remember that you should not count the moving columns when calculating the new index");
        return;
      }
      const movedColumns = this.getGridColumns(columnsToMoveKeys);
      const failedRules = !this.doesMovePassRules(movedColumns, toIndex);
      if (failedRules) {
        return;
      }
      moveInArray(this.gridColumns, movedColumns, toIndex);
      this.updateDisplayedColumns(source);
      this.dispatchColumnMovedEvent({ movedColumns, source, toIndex, finished });
      this.columnAnimationService.finish();
    }
    doesMovePassRules(columnsToMove, toIndex) {
      const proposedColumnOrder = this.getProposedColumnOrder(columnsToMove, toIndex);
      return this.doesOrderPassRules(proposedColumnOrder);
    }
    doesOrderPassRules(gridOrder) {
      if (!this.doesMovePassMarryChildren(gridOrder)) {
        return false;
      }
      if (!this.doesMovePassLockedPositions(gridOrder)) {
        return false;
      }
      return true;
    }
    getProposedColumnOrder(columnsToMove, toIndex) {
      const proposedColumnOrder = this.gridColumns.slice();
      moveInArray(proposedColumnOrder, columnsToMove, toIndex);
      return proposedColumnOrder;
    }
    // returns the provided cols sorted in same order as they appear in grid columns. eg if grid columns
    // contains [a,b,c,d,e] and col passed is [e,a] then the passed cols are sorted into [a,e]
    sortColumnsLikeGridColumns(cols) {
      if (!cols || cols.length <= 1) {
        return;
      }
      const notAllColsInGridColumns = cols.filter((c) => this.gridColumns.indexOf(c) < 0).length > 0;
      if (notAllColsInGridColumns) {
        return;
      }
      cols.sort((a, b) => {
        const indexA = this.gridColumns.indexOf(a);
        const indexB = this.gridColumns.indexOf(b);
        return indexA - indexB;
      });
    }
    doesMovePassLockedPositions(proposedColumnOrder) {
      let lastPlacement = 0;
      let rulePassed = true;
      const lockPositionToPlacement = (position) => {
        if (!position) {
          return 1;
        }
        if (position === true) {
          return 0;
        }
        return position === "left" ? 0 : 2;
      };
      proposedColumnOrder.forEach((col) => {
        const placement = lockPositionToPlacement(col.getColDef().lockPosition);
        if (placement < lastPlacement) {
          rulePassed = false;
        }
        lastPlacement = placement;
      });
      return rulePassed;
    }
    doesMovePassMarryChildren(allColumnsCopy) {
      let rulePassed = true;
      depthFirstOriginalTreeSearch(null, this.gridBalancedTree, (child) => {
        if (!(child instanceof ProvidedColumnGroup)) {
          return;
        }
        const columnGroup = child;
        const colGroupDef = columnGroup.getColGroupDef();
        const marryChildren = colGroupDef && colGroupDef.marryChildren;
        if (!marryChildren) {
          return;
        }
        const newIndexes = [];
        columnGroup.getLeafColumns().forEach((col) => {
          const newColIndex = allColumnsCopy.indexOf(col);
          newIndexes.push(newColIndex);
        });
        const maxIndex = Math.max.apply(Math, newIndexes);
        const minIndex = Math.min.apply(Math, newIndexes);
        const spread = maxIndex - minIndex;
        const maxSpread = columnGroup.getLeafColumns().length - 1;
        if (spread > maxSpread) {
          rulePassed = false;
        }
      });
      return rulePassed;
    }
    moveColumnByIndex(fromIndex, toIndex, source) {
      if (!this.gridColumns) {
        return;
      }
      const column = this.gridColumns[fromIndex];
      this.moveColumns([column], toIndex, source);
    }
    getColumnDefs() {
      if (!this.primaryColumns) {
        return;
      }
      const cols = this.primaryColumns.slice();
      if (this.gridColsArePrimary) {
        cols.sort((a, b) => this.gridColumns.indexOf(a) - this.gridColumns.indexOf(b));
      } else if (this.lastPrimaryOrder) {
        cols.sort((a, b) => this.lastPrimaryOrder.indexOf(a) - this.lastPrimaryOrder.indexOf(b));
      }
      return this.columnDefFactory.buildColumnDefs(cols, this.rowGroupColumns, this.pivotColumns);
    }
    // used by:
    // + angularGrid -> for setting body width
    // + rowController -> setting main row widths (when inserting and resizing)
    // need to cache this
    getBodyContainerWidth() {
      return this.bodyWidth;
    }
    getContainerWidth(pinned) {
      switch (pinned) {
        case "left":
          return this.leftWidth;
        case "right":
          return this.rightWidth;
        default:
          return this.bodyWidth;
      }
    }
    // after setColumnWidth or updateGroupsAndDisplayedColumns
    updateBodyWidths() {
      const newBodyWidth = this.getWidthOfColsInList(this.displayedColumnsCenter);
      const newLeftWidth = this.getWidthOfColsInList(this.displayedColumnsLeft);
      const newRightWidth = this.getWidthOfColsInList(this.displayedColumnsRight);
      this.bodyWidthDirty = this.bodyWidth !== newBodyWidth;
      const atLeastOneChanged = this.bodyWidth !== newBodyWidth || this.leftWidth !== newLeftWidth || this.rightWidth !== newRightWidth;
      if (atLeastOneChanged) {
        this.bodyWidth = newBodyWidth;
        this.leftWidth = newLeftWidth;
        this.rightWidth = newRightWidth;
        const evt = {
          type: Events.EVENT_COLUMN_CONTAINER_WIDTH_CHANGED
        };
        this.eventService.dispatchEvent(evt);
        const event = {
          type: Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED
        };
        this.eventService.dispatchEvent(event);
      }
    }
    // + rowController
    getValueColumns() {
      return this.valueColumns ? this.valueColumns : [];
    }
    // + rowController
    getPivotColumns() {
      return this.pivotColumns ? this.pivotColumns : [];
    }
    // + clientSideRowModel
    isPivotActive() {
      return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;
    }
    // + toolPanel
    getRowGroupColumns() {
      return this.rowGroupColumns ? this.rowGroupColumns : [];
    }
    // + rowController -> while inserting rows
    getDisplayedCenterColumns() {
      return this.displayedColumnsCenter;
    }
    // + rowController -> while inserting rows
    getDisplayedLeftColumns() {
      return this.displayedColumnsLeft;
    }
    getDisplayedRightColumns() {
      return this.displayedColumnsRight;
    }
    // used by:
    // + clientSideRowController -> sorting, building quick filter text
    // + headerRenderer -> sorting (clearing icon)
    getAllPrimaryColumns() {
      return this.primaryColumns ? this.primaryColumns : null;
    }
    getSecondaryColumns() {
      return this.secondaryColumns ? this.secondaryColumns : null;
    }
    getAllColumnsForQuickFilter() {
      return this.columnsForQuickFilter;
    }
    // + moveColumnController
    getAllGridColumns() {
      var _a;
      return (_a = this.gridColumns) != null ? _a : [];
    }
    isRowGroupEmpty() {
      return missingOrEmpty(this.rowGroupColumns);
    }
    setColumnsVisible(keys2, visible = false, source) {
      this.applyColumnState({
        state: keys2.map(
          (key) => ({
            colId: typeof key === "string" ? key : key.getColId(),
            hide: !visible
          })
        )
      }, source);
    }
    setColumnsPinned(keys2, pinned, source) {
      if (!this.gridColumns) {
        return;
      }
      if (this.gos.isDomLayout("print")) {
        console.warn(`AG Grid: Changing the column pinning status is not allowed with domLayout='print'`);
        return;
      }
      this.columnAnimationService.start();
      let actualPinned;
      if (pinned === true || pinned === "left") {
        actualPinned = "left";
      } else if (pinned === "right") {
        actualPinned = "right";
      } else {
        actualPinned = null;
      }
      this.actionOnGridColumns(keys2, (col) => {
        if (col.getPinned() !== actualPinned) {
          col.setPinned(actualPinned);
          return true;
        }
        return false;
      }, source, () => {
        const event = {
          type: Events.EVENT_COLUMN_PINNED,
          pinned: actualPinned,
          column: null,
          columns: null,
          source
        };
        return event;
      });
      this.columnAnimationService.finish();
    }
    // does an action on a set of columns. provides common functionality for looking up the
    // columns based on key, getting a list of effected columns, and then updated the event
    // with either one column (if it was just one col) or a list of columns
    // used by: autoResize, setVisible, setPinned
    actionOnGridColumns(keys2, action, source, createEvent) {
      if (missingOrEmpty(keys2)) {
        return;
      }
      const updatedColumns = [];
      keys2.forEach((key) => {
        if (!key) {
          return;
        }
        const column = this.getGridColumn(key);
        if (!column) {
          return;
        }
        const resultOfAction = action(column);
        if (resultOfAction !== false) {
          updatedColumns.push(column);
        }
      });
      if (!updatedColumns.length) {
        return;
      }
      this.updateDisplayedColumns(source);
      if (exists(createEvent) && createEvent) {
        const event = createEvent();
        event.columns = updatedColumns;
        event.column = updatedColumns.length === 1 ? updatedColumns[0] : null;
        this.eventService.dispatchEvent(event);
      }
    }
    getDisplayedColBefore(col) {
      const allDisplayedColumns = this.getAllDisplayedColumns();
      const oldIndex = allDisplayedColumns.indexOf(col);
      if (oldIndex > 0) {
        return allDisplayedColumns[oldIndex - 1];
      }
      return null;
    }
    // used by:
    // + rowRenderer -> for navigation
    getDisplayedColAfter(col) {
      const allDisplayedColumns = this.getAllDisplayedColumns();
      const oldIndex = allDisplayedColumns.indexOf(col);
      if (oldIndex < allDisplayedColumns.length - 1) {
        return allDisplayedColumns[oldIndex + 1];
      }
      return null;
    }
    getDisplayedGroupAtDirection(columnGroup, direction) {
      const requiredLevel = columnGroup.getProvidedColumnGroup().getLevel() + columnGroup.getPaddingLevel();
      const colGroupLeafColumns = columnGroup.getDisplayedLeafColumns();
      const col = direction === "After" ? last(colGroupLeafColumns) : colGroupLeafColumns[0];
      const getDisplayColMethod = `getDisplayedCol${direction}`;
      while (true) {
        const column = this[getDisplayColMethod](col);
        if (!column) {
          return null;
        }
        const groupPointer = this.getColumnGroupAtLevel(column, requiredLevel);
        if (groupPointer !== columnGroup) {
          return groupPointer;
        }
      }
    }
    getColumnGroupAtLevel(column, level) {
      let groupPointer = column.getParent();
      let originalGroupLevel;
      let groupPointerLevel;
      while (true) {
        const groupPointerProvidedColumnGroup = groupPointer.getProvidedColumnGroup();
        originalGroupLevel = groupPointerProvidedColumnGroup.getLevel();
        groupPointerLevel = groupPointer.getPaddingLevel();
        if (originalGroupLevel + groupPointerLevel <= level) {
          break;
        }
        groupPointer = groupPointer.getParent();
      }
      return groupPointer;
    }
    isPinningLeft() {
      return this.displayedColumnsLeft.length > 0;
    }
    isPinningRight() {
      return this.displayedColumnsRight.length > 0;
    }
    getPrimaryAndSecondaryAndAutoColumns() {
      return [].concat(...[
        this.primaryColumns || [],
        this.groupAutoColumns || [],
        this.secondaryColumns || []
      ]);
    }
    createStateItemFromColumn(column) {
      const rowGroupIndex = column.isRowGroupActive() ? this.rowGroupColumns.indexOf(column) : null;
      const pivotIndex = column.isPivotActive() ? this.pivotColumns.indexOf(column) : null;
      const aggFunc = column.isValueActive() ? column.getAggFunc() : null;
      const sort = column.getSort() != null ? column.getSort() : null;
      const sortIndex = column.getSortIndex() != null ? column.getSortIndex() : null;
      const flex = column.getFlex() != null && column.getFlex() > 0 ? column.getFlex() : null;
      const res = {
        colId: column.getColId(),
        width: column.getActualWidth(),
        hide: !column.isVisible(),
        pinned: column.getPinned(),
        sort,
        sortIndex,
        aggFunc,
        rowGroup: column.isRowGroupActive(),
        rowGroupIndex,
        pivot: column.isPivotActive(),
        pivotIndex,
        flex
      };
      return res;
    }
    getColumnState() {
      if (missing(this.primaryColumns) || !this.isAlive()) {
        return [];
      }
      const colsForState = this.getPrimaryAndSecondaryAndAutoColumns();
      const res = colsForState.map(this.createStateItemFromColumn.bind(this));
      this.orderColumnStateList(res);
      return res;
    }
    orderColumnStateList(columnStateList) {
      const colIdToGridIndexMap = convertToMap(this.gridColumns.map((col, index) => [col.getColId(), index]));
      columnStateList.sort((itemA, itemB) => {
        const posA = colIdToGridIndexMap.has(itemA.colId) ? colIdToGridIndexMap.get(itemA.colId) : -1;
        const posB = colIdToGridIndexMap.has(itemB.colId) ? colIdToGridIndexMap.get(itemB.colId) : -1;
        return posA - posB;
      });
    }
    resetColumnState(source) {
      if (missingOrEmpty(this.primaryColumns)) {
        return;
      }
      const primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);
      const columnStates = [];
      let letRowGroupIndex = 1e3;
      let letPivotIndex = 1e3;
      let colsToProcess = [];
      if (this.groupAutoColumns) {
        colsToProcess = colsToProcess.concat(this.groupAutoColumns);
      }
      if (primaryColumns) {
        colsToProcess = colsToProcess.concat(primaryColumns);
      }
      colsToProcess.forEach((column) => {
        const stateItem = this.getColumnStateFromColDef(column);
        if (missing(stateItem.rowGroupIndex) && stateItem.rowGroup) {
          stateItem.rowGroupIndex = letRowGroupIndex++;
        }
        if (missing(stateItem.pivotIndex) && stateItem.pivot) {
          stateItem.pivotIndex = letPivotIndex++;
        }
        columnStates.push(stateItem);
      });
      this.applyColumnState({ state: columnStates, applyOrder: true }, source);
    }
    getColumnStateFromColDef(column) {
      const getValueOrNull = (a, b) => a != null ? a : b != null ? b : null;
      const colDef = column.getColDef();
      const sort = getValueOrNull(colDef.sort, colDef.initialSort);
      const sortIndex = getValueOrNull(colDef.sortIndex, colDef.initialSortIndex);
      const hide = getValueOrNull(colDef.hide, colDef.initialHide);
      const pinned = getValueOrNull(colDef.pinned, colDef.initialPinned);
      const width = getValueOrNull(colDef.width, colDef.initialWidth);
      const flex = getValueOrNull(colDef.flex, colDef.initialFlex);
      let rowGroupIndex = getValueOrNull(colDef.rowGroupIndex, colDef.initialRowGroupIndex);
      let rowGroup = getValueOrNull(colDef.rowGroup, colDef.initialRowGroup);
      if (rowGroupIndex == null && (rowGroup == null || rowGroup == false)) {
        rowGroupIndex = null;
        rowGroup = null;
      }
      let pivotIndex = getValueOrNull(colDef.pivotIndex, colDef.initialPivotIndex);
      let pivot = getValueOrNull(colDef.pivot, colDef.initialPivot);
      if (pivotIndex == null && (pivot == null || pivot == false)) {
        pivotIndex = null;
        pivot = null;
      }
      const aggFunc = getValueOrNull(colDef.aggFunc, colDef.initialAggFunc);
      return {
        colId: column.getColId(),
        sort,
        sortIndex,
        hide,
        pinned,
        width,
        flex,
        rowGroup,
        rowGroupIndex,
        pivot,
        pivotIndex,
        aggFunc
      };
    }
    applyColumnState(params, source) {
      if (missingOrEmpty(this.primaryColumns)) {
        return false;
      }
      if (params && params.state && !params.state.forEach) {
        console.warn("AG Grid: applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state.");
        return false;
      }
      const applyStates = (states, existingColumns, getById) => {
        const dispatchEventsFunc = this.compareColumnStatesAndDispatchEvents(source);
        this.autoGroupsNeedBuilding = true;
        const columnsWithNoState = existingColumns.slice();
        const rowGroupIndexes = {};
        const pivotIndexes = {};
        const autoGroupColumnStates = [];
        const unmatchedAndAutoStates2 = [];
        let unmatchedCount2 = 0;
        const previousRowGroupCols = this.rowGroupColumns.slice();
        const previousPivotCols = this.pivotColumns.slice();
        states.forEach((state) => {
          const colId = state.colId || "";
          const isAutoGroupColumn = colId.startsWith(GROUP_AUTO_COLUMN_ID);
          if (isAutoGroupColumn) {
            autoGroupColumnStates.push(state);
            unmatchedAndAutoStates2.push(state);
            return;
          }
          const column = getById(colId);
          if (!column) {
            unmatchedAndAutoStates2.push(state);
            unmatchedCount2 += 1;
          } else {
            this.syncColumnWithStateItem(
              column,
              state,
              params.defaultState,
              rowGroupIndexes,
              pivotIndexes,
              false,
              source
            );
            removeFromArray(columnsWithNoState, column);
          }
        });
        const applyDefaultsFunc = (col) => this.syncColumnWithStateItem(
          col,
          null,
          params.defaultState,
          rowGroupIndexes,
          pivotIndexes,
          false,
          source
        );
        columnsWithNoState.forEach(applyDefaultsFunc);
        const comparator2 = (indexes, oldList, colA, colB) => {
          const indexA = indexes[colA.getId()];
          const indexB = indexes[colB.getId()];
          const aHasIndex = indexA != null;
          const bHasIndex = indexB != null;
          if (aHasIndex && bHasIndex) {
            return indexA - indexB;
          }
          if (aHasIndex) {
            return -1;
          }
          if (bHasIndex) {
            return 1;
          }
          const oldIndexA = oldList.indexOf(colA);
          const oldIndexB = oldList.indexOf(colB);
          const aHasOldIndex = oldIndexA >= 0;
          const bHasOldIndex = oldIndexB >= 0;
          if (aHasOldIndex && bHasOldIndex) {
            return oldIndexA - oldIndexB;
          }
          if (aHasOldIndex) {
            return -1;
          }
          return 1;
        };
        this.rowGroupColumns.sort(comparator2.bind(this, rowGroupIndexes, previousRowGroupCols));
        this.pivotColumns.sort(comparator2.bind(this, pivotIndexes, previousPivotCols));
        this.updateGridColumns();
        const autoGroupColsCopy = this.groupAutoColumns ? this.groupAutoColumns.slice() : [];
        autoGroupColumnStates.forEach((stateItem) => {
          const autoCol = this.getAutoColumn(stateItem.colId);
          removeFromArray(autoGroupColsCopy, autoCol);
          this.syncColumnWithStateItem(autoCol, stateItem, params.defaultState, null, null, true, source);
        });
        autoGroupColsCopy.forEach(applyDefaultsFunc);
        this.applyOrderAfterApplyState(params);
        this.updateDisplayedColumns(source);
        this.dispatchEverythingChanged(source);
        dispatchEventsFunc();
        return { unmatchedAndAutoStates: unmatchedAndAutoStates2, unmatchedCount: unmatchedCount2 };
      };
      this.columnAnimationService.start();
      let {
        unmatchedAndAutoStates,
        unmatchedCount
      } = applyStates(params.state || [], this.primaryColumns || [], (id) => this.getPrimaryColumn(id));
      if (unmatchedAndAutoStates.length > 0 || exists(params.defaultState)) {
        unmatchedCount = applyStates(
          unmatchedAndAutoStates,
          this.secondaryColumns || [],
          (id) => this.getSecondaryColumn(id)
        ).unmatchedCount;
      }
      this.columnAnimationService.finish();
      return unmatchedCount === 0;
    }
    applyOrderAfterApplyState(params) {
      if (!params.applyOrder || !params.state) {
        return;
      }
      let newOrder = [];
      const processedColIds = {};
      params.state.forEach((item) => {
        if (!item.colId || processedColIds[item.colId]) {
          return;
        }
        const col = this.gridColumnsMap[item.colId];
        if (col) {
          newOrder.push(col);
          processedColIds[item.colId] = true;
        }
      });
      let autoGroupInsertIndex = 0;
      this.gridColumns.forEach((col) => {
        const colId = col.getColId();
        const alreadyProcessed = processedColIds[colId] != null;
        if (alreadyProcessed) {
          return;
        }
        const isAutoGroupCol = colId.startsWith(GROUP_AUTO_COLUMN_ID);
        if (isAutoGroupCol) {
          insertIntoArray(newOrder, col, autoGroupInsertIndex++);
        } else {
          newOrder.push(col);
        }
      });
      newOrder = this.placeLockedColumns(newOrder);
      if (!this.doesMovePassMarryChildren(newOrder)) {
        console.warn("AG Grid: Applying column order broke a group where columns should be married together. Applying new order has been discarded.");
        return;
      }
      this.gridColumns = newOrder;
    }
    compareColumnStatesAndDispatchEvents(source) {
      const startState = {
        rowGroupColumns: this.rowGroupColumns.slice(),
        pivotColumns: this.pivotColumns.slice(),
        valueColumns: this.valueColumns.slice()
      };
      const columnStateBefore = this.getColumnState();
      const columnStateBeforeMap = {};
      columnStateBefore.forEach((col) => {
        columnStateBeforeMap[col.colId] = col;
      });
      return () => {
        const colsForState = this.getPrimaryAndSecondaryAndAutoColumns();
        const dispatchWhenListsDifferent = (eventType, colsBefore, colsAfter, idMapper) => {
          const beforeList = colsBefore.map(idMapper);
          const afterList = colsAfter.map(idMapper);
          const unchanged = areEqual(beforeList, afterList);
          if (unchanged) {
            return;
          }
          const changes = new Set(colsBefore);
          colsAfter.forEach((id) => {
            if (!changes.delete(id)) {
              changes.add(id);
            }
          });
          const changesArr = [...changes];
          const event = {
            type: eventType,
            columns: changesArr,
            column: changesArr.length === 1 ? changesArr[0] : null,
            source
          };
          this.eventService.dispatchEvent(event);
        };
        const getChangedColumns = (changedPredicate) => {
          const changedColumns2 = [];
          colsForState.forEach((column) => {
            const colStateBefore = columnStateBeforeMap[column.getColId()];
            if (colStateBefore && changedPredicate(colStateBefore, column)) {
              changedColumns2.push(column);
            }
          });
          return changedColumns2;
        };
        const columnIdMapper = (c) => c.getColId();
        dispatchWhenListsDifferent(
          Events.EVENT_COLUMN_ROW_GROUP_CHANGED,
          startState.rowGroupColumns,
          this.rowGroupColumns,
          columnIdMapper
        );
        dispatchWhenListsDifferent(
          Events.EVENT_COLUMN_PIVOT_CHANGED,
          startState.pivotColumns,
          this.pivotColumns,
          columnIdMapper
        );
        const valueChangePredicate = (cs, c) => {
          const oldActive = cs.aggFunc != null;
          const activeChanged = oldActive != c.isValueActive();
          const aggFuncChanged = oldActive && cs.aggFunc != c.getAggFunc();
          return activeChanged || aggFuncChanged;
        };
        const changedValues = getChangedColumns(valueChangePredicate);
        if (changedValues.length > 0) {
          this.dispatchColumnChangedEvent(Events.EVENT_COLUMN_VALUE_CHANGED, changedValues, source);
        }
        const resizeChangePredicate = (cs, c) => cs.width != c.getActualWidth();
        this.dispatchColumnResizedEvent(getChangedColumns(resizeChangePredicate), true, source);
        const pinnedChangePredicate = (cs, c) => cs.pinned != c.getPinned();
        this.dispatchColumnPinnedEvent(getChangedColumns(pinnedChangePredicate), source);
        const visibilityChangePredicate = (cs, c) => cs.hide == c.isVisible();
        this.dispatchColumnVisibleEvent(getChangedColumns(visibilityChangePredicate), source);
        const sortChangePredicate = (cs, c) => cs.sort != c.getSort() || cs.sortIndex != c.getSortIndex();
        const changedColumns = getChangedColumns(sortChangePredicate);
        if (changedColumns.length > 0) {
          this.sortController.dispatchSortChangedEvents(source, changedColumns);
        }
        this.normaliseColumnMovedEventForColumnState(columnStateBefore, source);
      };
    }
    getCommonValue(cols, valueGetter) {
      if (!cols || cols.length == 0) {
        return void 0;
      }
      const firstValue = valueGetter(cols[0]);
      for (let i = 1; i < cols.length; i++) {
        if (firstValue !== valueGetter(cols[i])) {
          return void 0;
        }
      }
      return firstValue;
    }
    normaliseColumnMovedEventForColumnState(colStateBefore, source) {
      const colStateAfter = this.getColumnState();
      const colStateAfterMapped = {};
      colStateAfter.forEach((s) => colStateAfterMapped[s.colId] = s);
      const colsIntersectIds = {};
      colStateBefore.forEach((s) => {
        if (colStateAfterMapped[s.colId]) {
          colsIntersectIds[s.colId] = true;
        }
      });
      const beforeFiltered = colStateBefore.filter((c) => colsIntersectIds[c.colId]);
      const afterFiltered = colStateAfter.filter((c) => colsIntersectIds[c.colId]);
      const movedColumns = [];
      afterFiltered.forEach((csAfter, index) => {
        const csBefore = beforeFiltered && beforeFiltered[index];
        if (csBefore && csBefore.colId !== csAfter.colId) {
          const gridCol = this.getGridColumn(csBefore.colId);
          if (gridCol) {
            movedColumns.push(gridCol);
          }
        }
      });
      if (!movedColumns.length) {
        return;
      }
      this.dispatchColumnMovedEvent({ movedColumns, source, finished: true });
    }
    syncColumnWithStateItem(column, stateItem, defaultState, rowGroupIndexes, pivotIndexes, autoCol, source) {
      var _a;
      if (!column) {
        return;
      }
      const getValue2 = (key1, key2) => {
        const obj = { value1: void 0, value2: void 0 };
        let calculated = false;
        if (stateItem) {
          if (stateItem[key1] !== void 0) {
            obj.value1 = stateItem[key1];
            calculated = true;
          }
          if (exists(key2) && stateItem[key2] !== void 0) {
            obj.value2 = stateItem[key2];
            calculated = true;
          }
        }
        if (!calculated && defaultState) {
          if (defaultState[key1] !== void 0) {
            obj.value1 = defaultState[key1];
          }
          if (exists(key2) && defaultState[key2] !== void 0) {
            obj.value2 = defaultState[key2];
          }
        }
        return obj;
      };
      const hide = getValue2("hide").value1;
      if (hide !== void 0) {
        column.setVisible(!hide, source);
      }
      const pinned = getValue2("pinned").value1;
      if (pinned !== void 0) {
        column.setPinned(pinned);
      }
      const minColWidth = (_a = column.getColDef().minWidth) != null ? _a : this.environment.getMinColWidth();
      const flex = getValue2("flex").value1;
      if (flex !== void 0) {
        column.setFlex(flex);
      }
      if (flex == null) {
        const width = getValue2("width").value1;
        if (width != null) {
          if (minColWidth != null && width >= minColWidth) {
            column.setActualWidth(width, source);
          }
        }
      }
      const sort = getValue2("sort").value1;
      if (sort !== void 0) {
        if (sort === "desc" || sort === "asc") {
          column.setSort(sort, source);
        } else {
          column.setSort(void 0, source);
        }
      }
      const sortIndex = getValue2("sortIndex").value1;
      if (sortIndex !== void 0) {
        column.setSortIndex(sortIndex);
      }
      if (autoCol || !column.isPrimary()) {
        return;
      }
      const aggFunc = getValue2("aggFunc").value1;
      if (aggFunc !== void 0) {
        if (typeof aggFunc === "string") {
          column.setAggFunc(aggFunc);
          if (!column.isValueActive()) {
            column.setValueActive(true, source);
            this.valueColumns.push(column);
          }
        } else {
          if (exists(aggFunc)) {
            console.warn("AG Grid: stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON.");
          }
          if (column.isValueActive()) {
            column.setValueActive(false, source);
            removeFromArray(this.valueColumns, column);
          }
        }
      }
      const { value1: rowGroup, value2: rowGroupIndex } = getValue2("rowGroup", "rowGroupIndex");
      if (rowGroup !== void 0 || rowGroupIndex !== void 0) {
        if (typeof rowGroupIndex === "number" || rowGroup) {
          if (!column.isRowGroupActive()) {
            column.setRowGroupActive(true, source);
            this.rowGroupColumns.push(column);
          }
          if (rowGroupIndexes && typeof rowGroupIndex === "number") {
            rowGroupIndexes[column.getId()] = rowGroupIndex;
          }
        } else {
          if (column.isRowGroupActive()) {
            column.setRowGroupActive(false, source);
            removeFromArray(this.rowGroupColumns, column);
          }
        }
      }
      const { value1: pivot, value2: pivotIndex } = getValue2("pivot", "pivotIndex");
      if (pivot !== void 0 || pivotIndex !== void 0) {
        if (typeof pivotIndex === "number" || pivot) {
          if (!column.isPivotActive()) {
            column.setPivotActive(true, source);
            this.pivotColumns.push(column);
          }
          if (pivotIndexes && typeof pivotIndex === "number") {
            pivotIndexes[column.getId()] = pivotIndex;
          }
        } else {
          if (column.isPivotActive()) {
            column.setPivotActive(false, source);
            removeFromArray(this.pivotColumns, column);
          }
        }
      }
    }
    getGridColumns(keys2) {
      return this.getColumns(keys2, this.getGridColumn.bind(this));
    }
    getColumns(keys2, columnLookupCallback) {
      const foundColumns = [];
      if (keys2) {
        keys2.forEach((key) => {
          const column = columnLookupCallback(key);
          if (column) {
            foundColumns.push(column);
          }
        });
      }
      return foundColumns;
    }
    // used by growGroupPanel
    getColumnWithValidation(key) {
      if (key == null) {
        return null;
      }
      const column = this.getGridColumn(key);
      if (!column) {
        console.warn("AG Grid: could not find column " + key);
      }
      return column;
    }
    getPrimaryColumn(key) {
      if (!this.primaryColumns) {
        return null;
      }
      return this.getColumn(key, this.primaryColumns, this.primaryColumnsMap);
    }
    getGridColumn(key) {
      return this.getColumn(key, this.gridColumns, this.gridColumnsMap);
    }
    lookupGridColumn(key) {
      return this.gridColumnsMap[key];
    }
    getSecondaryColumn(key) {
      if (!this.secondaryColumns) {
        return null;
      }
      return this.getColumn(key, this.secondaryColumns, this.secondaryColumnsMap);
    }
    getColumn(key, columnList, columnMap) {
      if (!key || !columnMap) {
        return null;
      }
      if (typeof key == "string" && columnMap[key]) {
        return columnMap[key];
      }
      for (let i = 0; i < columnList.length; i++) {
        if (this.columnsMatch(columnList[i], key)) {
          return columnList[i];
        }
      }
      return this.getAutoColumn(key);
    }
    getSourceColumnsForGroupColumn(groupCol) {
      const sourceColumnId = groupCol.getColDef().showRowGroup;
      if (!sourceColumnId) {
        return null;
      }
      if (sourceColumnId === true) {
        return this.rowGroupColumns.slice(0);
      }
      const column = this.getPrimaryColumn(sourceColumnId);
      return column ? [column] : null;
    }
    getAutoColumn(key) {
      if (!this.groupAutoColumns || !exists(this.groupAutoColumns) || missing(this.groupAutoColumns)) {
        return null;
      }
      return this.groupAutoColumns.find((groupCol) => this.columnsMatch(groupCol, key)) || null;
    }
    columnsMatch(column, key) {
      const columnMatches = column === key;
      const colDefMatches = column.getColDef() === key;
      const idMatches = column.getColId() == key;
      return columnMatches || colDefMatches || idMatches;
    }
    getDisplayNameForColumn(column, location2, includeAggFunc = false) {
      if (!column) {
        return null;
      }
      const headerName = this.getHeaderName(column.getColDef(), column, null, null, location2);
      if (includeAggFunc) {
        return this.wrapHeaderNameWithAggFunc(column, headerName);
      }
      return headerName;
    }
    getDisplayNameForProvidedColumnGroup(columnGroup, providedColumnGroup, location2) {
      const colGroupDef = providedColumnGroup ? providedColumnGroup.getColGroupDef() : null;
      if (colGroupDef) {
        return this.getHeaderName(colGroupDef, null, columnGroup, providedColumnGroup, location2);
      }
      return null;
    }
    getDisplayNameForColumnGroup(columnGroup, location2) {
      return this.getDisplayNameForProvidedColumnGroup(columnGroup, columnGroup.getProvidedColumnGroup(), location2);
    }
    // location is where the column is going to appear, ie who is calling us
    getHeaderName(colDef, column, columnGroup, providedColumnGroup, location2) {
      const headerValueGetter = colDef.headerValueGetter;
      if (headerValueGetter) {
        const params = this.gos.addGridCommonParams({
          colDef,
          column,
          columnGroup,
          providedColumnGroup,
          location: location2
        });
        if (typeof headerValueGetter === "function") {
          return headerValueGetter(params);
        } else if (typeof headerValueGetter === "string") {
          return this.expressionService.evaluate(headerValueGetter, params);
        }
        console.warn("AG Grid: headerValueGetter must be a function or a string");
        return "";
      } else if (colDef.headerName != null) {
        return colDef.headerName;
      } else if (colDef.field) {
        return camelCaseToHumanText(colDef.field);
      }
      return "";
    }
    wrapHeaderNameWithAggFunc(column, headerName) {
      if (this.gos.get("suppressAggFuncInHeader")) {
        return headerName;
      }
      const pivotValueColumn = column.getColDef().pivotValueColumn;
      const pivotActiveOnThisColumn = exists(pivotValueColumn);
      let aggFunc = null;
      let aggFuncFound;
      if (pivotActiveOnThisColumn) {
        const isCollapsedHeaderEnabled = this.gos.get("removePivotHeaderRowWhenSingleValueColumn") && this.valueColumns.length === 1;
        const isTotalColumn = column.getColDef().pivotTotalColumnIds !== void 0;
        if (isCollapsedHeaderEnabled && !isTotalColumn) {
          return headerName;
        }
        aggFunc = pivotValueColumn ? pivotValueColumn.getAggFunc() : null;
        aggFuncFound = true;
      } else {
        const measureActive = column.isValueActive();
        const aggregationPresent = this.pivotMode || !this.isRowGroupEmpty();
        if (measureActive && aggregationPresent) {
          aggFunc = column.getAggFunc();
          aggFuncFound = true;
        } else {
          aggFuncFound = false;
        }
      }
      if (aggFuncFound) {
        const aggFuncString = typeof aggFunc === "string" ? aggFunc : "func";
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);
        return `${aggFuncStringTranslated}(${headerName})`;
      }
      return headerName;
    }
    // returns the group with matching colId and instanceId. If instanceId is missing,
    // matches only on the colId.
    getColumnGroup(colId, partId) {
      if (!colId) {
        return null;
      }
      if (colId instanceof ColumnGroup) {
        return colId;
      }
      const allColumnGroups = this.getAllDisplayedTrees();
      const checkPartId = typeof partId === "number";
      let result = null;
      depthFirstAllColumnTreeSearch(allColumnGroups, false, (child) => {
        if (child instanceof ColumnGroup) {
          const columnGroup = child;
          let matched;
          if (checkPartId) {
            matched = colId === columnGroup.getGroupId() && partId === columnGroup.getPartId();
          } else {
            matched = colId === columnGroup.getGroupId();
          }
          if (matched) {
            result = columnGroup;
          }
        }
      });
      return result;
    }
    isReady() {
      return this.ready;
    }
    extractValueColumns(source, oldPrimaryColumns) {
      this.valueColumns = this.extractColumns(
        oldPrimaryColumns,
        this.valueColumns,
        (col, flag) => col.setValueActive(flag, source),
        // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null
        () => void 0,
        () => void 0,
        // aggFunc is a string, so return it's existence
        (colDef) => {
          const aggFunc = colDef.aggFunc;
          if (aggFunc === null || aggFunc === "") {
            return null;
          }
          if (aggFunc === void 0) {
            return;
          }
          return !!aggFunc;
        },
        (colDef) => {
          return colDef.initialAggFunc != null && colDef.initialAggFunc != "";
        }
      );
      this.valueColumns.forEach((col) => {
        const colDef = col.getColDef();
        if (colDef.aggFunc != null && colDef.aggFunc != "") {
          col.setAggFunc(colDef.aggFunc);
        } else {
          if (!col.getAggFunc()) {
            col.setAggFunc(colDef.initialAggFunc);
          }
        }
      });
    }
    extractRowGroupColumns(source, oldPrimaryColumns) {
      this.rowGroupColumns = this.extractColumns(
        oldPrimaryColumns,
        this.rowGroupColumns,
        (col, flag) => col.setRowGroupActive(flag, source),
        (colDef) => colDef.rowGroupIndex,
        (colDef) => colDef.initialRowGroupIndex,
        (colDef) => colDef.rowGroup,
        (colDef) => colDef.initialRowGroup
      );
    }
    extractColumns(oldPrimaryColumns = [], previousCols = [], setFlagFunc, getIndexFunc, getInitialIndexFunc, getValueFunc, getInitialValueFunc) {
      const colsWithIndex = [];
      const colsWithValue = [];
      (this.primaryColumns || []).forEach((col) => {
        const colIsNew = oldPrimaryColumns.indexOf(col) < 0;
        const colDef = col.getColDef();
        const value = attrToBoolean(getValueFunc(colDef));
        const initialValue = attrToBoolean(getInitialValueFunc(colDef));
        const index = attrToNumber(getIndexFunc(colDef));
        const initialIndex = attrToNumber(getInitialIndexFunc(colDef));
        let include;
        const valuePresent = value !== void 0;
        const indexPresent = index !== void 0;
        const initialValuePresent = initialValue !== void 0;
        const initialIndexPresent = initialIndex !== void 0;
        if (valuePresent) {
          include = value;
        } else if (indexPresent) {
          if (index === null) {
            include = false;
          } else {
            include = index >= 0;
          }
        } else {
          if (colIsNew) {
            if (initialValuePresent) {
              include = initialValue;
            } else if (initialIndexPresent) {
              include = initialIndex != null && initialIndex >= 0;
            } else {
              include = false;
            }
          } else {
            include = previousCols.indexOf(col) >= 0;
          }
        }
        if (include) {
          const useIndex = colIsNew ? index != null || initialIndex != null : index != null;
          useIndex ? colsWithIndex.push(col) : colsWithValue.push(col);
        }
      });
      const getIndexForCol = (col) => {
        const index = getIndexFunc(col.getColDef());
        const defaultIndex = getInitialIndexFunc(col.getColDef());
        return index != null ? index : defaultIndex;
      };
      colsWithIndex.sort((colA, colB) => {
        const indexA = getIndexForCol(colA);
        const indexB = getIndexForCol(colB);
        if (indexA === indexB) {
          return 0;
        }
        if (indexA < indexB) {
          return -1;
        }
        return 1;
      });
      const res = [].concat(colsWithIndex);
      previousCols.forEach((col) => {
        if (colsWithValue.indexOf(col) >= 0) {
          res.push(col);
        }
      });
      colsWithValue.forEach((col) => {
        if (res.indexOf(col) < 0) {
          res.push(col);
        }
      });
      previousCols.forEach((col) => {
        if (res.indexOf(col) < 0) {
          setFlagFunc(col, false);
        }
      });
      res.forEach((col) => {
        if (previousCols.indexOf(col) < 0) {
          setFlagFunc(col, true);
        }
      });
      return res;
    }
    extractPivotColumns(source, oldPrimaryColumns) {
      this.pivotColumns = this.extractColumns(
        oldPrimaryColumns,
        this.pivotColumns,
        (col, flag) => col.setPivotActive(flag, source),
        (colDef) => colDef.pivotIndex,
        (colDef) => colDef.initialPivotIndex,
        (colDef) => colDef.pivot,
        (colDef) => colDef.initialPivot
      );
    }
    resetColumnGroupState(source) {
      if (!this.primaryColumnTree) {
        return;
      }
      const stateItems = [];
      depthFirstOriginalTreeSearch(null, this.primaryColumnTree, (child) => {
        if (child instanceof ProvidedColumnGroup) {
          const colGroupDef = child.getColGroupDef();
          const groupState = {
            groupId: child.getGroupId(),
            open: !colGroupDef ? void 0 : colGroupDef.openByDefault
          };
          stateItems.push(groupState);
        }
      });
      this.setColumnGroupState(stateItems, source);
    }
    getColumnGroupState() {
      const columnGroupState = [];
      depthFirstOriginalTreeSearch(null, this.gridBalancedTree, (node) => {
        if (node instanceof ProvidedColumnGroup) {
          columnGroupState.push({
            groupId: node.getGroupId(),
            open: node.isExpanded()
          });
        }
      });
      return columnGroupState;
    }
    setColumnGroupState(stateItems, source) {
      if (!this.gridBalancedTree) {
        return;
      }
      this.columnAnimationService.start();
      const impactedGroups = [];
      stateItems.forEach((stateItem) => {
        const groupKey = stateItem.groupId;
        const newValue = stateItem.open;
        const providedColumnGroup = this.getProvidedColumnGroup(groupKey);
        if (!providedColumnGroup) {
          return;
        }
        if (providedColumnGroup.isExpanded() === newValue) {
          return;
        }
        this.logger.log("columnGroupOpened(" + providedColumnGroup.getGroupId() + "," + newValue + ")");
        providedColumnGroup.setExpanded(newValue);
        impactedGroups.push(providedColumnGroup);
      });
      this.updateGroupsAndDisplayedColumns(source);
      this.setFirstRightAndLastLeftPinned(source);
      if (impactedGroups.length) {
        const event = {
          type: Events.EVENT_COLUMN_GROUP_OPENED,
          columnGroup: ProvidedColumnGroup.length === 1 ? impactedGroups[0] : void 0,
          columnGroups: impactedGroups
        };
        this.eventService.dispatchEvent(event);
      }
      this.columnAnimationService.finish();
    }
    // called by headerRenderer - when a header is opened or closed
    setColumnGroupOpened(key, newValue, source) {
      let keyAsString;
      if (key instanceof ProvidedColumnGroup) {
        keyAsString = key.getId();
      } else {
        keyAsString = key || "";
      }
      this.setColumnGroupState([{ groupId: keyAsString, open: newValue }], source);
    }
    getProvidedColumnGroup(key) {
      if (typeof key !== "string") {
        console.error("AG Grid: group key must be a string");
      }
      let res = null;
      depthFirstOriginalTreeSearch(null, this.gridBalancedTree, (node) => {
        if (node instanceof ProvidedColumnGroup) {
          if (node.getId() === key) {
            res = node;
          }
        }
      });
      return res;
    }
    calculateColumnsForDisplay() {
      let columnsForDisplay;
      if (this.pivotMode && missing(this.secondaryColumns)) {
        columnsForDisplay = this.gridColumns.filter((column) => {
          const isAutoGroupCol = this.groupAutoColumns && includes(this.groupAutoColumns, column);
          const isValueCol = this.valueColumns && includes(this.valueColumns, column);
          return isAutoGroupCol || isValueCol;
        });
      } else {
        columnsForDisplay = this.gridColumns.filter((column) => {
          const isAutoGroupCol = this.groupAutoColumns && includes(this.groupAutoColumns, column);
          return isAutoGroupCol || column.isVisible();
        });
      }
      return columnsForDisplay;
    }
    checkColSpanActiveInCols(columns) {
      let result = false;
      columns.forEach((col) => {
        if (exists(col.getColDef().colSpan)) {
          result = true;
        }
      });
      return result;
    }
    calculateColumnsForGroupDisplay() {
      this.groupDisplayColumns = [];
      this.groupDisplayColumnsMap = {};
      const checkFunc = (col) => {
        const colDef = col.getColDef();
        const underlyingColumn = colDef.showRowGroup;
        if (colDef && exists(underlyingColumn)) {
          this.groupDisplayColumns.push(col);
          if (typeof underlyingColumn === "string") {
            this.groupDisplayColumnsMap[underlyingColumn] = col;
          } else if (underlyingColumn === true) {
            this.getRowGroupColumns().forEach((rowGroupCol) => {
              this.groupDisplayColumnsMap[rowGroupCol.getId()] = col;
            });
          }
        }
      };
      this.gridColumns.forEach(checkFunc);
    }
    getGroupDisplayColumns() {
      return this.groupDisplayColumns;
    }
    getGroupDisplayColumnForGroup(rowGroupColumnId) {
      return this.groupDisplayColumnsMap[rowGroupColumnId];
    }
    updateDisplayedColumns(source) {
      const columnsForDisplay = this.calculateColumnsForDisplay();
      this.buildDisplayedTrees(columnsForDisplay);
      this.updateGroupsAndDisplayedColumns(source);
      this.setFirstRightAndLastLeftPinned(source);
    }
    isSecondaryColumnsPresent() {
      return exists(this.secondaryColumns);
    }
    setSecondaryColumns(colDefs, source) {
      if (!this.gridColumns) {
        return;
      }
      const newColsPresent = colDefs;
      if (!newColsPresent && missing(this.secondaryColumns)) {
        return;
      }
      if (newColsPresent) {
        this.processSecondaryColumnDefinitions(colDefs);
        const balancedTreeResult = this.columnFactory.createColumnTree(
          colDefs,
          false,
          this.secondaryBalancedTree || this.previousSecondaryColumns || void 0,
          source
        );
        this.destroyOldColumns(this.secondaryBalancedTree, balancedTreeResult.columnTree);
        this.secondaryBalancedTree = balancedTreeResult.columnTree;
        this.secondaryHeaderRowCount = balancedTreeResult.treeDept + 1;
        this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree);
        this.secondaryColumnsMap = {};
        this.secondaryColumns.forEach((col) => this.secondaryColumnsMap[col.getId()] = col);
        this.previousSecondaryColumns = null;
      } else {
        this.previousSecondaryColumns = this.secondaryBalancedTree;
        this.secondaryBalancedTree = null;
        this.secondaryHeaderRowCount = -1;
        this.secondaryColumns = null;
        this.secondaryColumnsMap = {};
      }
      this.updateGridColumns();
      this.updateDisplayedColumns(source);
    }
    processSecondaryColumnDefinitions(colDefs) {
      const columnCallback = this.gos.get("processPivotResultColDef");
      const groupCallback = this.gos.get("processPivotResultColGroupDef");
      if (!columnCallback && !groupCallback) {
        return void 0;
      }
      const searchForColDefs = (colDefs2) => {
        colDefs2.forEach((abstractColDef) => {
          const isGroup = exists(abstractColDef.children);
          if (isGroup) {
            const colGroupDef = abstractColDef;
            if (groupCallback) {
              groupCallback(colGroupDef);
            }
            searchForColDefs(colGroupDef.children);
          } else {
            const colDef = abstractColDef;
            if (columnCallback) {
              columnCallback(colDef);
            }
          }
        });
      };
      if (colDefs) {
        searchForColDefs(colDefs);
      }
    }
    // called from: applyColumnState, setColumnDefs, setSecondaryColumns
    updateGridColumns() {
      const prevGridCols = this.gridBalancedTree;
      if (this.gridColsArePrimary) {
        this.lastPrimaryOrder = this.gridColumns;
      } else {
        this.lastSecondaryOrder = this.gridColumns;
      }
      const areAutoColsChanged = this.createGroupAutoColumnsIfNeeded();
      if (areAutoColsChanged) {
        const groupAutoColsMap = convertToMap(this.groupAutoColumns.map((col) => [col, true]));
        if (this.lastPrimaryOrder) {
          this.lastPrimaryOrder = this.lastPrimaryOrder.filter((col) => !groupAutoColsMap.has(col));
          this.lastPrimaryOrder = [...this.groupAutoColumns, ...this.lastPrimaryOrder];
        }
        if (this.lastSecondaryOrder) {
          this.lastSecondaryOrder = this.lastSecondaryOrder.filter((col) => !groupAutoColsMap.has(col));
          this.lastSecondaryOrder = [...this.groupAutoColumns, ...this.lastSecondaryOrder];
        }
      }
      let sortOrderToRecover;
      if (this.secondaryColumns && this.secondaryBalancedTree) {
        const hasSameColumns = this.secondaryColumns.some((col) => {
          return this.gridColumnsMap[col.getColId()] !== void 0;
        });
        this.gridBalancedTree = this.secondaryBalancedTree.slice();
        this.gridHeaderRowCount = this.secondaryHeaderRowCount;
        this.gridColumns = this.secondaryColumns.slice();
        this.gridColsArePrimary = false;
        if (hasSameColumns) {
          sortOrderToRecover = this.lastSecondaryOrder;
        }
      } else if (this.primaryColumns) {
        this.gridBalancedTree = this.primaryColumnTree.slice();
        this.gridHeaderRowCount = this.primaryHeaderRowCount;
        this.gridColumns = this.primaryColumns.slice();
        this.gridColsArePrimary = true;
        sortOrderToRecover = this.lastPrimaryOrder;
      }
      this.addAutoGroupToGridColumns();
      this.orderGridColsLike(sortOrderToRecover);
      this.gridColumns = this.placeLockedColumns(this.gridColumns);
      this.calculateColumnsForGroupDisplay();
      this.refreshQuickFilterColumns();
      this.clearDisplayedAndViewportColumns();
      this.colSpanActive = this.checkColSpanActiveInCols(this.gridColumns);
      this.gridColumnsMap = {};
      this.gridColumns.forEach((col) => this.gridColumnsMap[col.getId()] = col);
      this.setAutoHeightActive();
      if (!areEqual(prevGridCols, this.gridBalancedTree)) {
        const event = {
          type: Events.EVENT_GRID_COLUMNS_CHANGED
        };
        this.eventService.dispatchEvent(event);
      }
    }
    setAutoHeightActive() {
      this.autoHeightActive = this.gridColumns.filter((col) => col.isAutoHeight()).length > 0;
      if (this.autoHeightActive) {
        this.autoHeightActiveAtLeastOnce = true;
        const supportedRowModel = this.gos.isRowModelType("clientSide") || this.gos.isRowModelType("serverSide");
        if (!supportedRowModel) {
          warnOnce("autoHeight columns only work with Client Side Row Model and Server Side Row Model.");
        }
      }
    }
    orderGridColsLike(colsOrder) {
      if (missing(colsOrder)) {
        return;
      }
      const lastOrderMapped = convertToMap(colsOrder.map((col, index) => [col, index]));
      let noColsFound = true;
      this.gridColumns.forEach((col) => {
        if (lastOrderMapped.has(col)) {
          noColsFound = false;
        }
      });
      if (noColsFound) {
        return;
      }
      const gridColsMap = convertToMap(this.gridColumns.map((col) => [col, true]));
      const oldColsOrdered = colsOrder.filter((col) => gridColsMap.has(col));
      const oldColsMap = convertToMap(oldColsOrdered.map((col) => [col, true]));
      const newColsOrdered = this.gridColumns.filter((col) => !oldColsMap.has(col));
      const newGridColumns = oldColsOrdered.slice();
      newColsOrdered.forEach((newCol) => {
        let parent = newCol.getOriginalParent();
        if (!parent) {
          newGridColumns.push(newCol);
          return;
        }
        const siblings = [];
        while (!siblings.length && parent) {
          const leafCols = parent.getLeafColumns();
          leafCols.forEach((leafCol) => {
            const presentInNewGriColumns = newGridColumns.indexOf(leafCol) >= 0;
            const noYetInSiblings = siblings.indexOf(leafCol) < 0;
            if (presentInNewGriColumns && noYetInSiblings) {
              siblings.push(leafCol);
            }
          });
          parent = parent.getOriginalParent();
        }
        if (!siblings.length) {
          newGridColumns.push(newCol);
          return;
        }
        const indexes = siblings.map((col) => newGridColumns.indexOf(col));
        const lastIndex = Math.max(...indexes);
        insertIntoArray(newGridColumns, newCol, lastIndex + 1);
      });
      this.gridColumns = newGridColumns;
    }
    isPrimaryColumnGroupsPresent() {
      return this.primaryHeaderRowCount > 1;
    }
    // if we are using autoGroupCols, then they should be included for quick filter. this covers the
    // following scenarios:
    // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on
    // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this
    //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)
    refreshQuickFilterColumns() {
      var _a;
      let columnsForQuickFilter = (_a = this.isPivotMode() && !this.gos.get("applyQuickFilterBeforePivotOrAgg") ? this.secondaryColumns : this.primaryColumns) != null ? _a : [];
      if (this.groupAutoColumns) {
        columnsForQuickFilter = columnsForQuickFilter.concat(this.groupAutoColumns);
      }
      this.columnsForQuickFilter = this.gos.get("includeHiddenColumnsInQuickFilter") ? columnsForQuickFilter : columnsForQuickFilter.filter((col) => col.isVisible() || col.isRowGroupActive());
    }
    placeLockedColumns(cols) {
      const left = [];
      const normal = [];
      const right = [];
      cols.forEach((col) => {
        const position = col.getColDef().lockPosition;
        if (position === "right") {
          right.push(col);
        } else if (position === "left" || position === true) {
          left.push(col);
        } else {
          normal.push(col);
        }
      });
      return [...left, ...normal, ...right];
    }
    addAutoGroupToGridColumns() {
      if (missing(this.groupAutoColumns)) {
        this.destroyOldColumns(this.groupAutoColsBalancedTree);
        this.groupAutoColsBalancedTree = null;
        return;
      }
      this.gridColumns = this.groupAutoColumns ? this.groupAutoColumns.concat(this.gridColumns) : this.gridColumns;
      const newAutoColsTree = this.columnFactory.createForAutoGroups(this.groupAutoColumns, this.gridBalancedTree);
      this.destroyOldColumns(this.groupAutoColsBalancedTree, newAutoColsTree);
      this.groupAutoColsBalancedTree = newAutoColsTree;
      this.gridBalancedTree = newAutoColsTree.concat(this.gridBalancedTree);
    }
    // gets called after we copy down grid columns, to make sure any part of the gui
    // that tries to draw, eg the header, it will get empty lists of columns rather
    // than stale columns. for example, the header will received gridColumnsChanged
    // event, so will try and draw, but it will draw successfully when it acts on the
    // virtualColumnsChanged event
    clearDisplayedAndViewportColumns() {
      this.viewportRowLeft = {};
      this.viewportRowRight = {};
      this.viewportRowCenter = {};
      this.displayedColumnsLeft = [];
      this.displayedColumnsRight = [];
      this.displayedColumnsCenter = [];
      this.displayedColumns = [];
      this.ariaOrderColumns = [];
      this.viewportColumns = [];
      this.headerViewportColumns = [];
      this.viewportColumnsHash = "";
    }
    updateGroupsAndDisplayedColumns(source) {
      this.updateOpenClosedVisibilityInColumnGroups();
      this.deriveDisplayedColumns(source);
      this.refreshFlexedColumns();
      this.extractViewport();
      this.updateBodyWidths();
      const event = {
        type: Events.EVENT_DISPLAYED_COLUMNS_CHANGED
      };
      this.eventService.dispatchEvent(event);
    }
    deriveDisplayedColumns(source) {
      this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeLeft, this.displayedColumnsLeft);
      this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeCentre, this.displayedColumnsCenter);
      this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeRight, this.displayedColumnsRight);
      this.joinColumnsAriaOrder();
      this.joinDisplayedColumns();
      this.setLeftValues(source);
      this.displayedAutoHeightCols = this.displayedColumns.filter((col) => col.isAutoHeight());
    }
    isAutoRowHeightActive() {
      return this.autoHeightActive;
    }
    wasAutoRowHeightEverActive() {
      return this.autoHeightActiveAtLeastOnce;
    }
    joinColumnsAriaOrder() {
      const allColumns = this.getAllGridColumns();
      const pinnedLeft = [];
      const center = [];
      const pinnedRight = [];
      for (const col of allColumns) {
        const pinned = col.getPinned();
        if (!pinned) {
          center.push(col);
        } else if (pinned === true || pinned === "left") {
          pinnedLeft.push(col);
        } else {
          pinnedRight.push(col);
        }
      }
      this.ariaOrderColumns = pinnedLeft.concat(center).concat(pinnedRight);
    }
    joinDisplayedColumns() {
      if (this.gos.get("enableRtl")) {
        this.displayedColumns = this.displayedColumnsRight.concat(this.displayedColumnsCenter).concat(this.displayedColumnsLeft);
      } else {
        this.displayedColumns = this.displayedColumnsLeft.concat(this.displayedColumnsCenter).concat(this.displayedColumnsRight);
      }
    }
    // sets the left pixel position of each column
    setLeftValues(source) {
      this.setLeftValuesOfColumns(source);
      this.setLeftValuesOfGroups();
    }
    setLeftValuesOfColumns(source) {
      if (!this.primaryColumns) {
        return;
      }
      const allColumns = this.getPrimaryAndSecondaryAndAutoColumns().slice(0);
      const doingRtl = this.gos.get("enableRtl");
      [
        this.displayedColumnsLeft,
        this.displayedColumnsRight,
        this.displayedColumnsCenter
      ].forEach((columns) => {
        if (doingRtl) {
          let left = this.getWidthOfColsInList(columns);
          columns.forEach((column) => {
            left -= column.getActualWidth();
            column.setLeft(left, source);
          });
        } else {
          let left = 0;
          columns.forEach((column) => {
            column.setLeft(left, source);
            left += column.getActualWidth();
          });
        }
        removeAllFromUnorderedArray(allColumns, columns);
      });
      allColumns.forEach((column) => {
        column.setLeft(null, source);
      });
    }
    setLeftValuesOfGroups() {
      [
        this.displayedTreeLeft,
        this.displayedTreeRight,
        this.displayedTreeCentre
      ].forEach((columns) => {
        columns.forEach((column) => {
          if (column instanceof ColumnGroup) {
            const columnGroup = column;
            columnGroup.checkLeft();
          }
        });
      });
    }
    derivedDisplayedColumnsFromDisplayedTree(tree, columns) {
      columns.length = 0;
      depthFirstAllColumnTreeSearch(tree, true, (child) => {
        if (child instanceof Column) {
          columns.push(child);
        }
      });
    }
    isColumnVirtualisationSuppressed() {
      return this.suppressColumnVirtualisation || this.viewportRight === 0;
    }
    extractViewportColumns() {
      if (this.isColumnVirtualisationSuppressed()) {
        this.viewportColumnsCenter = this.displayedColumnsCenter;
        this.headerViewportColumnsCenter = this.displayedColumnsCenter;
      } else {
        this.viewportColumnsCenter = this.displayedColumnsCenter.filter(this.isColumnInRowViewport.bind(this));
        this.headerViewportColumnsCenter = this.displayedColumnsCenter.filter(this.isColumnInHeaderViewport.bind(this));
      }
      this.viewportColumns = this.viewportColumnsCenter.concat(this.displayedColumnsLeft).concat(this.displayedColumnsRight);
      this.headerViewportColumns = this.headerViewportColumnsCenter.concat(this.displayedColumnsLeft).concat(this.displayedColumnsRight);
    }
    getVirtualHeaderGroupRow(type, dept) {
      let result;
      switch (type) {
        case "left":
          result = this.viewportRowLeft[dept];
          break;
        case "right":
          result = this.viewportRowRight[dept];
          break;
        default:
          result = this.viewportRowCenter[dept];
          break;
      }
      if (missing(result)) {
        result = [];
      }
      return result;
    }
    calculateHeaderRows() {
      this.viewportRowLeft = {};
      this.viewportRowRight = {};
      this.viewportRowCenter = {};
      const virtualColIds = {};
      this.headerViewportColumns.forEach((col) => virtualColIds[col.getId()] = true);
      const testGroup = (children, result, dept) => {
        let returnValue = false;
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          let addThisItem = false;
          if (child instanceof Column) {
            addThisItem = virtualColIds[child.getId()] === true;
          } else {
            const columnGroup = child;
            const displayedChildren = columnGroup.getDisplayedChildren();
            if (displayedChildren) {
              addThisItem = testGroup(displayedChildren, result, dept + 1);
            }
          }
          if (addThisItem) {
            returnValue = true;
            if (!result[dept]) {
              result[dept] = [];
            }
            result[dept].push(child);
          }
        }
        return returnValue;
      };
      testGroup(this.displayedTreeLeft, this.viewportRowLeft, 0);
      testGroup(this.displayedTreeRight, this.viewportRowRight, 0);
      testGroup(this.displayedTreeCentre, this.viewportRowCenter, 0);
    }
    extractViewport() {
      const hashColumn = (c) => `${c.getId()}-${c.getPinned() || "normal"}`;
      this.extractViewportColumns();
      const newHash = this.viewportColumns.map(hashColumn).join("#");
      const changed = this.viewportColumnsHash !== newHash;
      if (changed) {
        this.viewportColumnsHash = newHash;
        this.calculateHeaderRows();
      }
      return changed;
    }
    refreshFlexedColumns(params = {}) {
      var _a;
      const source = params.source ? params.source : "flex";
      if (params.viewportWidth != null) {
        this.flexViewportWidth = params.viewportWidth;
      }
      if (!this.flexViewportWidth) {
        return [];
      }
      let flexAfterDisplayIndex = -1;
      if (params.resizingCols) {
        const allResizingCols = new Set(params.resizingCols);
        let displayedCols = this.displayedColumnsCenter;
        for (let i = displayedCols.length - 1; i >= 0; i--) {
          if (allResizingCols.has(displayedCols[i])) {
            flexAfterDisplayIndex = i;
            break;
          }
        }
      }
      let knownColumnsWidth = 0;
      let flexingColumns = [];
      let minimumFlexedWidth = 0;
      let totalFlex = 0;
      for (let i = 0; i < this.displayedColumnsCenter.length; i++) {
        const isFlex = this.displayedColumnsCenter[i].getFlex() && i > flexAfterDisplayIndex;
        if (isFlex) {
          flexingColumns.push(this.displayedColumnsCenter[i]);
          totalFlex += this.displayedColumnsCenter[i].getFlex();
          minimumFlexedWidth += (_a = this.displayedColumnsCenter[i].getMinWidth()) != null ? _a : 0;
        } else {
          knownColumnsWidth += this.displayedColumnsCenter[i].getActualWidth();
        }
      }
      ;
      if (!flexingColumns.length) {
        return [];
      }
      let changedColumns = [];
      if (knownColumnsWidth + minimumFlexedWidth > this.flexViewportWidth) {
        flexingColumns.forEach((col) => {
          var _a2;
          return col.setActualWidth((_a2 = col.getMinWidth()) != null ? _a2 : 0, source);
        });
        changedColumns = flexingColumns;
        flexingColumns = [];
      }
      const flexingColumnSizes = [];
      let spaceForFlexingColumns;
      outer:
        while (true) {
          spaceForFlexingColumns = this.flexViewportWidth - knownColumnsWidth;
          const spacePerFlex = spaceForFlexingColumns / totalFlex;
          for (let i = 0; i < flexingColumns.length; i++) {
            const col = flexingColumns[i];
            const widthByFlexRule = spacePerFlex * col.getFlex();
            let constrainedWidth = 0;
            const minWidth = col.getMinWidth();
            const maxWidth = col.getMaxWidth();
            if (exists(minWidth) && widthByFlexRule < minWidth) {
              constrainedWidth = minWidth;
            } else if (exists(maxWidth) && widthByFlexRule > maxWidth) {
              constrainedWidth = maxWidth;
            }
            if (constrainedWidth) {
              col.setActualWidth(constrainedWidth, source);
              removeFromUnorderedArray(flexingColumns, col);
              totalFlex -= col.getFlex();
              changedColumns.push(col);
              knownColumnsWidth += col.getActualWidth();
              continue outer;
            }
            flexingColumnSizes[i] = Math.round(widthByFlexRule);
          }
          break;
        }
      let remainingSpace = spaceForFlexingColumns;
      flexingColumns.forEach((col, i) => {
        col.setActualWidth(Math.min(flexingColumnSizes[i], remainingSpace), source);
        changedColumns.push(col);
        remainingSpace -= flexingColumnSizes[i];
      });
      if (!params.skipSetLeft) {
        this.setLeftValues(source);
      }
      if (params.updateBodyWidths) {
        this.updateBodyWidths();
      }
      if (params.fireResizedEvent) {
        this.dispatchColumnResizedEvent(changedColumns, true, source, flexingColumns);
      }
      return flexingColumns;
    }
    // called from api
    sizeColumnsToFit(gridWidth, source = "sizeColumnsToFit", silent, params) {
      var _c, _d, _e, _f, _g;
      if (this.shouldQueueResizeOperations) {
        this.resizeOperationQueue.push(() => this.sizeColumnsToFit(gridWidth, source, silent, params));
        return;
      }
      const limitsMap = {};
      if (params) {
        (_c = params == null ? void 0 : params.columnLimits) == null ? void 0 : _c.forEach((_a) => {
          var _b = _a, { key } = _b, dimensions = __objRest(_b, ["key"]);
          limitsMap[typeof key === "string" ? key : key.getColId()] = dimensions;
        });
      }
      const allDisplayedColumns = this.getAllDisplayedColumns();
      const doColumnsAlreadyFit = gridWidth === this.getWidthOfColsInList(allDisplayedColumns);
      if (gridWidth <= 0 || !allDisplayedColumns.length || doColumnsAlreadyFit) {
        return;
      }
      const colsToSpread = [];
      const colsToNotSpread = [];
      allDisplayedColumns.forEach((column) => {
        if (column.getColDef().suppressSizeToFit === true) {
          colsToNotSpread.push(column);
        } else {
          colsToSpread.push(column);
        }
      });
      const colsToDispatchEventFor = colsToSpread.slice(0);
      let finishedResizing = false;
      const moveToNotSpread = (column) => {
        removeFromArray(colsToSpread, column);
        colsToNotSpread.push(column);
      };
      colsToSpread.forEach((column) => {
        var _a, _b;
        column.resetActualWidth(source);
        const widthOverride = limitsMap == null ? void 0 : limitsMap[column.getId()];
        const minOverride = (_a = widthOverride == null ? void 0 : widthOverride.minWidth) != null ? _a : params == null ? void 0 : params.defaultMinWidth;
        const maxOverride = (_b = widthOverride == null ? void 0 : widthOverride.maxWidth) != null ? _b : params == null ? void 0 : params.defaultMaxWidth;
        const colWidth = column.getActualWidth();
        if (typeof minOverride === "number" && colWidth < minOverride) {
          column.setActualWidth(minOverride, source, true);
        } else if (typeof maxOverride === "number" && colWidth > maxOverride) {
          column.setActualWidth(maxOverride, source, true);
        }
      });
      while (!finishedResizing) {
        finishedResizing = true;
        const availablePixels = gridWidth - this.getWidthOfColsInList(colsToNotSpread);
        if (availablePixels <= 0) {
          colsToSpread.forEach((column) => {
            var _a, _b;
            const widthOverride = (_b = (_a = limitsMap == null ? void 0 : limitsMap[column.getId()]) == null ? void 0 : _a.minWidth) != null ? _b : params == null ? void 0 : params.defaultMinWidth;
            if (typeof widthOverride === "number") {
              column.setActualWidth(widthOverride, source, true);
              return;
            }
            column.setMinimum(source);
          });
        } else {
          const scale = availablePixels / this.getWidthOfColsInList(colsToSpread);
          let pixelsForLastCol = availablePixels;
          for (let i = colsToSpread.length - 1; i >= 0; i--) {
            const column = colsToSpread[i];
            const widthOverride = limitsMap == null ? void 0 : limitsMap[column.getId()];
            const minOverride = (_d = widthOverride == null ? void 0 : widthOverride.minWidth) != null ? _d : params == null ? void 0 : params.defaultMinWidth;
            const maxOverride = (_e = widthOverride == null ? void 0 : widthOverride.maxWidth) != null ? _e : params == null ? void 0 : params.defaultMaxWidth;
            const colMinWidth = (_f = column.getMinWidth()) != null ? _f : 0;
            const colMaxWidth = (_g = column.getMaxWidth()) != null ? _g : Number.MAX_VALUE;
            const minWidth = typeof minOverride === "number" && minOverride > colMinWidth ? minOverride : column.getMinWidth();
            const maxWidth = typeof maxOverride === "number" && maxOverride < colMaxWidth ? maxOverride : column.getMaxWidth();
            let newWidth = Math.round(column.getActualWidth() * scale);
            if (exists(minWidth) && newWidth < minWidth) {
              newWidth = minWidth;
              moveToNotSpread(column);
              finishedResizing = false;
            } else if (exists(maxWidth) && newWidth > maxWidth) {
              newWidth = maxWidth;
              moveToNotSpread(column);
              finishedResizing = false;
            } else if (i === 0) {
              newWidth = pixelsForLastCol;
            }
            column.setActualWidth(newWidth, source, true);
            pixelsForLastCol -= newWidth;
          }
        }
      }
      colsToDispatchEventFor.forEach((col) => {
        col.fireColumnWidthChangedEvent(source);
      });
      this.setLeftValues(source);
      this.updateBodyWidths();
      if (silent) {
        return;
      }
      this.dispatchColumnResizedEvent(colsToDispatchEventFor, true, source);
    }
    buildDisplayedTrees(visibleColumns) {
      const leftVisibleColumns = [];
      const rightVisibleColumns = [];
      const centerVisibleColumns = [];
      visibleColumns.forEach((column) => {
        switch (column.getPinned()) {
          case "left":
            leftVisibleColumns.push(column);
            break;
          case "right":
            rightVisibleColumns.push(column);
            break;
          default:
            centerVisibleColumns.push(column);
            break;
        }
      });
      const groupInstanceIdCreator = new GroupInstanceIdCreator();
      this.displayedTreeLeft = this.displayedGroupCreator.createDisplayedGroups(
        leftVisibleColumns,
        groupInstanceIdCreator,
        "left",
        this.displayedTreeLeft
      );
      this.displayedTreeRight = this.displayedGroupCreator.createDisplayedGroups(
        rightVisibleColumns,
        groupInstanceIdCreator,
        "right",
        this.displayedTreeRight
      );
      this.displayedTreeCentre = this.displayedGroupCreator.createDisplayedGroups(
        centerVisibleColumns,
        groupInstanceIdCreator,
        null,
        this.displayedTreeCentre
      );
      this.updateDisplayedMap();
    }
    updateDisplayedMap() {
      this.displayedColumnsAndGroupsMap = {};
      const func = (child) => {
        this.displayedColumnsAndGroupsMap[child.getUniqueId()] = child;
      };
      depthFirstAllColumnTreeSearch(this.displayedTreeCentre, false, func);
      depthFirstAllColumnTreeSearch(this.displayedTreeLeft, false, func);
      depthFirstAllColumnTreeSearch(this.displayedTreeRight, false, func);
    }
    isDisplayed(item) {
      const fromMap = this.displayedColumnsAndGroupsMap[item.getUniqueId()];
      return fromMap === item;
    }
    updateOpenClosedVisibilityInColumnGroups() {
      const allColumnGroups = this.getAllDisplayedTrees();
      depthFirstAllColumnTreeSearch(allColumnGroups, false, (child) => {
        if (child instanceof ColumnGroup) {
          child.calculateDisplayedColumns();
        }
      });
    }
    getGroupAutoColumns() {
      return this.groupAutoColumns;
    }
    /**
     * Creates new auto group columns if required
     * @returns whether auto cols have changed
     */
    createGroupAutoColumnsIfNeeded() {
      const forceRecreateAutoGroups = this.forceRecreateAutoGroups;
      this.forceRecreateAutoGroups = false;
      if (!this.autoGroupsNeedBuilding) {
        return false;
      }
      this.autoGroupsNeedBuilding = false;
      const groupFullWidthRow = this.gos.isGroupUseEntireRow(this.pivotMode);
      const suppressAutoColumn = this.pivotMode ? this.gos.get("pivotSuppressAutoColumn") : this.isGroupSuppressAutoColumn();
      const groupingActive = this.rowGroupColumns.length > 0 || this.gos.get("treeData");
      const needAutoColumns = groupingActive && !suppressAutoColumn && !groupFullWidthRow;
      if (needAutoColumns) {
        const newAutoGroupCols = this.autoGroupColService.createAutoGroupColumns(this.rowGroupColumns);
        const autoColsDifferent = !this.autoColsEqual(newAutoGroupCols, this.groupAutoColumns);
        if (autoColsDifferent || forceRecreateAutoGroups) {
          this.groupAutoColumns = newAutoGroupCols;
          return true;
        }
      } else {
        this.groupAutoColumns = null;
      }
      return false;
    }
    isGroupSuppressAutoColumn() {
      const groupDisplayType = this.gos.get("groupDisplayType");
      const isCustomRowGroups = groupDisplayType === "custom";
      if (isCustomRowGroups) {
        return true;
      }
      const treeDataDisplayType = this.gos.get("treeDataDisplayType");
      return treeDataDisplayType === "custom";
    }
    autoColsEqual(colsA, colsB) {
      return areEqual(colsA, colsB, (a, b) => a.getColId() === b.getColId());
    }
    getWidthOfColsInList(columnList) {
      return columnList.reduce((width, col) => width + col.getActualWidth(), 0);
    }
    getFirstDisplayedColumn() {
      const isRtl = this.gos.get("enableRtl");
      const queryOrder = [
        "getDisplayedLeftColumns",
        "getDisplayedCenterColumns",
        "getDisplayedRightColumns"
      ];
      if (isRtl) {
        queryOrder.reverse();
      }
      for (let i = 0; i < queryOrder.length; i++) {
        const container = this[queryOrder[i]]();
        if (container.length) {
          return isRtl ? last(container) : container[0];
        }
      }
      return null;
    }
    setColumnHeaderHeight(col, height) {
      const changed = col.setAutoHeaderHeight(height);
      if (changed) {
        const event = {
          type: Events.EVENT_COLUMN_HEADER_HEIGHT_CHANGED,
          column: col,
          columns: [col],
          source: "autosizeColumnHeaderHeight"
        };
        this.eventService.dispatchEvent(event);
      }
    }
    getColumnGroupHeaderRowHeight() {
      if (this.isPivotMode()) {
        return this.getPivotGroupHeaderHeight();
      }
      return this.getGroupHeaderHeight();
    }
    getColumnHeaderRowHeight() {
      const defaultHeight = this.isPivotMode() ? this.getPivotHeaderHeight() : this.getHeaderHeight();
      const displayedHeights = this.getAllDisplayedColumns().filter((col) => col.isAutoHeaderHeight()).map((col) => col.getAutoHeaderHeight() || 0);
      return Math.max(defaultHeight, ...displayedHeights);
    }
    getHeaderHeight() {
      var _a;
      return (_a = this.gos.get("headerHeight")) != null ? _a : this.environment.getFromTheme(25, "headerHeight");
    }
    getFloatingFiltersHeight() {
      var _a;
      return (_a = this.gos.get("floatingFiltersHeight")) != null ? _a : this.getHeaderHeight();
    }
    getGroupHeaderHeight() {
      var _a;
      return (_a = this.gos.get("groupHeaderHeight")) != null ? _a : this.getHeaderHeight();
    }
    getPivotHeaderHeight() {
      var _a;
      return (_a = this.gos.get("pivotHeaderHeight")) != null ? _a : this.getHeaderHeight();
    }
    getPivotGroupHeaderHeight() {
      var _a;
      return (_a = this.gos.get("pivotGroupHeaderHeight")) != null ? _a : this.getGroupHeaderHeight();
    }
    queueResizeOperations() {
      this.shouldQueueResizeOperations = true;
    }
    processResizeOperations() {
      this.shouldQueueResizeOperations = false;
      this.resizeOperationQueue.forEach((resizeOperation) => resizeOperation());
      this.resizeOperationQueue = [];
    }
    resetColumnDefIntoColumn(column, source) {
      const userColDef = column.getUserProvidedColDef();
      if (!userColDef) {
        return false;
      }
      const newColDef = this.columnFactory.addColumnDefaultAndTypes(userColDef, column.getColId());
      column.setColDef(newColDef, userColDef, source);
      return true;
    }
    isColumnGroupingLocked(column) {
      const groupLockGroupColumns = this.gos.get("groupLockGroupColumns");
      if (!column.isRowGroupActive() || groupLockGroupColumns === 0) {
        return false;
      }
      if (groupLockGroupColumns === -1) {
        return true;
      }
      const colIndex = this.rowGroupColumns.findIndex((groupCol) => groupCol.getColId() === column.getColId());
      return groupLockGroupColumns > colIndex;
    }
    generateColumnStateForRowGroupAndPivotIndexes(updatedRowGroupColumnState, updatedPivotColumnState) {
      let existingColumnStateUpdates = {};
      const orderColumns = (updatedColumnState, colList, enableProp, initialEnableProp, indexProp, initialIndexProp) => {
        if (!colList.length || !this.primaryColumns) {
          return [];
        }
        const updatedColIdArray = Object.keys(updatedColumnState);
        const updatedColIds = new Set(updatedColIdArray);
        const newColIds = new Set(updatedColIdArray);
        const allColIds = new Set(colList.map((column) => {
          const colId = column.getColId();
          newColIds.delete(colId);
          return colId;
        }).concat(updatedColIdArray));
        const colIdsInOriginalOrder = [];
        const originalOrderMap = {};
        let orderIndex = 0;
        for (let i = 0; i < this.primaryColumns.length; i++) {
          const colId = this.primaryColumns[i].getColId();
          if (allColIds.has(colId)) {
            colIdsInOriginalOrder.push(colId);
            originalOrderMap[colId] = orderIndex++;
          }
        }
        let index = 1e3;
        let hasAddedNewCols = false;
        let lastIndex = 0;
        const processPrecedingNewCols = (colId) => {
          const originalOrderIndex = originalOrderMap[colId];
          for (let i = lastIndex; i < originalOrderIndex; i++) {
            const newColId = colIdsInOriginalOrder[i];
            if (newColIds.has(newColId)) {
              updatedColumnState[newColId][indexProp] = index++;
              newColIds.delete(newColId);
            }
          }
          lastIndex = originalOrderIndex;
        };
        colList.forEach((column) => {
          const colId = column.getColId();
          if (updatedColIds.has(colId)) {
            processPrecedingNewCols(colId);
            updatedColumnState[colId][indexProp] = index++;
          } else {
            const colDef = column.getColDef();
            const missingIndex = colDef[indexProp] === null || colDef[indexProp] === void 0 && colDef[initialIndexProp] == null;
            if (missingIndex) {
              if (!hasAddedNewCols) {
                const propEnabled = colDef[enableProp] || colDef[enableProp] === void 0 && colDef[initialEnableProp];
                if (propEnabled) {
                  processPrecedingNewCols(colId);
                } else {
                  newColIds.forEach((newColId) => {
                    updatedColumnState[newColId][indexProp] = index + originalOrderMap[newColId];
                  });
                  index += colIdsInOriginalOrder.length;
                  hasAddedNewCols = true;
                }
              }
              if (!existingColumnStateUpdates[colId]) {
                existingColumnStateUpdates[colId] = { colId };
              }
              existingColumnStateUpdates[colId][indexProp] = index++;
            }
          }
        });
      };
      orderColumns(updatedRowGroupColumnState, this.rowGroupColumns, "rowGroup", "initialRowGroup", "rowGroupIndex", "initialRowGroupIndex");
      orderColumns(updatedPivotColumnState, this.pivotColumns, "pivot", "initialPivot", "pivotIndex", "initialPivotIndex");
      return Object.values(existingColumnStateUpdates);
    }
    onColumnsReady() {
      const autoSizeStrategy = this.gos.get("autoSizeStrategy");
      if (!autoSizeStrategy) {
        return;
      }
      const { type } = autoSizeStrategy;
      setTimeout(() => {
        if (type === "fitGridWidth") {
          const { columnLimits: propColumnLimits, defaultMinWidth, defaultMaxWidth } = autoSizeStrategy;
          const columnLimits = propColumnLimits == null ? void 0 : propColumnLimits.map(({ colId: key, minWidth, maxWidth }) => ({
            key,
            minWidth,
            maxWidth
          }));
          this.ctrlsService.getGridBodyCtrl().sizeColumnsToFit({
            defaultMinWidth,
            defaultMaxWidth,
            columnLimits
          });
        } else if (type === "fitProvidedWidth") {
          this.sizeColumnsToFit(autoSizeStrategy.width, "sizeColumnsToFit");
        }
      });
    }
    onFirstDataRendered() {
      const autoSizeStrategy = this.gos.get("autoSizeStrategy");
      if ((autoSizeStrategy == null ? void 0 : autoSizeStrategy.type) !== "fitCellContents") {
        return;
      }
      const { colIds: columns, skipHeader } = autoSizeStrategy;
      setTimeout(() => {
        if (columns) {
          this.autoSizeColumns({
            columns,
            skipHeader,
            source: "autosizeColumns"
          });
        } else {
          this.autoSizeAllColumns("autosizeColumns", skipHeader);
        }
      });
    }
  };
  __decorateClass([
    Autowired("expressionService")
  ], ColumnModel.prototype, "expressionService", 2);
  __decorateClass([
    Autowired("columnFactory")
  ], ColumnModel.prototype, "columnFactory", 2);
  __decorateClass([
    Autowired("displayedGroupCreator")
  ], ColumnModel.prototype, "displayedGroupCreator", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], ColumnModel.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("autoWidthCalculator")
  ], ColumnModel.prototype, "autoWidthCalculator", 2);
  __decorateClass([
    Autowired("columnAnimationService")
  ], ColumnModel.prototype, "columnAnimationService", 2);
  __decorateClass([
    Autowired("autoGroupColService")
  ], ColumnModel.prototype, "autoGroupColService", 2);
  __decorateClass([
    Autowired("valueCache")
  ], ColumnModel.prototype, "valueCache", 2);
  __decorateClass([
    Autowired("animationFrameService")
  ], ColumnModel.prototype, "animationFrameService", 2);
  __decorateClass([
    Autowired("sortController")
  ], ColumnModel.prototype, "sortController", 2);
  __decorateClass([
    Autowired("columnDefFactory")
  ], ColumnModel.prototype, "columnDefFactory", 2);
  __decorateClass([
    Optional("aggFuncService")
  ], ColumnModel.prototype, "aggFuncService", 2);
  __decorateClass([
    PostConstruct
  ], ColumnModel.prototype, "init", 1);
  __decorateClass([
    PreDestroy
  ], ColumnModel.prototype, "destroyColumns", 1);
  __decorateClass([
    __decorateParam(0, Qualifier("loggerFactory"))
  ], ColumnModel.prototype, "setBeans", 1);
  ColumnModel = __decorateClass([
    Bean("columnModel")
  ], ColumnModel);
  function convertSourceType(source) {
    return source === "gridOptionsUpdated" ? "gridOptionsChanged" : source;
  }
  function depthFirstAllColumnTreeSearch(tree, useDisplayedChildren, callback) {
    if (!tree) {
      return;
    }
    for (let i = 0; i < tree.length; i++) {
      const child = tree[i];
      if (child instanceof ColumnGroup) {
        const childTree = useDisplayedChildren ? child.getDisplayedChildren() : child.getChildren();
        depthFirstAllColumnTreeSearch(childTree, useDisplayedChildren, callback);
      }
      callback(child);
    }
  }
  var DisplayedGroupCreator = class extends BeanStub {
    createDisplayedGroups(sortedVisibleColumns, groupInstanceIdCreator, pinned, oldDisplayedGroups) {
      const oldColumnsMapped = this.mapOldGroupsById(oldDisplayedGroups);
      const topLevelResultCols = [];
      let groupsOrColsAtCurrentLevel = sortedVisibleColumns;
      while (groupsOrColsAtCurrentLevel.length) {
        const currentlyIterating = groupsOrColsAtCurrentLevel;
        groupsOrColsAtCurrentLevel = [];
        let lastGroupedColIdx = 0;
        const createGroupToIndex = (to) => {
          const from = lastGroupedColIdx;
          lastGroupedColIdx = to;
          const previousNode = currentlyIterating[from];
          const previousNodeProvided = previousNode instanceof ColumnGroup ? previousNode.getProvidedColumnGroup() : previousNode;
          const previousNodeParent = previousNodeProvided.getOriginalParent();
          if (previousNodeParent == null) {
            for (let i = from; i < to; i++) {
              topLevelResultCols.push(currentlyIterating[i]);
            }
            return;
          }
          const newGroup = this.createColumnGroup(
            previousNodeParent,
            groupInstanceIdCreator,
            oldColumnsMapped,
            pinned
          );
          for (let i = from; i < to; i++) {
            newGroup.addChild(currentlyIterating[i]);
          }
          groupsOrColsAtCurrentLevel.push(newGroup);
        };
        for (let i = 1; i < currentlyIterating.length; i++) {
          const thisNode = currentlyIterating[i];
          const thisNodeProvided = thisNode instanceof ColumnGroup ? thisNode.getProvidedColumnGroup() : thisNode;
          const thisNodeParent = thisNodeProvided.getOriginalParent();
          const previousNode = currentlyIterating[lastGroupedColIdx];
          const previousNodeProvided = previousNode instanceof ColumnGroup ? previousNode.getProvidedColumnGroup() : previousNode;
          const previousNodeParent = previousNodeProvided.getOriginalParent();
          if (thisNodeParent !== previousNodeParent) {
            createGroupToIndex(i);
          }
        }
        if (lastGroupedColIdx < currentlyIterating.length) {
          createGroupToIndex(currentlyIterating.length);
        }
      }
      this.setupParentsIntoColumns(topLevelResultCols, null);
      return topLevelResultCols;
    }
    createColumnGroup(providedGroup, groupInstanceIdCreator, oldColumnsMapped, pinned) {
      const groupId = providedGroup.getGroupId();
      const instanceId = groupInstanceIdCreator.getInstanceIdForKey(groupId);
      const uniqueId = ColumnGroup.createUniqueId(groupId, instanceId);
      let columnGroup = oldColumnsMapped[uniqueId];
      if (columnGroup && columnGroup.getProvidedColumnGroup() !== providedGroup) {
        columnGroup = null;
      }
      if (exists(columnGroup)) {
        columnGroup.reset();
      } else {
        columnGroup = new ColumnGroup(providedGroup, groupId, instanceId, pinned);
        this.context.createBean(columnGroup);
      }
      return columnGroup;
    }
    // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup
    mapOldGroupsById(displayedGroups) {
      const result = {};
      const recursive = (columnsOrGroups) => {
        columnsOrGroups.forEach((columnOrGroup) => {
          if (columnOrGroup instanceof ColumnGroup) {
            const columnGroup = columnOrGroup;
            result[columnOrGroup.getUniqueId()] = columnGroup;
            recursive(columnGroup.getChildren());
          }
        });
      };
      if (displayedGroups) {
        recursive(displayedGroups);
      }
      return result;
    }
    setupParentsIntoColumns(columnsOrGroups, parent) {
      columnsOrGroups.forEach((columnsOrGroup) => {
        columnsOrGroup.setParent(parent);
        if (columnsOrGroup instanceof ColumnGroup) {
          const columnGroup = columnsOrGroup;
          this.setupParentsIntoColumns(columnGroup.getChildren(), columnGroup);
        }
      });
    }
  };
  DisplayedGroupCreator = __decorateClass([
    Bean("displayedGroupCreator")
  ], DisplayedGroupCreator);
  var INITIAL_GRID_OPTION_KEYS = {
    enableBrowserTooltips: true,
    tooltipTrigger: true,
    tooltipMouseTrack: true,
    tooltipShowMode: true,
    tooltipInteraction: true,
    defaultColGroupDef: true,
    suppressAutoSize: true,
    skipHeaderOnAutoSize: true,
    autoSizeStrategy: true,
    components: true,
    stopEditingWhenCellsLoseFocus: true,
    undoRedoCellEditing: true,
    undoRedoCellEditingLimit: true,
    excelStyles: true,
    cacheQuickFilter: true,
    excludeHiddenColumnsFromQuickFilter: true,
    advancedFilterModel: true,
    customChartThemes: true,
    chartThemeOverrides: true,
    enableChartToolPanelsButton: true,
    suppressChartToolPanelsButton: true,
    chartToolPanelsDef: true,
    loadingCellRendererSelector: true,
    localeText: true,
    keepDetailRows: true,
    keepDetailRowsCount: true,
    detailRowHeight: true,
    detailRowAutoHeight: true,
    tabIndex: true,
    valueCache: true,
    valueCacheNeverExpires: true,
    enableCellExpressions: true,
    suppressParentsInRowNodes: true,
    suppressTouch: true,
    suppressAsyncEvents: true,
    suppressBrowserResizeObserver: true,
    suppressPropertyNamesCheck: true,
    debug: true,
    loadingOverlayComponent: true,
    suppressLoadingOverlay: true,
    noRowsOverlayComponent: true,
    paginationPageSizeSelector: true,
    paginateChildRows: true,
    pivotPanelShow: true,
    pivotSuppressAutoColumn: true,
    suppressExpandablePivotGroups: true,
    aggFuncs: true,
    suppressAggFuncInHeader: true,
    suppressAggAtRootLevel: true,
    removePivotHeaderRowWhenSingleValueColumn: true,
    allowShowChangeAfterFilter: true,
    ensureDomOrder: true,
    enableRtl: true,
    suppressColumnVirtualisation: true,
    suppressMaxRenderedRowRestriction: true,
    suppressRowVirtualisation: true,
    rowDragText: true,
    suppressGroupMaintainValueType: true,
    groupLockGroupColumns: true,
    rowGroupPanelSuppressSort: true,
    suppressGroupRowsSticky: true,
    rowModelType: true,
    cacheOverflowSize: true,
    infiniteInitialRowCount: true,
    serverSideInitialRowCount: true,
    suppressServerSideInfiniteScroll: true,
    maxBlocksInCache: true,
    maxConcurrentDatasourceRequests: true,
    blockLoadDebounceMillis: true,
    serverSideOnlyRefreshFilteredGroups: true,
    serverSidePivotResultFieldSeparator: true,
    viewportRowModelPageSize: true,
    viewportRowModelBufferSize: true,
    debounceVerticalScrollbar: true,
    suppressAnimationFrame: true,
    suppressPreventDefaultOnMouseWheel: true,
    scrollbarWidth: true,
    icons: true,
    suppressRowTransform: true,
    gridId: true,
    functionsPassive: true,
    enableGroupEdit: true,
    initialState: true,
    processUnpinnedColumns: true,
    createChartContainer: true,
    getLocaleText: true,
    getRowId: true,
    reactiveCustomComponents: true,
    columnMenu: true
  };
  var _PropertyKeys = class _PropertyKeys2 {
  };
  _PropertyKeys.STRING_PROPERTIES = [
    "rowSelection",
    "overlayLoadingTemplate",
    "overlayNoRowsTemplate",
    "gridId",
    "quickFilterText",
    "rowModelType",
    "editType",
    "domLayout",
    "clipboardDelimiter",
    "rowGroupPanelShow",
    "multiSortKey",
    "pivotColumnGroupTotals",
    "pivotRowTotals",
    "pivotPanelShow",
    "fillHandleDirection",
    "groupDisplayType",
    "treeDataDisplayType",
    "colResizeDefault",
    "tooltipTrigger",
    "serverSidePivotResultFieldSeparator",
    "columnMenu",
    "tooltipShowMode",
    "grandTotalRow"
  ];
  _PropertyKeys.OBJECT_PROPERTIES = [
    "components",
    "rowStyle",
    "context",
    "autoGroupColumnDef",
    "localeText",
    "icons",
    "datasource",
    "serverSideDatasource",
    "viewportDatasource",
    "groupRowRendererParams",
    "aggFuncs",
    "fullWidthCellRendererParams",
    "defaultColGroupDef",
    "defaultColDef",
    "defaultCsvExportParams",
    "defaultExcelExportParams",
    "columnTypes",
    "rowClassRules",
    "detailCellRendererParams",
    "loadingCellRendererParams",
    "loadingOverlayComponentParams",
    "noRowsOverlayComponentParams",
    "popupParent",
    "statusBar",
    "sideBar",
    "chartThemeOverrides",
    "customChartThemes",
    "chartToolPanelsDef",
    "dataTypeDefinitions",
    "advancedFilterModel",
    "advancedFilterParent",
    "advancedFilterBuilderParams",
    "initialState",
    "autoSizeStrategy"
  ];
  _PropertyKeys.ARRAY_PROPERTIES = [
    "sortingOrder",
    "alignedGrids",
    "rowData",
    "columnDefs",
    "excelStyles",
    "pinnedTopRowData",
    "pinnedBottomRowData",
    "chartThemes",
    "rowClass",
    "paginationPageSizeSelector"
  ];
  _PropertyKeys.NUMBER_PROPERTIES = [
    "rowHeight",
    "detailRowHeight",
    "rowBuffer",
    "headerHeight",
    "groupHeaderHeight",
    "groupLockGroupColumns",
    "floatingFiltersHeight",
    "pivotHeaderHeight",
    "pivotGroupHeaderHeight",
    "groupDefaultExpanded",
    "pivotDefaultExpanded",
    "viewportRowModelPageSize",
    "viewportRowModelBufferSize",
    "autoSizePadding",
    "maxBlocksInCache",
    "maxConcurrentDatasourceRequests",
    "tooltipShowDelay",
    "tooltipHideDelay",
    "cacheOverflowSize",
    "paginationPageSize",
    "cacheBlockSize",
    "infiniteInitialRowCount",
    "serverSideInitialRowCount",
    "scrollbarWidth",
    "asyncTransactionWaitMillis",
    "blockLoadDebounceMillis",
    "keepDetailRowsCount",
    "undoRedoCellEditingLimit",
    "cellFlashDelay",
    "cellFadeDelay",
    "cellFlashDuration",
    "cellFadeDuration",
    "tabIndex",
    "pivotMaxGeneratedColumns"
  ];
  _PropertyKeys.BOOLEAN_PROPERTIES = [
    "suppressMakeColumnVisibleAfterUnGroup",
    "suppressRowClickSelection",
    "suppressCellFocus",
    "suppressHeaderFocus",
    "suppressHorizontalScroll",
    "groupSelectsChildren",
    "alwaysShowHorizontalScroll",
    "alwaysShowVerticalScroll",
    "debug",
    "enableBrowserTooltips",
    "enableCellExpressions",
    "groupIncludeTotalFooter",
    "groupSuppressBlankHeader",
    "suppressMenuHide",
    "suppressRowDeselection",
    "unSortIcon",
    "suppressMultiSort",
    "alwaysMultiSort",
    "singleClickEdit",
    "suppressLoadingOverlay",
    "suppressNoRowsOverlay",
    "suppressAutoSize",
    "skipHeaderOnAutoSize",
    "suppressParentsInRowNodes",
    "suppressColumnMoveAnimation",
    "suppressMovableColumns",
    "suppressFieldDotNotation",
    "enableRangeSelection",
    "enableRangeHandle",
    "enableFillHandle",
    "suppressClearOnFillReduction",
    "deltaSort",
    "suppressTouch",
    "suppressAsyncEvents",
    "allowContextMenuWithControlKey",
    "suppressContextMenu",
    "enableCellChangeFlash",
    "suppressDragLeaveHidesColumns",
    "suppressRowGroupHidesColumns",
    "suppressMiddleClickScrolls",
    "suppressPreventDefaultOnMouseWheel",
    "suppressCopyRowsToClipboard",
    "copyHeadersToClipboard",
    "copyGroupHeadersToClipboard",
    "pivotMode",
    "suppressAggFuncInHeader",
    "suppressColumnVirtualisation",
    "alwaysAggregateAtRootLevel",
    "suppressAggAtRootLevel",
    "suppressFocusAfterRefresh",
    "functionsPassive",
    "functionsReadOnly",
    "animateRows",
    "groupSelectsFiltered",
    "groupRemoveSingleChildren",
    "groupRemoveLowestSingleChildren",
    "enableRtl",
    "suppressClickEdit",
    "rowDragEntireRow",
    "rowDragManaged",
    "suppressRowDrag",
    "suppressMoveWhenRowDragging",
    "rowDragMultiRow",
    "enableGroupEdit",
    "embedFullWidthRows",
    "suppressPaginationPanel",
    "groupHideOpenParents",
    "groupAllowUnbalanced",
    "pagination",
    "paginationAutoPageSize",
    "suppressScrollOnNewData",
    "suppressScrollWhenPopupsAreOpen",
    "purgeClosedRowNodes",
    "cacheQuickFilter",
    "includeHiddenColumnsInQuickFilter",
    "excludeHiddenColumnsFromQuickFilter",
    "ensureDomOrder",
    "accentedSort",
    "suppressChangeDetection",
    "valueCache",
    "valueCacheNeverExpires",
    "aggregateOnlyChangedColumns",
    "suppressAnimationFrame",
    "suppressExcelExport",
    "suppressCsvExport",
    "includeHiddenColumnsInAdvancedFilter",
    "suppressMultiRangeSelection",
    "enterMovesDown",
    "enterMovesDownAfterEdit",
    "enterNavigatesVerticallyAfterEdit",
    "enterNavigatesVertically",
    "suppressPropertyNamesCheck",
    "rowMultiSelectWithClick",
    "suppressRowHoverHighlight",
    "suppressRowTransform",
    "suppressClipboardPaste",
    "suppressLastEmptyLineOnPaste",
    "enableCharts",
    "enableChartToolPanelsButton",
    "suppressChartToolPanelsButton",
    "suppressMaintainUnsortedOrder",
    "enableCellTextSelection",
    "suppressBrowserResizeObserver",
    "suppressMaxRenderedRowRestriction",
    "excludeChildrenWhenTreeDataFiltering",
    "tooltipMouseTrack",
    "tooltipInteraction",
    "keepDetailRows",
    "paginateChildRows",
    "preventDefaultOnContextMenu",
    "undoRedoCellEditing",
    "allowDragFromColumnsToolPanel",
    "pivotSuppressAutoColumn",
    "suppressExpandablePivotGroups",
    "debounceVerticalScrollbar",
    "detailRowAutoHeight",
    "serverSideFilterAllLevels",
    "serverSideSortAllLevels",
    "serverSideEnableClientSideSort",
    "serverSideOnlyRefreshFilteredGroups",
    "serverSideSortOnServer",
    "serverSideFilterOnServer",
    "suppressAggFilteredOnly",
    "showOpenedGroup",
    "suppressClipboardApi",
    "suppressModelUpdateAfterUpdateTransaction",
    "stopEditingWhenCellsLoseFocus",
    "maintainColumnOrder",
    "groupMaintainOrder",
    "columnHoverHighlight",
    "readOnlyEdit",
    "suppressRowVirtualisation",
    "enableCellEditingOnBackspace",
    "resetRowDataOnUpdate",
    "removePivotHeaderRowWhenSingleValueColumn",
    "suppressCopySingleCellRanges",
    "suppressGroupRowsSticky",
    "suppressCutToClipboard",
    "suppressServerSideInfiniteScroll",
    "rowGroupPanelSuppressSort",
    "allowShowChangeAfterFilter",
    "enableAdvancedFilter",
    "masterDetail",
    "treeData",
    "suppressGroupMaintainValueType",
    "reactiveCustomComponents",
    "applyQuickFilterBeforePivotOrAgg",
    "suppressServerSideFullWidthLoadingRow",
    "suppressAdvancedFilterEval"
  ];
  _PropertyKeys.OTHER_PROPERTIES = [
    "suppressStickyTotalRow"
  ];
  _PropertyKeys.FUNCTIONAL_PROPERTIES = [
    "doesExternalFilterPass",
    "processPivotResultColDef",
    "processPivotResultColGroupDef",
    "getBusinessKeyForNode",
    "isRowSelectable",
    "rowDragText",
    "groupRowRenderer",
    "fullWidthCellRenderer",
    "loadingCellRenderer",
    "loadingOverlayComponent",
    "noRowsOverlayComponent",
    "detailCellRenderer",
    "quickFilterParser",
    "quickFilterMatcher"
  ];
  _PropertyKeys.CALLBACK_PROPERTIES = [
    "getLocaleText",
    "isExternalFilterPresent",
    "getRowHeight",
    "getRowClass",
    "getRowStyle",
    "getContextMenuItems",
    "getMainMenuItems",
    "processRowPostCreate",
    "processCellForClipboard",
    "getGroupRowAgg",
    "isFullWidthRow",
    "sendToClipboard",
    "navigateToNextHeader",
    "tabToNextHeader",
    "navigateToNextCell",
    "tabToNextCell",
    "processCellFromClipboard",
    "getDocument",
    "postProcessPopup",
    "getChildCount",
    "getDataPath",
    "isRowMaster",
    "postSortRows",
    "processHeaderForClipboard",
    "processUnpinnedColumns",
    "processGroupHeaderForClipboard",
    "paginationNumberFormatter",
    "processDataFromClipboard",
    "getServerSideGroupKey",
    "isServerSideGroup",
    "createChartContainer",
    "getChartToolbarItems",
    "fillOperation",
    "isApplyServerSideTransaction",
    "getServerSideGroupLevelParams",
    "isServerSideGroupOpenByDefault",
    "isGroupOpenByDefault",
    "initialGroupOrderComparator",
    "groupIncludeFooter",
    "loadingCellRendererSelector",
    "getRowId",
    "groupAggFiltering",
    "chartMenuItems",
    "groupTotalRow"
  ];
  _PropertyKeys.FUNCTION_PROPERTIES = [
    ..._PropertyKeys.FUNCTIONAL_PROPERTIES,
    ..._PropertyKeys.CALLBACK_PROPERTIES
  ];
  _PropertyKeys.ALL_PROPERTIES = [
    ..._PropertyKeys.ARRAY_PROPERTIES,
    ..._PropertyKeys.OBJECT_PROPERTIES,
    ..._PropertyKeys.STRING_PROPERTIES,
    ..._PropertyKeys.NUMBER_PROPERTIES,
    ..._PropertyKeys.FUNCTION_PROPERTIES,
    ..._PropertyKeys.BOOLEAN_PROPERTIES,
    ..._PropertyKeys.OTHER_PROPERTIES
  ];
  var PropertyKeys = _PropertyKeys;
  var _ComponentUtil = class _ComponentUtil2 {
    static getCallbackForEvent(eventName) {
      if (!eventName || eventName.length < 2) {
        return eventName;
      }
      return "on" + eventName[0].toUpperCase() + eventName.substring(1);
    }
    static getGridOptionKeys() {
      return this.ALL_PROPERTIES_AND_CALLBACKS;
    }
    /** Combines component props / attributes with the provided gridOptions returning a new combined gridOptions object */
    static combineAttributesAndGridOptions(gridOptions, component) {
      if (typeof gridOptions !== "object") {
        gridOptions = {};
      }
      const mergedOptions = __spreadValues({}, gridOptions);
      const keys2 = _ComponentUtil2.getGridOptionKeys();
      keys2.forEach((key) => {
        const value = component[key];
        if (typeof value !== "undefined" && value !== _ComponentUtil2.VUE_OMITTED_PROPERTY) {
          mergedOptions[key] = value;
        }
      });
      return mergedOptions;
    }
    static processOnChange(changes, api, isVue) {
      if (!changes) {
        return;
      }
      const gridChanges = {};
      let hasChanges = false;
      Object.keys(changes).filter((key) => _ComponentUtil2.ALL_PROPERTIES_AND_CALLBACKS_SET.has(key)).forEach((key) => {
        gridChanges[key] = changes[key];
        hasChanges = true;
      });
      if (!hasChanges) {
        return;
      }
      api.__internalUpdateGridOptions(gridChanges, true);
      const event = {
        type: Events.EVENT_COMPONENT_STATE_CHANGED
      };
      iterateObject(gridChanges, (key, value) => {
        event[key] = value;
      });
      api.dispatchEvent(event);
    }
  };
  _ComponentUtil.EVENTS = values(Events);
  _ComponentUtil.VUE_OMITTED_PROPERTY = "AG-VUE-OMITTED-PROPERTY";
  _ComponentUtil.EXCLUDED_INTERNAL_EVENTS = [
    Events.EVENT_SCROLLBAR_WIDTH_CHANGED,
    Events.EVENT_CHECKBOX_CHANGED,
    Events.EVENT_HEIGHT_SCALE_CHANGED,
    Events.EVENT_BODY_HEIGHT_CHANGED,
    Events.EVENT_COLUMN_CONTAINER_WIDTH_CHANGED,
    Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,
    Events.EVENT_SCROLL_VISIBILITY_CHANGED,
    Events.EVENT_COLUMN_HOVER_CHANGED,
    Events.EVENT_FLASH_CELLS,
    Events.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED,
    Events.EVENT_DISPLAYED_ROWS_CHANGED,
    Events.EVENT_LEFT_PINNED_WIDTH_CHANGED,
    Events.EVENT_RIGHT_PINNED_WIDTH_CHANGED,
    Events.EVENT_ROW_CONTAINER_HEIGHT_CHANGED,
    Events.EVENT_STORE_UPDATED,
    Events.EVENT_COLUMN_PANEL_ITEM_DRAG_START,
    Events.EVENT_COLUMN_PANEL_ITEM_DRAG_END,
    Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_START,
    Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_END,
    Events.EVENT_FULL_WIDTH_ROW_FOCUSED,
    Events.EVENT_HEADER_HEIGHT_CHANGED,
    Events.EVENT_COLUMN_HEADER_HEIGHT_CHANGED,
    Events.EVENT_CELL_FOCUS_CLEARED,
    Events.EVENT_GRID_STYLES_CHANGED,
    Events.EVENT_FILTER_DESTROYED,
    Events.EVENT_ROW_DATA_UPDATE_STARTED,
    Events.EVENT_ADVANCED_FILTER_ENABLED_CHANGED,
    Events.EVENT_DATA_TYPES_INFERRED,
    Events.EVENT_FIELD_VALUE_CHANGED,
    Events.EVENT_FIELD_PICKER_VALUE_SELECTED,
    Events.EVENT_SUPPRESS_COLUMN_MOVE_CHANGED,
    Events.EVENT_SUPPRESS_MENU_HIDE_CHANGED,
    Events.EVENT_SUPPRESS_FIELD_DOT_NOTATION,
    Events.EVENT_ROW_COUNT_READY,
    Events.EVENT_SIDE_BAR_UPDATED
  ];
  _ComponentUtil.PUBLIC_EVENTS = _ComponentUtil.EVENTS.filter((e) => !includes(_ComponentUtil.EXCLUDED_INTERNAL_EVENTS, e));
  _ComponentUtil.EVENT_CALLBACKS = _ComponentUtil.EVENTS.map((event) => _ComponentUtil.getCallbackForEvent(event));
  _ComponentUtil.BOOLEAN_PROPERTIES = PropertyKeys.BOOLEAN_PROPERTIES;
  _ComponentUtil.ALL_PROPERTIES = PropertyKeys.ALL_PROPERTIES;
  _ComponentUtil.ALL_PROPERTIES_AND_CALLBACKS = [..._ComponentUtil.ALL_PROPERTIES, ..._ComponentUtil.EVENT_CALLBACKS];
  _ComponentUtil.ALL_PROPERTIES_AND_CALLBACKS_SET = new Set(_ComponentUtil.ALL_PROPERTIES_AND_CALLBACKS);
  var ComponentUtil = _ComponentUtil;
  var AgStackComponentsRegistry = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.componentsMappedByName = {};
    }
    setupComponents(components) {
      if (components) {
        components.forEach((componentMeta) => this.addComponent(componentMeta));
      }
    }
    addComponent(componentMeta) {
      const classEscaped = componentMeta.componentName.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      const classUpperCase = classEscaped.toUpperCase();
      this.componentsMappedByName[classUpperCase] = componentMeta.componentClass;
    }
    getComponentClass(htmlTag) {
      return this.componentsMappedByName[htmlTag];
    }
  };
  AgStackComponentsRegistry = __decorateClass([
    Bean("agStackComponentsRegistry")
  ], AgStackComponentsRegistry);
  var aria_exports = {};
  __export2(aria_exports, {
    getAriaCheckboxStateName: () => getAriaCheckboxStateName,
    getAriaLabel: () => getAriaLabel,
    getAriaLevel: () => getAriaLevel,
    getAriaPosInSet: () => getAriaPosInSet,
    getAriaSortState: () => getAriaSortState,
    removeAriaExpanded: () => removeAriaExpanded,
    removeAriaSort: () => removeAriaSort,
    setAriaActiveDescendant: () => setAriaActiveDescendant,
    setAriaAtomic: () => setAriaAtomic,
    setAriaChecked: () => setAriaChecked,
    setAriaColCount: () => setAriaColCount,
    setAriaColIndex: () => setAriaColIndex,
    setAriaColSpan: () => setAriaColSpan,
    setAriaControls: () => setAriaControls,
    setAriaDescribedBy: () => setAriaDescribedBy,
    setAriaDisabled: () => setAriaDisabled,
    setAriaExpanded: () => setAriaExpanded,
    setAriaHidden: () => setAriaHidden,
    setAriaLabel: () => setAriaLabel,
    setAriaLabelledBy: () => setAriaLabelledBy,
    setAriaLevel: () => setAriaLevel,
    setAriaLive: () => setAriaLive,
    setAriaMultiSelectable: () => setAriaMultiSelectable,
    setAriaPosInSet: () => setAriaPosInSet,
    setAriaRelevant: () => setAriaRelevant,
    setAriaRole: () => setAriaRole,
    setAriaRowCount: () => setAriaRowCount,
    setAriaRowIndex: () => setAriaRowIndex,
    setAriaSelected: () => setAriaSelected,
    setAriaSetSize: () => setAriaSetSize,
    setAriaSort: () => setAriaSort
  });
  function toggleAriaAttribute(element, attribute, value) {
    if (value == null || typeof value === "string" && value == "") {
      removeAriaAttribute(element, attribute);
    } else {
      setAriaAttribute(element, attribute, value);
    }
  }
  function setAriaAttribute(element, attribute, value) {
    element.setAttribute(ariaAttributeName(attribute), value.toString());
  }
  function removeAriaAttribute(element, attribute) {
    element.removeAttribute(ariaAttributeName(attribute));
  }
  function ariaAttributeName(attribute) {
    return `aria-${attribute}`;
  }
  function setAriaRole(element, role) {
    if (role) {
      element.setAttribute("role", role);
    } else {
      element.removeAttribute("role");
    }
  }
  function getAriaSortState(sortDirection) {
    let sort;
    if (sortDirection === "asc") {
      sort = "ascending";
    } else if (sortDirection === "desc") {
      sort = "descending";
    } else if (sortDirection === "mixed") {
      sort = "other";
    } else {
      sort = "none";
    }
    return sort;
  }
  function getAriaLevel(element) {
    return parseInt(element.getAttribute("aria-level"), 10);
  }
  function getAriaPosInSet(element) {
    return parseInt(element.getAttribute("aria-posinset"), 10);
  }
  function getAriaLabel(element) {
    return element.getAttribute("aria-label");
  }
  function setAriaLabel(element, label) {
    toggleAriaAttribute(element, "label", label);
  }
  function setAriaLabelledBy(element, labelledBy) {
    toggleAriaAttribute(element, "labelledby", labelledBy);
  }
  function setAriaDescribedBy(element, describedby) {
    toggleAriaAttribute(element, "describedby", describedby);
  }
  function setAriaLive(element, live) {
    toggleAriaAttribute(element, "live", live);
  }
  function setAriaAtomic(element, atomic) {
    toggleAriaAttribute(element, "atomic", atomic);
  }
  function setAriaRelevant(element, relevant) {
    toggleAriaAttribute(element, "relevant", relevant);
  }
  function setAriaLevel(element, level) {
    toggleAriaAttribute(element, "level", level);
  }
  function setAriaDisabled(element, disabled) {
    toggleAriaAttribute(element, "disabled", disabled);
  }
  function setAriaHidden(element, hidden) {
    toggleAriaAttribute(element, "hidden", hidden);
  }
  function setAriaActiveDescendant(element, descendantId) {
    toggleAriaAttribute(element, "activedescendant", descendantId);
  }
  function setAriaExpanded(element, expanded) {
    setAriaAttribute(element, "expanded", expanded);
  }
  function removeAriaExpanded(element) {
    removeAriaAttribute(element, "expanded");
  }
  function setAriaSetSize(element, setsize) {
    setAriaAttribute(element, "setsize", setsize);
  }
  function setAriaPosInSet(element, position) {
    setAriaAttribute(element, "posinset", position);
  }
  function setAriaMultiSelectable(element, multiSelectable) {
    setAriaAttribute(element, "multiselectable", multiSelectable);
  }
  function setAriaRowCount(element, rowCount) {
    setAriaAttribute(element, "rowcount", rowCount);
  }
  function setAriaRowIndex(element, rowIndex) {
    setAriaAttribute(element, "rowindex", rowIndex);
  }
  function setAriaColCount(element, colCount) {
    setAriaAttribute(element, "colcount", colCount);
  }
  function setAriaColIndex(element, colIndex) {
    setAriaAttribute(element, "colindex", colIndex);
  }
  function setAriaColSpan(element, colSpan) {
    setAriaAttribute(element, "colspan", colSpan);
  }
  function setAriaSort(element, sort) {
    setAriaAttribute(element, "sort", sort);
  }
  function removeAriaSort(element) {
    removeAriaAttribute(element, "sort");
  }
  function setAriaSelected(element, selected) {
    toggleAriaAttribute(element, "selected", selected);
  }
  function setAriaChecked(element, checked) {
    setAriaAttribute(element, "checked", checked === void 0 ? "mixed" : checked);
  }
  function setAriaControls(controllerElement, controlledElement) {
    toggleAriaAttribute(controllerElement, "controls", controlledElement.id);
    setAriaLabelledBy(controlledElement, controllerElement.id);
  }
  function getAriaCheckboxStateName(translate, state) {
    return state === void 0 ? translate("ariaIndeterminate", "indeterminate") : state === true ? translate("ariaChecked", "checked") : translate("ariaUnchecked", "unchecked");
  }
  var browser_exports = {};
  __export2(browser_exports, {
    browserSupportsPreventScroll: () => browserSupportsPreventScroll,
    getBodyHeight: () => getBodyHeight,
    getBodyWidth: () => getBodyWidth,
    getMaxDivHeight: () => getMaxDivHeight,
    getSafariVersion: () => getSafariVersion,
    getScrollbarWidth: () => getScrollbarWidth,
    getTabIndex: () => getTabIndex,
    isBrowserChrome: () => isBrowserChrome,
    isBrowserFirefox: () => isBrowserFirefox,
    isBrowserSafari: () => isBrowserSafari,
    isIOSUserAgent: () => isIOSUserAgent,
    isInvisibleScrollbar: () => isInvisibleScrollbar,
    isMacOsUserAgent: () => isMacOsUserAgent
  });
  var isSafari;
  var safariVersion;
  var isChrome;
  var isFirefox;
  var isMacOs;
  var isIOS;
  var invisibleScrollbar;
  var browserScrollbarWidth;
  function isBrowserSafari() {
    if (isSafari === void 0) {
      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    }
    return isSafari;
  }
  function getSafariVersion() {
    if (safariVersion === void 0) {
      if (isBrowserSafari()) {
        const versionMatch = navigator.userAgent.match(/version\/(\d+)/i);
        if (versionMatch) {
          safariVersion = versionMatch[1] != null ? parseFloat(versionMatch[1]) : 0;
        }
      } else {
        safariVersion = 0;
      }
    }
    return safariVersion;
  }
  function isBrowserChrome() {
    if (isChrome === void 0) {
      const win = window;
      isChrome = !!win.chrome && (!!win.chrome.webstore || !!win.chrome.runtime) || /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    }
    return isChrome;
  }
  function isBrowserFirefox() {
    if (isFirefox === void 0) {
      isFirefox = /(firefox)/i.test(navigator.userAgent);
    }
    return isFirefox;
  }
  function isMacOsUserAgent() {
    if (isMacOs === void 0) {
      isMacOs = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
    }
    return isMacOs;
  }
  function isIOSUserAgent() {
    if (isIOS === void 0) {
      isIOS = /iPad|iPhone|iPod/.test(navigator.platform) || // eslint-disable-next-line
      navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
    }
    return isIOS;
  }
  function browserSupportsPreventScroll() {
    return !isBrowserSafari() || getSafariVersion() >= 15;
  }
  function getTabIndex(el) {
    if (!el) {
      return null;
    }
    const numberTabIndex = el.tabIndex;
    const tabIndex = el.getAttribute("tabIndex");
    if (numberTabIndex === -1 && (tabIndex === null || tabIndex === "" && !isBrowserFirefox())) {
      return null;
    }
    return numberTabIndex.toString();
  }
  function getMaxDivHeight() {
    if (!document.body) {
      return -1;
    }
    let res = 1e6;
    const testUpTo = navigator.userAgent.toLowerCase().match(/firefox/) ? 6e6 : 1e9;
    const div = document.createElement("div");
    document.body.appendChild(div);
    while (true) {
      const test = res * 2;
      div.style.height = test + "px";
      if (test > testUpTo || div.clientHeight !== test) {
        break;
      } else {
        res = test;
      }
    }
    document.body.removeChild(div);
    return res;
  }
  function getBodyWidth() {
    var _a, _b, _c;
    return (_c = (_a = document.body) == null ? void 0 : _a.clientWidth) != null ? _c : window.innerHeight || ((_b = document.documentElement) == null ? void 0 : _b.clientWidth) || -1;
  }
  function getBodyHeight() {
    var _a, _b, _c;
    return (_c = (_a = document.body) == null ? void 0 : _a.clientHeight) != null ? _c : window.innerHeight || ((_b = document.documentElement) == null ? void 0 : _b.clientHeight) || -1;
  }
  function getScrollbarWidth() {
    if (browserScrollbarWidth == null) {
      initScrollbarWidthAndVisibility();
    }
    return browserScrollbarWidth;
  }
  function initScrollbarWidthAndVisibility() {
    const body = document.body;
    const div = document.createElement("div");
    div.style.width = div.style.height = "100px";
    div.style.opacity = "0";
    div.style.overflow = "scroll";
    div.style.msOverflowStyle = "scrollbar";
    div.style.position = "absolute";
    body.appendChild(div);
    let width = div.offsetWidth - div.clientWidth;
    if (width === 0 && div.clientWidth === 0) {
      width = null;
    }
    if (div.parentNode) {
      div.parentNode.removeChild(div);
    }
    if (width != null) {
      browserScrollbarWidth = width;
      invisibleScrollbar = width === 0;
    }
  }
  function isInvisibleScrollbar() {
    if (invisibleScrollbar == null) {
      initScrollbarWidthAndVisibility();
    }
    return invisibleScrollbar;
  }
  var date_exports = {};
  __export2(date_exports, {
    dateToFormattedString: () => dateToFormattedString,
    parseDateTimeFromString: () => parseDateTimeFromString,
    serialiseDate: () => serialiseDate
  });
  var number_exports = {};
  __export2(number_exports, {
    cleanNumber: () => cleanNumber,
    createArrayOfNumbers: () => createArrayOfNumbers,
    decToHex: () => decToHex,
    formatNumberCommas: () => formatNumberCommas,
    formatNumberTwoDecimalPlacesAndCommas: () => formatNumberTwoDecimalPlacesAndCommas,
    padStartWidthZeros: () => padStartWidthZeros,
    sum: () => sum
  });
  function padStartWidthZeros(value, totalStringSize) {
    return value.toString().padStart(totalStringSize, "0");
  }
  function createArrayOfNumbers(first, last2) {
    const result = [];
    for (let i = first; i <= last2; i++) {
      result.push(i);
    }
    return result;
  }
  function cleanNumber(value) {
    if (typeof value === "string") {
      value = parseInt(value, 10);
    }
    if (typeof value === "number") {
      return Math.floor(value);
    }
    return null;
  }
  function decToHex(number, bytes) {
    let hex = "";
    for (let i = 0; i < bytes; i++) {
      hex += String.fromCharCode(number & 255);
      number >>>= 8;
    }
    return hex;
  }
  function formatNumberTwoDecimalPlacesAndCommas(value, thousandSeparator, decimalSeparator) {
    if (typeof value !== "number") {
      return "";
    }
    return formatNumberCommas(Math.round(value * 100) / 100, thousandSeparator, decimalSeparator);
  }
  function formatNumberCommas(value, thousandSeparator, decimalSeparator) {
    if (typeof value !== "number") {
      return "";
    }
    return value.toString().replace(".", decimalSeparator).replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${thousandSeparator}`);
  }
  function sum(values2) {
    return values2 == null ? null : values2.reduce((total, value) => total + value, 0);
  }
  function serialiseDate(date, includeTime = true, separator = "-") {
    if (!date) {
      return null;
    }
    let serialised = [date.getFullYear(), date.getMonth() + 1, date.getDate()].map((part) => padStartWidthZeros(part, 2)).join(separator);
    if (includeTime) {
      serialised += " " + [date.getHours(), date.getMinutes(), date.getSeconds()].map((part) => padStartWidthZeros(part, 2)).join(":");
    }
    return serialised;
  }
  var calculateOrdinal = (value) => {
    if (value > 3 && value < 21) {
      return "th";
    }
    const remainder = value % 10;
    switch (remainder) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
    }
    return "th";
  };
  function dateToFormattedString(date, format = "YYYY-MM-DD") {
    const fullYear = padStartWidthZeros(date.getFullYear(), 4);
    const months = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    const days = [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ];
    const replace = {
      YYYY: () => fullYear.slice(fullYear.length - 4, fullYear.length),
      YY: () => fullYear.slice(fullYear.length - 2, fullYear.length),
      Y: () => `${date.getFullYear()}`,
      MMMM: () => months[date.getMonth()],
      MMM: () => months[date.getMonth()].slice(0, 3),
      MM: () => padStartWidthZeros(date.getMonth() + 1, 2),
      Mo: () => `${date.getMonth() + 1}${calculateOrdinal(date.getMonth() + 1)}`,
      M: () => `${date.getMonth() + 1}`,
      Do: () => `${date.getDate()}${calculateOrdinal(date.getDate())}`,
      DD: () => padStartWidthZeros(date.getDate(), 2),
      D: () => `${date.getDate()}`,
      dddd: () => days[date.getDay()],
      ddd: () => days[date.getDay()].slice(0, 3),
      dd: () => days[date.getDay()].slice(0, 2),
      do: () => `${date.getDay()}${calculateOrdinal(date.getDay())}`,
      d: () => `${date.getDay()}`
    };
    const regexp = new RegExp(Object.keys(replace).join("|"), "g");
    return format.replace(regexp, (match) => {
      if (match in replace) {
        return replace[match]();
      }
      return match;
    });
  }
  function parseDateTimeFromString(value) {
    if (!value) {
      return null;
    }
    const [dateStr, timeStr] = value.split(" ");
    if (!dateStr) {
      return null;
    }
    const fields = dateStr.split("-").map((f) => parseInt(f, 10));
    if (fields.filter((f) => !isNaN(f)).length !== 3) {
      return null;
    }
    const [year, month, day] = fields;
    const date = new Date(year, month - 1, day);
    if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {
      return null;
    }
    if (!timeStr || timeStr === "00:00:00") {
      return date;
    }
    const [hours, minutes, seconds] = timeStr.split(":").map((part) => parseInt(part, 10));
    if (hours >= 0 && hours < 24) {
      date.setHours(hours);
    }
    if (minutes >= 0 && minutes < 60) {
      date.setMinutes(minutes);
    }
    if (seconds >= 0 && seconds < 60) {
      date.setSeconds(seconds);
    }
    return date;
  }
  var dom_exports = {};
  __export2(dom_exports, {
    FOCUSABLE_EXCLUDE: () => FOCUSABLE_EXCLUDE,
    FOCUSABLE_SELECTOR: () => FOCUSABLE_SELECTOR,
    addOrRemoveAttribute: () => addOrRemoveAttribute,
    addStylesToElement: () => addStylesToElement,
    bindCellRendererToHtmlElement: () => bindCellRendererToHtmlElement,
    clearElement: () => clearElement,
    copyNodeList: () => copyNodeList,
    ensureDomOrder: () => ensureDomOrder,
    formatSize: () => formatSize,
    getAbsoluteHeight: () => getAbsoluteHeight,
    getAbsoluteWidth: () => getAbsoluteWidth,
    getElementRectWithOffset: () => getElementRectWithOffset,
    getElementSize: () => getElementSize,
    getInnerHeight: () => getInnerHeight,
    getInnerWidth: () => getInnerWidth,
    getScrollLeft: () => getScrollLeft,
    insertWithDomOrder: () => insertWithDomOrder,
    isElementChildOfClass: () => isElementChildOfClass,
    isFocusableFormField: () => isFocusableFormField,
    isHorizontalScrollShowing: () => isHorizontalScrollShowing,
    isInDOM: () => isInDOM,
    isNodeOrElement: () => isNodeOrElement,
    isRtlNegativeScroll: () => isRtlNegativeScroll,
    isVerticalScrollShowing: () => isVerticalScrollShowing,
    isVisible: () => isVisible,
    iterateNamedNodeMap: () => iterateNamedNodeMap,
    loadTemplate: () => loadTemplate,
    nodeListForEach: () => nodeListForEach,
    radioCssClass: () => radioCssClass,
    removeFromParent: () => removeFromParent,
    setDisabled: () => setDisabled,
    setDisplayed: () => setDisplayed,
    setDomChildOrder: () => setDomChildOrder,
    setElementHeight: () => setElementHeight,
    setElementWidth: () => setElementWidth,
    setFixedHeight: () => setFixedHeight,
    setFixedWidth: () => setFixedWidth,
    setScrollLeft: () => setScrollLeft,
    setVisible: () => setVisible
  });
  var rtlNegativeScroll;
  function radioCssClass(element, elementClass, otherElementClass) {
    const parent = element.parentElement;
    let sibling = parent && parent.firstChild;
    while (sibling) {
      if (elementClass) {
        sibling.classList.toggle(elementClass, sibling === element);
      }
      if (otherElementClass) {
        sibling.classList.toggle(otherElementClass, sibling !== element);
      }
      sibling = sibling.nextSibling;
    }
  }
  var FOCUSABLE_SELECTOR = "[tabindex], input, select, button, textarea, [href]";
  var FOCUSABLE_EXCLUDE = "[disabled], .ag-disabled:not(.ag-button), .ag-disabled *";
  function isFocusableFormField(element) {
    const matches2 = Element.prototype.matches || Element.prototype.msMatchesSelector;
    const inputSelector = "input, select, button, textarea";
    const isFocusable = matches2.call(element, inputSelector);
    const isNotFocusable = matches2.call(element, FOCUSABLE_EXCLUDE);
    const isElementVisible = isVisible(element);
    const focusable = isFocusable && !isNotFocusable && isElementVisible;
    return focusable;
  }
  function setDisplayed(element, displayed, options = {}) {
    const { skipAriaHidden } = options;
    element.classList.toggle("ag-hidden", !displayed);
    if (!skipAriaHidden) {
      setAriaHidden(element, !displayed);
    }
  }
  function setVisible(element, visible, options = {}) {
    const { skipAriaHidden } = options;
    element.classList.toggle("ag-invisible", !visible);
    if (!skipAriaHidden) {
      setAriaHidden(element, !visible);
    }
  }
  function setDisabled(element, disabled) {
    const attributeName = "disabled";
    const addOrRemoveDisabledAttribute = disabled ? (e) => e.setAttribute(attributeName, "") : (e) => e.removeAttribute(attributeName);
    addOrRemoveDisabledAttribute(element);
    nodeListForEach(element.querySelectorAll("input"), (input) => addOrRemoveDisabledAttribute(input));
  }
  function isElementChildOfClass(element, cls, maxNest) {
    let counter = 0;
    while (element) {
      if (element.classList.contains(cls)) {
        return true;
      }
      element = element.parentElement;
      if (typeof maxNest == "number") {
        if (++counter > maxNest) {
          break;
        }
      } else if (element === maxNest) {
        break;
      }
    }
    return false;
  }
  function getElementSize(el) {
    const {
      height,
      width,
      borderTopWidth,
      borderRightWidth,
      borderBottomWidth,
      borderLeftWidth,
      paddingTop,
      paddingRight,
      paddingBottom,
      paddingLeft,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      boxSizing
    } = window.getComputedStyle(el);
    return {
      height: parseFloat(height || "0"),
      width: parseFloat(width || "0"),
      borderTopWidth: parseFloat(borderTopWidth || "0"),
      borderRightWidth: parseFloat(borderRightWidth || "0"),
      borderBottomWidth: parseFloat(borderBottomWidth || "0"),
      borderLeftWidth: parseFloat(borderLeftWidth || "0"),
      paddingTop: parseFloat(paddingTop || "0"),
      paddingRight: parseFloat(paddingRight || "0"),
      paddingBottom: parseFloat(paddingBottom || "0"),
      paddingLeft: parseFloat(paddingLeft || "0"),
      marginTop: parseFloat(marginTop || "0"),
      marginRight: parseFloat(marginRight || "0"),
      marginBottom: parseFloat(marginBottom || "0"),
      marginLeft: parseFloat(marginLeft || "0"),
      boxSizing
    };
  }
  function getInnerHeight(el) {
    const size2 = getElementSize(el);
    if (size2.boxSizing === "border-box") {
      return size2.height - size2.paddingTop - size2.paddingBottom;
    }
    return size2.height;
  }
  function getInnerWidth(el) {
    const size2 = getElementSize(el);
    if (size2.boxSizing === "border-box") {
      return size2.width - size2.paddingLeft - size2.paddingRight;
    }
    return size2.width;
  }
  function getAbsoluteHeight(el) {
    const size2 = getElementSize(el);
    const marginRight = size2.marginBottom + size2.marginTop;
    return Math.ceil(el.offsetHeight + marginRight);
  }
  function getAbsoluteWidth(el) {
    const size2 = getElementSize(el);
    const marginWidth = size2.marginLeft + size2.marginRight;
    return Math.ceil(el.offsetWidth + marginWidth);
  }
  function getElementRectWithOffset(el) {
    const offsetElementRect = el.getBoundingClientRect();
    const { borderTopWidth, borderLeftWidth, borderRightWidth, borderBottomWidth } = getElementSize(el);
    return {
      top: offsetElementRect.top + (borderTopWidth || 0),
      left: offsetElementRect.left + (borderLeftWidth || 0),
      right: offsetElementRect.right + (borderRightWidth || 0),
      bottom: offsetElementRect.bottom + (borderBottomWidth || 0)
    };
  }
  function isRtlNegativeScroll() {
    if (typeof rtlNegativeScroll === "boolean") {
      return rtlNegativeScroll;
    }
    const template = document.createElement("div");
    template.style.direction = "rtl";
    template.style.width = "1px";
    template.style.height = "1px";
    template.style.position = "fixed";
    template.style.top = "0px";
    template.style.overflow = "hidden";
    template.dir = "rtl";
    template.innerHTML = /* html */
    `<div style="width: 2px">
            <span style="display: inline-block; width: 1px"></span>
            <span style="display: inline-block; width: 1px"></span>
        </div>`;
    document.body.appendChild(template);
    template.scrollLeft = 1;
    rtlNegativeScroll = Math.floor(template.scrollLeft) === 0;
    document.body.removeChild(template);
    return rtlNegativeScroll;
  }
  function getScrollLeft(element, rtl) {
    let scrollLeft = element.scrollLeft;
    if (rtl) {
      scrollLeft = Math.abs(scrollLeft);
      if (isBrowserChrome() && !isRtlNegativeScroll()) {
        scrollLeft = element.scrollWidth - element.clientWidth - scrollLeft;
      }
    }
    return scrollLeft;
  }
  function setScrollLeft(element, value, rtl) {
    if (rtl) {
      if (isRtlNegativeScroll()) {
        value *= -1;
      } else if (isBrowserSafari() || isBrowserChrome()) {
        value = element.scrollWidth - element.clientWidth - value;
      }
    }
    element.scrollLeft = value;
  }
  function clearElement(el) {
    while (el && el.firstChild) {
      el.removeChild(el.firstChild);
    }
  }
  function removeFromParent(node) {
    if (node && node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  function isInDOM(element) {
    return !!element.offsetParent;
  }
  function isVisible(element) {
    const el = element;
    if (el.checkVisibility) {
      return el.checkVisibility({ checkVisibilityCSS: true });
    }
    const isHidden = !isInDOM(element) || window.getComputedStyle(element).visibility !== "visible";
    return !isHidden;
  }
  function loadTemplate(template) {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = (template || "").trim();
    return tempDiv.firstChild;
  }
  function ensureDomOrder(eContainer, eChild, eChildBefore) {
    if (eChildBefore && eChildBefore.nextSibling === eChild) {
      return;
    }
    if (eChildBefore) {
      if (eChildBefore.nextSibling) {
        eContainer.insertBefore(eChild, eChildBefore.nextSibling);
      } else {
        eContainer.appendChild(eChild);
      }
    } else {
      if (eContainer.firstChild && eContainer.firstChild !== eChild) {
        eContainer.insertAdjacentElement("afterbegin", eChild);
      }
    }
  }
  function setDomChildOrder(eContainer, orderedChildren) {
    for (let i = 0; i < orderedChildren.length; i++) {
      const correctCellAtIndex = orderedChildren[i];
      const actualCellAtIndex = eContainer.children[i];
      if (actualCellAtIndex !== correctCellAtIndex) {
        eContainer.insertBefore(correctCellAtIndex, actualCellAtIndex);
      }
    }
  }
  function insertWithDomOrder(eContainer, eToInsert, eChildBefore) {
    if (eChildBefore) {
      eChildBefore.insertAdjacentElement("afterend", eToInsert);
    } else {
      if (eContainer.firstChild) {
        eContainer.insertAdjacentElement("afterbegin", eToInsert);
      } else {
        eContainer.appendChild(eToInsert);
      }
    }
  }
  function addStylesToElement(eElement, styles) {
    if (!styles) {
      return;
    }
    for (const [key, value] of Object.entries(styles)) {
      if (!key || !key.length || value == null) {
        continue;
      }
      const parsedKey = camelCaseToHyphenated(key);
      const valueAsString = value.toString();
      const parsedValue = valueAsString.replace(/\s*!important/g, "");
      const priority = parsedValue.length != valueAsString.length ? "important" : void 0;
      eElement.style.setProperty(parsedKey, parsedValue, priority);
    }
  }
  function isHorizontalScrollShowing(element) {
    return element.clientWidth < element.scrollWidth;
  }
  function isVerticalScrollShowing(element) {
    return element.clientHeight < element.scrollHeight;
  }
  function setElementWidth(element, width) {
    if (width === "flex") {
      element.style.removeProperty("width");
      element.style.removeProperty("minWidth");
      element.style.removeProperty("maxWidth");
      element.style.flex = "1 1 auto";
    } else {
      setFixedWidth(element, width);
    }
  }
  function setFixedWidth(element, width) {
    width = formatSize(width);
    element.style.width = width.toString();
    element.style.maxWidth = width.toString();
    element.style.minWidth = width.toString();
  }
  function setElementHeight(element, height) {
    if (height === "flex") {
      element.style.removeProperty("height");
      element.style.removeProperty("minHeight");
      element.style.removeProperty("maxHeight");
      element.style.flex = "1 1 auto";
    } else {
      setFixedHeight(element, height);
    }
  }
  function setFixedHeight(element, height) {
    height = formatSize(height);
    element.style.height = height.toString();
    element.style.maxHeight = height.toString();
    element.style.minHeight = height.toString();
  }
  function formatSize(size2) {
    if (typeof size2 === "number") {
      return `${size2}px`;
    }
    return size2;
  }
  function isNodeOrElement(o) {
    return o instanceof Node || o instanceof HTMLElement;
  }
  function copyNodeList(nodeList) {
    if (nodeList == null) {
      return [];
    }
    const result = [];
    nodeListForEach(nodeList, (node) => result.push(node));
    return result;
  }
  function iterateNamedNodeMap(map2, callback) {
    if (!map2) {
      return;
    }
    for (let i = 0; i < map2.length; i++) {
      const attr = map2[i];
      callback(attr.name, attr.value);
    }
  }
  function addOrRemoveAttribute(element, name, value) {
    if (value == null) {
      element.removeAttribute(name);
    } else {
      element.setAttribute(name, value.toString());
    }
  }
  function nodeListForEach(nodeList, action) {
    if (nodeList == null) {
      return;
    }
    for (let i = 0; i < nodeList.length; i++) {
      action(nodeList[i]);
    }
  }
  function bindCellRendererToHtmlElement(cellRendererPromise, eTarget) {
    cellRendererPromise.then((cellRenderer) => {
      const gui = cellRenderer.getGui();
      if (gui != null) {
        if (typeof gui === "object") {
          eTarget.appendChild(gui);
        } else {
          eTarget.innerHTML = gui;
        }
      }
    });
  }
  var fuzzyMatch_exports = {};
  __export2(fuzzyMatch_exports, {
    fuzzyCheckStrings: () => fuzzyCheckStrings,
    fuzzySuggestions: () => fuzzySuggestions
  });
  function fuzzyCheckStrings(inputValues, validValues, allSuggestions) {
    const fuzzyMatches = {};
    const invalidInputs = inputValues.filter(
      (inputValue) => !validValues.some(
        (validValue) => validValue === inputValue
      )
    );
    if (invalidInputs.length > 0) {
      invalidInputs.forEach(
        (invalidInput) => fuzzyMatches[invalidInput] = fuzzySuggestions(invalidInput, allSuggestions).values
      );
    }
    return fuzzyMatches;
  }
  function fuzzySuggestions(inputValue, allSuggestions, hideIrrelevant, filterByPercentageOfBestMatch) {
    let thisSuggestions = allSuggestions.map((text, idx) => ({
      value: text,
      relevance: stringWeightedDistances(inputValue.toLowerCase(), text.toLocaleLowerCase()),
      idx
    }));
    thisSuggestions.sort((a, b) => b.relevance - a.relevance);
    if (hideIrrelevant) {
      thisSuggestions = thisSuggestions.filter((suggestion) => suggestion.relevance !== 0);
    }
    if (thisSuggestions.length > 0 && filterByPercentageOfBestMatch && filterByPercentageOfBestMatch > 0) {
      const bestMatch = thisSuggestions[0].relevance;
      const limit = bestMatch * filterByPercentageOfBestMatch;
      thisSuggestions = thisSuggestions.filter((suggestion) => limit - suggestion.relevance < 0);
    }
    const values2 = [];
    const indices = [];
    for (const suggestion of thisSuggestions) {
      values2.push(suggestion.value);
      indices.push(suggestion.idx);
    }
    return { values: values2, indices };
  }
  function stringWeightedDistances(str1, str2) {
    const a = str1.replace(/\s/g, "");
    const b = str2.replace(/\s/g, "");
    let weight = 0;
    let lastIndex = -1;
    for (let i = 0; i < a.length; i++) {
      const idx = b.indexOf(a[i], lastIndex + 1);
      if (idx === -1) {
        continue;
      }
      lastIndex = idx;
      weight += 100 - lastIndex * 100 / 1e4 * 100;
    }
    return weight;
  }
  var icon_exports = {};
  __export2(icon_exports, {
    createIcon: () => createIcon,
    createIconNoSpan: () => createIconNoSpan,
    iconNameClassMap: () => iconNameClassMap
  });
  var iconNameClassMap = {
    // header column group shown when expanded (click to contract)
    columnGroupOpened: "expanded",
    // header column group shown when contracted (click to expand)
    columnGroupClosed: "contracted",
    // tool panel column group contracted (click to expand)
    columnSelectClosed: "tree-closed",
    // tool panel column group expanded (click to contract)
    columnSelectOpen: "tree-open",
    // column tool panel header expand/collapse all button, shown when some children are expanded and
    //     others are collapsed
    columnSelectIndeterminate: "tree-indeterminate",
    // shown on ghost icon while dragging column to the side of the grid to pin
    columnMovePin: "pin",
    // shown on ghost icon while dragging over part of the page that is not a drop zone
    columnMoveHide: "eye-slash",
    // shown on ghost icon while dragging columns to reorder
    columnMoveMove: "arrows",
    // animating icon shown when dragging a column to the right of the grid causes horizontal scrolling
    columnMoveLeft: "left",
    // animating icon shown when dragging a column to the left of the grid causes horizontal scrolling
    columnMoveRight: "right",
    // shown on ghost icon while dragging over Row Groups drop zone
    columnMoveGroup: "group",
    // shown on ghost icon while dragging over Values drop zone
    columnMoveValue: "aggregation",
    // shown on ghost icon while dragging over pivot drop zone
    columnMovePivot: "pivot",
    // shown on ghost icon while dragging over drop zone that doesn't support it, e.g.
    //     string column over aggregation drop zone
    dropNotAllowed: "not-allowed",
    // shown on row group when contracted (click to expand)
    groupContracted: "tree-closed",
    // shown on row group when expanded (click to contract)
    groupExpanded: "tree-open",
    // set filter tree list group contracted (click to expand)
    setFilterGroupClosed: "tree-closed",
    // set filter tree list group expanded (click to contract)
    setFilterGroupOpen: "tree-open",
    // set filter tree list expand/collapse all button, shown when some children are expanded and
    //     others are collapsed
    setFilterGroupIndeterminate: "tree-indeterminate",
    // context menu chart item
    chart: "chart",
    // chart window title bar
    close: "cross",
    // X (remove) on column 'pill' after adding it to a drop zone list
    cancel: "cancel",
    // indicates the currently active pin state in the "Pin column" sub-menu of the column menu
    check: "tick",
    // "go to first" button in pagination controls
    first: "first",
    // "go to previous" button in pagination controls
    previous: "previous",
    // "go to next" button in pagination controls
    next: "next",
    // "go to last" button in pagination controls
    last: "last",
    // shown on top right of chart when chart is linked to range data (click to unlink)
    linked: "linked",
    // shown on top right of chart when chart is not linked to range data (click to link)
    unlinked: "unlinked",
    // "Choose colour" button on chart settings tab
    colorPicker: "color-picker",
    // rotating spinner shown by the loading cell renderer
    groupLoading: "loading",
    // button to launch enterprise column menu
    menu: "menu",
    menuAlt: "menu-alt",
    // filter tool panel tab
    filter: "filter",
    // column tool panel tab
    columns: "columns",
    // button in chart regular size window title bar (click to maximise)
    maximize: "maximize",
    // button in chart maximised window title bar (click to make regular size)
    minimize: "minimize",
    // "Pin column" item in column header menu
    menuPin: "pin",
    // "Value aggregation" column menu item (shown on numeric columns when grouping is active)"
    menuValue: "aggregation",
    // "Group by {column-name}" item in column header menu
    menuAddRowGroup: "group",
    // "Un-Group by {column-name}" item in column header menu
    menuRemoveRowGroup: "group",
    // context menu copy item
    clipboardCopy: "copy",
    // context menu cut item
    clipboardCut: "cut",
    // context menu paste item
    clipboardPaste: "paste",
    // identifies the pivot drop zone
    pivotPanel: "pivot",
    // "Row groups" drop zone in column tool panel
    rowGroupPanel: "group",
    // columns tool panel Values drop zone
    valuePanel: "aggregation",
    // drag handle used to pick up draggable columns
    columnDrag: "grip",
    // drag handle used to pick up draggable rows
    rowDrag: "grip",
    // context menu export item
    save: "save",
    // csv export
    csvExport: "csv",
    // excel export,
    excelExport: "excel",
    // icon on dropdown editors
    smallDown: "small-down",
    // version of small-right used in RTL mode
    smallLeft: "small-left",
    // separater between column 'pills' when you add multiple columns to the header drop zone
    smallRight: "small-right",
    smallUp: "small-up",
    // show on column header when column is sorted ascending
    sortAscending: "asc",
    // show on column header when column is sorted descending
    sortDescending: "desc",
    // show on column header when column has no sort, only when enabled with gridOptions.unSortIcon=true
    sortUnSort: "none",
    // Builder button in Advanced Filter
    advancedFilterBuilder: "group",
    // drag handle used to pick up Advanced Filter Builder rows
    advancedFilterBuilderDrag: "grip",
    // Advanced Filter Builder row validation error
    advancedFilterBuilderInvalid: "not-allowed",
    // shown on Advanced Filter Builder rows to move them up
    advancedFilterBuilderMoveUp: "up",
    // shown on Advanced Filter Builder rows to move them down
    advancedFilterBuilderMoveDown: "down",
    // shown on Advanced Filter Builder rows to add new rows
    advancedFilterBuilderAdd: "plus",
    // shown on Advanced Filter Builder rows to remove row
    advancedFilterBuilderRemove: "minus",
    // Edit Chart menu item shown in Integrated Charts menu
    chartsMenuEdit: "chart",
    // Advanced Settings menu item shown in Integrated Charts menu
    chartsMenuAdvancedSettings: "settings",
    // shown in Integrated Charts menu add fields
    chartsMenuAdd: "plus"
  };
  function createIcon(iconName, gos, column) {
    const iconContents = createIconNoSpan(iconName, gos, column);
    if (iconContents) {
      const { className } = iconContents;
      if (typeof className === "string" && className.indexOf("ag-icon") > -1 || typeof className === "object" && className["ag-icon"]) {
        return iconContents;
      }
    }
    const eResult = document.createElement("span");
    eResult.appendChild(iconContents);
    return eResult;
  }
  function createIconNoSpan(iconName, gos, column, forceCreate) {
    let userProvidedIcon = null;
    const icons = column && column.getColDef().icons;
    if (icons) {
      userProvidedIcon = icons[iconName];
    }
    if (gos && !userProvidedIcon) {
      const optionsIcons = gos.get("icons");
      if (optionsIcons) {
        userProvidedIcon = optionsIcons[iconName];
      }
    }
    if (userProvidedIcon) {
      let rendererResult;
      if (typeof userProvidedIcon === "function") {
        rendererResult = userProvidedIcon();
      } else if (typeof userProvidedIcon === "string") {
        rendererResult = userProvidedIcon;
      } else {
        throw new Error("icon from grid options needs to be a string or a function");
      }
      if (typeof rendererResult === "string") {
        return loadTemplate(rendererResult);
      }
      if (isNodeOrElement(rendererResult)) {
        return rendererResult;
      }
      console.warn("AG Grid: iconRenderer should return back a string or a dom object");
    } else {
      const span = document.createElement("span");
      let cssClass = iconNameClassMap[iconName];
      if (!cssClass) {
        if (!forceCreate) {
          console.warn(`AG Grid: Did not find icon ${iconName}`);
          cssClass = "";
        } else {
          cssClass = iconName;
        }
      }
      span.setAttribute("class", `ag-icon ag-icon-${cssClass}`);
      span.setAttribute("unselectable", "on");
      setAriaRole(span, "presentation");
      return span;
    }
  }
  var keyboard_exports = {};
  __export2(keyboard_exports, {
    isDeleteKey: () => isDeleteKey,
    isEventFromPrintableCharacter: () => isEventFromPrintableCharacter,
    isUserSuppressingHeaderKeyboardEvent: () => isUserSuppressingHeaderKeyboardEvent,
    isUserSuppressingKeyboardEvent: () => isUserSuppressingKeyboardEvent,
    normaliseQwertyAzerty: () => normaliseQwertyAzerty
  });
  var KeyCode = class {
  };
  KeyCode.BACKSPACE = "Backspace";
  KeyCode.TAB = "Tab";
  KeyCode.ENTER = "Enter";
  KeyCode.ESCAPE = "Escape";
  KeyCode.SPACE = " ";
  KeyCode.LEFT = "ArrowLeft";
  KeyCode.UP = "ArrowUp";
  KeyCode.RIGHT = "ArrowRight";
  KeyCode.DOWN = "ArrowDown";
  KeyCode.DELETE = "Delete";
  KeyCode.F2 = "F2";
  KeyCode.PAGE_UP = "PageUp";
  KeyCode.PAGE_DOWN = "PageDown";
  KeyCode.PAGE_HOME = "Home";
  KeyCode.PAGE_END = "End";
  KeyCode.A = "KeyA";
  KeyCode.C = "KeyC";
  KeyCode.D = "KeyD";
  KeyCode.V = "KeyV";
  KeyCode.X = "KeyX";
  KeyCode.Y = "KeyY";
  KeyCode.Z = "KeyZ";
  var A_KEYCODE = 65;
  var C_KEYCODE = 67;
  var V_KEYCODE = 86;
  var D_KEYCODE = 68;
  var Z_KEYCODE = 90;
  var Y_KEYCODE = 89;
  function isEventFromPrintableCharacter(event) {
    if (event.altKey || event.ctrlKey || event.metaKey) {
      return false;
    }
    const printableCharacter = event.key.length === 1;
    return printableCharacter;
  }
  function isUserSuppressingKeyboardEvent(gos, keyboardEvent, rowNode, column, editing) {
    const colDefFunc = column ? column.getColDef().suppressKeyboardEvent : void 0;
    if (!colDefFunc) {
      return false;
    }
    const params = gos.addGridCommonParams({
      event: keyboardEvent,
      editing,
      column,
      node: rowNode,
      data: rowNode.data,
      colDef: column.getColDef()
    });
    if (colDefFunc) {
      const colDefFuncResult = colDefFunc(params);
      if (colDefFuncResult) {
        return true;
      }
    }
    return false;
  }
  function isUserSuppressingHeaderKeyboardEvent(gos, keyboardEvent, headerRowIndex, column) {
    const colDef = column.getDefinition();
    const colDefFunc = colDef && colDef.suppressHeaderKeyboardEvent;
    if (!exists(colDefFunc)) {
      return false;
    }
    const params = gos.addGridCommonParams({
      colDef,
      column,
      headerRowIndex,
      event: keyboardEvent
    });
    return !!colDefFunc(params);
  }
  function normaliseQwertyAzerty(keyboardEvent) {
    const { keyCode } = keyboardEvent;
    let code;
    switch (keyCode) {
      case A_KEYCODE:
        code = KeyCode.A;
        break;
      case C_KEYCODE:
        code = KeyCode.C;
        break;
      case V_KEYCODE:
        code = KeyCode.V;
        break;
      case D_KEYCODE:
        code = KeyCode.D;
        break;
      case Z_KEYCODE:
        code = KeyCode.Z;
        break;
      case Y_KEYCODE:
        code = KeyCode.Y;
        break;
      default:
        code = keyboardEvent.code;
    }
    return code;
  }
  function isDeleteKey(key, alwaysReturnFalseOnBackspace = false) {
    if (key === KeyCode.DELETE) {
      return true;
    }
    if (!alwaysReturnFalseOnBackspace && key === KeyCode.BACKSPACE) {
      return isMacOsUserAgent();
    }
    return false;
  }
  var mouse_exports = {};
  __export2(mouse_exports, {
    areEventsNear: () => areEventsNear
  });
  function areEventsNear(e1, e2, pixelCount) {
    if (pixelCount === 0) {
      return false;
    }
    const diffX = Math.abs(e1.clientX - e2.clientX);
    const diffY = Math.abs(e1.clientY - e2.clientY);
    return Math.max(diffX, diffY) <= pixelCount;
  }
  var rowNode_exports = {};
  __export2(rowNode_exports, {
    sortRowNodesByOrder: () => sortRowNodesByOrder
  });
  function sortRowNodesByOrder(rowNodes, rowNodeOrder) {
    if (!rowNodes) {
      return false;
    }
    const comparator2 = (nodeA, nodeB) => {
      const positionA = rowNodeOrder[nodeA.id];
      const positionB = rowNodeOrder[nodeB.id];
      const aHasIndex = positionA !== void 0;
      const bHasIndex = positionB !== void 0;
      const bothNodesAreUserNodes = aHasIndex && bHasIndex;
      const bothNodesAreFillerNodes = !aHasIndex && !bHasIndex;
      if (bothNodesAreUserNodes) {
        return positionA - positionB;
      }
      if (bothNodesAreFillerNodes) {
        return nodeA.__objectId - nodeB.__objectId;
      }
      if (aHasIndex) {
        return 1;
      }
      return -1;
    };
    let rowNodeA;
    let rowNodeB;
    let atLeastOneOutOfOrder = false;
    for (let i = 0; i < rowNodes.length - 1; i++) {
      rowNodeA = rowNodes[i];
      rowNodeB = rowNodes[i + 1];
      if (comparator2(rowNodeA, rowNodeB) > 0) {
        atLeastOneOutOfOrder = true;
        break;
      }
    }
    if (atLeastOneOutOfOrder) {
      rowNodes.sort(comparator2);
      return true;
    }
    return false;
  }
  var set_exports = {};
  __export2(set_exports, {
    convertToSet: () => convertToSet
  });
  function convertToSet(list) {
    const set2 = /* @__PURE__ */ new Set();
    list.forEach((x) => set2.add(x));
    return set2;
  }
  var utils = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, aria_exports), array_exports), browser_exports), date_exports), dom_exports), event_exports), function_exports), fuzzyMatch_exports), generic_exports), icon_exports), keyboard_exports), map_exports), mouse_exports), number_exports), object_exports), rowNode_exports), set_exports), string_exports);
  var _ = utils;
  var NumberSequence = class {
    constructor(initValue = 0, step = 1) {
      this.nextValue = initValue;
      this.step = step;
    }
    next() {
      const valToReturn = this.nextValue;
      this.nextValue += this.step;
      return valToReturn;
    }
    peek() {
      return this.nextValue;
    }
    skip(count) {
      this.nextValue += count;
    }
  };
  var AgPromiseStatus = /* @__PURE__ */ ((AgPromiseStatus2) => {
    AgPromiseStatus2[AgPromiseStatus2["IN_PROGRESS"] = 0] = "IN_PROGRESS";
    AgPromiseStatus2[AgPromiseStatus2["RESOLVED"] = 1] = "RESOLVED";
    return AgPromiseStatus2;
  })(AgPromiseStatus || {});
  var AgPromise = class _AgPromise {
    constructor(callback) {
      this.status = 0;
      this.resolution = null;
      this.waiters = [];
      callback((value) => this.onDone(value), (params) => this.onReject(params));
    }
    static all(promises) {
      return new _AgPromise((resolve2) => {
        let remainingToResolve = promises.length;
        const combinedValues = new Array(remainingToResolve);
        promises.forEach((promise, index) => {
          promise.then((value) => {
            combinedValues[index] = value;
            remainingToResolve--;
            if (remainingToResolve === 0) {
              resolve2(combinedValues);
            }
          });
        });
      });
    }
    static resolve(value = null) {
      return new _AgPromise((resolve2) => resolve2(value));
    }
    then(func) {
      return new _AgPromise((resolve2) => {
        if (this.status === 1) {
          resolve2(func(this.resolution));
        } else {
          this.waiters.push((value) => resolve2(func(value)));
        }
      });
    }
    resolveNow(ifNotResolvedValue, ifResolved) {
      return this.status === 1 ? ifResolved(this.resolution) : ifNotResolvedValue;
    }
    onDone(value) {
      this.status = 1;
      this.resolution = value;
      this.waiters.forEach((waiter) => waiter(value));
    }
    onReject(params) {
      console.warn("TBI");
    }
  };
  var Timer = class {
    constructor() {
      this.timestamp = (/* @__PURE__ */ new Date()).getTime();
    }
    print(msg) {
      const duration = (/* @__PURE__ */ new Date()).getTime() - this.timestamp;
      console.info(`${msg} = ${duration}`);
      this.timestamp = (/* @__PURE__ */ new Date()).getTime();
    }
  };
  var CssClassManager = class {
    constructor(getGui) {
      this.cssClassStates = {};
      this.getGui = getGui;
    }
    addCssClass(className) {
      const list = (className || "").split(" ");
      if (list.length > 1) {
        list.forEach((cls) => this.addCssClass(cls));
        return;
      }
      const updateNeeded = this.cssClassStates[className] !== true;
      if (updateNeeded && className.length) {
        const eGui = this.getGui();
        if (eGui) {
          eGui.classList.add(className);
        }
        this.cssClassStates[className] = true;
      }
    }
    removeCssClass(className) {
      const list = (className || "").split(" ");
      if (list.length > 1) {
        list.forEach((cls) => this.removeCssClass(cls));
        return;
      }
      const updateNeeded = this.cssClassStates[className] !== false;
      if (updateNeeded && className.length) {
        const eGui = this.getGui();
        if (eGui) {
          eGui.classList.remove(className);
        }
        this.cssClassStates[className] = false;
      }
    }
    containsCssClass(className) {
      const eGui = this.getGui();
      if (!eGui) {
        return false;
      }
      return eGui.classList.contains(className);
    }
    addOrRemoveCssClass(className, addOrRemove) {
      if (!className) {
        return;
      }
      if (className.indexOf(" ") >= 0) {
        const list = (className || "").split(" ");
        if (list.length > 1) {
          list.forEach((cls) => this.addOrRemoveCssClass(cls, addOrRemove));
          return;
        }
      }
      const updateNeeded = this.cssClassStates[className] !== addOrRemove;
      if (updateNeeded && className.length) {
        const eGui = this.getGui();
        if (eGui) {
          eGui.classList.toggle(className, addOrRemove);
        }
        this.cssClassStates[className] = addOrRemove;
      }
    }
  };
  var _TooltipStateManager = class _TooltipStateManager2 extends BeanStub {
    constructor(parentComp, tooltipShowDelayOverride, tooltipHideDelayOverride, shouldDisplayTooltip) {
      super();
      this.parentComp = parentComp;
      this.tooltipShowDelayOverride = tooltipShowDelayOverride;
      this.tooltipHideDelayOverride = tooltipHideDelayOverride;
      this.shouldDisplayTooltip = shouldDisplayTooltip;
      this.SHOW_QUICK_TOOLTIP_DIFF = 1e3;
      this.FADE_OUT_TOOLTIP_TIMEOUT = 1e3;
      this.INTERACTIVE_HIDE_DELAY = 100;
      this.interactionEnabled = false;
      this.isInteractingWithTooltip = false;
      this.state = 0;
      this.tooltipInstanceCount = 0;
      this.tooltipMouseTrack = false;
    }
    postConstruct() {
      if (this.gos.get("tooltipInteraction")) {
        this.interactionEnabled = true;
      }
      this.tooltipTrigger = this.getTooltipTrigger();
      this.tooltipMouseTrack = this.gos.get("tooltipMouseTrack");
      const el = this.parentComp.getGui();
      if (this.tooltipTrigger === 0) {
        this.addManagedListener(el, "mouseenter", this.onMouseEnter.bind(this));
        this.addManagedListener(el, "mouseleave", this.onMouseLeave.bind(this));
      }
      if (this.tooltipTrigger === 1) {
        this.addManagedListener(el, "focusin", this.onFocusIn.bind(this));
        this.addManagedListener(el, "focusout", this.onFocusOut.bind(this));
      }
      this.addManagedListener(el, "mousemove", this.onMouseMove.bind(this));
      if (!this.interactionEnabled) {
        this.addManagedListener(el, "mousedown", this.onMouseDown.bind(this));
        this.addManagedListener(el, "keydown", this.onKeyDown.bind(this));
      }
    }
    getGridOptionsTooltipDelay(delayOption) {
      const delay = this.gos.get(delayOption);
      if (delay < 0) {
        warnOnce(`${delayOption} should not be lower than 0`);
      }
      return Math.max(200, delay);
    }
    getTooltipDelay(type) {
      var _a, _b;
      if (type === "show") {
        return (_a = this.tooltipShowDelayOverride) != null ? _a : this.getGridOptionsTooltipDelay("tooltipShowDelay");
      }
      return (_b = this.tooltipHideDelayOverride) != null ? _b : this.getGridOptionsTooltipDelay("tooltipHideDelay");
    }
    destroy() {
      this.setToDoNothing();
      super.destroy();
    }
    getTooltipTrigger() {
      const trigger2 = this.gos.get("tooltipTrigger");
      if (!trigger2 || trigger2 === "hover") {
        return 0;
      }
      return 1;
    }
    onMouseEnter(e) {
      if (this.interactionEnabled && this.interactiveTooltipTimeoutId) {
        this.unlockService();
        this.startHideTimeout();
      }
      if (isIOSUserAgent()) {
        return;
      }
      if (_TooltipStateManager2.isLocked) {
        this.showTooltipTimeoutId = window.setTimeout(() => {
          this.prepareToShowTooltip(e);
        }, this.INTERACTIVE_HIDE_DELAY);
      } else {
        this.prepareToShowTooltip(e);
      }
    }
    onMouseMove(e) {
      if (this.lastMouseEvent) {
        this.lastMouseEvent = e;
      }
      if (this.tooltipMouseTrack && this.state === 2 && this.tooltipComp) {
        this.positionTooltip();
      }
    }
    onMouseDown() {
      this.setToDoNothing();
    }
    onMouseLeave() {
      if (this.interactionEnabled) {
        this.lockService();
      } else {
        this.setToDoNothing();
      }
    }
    onFocusIn() {
      this.prepareToShowTooltip();
    }
    onFocusOut(e) {
      var _a;
      const relatedTarget = e.relatedTarget;
      const parentCompGui = this.parentComp.getGui();
      const tooltipGui = (_a = this.tooltipComp) == null ? void 0 : _a.getGui();
      if (this.isInteractingWithTooltip || parentCompGui.contains(relatedTarget) || this.interactionEnabled && (tooltipGui == null ? void 0 : tooltipGui.contains(relatedTarget))) {
        return;
      }
      this.setToDoNothing();
    }
    onKeyDown() {
      this.setToDoNothing();
    }
    prepareToShowTooltip(mouseEvent) {
      if (this.state != 0 || _TooltipStateManager2.isLocked) {
        return;
      }
      let delay = 0;
      if (mouseEvent) {
        delay = this.isLastTooltipHiddenRecently() ? 200 : this.getTooltipDelay("show");
      }
      this.lastMouseEvent = mouseEvent || null;
      this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), delay);
      this.state = 1;
    }
    isLastTooltipHiddenRecently() {
      const now2 = (/* @__PURE__ */ new Date()).getTime();
      const then = _TooltipStateManager2.lastTooltipHideTime;
      return now2 - then < this.SHOW_QUICK_TOOLTIP_DIFF;
    }
    setToDoNothing() {
      if (this.state === 2) {
        this.hideTooltip();
      }
      if (this.onBodyScrollEventCallback) {
        this.onBodyScrollEventCallback();
        this.onBodyScrollEventCallback = void 0;
      }
      if (this.onColumnMovedEventCallback) {
        this.onColumnMovedEventCallback();
        this.onColumnMovedEventCallback = void 0;
      }
      this.clearTimeouts();
      this.state = 0;
      this.lastMouseEvent = null;
    }
    showTooltip() {
      const params = __spreadValues({}, this.parentComp.getTooltipParams());
      if (!exists(params.value) || this.shouldDisplayTooltip && !this.shouldDisplayTooltip()) {
        this.setToDoNothing();
        return;
      }
      this.state = 2;
      this.tooltipInstanceCount++;
      const callback = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount);
      const userDetails = this.userComponentFactory.getTooltipCompDetails(params);
      userDetails.newAgStackInstance().then(callback);
    }
    hideTooltip(forceHide) {
      if (!forceHide && this.isInteractingWithTooltip) {
        return;
      }
      if (this.tooltipComp) {
        this.destroyTooltipComp();
        _TooltipStateManager2.lastTooltipHideTime = (/* @__PURE__ */ new Date()).getTime();
      }
      const event = {
        type: Events.EVENT_TOOLTIP_HIDE,
        parentGui: this.parentComp.getGui()
      };
      this.eventService.dispatchEvent(event);
      this.state = 0;
    }
    newTooltipComponentCallback(tooltipInstanceCopy, tooltipComp) {
      const compNoLongerNeeded = this.state !== 2 || this.tooltipInstanceCount !== tooltipInstanceCopy;
      if (compNoLongerNeeded) {
        this.getContext().destroyBean(tooltipComp);
        return;
      }
      const eGui = tooltipComp.getGui();
      this.tooltipComp = tooltipComp;
      if (!eGui.classList.contains("ag-tooltip")) {
        eGui.classList.add("ag-tooltip-custom");
      }
      if (this.tooltipTrigger === 0) {
        eGui.classList.add("ag-tooltip-animate");
      }
      if (this.interactionEnabled) {
        eGui.classList.add("ag-tooltip-interactive");
      }
      const translate = this.localeService.getLocaleTextFunc();
      const addPopupRes = this.popupService.addPopup({
        eChild: eGui,
        ariaLabel: translate("ariaLabelTooltip", "Tooltip")
      });
      if (addPopupRes) {
        this.tooltipPopupDestroyFunc = addPopupRes.hideFunc;
      }
      this.positionTooltip();
      if (this.tooltipTrigger === 1) {
        this.onBodyScrollEventCallback = this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL, this.setToDoNothing.bind(this));
        this.onColumnMovedEventCallback = this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, this.setToDoNothing.bind(this));
      }
      if (this.interactionEnabled) {
        if (this.tooltipTrigger === 0) {
          this.tooltipMouseEnterListener = this.addManagedListener(eGui, "mouseenter", this.onTooltipMouseEnter.bind(this)) || null;
          this.tooltipMouseLeaveListener = this.addManagedListener(eGui, "mouseleave", this.onTooltipMouseLeave.bind(this)) || null;
        } else {
          this.tooltipFocusInListener = this.addManagedListener(eGui, "focusin", this.onTooltipFocusIn.bind(this)) || null;
          this.tooltipFocusOutListener = this.addManagedListener(eGui, "focusout", this.onTooltipFocusOut.bind(this)) || null;
        }
      }
      const event = {
        type: Events.EVENT_TOOLTIP_SHOW,
        tooltipGui: eGui,
        parentGui: this.parentComp.getGui()
      };
      this.eventService.dispatchEvent(event);
      this.startHideTimeout();
    }
    onTooltipMouseEnter() {
      this.isInteractingWithTooltip = true;
      this.unlockService();
    }
    onTooltipMouseLeave() {
      this.isInteractingWithTooltip = false;
      this.lockService();
    }
    onTooltipFocusIn() {
      this.isInteractingWithTooltip = true;
    }
    onTooltipFocusOut(e) {
      var _a;
      const parentGui = this.parentComp.getGui();
      const tooltipGui = (_a = this.tooltipComp) == null ? void 0 : _a.getGui();
      const relatedTarget = e.relatedTarget;
      if (tooltipGui == null ? void 0 : tooltipGui.contains(relatedTarget)) {
        return;
      }
      this.isInteractingWithTooltip = false;
      if (parentGui.contains(relatedTarget)) {
        this.startHideTimeout();
      } else {
        this.hideTooltip();
      }
    }
    positionTooltip() {
      const params = {
        type: "tooltip",
        ePopup: this.tooltipComp.getGui(),
        nudgeY: 18,
        skipObserver: this.tooltipMouseTrack
      };
      if (this.lastMouseEvent) {
        this.popupService.positionPopupUnderMouseEvent(__spreadProps(__spreadValues({}, params), {
          mouseEvent: this.lastMouseEvent
        }));
      } else {
        this.popupService.positionPopupByComponent(__spreadProps(__spreadValues({}, params), {
          eventSource: this.parentComp.getGui(),
          position: "under",
          keepWithinBounds: true,
          nudgeY: 5
        }));
      }
    }
    destroyTooltipComp() {
      this.tooltipComp.getGui().classList.add("ag-tooltip-hiding");
      const tooltipPopupDestroyFunc = this.tooltipPopupDestroyFunc;
      const tooltipComp = this.tooltipComp;
      const delay = this.tooltipTrigger === 0 ? this.FADE_OUT_TOOLTIP_TIMEOUT : 0;
      window.setTimeout(() => {
        tooltipPopupDestroyFunc();
        this.getContext().destroyBean(tooltipComp);
      }, delay);
      this.clearTooltipListeners();
      this.tooltipPopupDestroyFunc = void 0;
      this.tooltipComp = void 0;
    }
    clearTooltipListeners() {
      [
        this.tooltipMouseEnterListener,
        this.tooltipMouseLeaveListener,
        this.tooltipFocusInListener,
        this.tooltipFocusOutListener
      ].forEach((listener) => {
        if (listener) {
          listener();
        }
      });
      this.tooltipMouseEnterListener = this.tooltipMouseLeaveListener = this.tooltipFocusInListener = this.tooltipFocusOutListener = null;
    }
    lockService() {
      _TooltipStateManager2.isLocked = true;
      this.interactiveTooltipTimeoutId = window.setTimeout(() => {
        this.unlockService();
        this.setToDoNothing();
      }, this.INTERACTIVE_HIDE_DELAY);
    }
    unlockService() {
      _TooltipStateManager2.isLocked = false;
      this.clearInteractiveTimeout();
    }
    startHideTimeout() {
      this.clearHideTimeout();
      this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.getTooltipDelay("hide"));
    }
    clearShowTimeout() {
      if (!this.showTooltipTimeoutId) {
        return;
      }
      window.clearTimeout(this.showTooltipTimeoutId);
      this.showTooltipTimeoutId = void 0;
    }
    clearHideTimeout() {
      if (!this.hideTooltipTimeoutId) {
        return;
      }
      window.clearTimeout(this.hideTooltipTimeoutId);
      this.hideTooltipTimeoutId = void 0;
    }
    clearInteractiveTimeout() {
      if (!this.interactiveTooltipTimeoutId) {
        return;
      }
      window.clearTimeout(this.interactiveTooltipTimeoutId);
      this.interactiveTooltipTimeoutId = void 0;
    }
    clearTimeouts() {
      this.clearShowTimeout();
      this.clearHideTimeout();
      this.clearInteractiveTimeout();
    }
  };
  _TooltipStateManager.isLocked = false;
  __decorateClass([
    Autowired("popupService")
  ], _TooltipStateManager.prototype, "popupService", 2);
  __decorateClass([
    Autowired("userComponentFactory")
  ], _TooltipStateManager.prototype, "userComponentFactory", 2);
  __decorateClass([
    PostConstruct
  ], _TooltipStateManager.prototype, "postConstruct", 1);
  var TooltipStateManager = _TooltipStateManager;
  var TooltipFeature = class extends BeanStub {
    constructor(ctrl, beans) {
      super();
      this.ctrl = ctrl;
      if (beans) {
        this.beans = beans;
      }
    }
    postConstruct() {
      this.refreshToolTip();
    }
    setBrowserTooltip(tooltip) {
      const name = "title";
      const eGui = this.ctrl.getGui();
      if (!eGui) {
        return;
      }
      if (tooltip != null && tooltip != "") {
        eGui.setAttribute(name, tooltip);
      } else {
        eGui.removeAttribute(name);
      }
    }
    updateTooltipText() {
      this.tooltip = this.ctrl.getTooltipValue();
    }
    createTooltipFeatureIfNeeded() {
      var _a, _b, _c, _d;
      if (this.tooltipManager != null) {
        return;
      }
      const parent = {
        getTooltipParams: () => this.getTooltipParams(),
        getGui: () => this.ctrl.getGui()
      };
      this.tooltipManager = this.createBean(new TooltipStateManager(
        parent,
        (_b = (_a = this.ctrl).getTooltipShowDelayOverride) == null ? void 0 : _b.call(_a),
        (_d = (_c = this.ctrl).getTooltipHideDelayOverride) == null ? void 0 : _d.call(_c),
        this.ctrl.shouldDisplayTooltip
      ), this.beans.context);
    }
    refreshToolTip() {
      this.browserTooltips = this.beans.gos.get("enableBrowserTooltips");
      this.updateTooltipText();
      if (this.browserTooltips) {
        this.setBrowserTooltip(this.tooltip);
        if (this.tooltipManager) {
          this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context);
        }
      } else {
        this.setBrowserTooltip(null);
        this.createTooltipFeatureIfNeeded();
      }
    }
    getTooltipParams() {
      const ctrl = this.ctrl;
      const column = ctrl.getColumn ? ctrl.getColumn() : void 0;
      const colDef = ctrl.getColDef ? ctrl.getColDef() : void 0;
      const rowNode = ctrl.getRowNode ? ctrl.getRowNode() : void 0;
      return {
        location: ctrl.getLocation(),
        //'cell',
        colDef,
        column,
        rowIndex: ctrl.getRowIndex ? ctrl.getRowIndex() : void 0,
        node: rowNode,
        data: rowNode ? rowNode.data : void 0,
        value: this.getTooltipText(),
        valueFormatted: ctrl.getValueFormatted ? ctrl.getValueFormatted() : void 0,
        hideTooltipCallback: () => {
          var _a;
          return (_a = this.tooltipManager) == null ? void 0 : _a.hideTooltip(true);
        }
      };
    }
    getTooltipText() {
      return this.tooltip;
    }
    // overriding to make public, as we don't dispose this bean via context
    destroy() {
      if (this.tooltipManager) {
        this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context);
      }
      super.destroy();
    }
  };
  __decorateClass([
    Autowired("beans")
  ], TooltipFeature.prototype, "beans", 2);
  __decorateClass([
    PostConstruct
  ], TooltipFeature.prototype, "postConstruct", 1);
  var compIdSequence = new NumberSequence();
  var _Component = class _Component2 extends BeanStub {
    constructor(template) {
      super();
      this.displayed = true;
      this.visible = true;
      this.compId = compIdSequence.next();
      this.cssClassManager = new CssClassManager(() => this.eGui);
      if (template) {
        this.setTemplate(template);
      }
    }
    preConstructOnComponent() {
      this.usingBrowserTooltips = this.gos.get("enableBrowserTooltips");
    }
    getCompId() {
      return this.compId;
    }
    getTooltipParams() {
      return {
        value: this.tooltipText,
        location: "UNKNOWN"
      };
    }
    setTooltip(params) {
      const { newTooltipText, showDelayOverride, hideDelayOverride, location: location2, shouldDisplayTooltip } = params || {};
      if (this.tooltipFeature) {
        this.tooltipFeature = this.destroyBean(this.tooltipFeature);
      }
      if (this.tooltipText !== newTooltipText) {
        this.tooltipText = newTooltipText;
      }
      const getTooltipValue = () => this.tooltipText;
      if (newTooltipText != null) {
        this.tooltipFeature = this.createBean(new TooltipFeature({
          getTooltipValue,
          getGui: () => this.getGui(),
          getLocation: () => location2 != null ? location2 : "UNKNOWN",
          getColDef: params == null ? void 0 : params.getColDef,
          getColumn: params == null ? void 0 : params.getColumn,
          getTooltipShowDelayOverride: showDelayOverride != null ? () => showDelayOverride : void 0,
          getTooltipHideDelayOverride: hideDelayOverride != null ? () => hideDelayOverride : void 0,
          shouldDisplayTooltip
        }));
      }
    }
    // for registered components only, eg creates AgCheckbox instance from ag-checkbox HTML tag
    createChildComponentsFromTags(parentNode, paramsMap) {
      const childNodeList = copyNodeList(parentNode.childNodes);
      childNodeList.forEach((childNode) => {
        if (!(childNode instanceof HTMLElement)) {
          return;
        }
        const childComp = this.createComponentFromElement(childNode, (childComp2) => {
          const childGui = childComp2.getGui();
          if (childGui) {
            this.copyAttributesFromNode(childNode, childComp2.getGui());
          }
        }, paramsMap);
        if (childComp) {
          if (childComp.addItems && childNode.children.length) {
            this.createChildComponentsFromTags(childNode, paramsMap);
            const items = Array.prototype.slice.call(childNode.children);
            childComp.addItems(items);
          }
          this.swapComponentForNode(childComp, parentNode, childNode);
        } else if (childNode.childNodes) {
          this.createChildComponentsFromTags(childNode, paramsMap);
        }
      });
    }
    createComponentFromElement(element, afterPreCreateCallback, paramsMap) {
      const key = element.nodeName;
      const componentParams = paramsMap ? paramsMap[element.getAttribute("ref")] : void 0;
      const ComponentClass = this.agStackComponentsRegistry.getComponentClass(key);
      if (ComponentClass) {
        _Component2.elementGettingCreated = element;
        const newComponent = new ComponentClass(componentParams);
        newComponent.setParentComponent(this);
        this.createBean(newComponent, null, afterPreCreateCallback);
        return newComponent;
      }
      return null;
    }
    copyAttributesFromNode(source, dest) {
      iterateNamedNodeMap(source.attributes, (name, value) => dest.setAttribute(name, value));
    }
    swapComponentForNode(newComponent, parentNode, childNode) {
      const eComponent = newComponent.getGui();
      parentNode.replaceChild(eComponent, childNode);
      parentNode.insertBefore(document.createComment(childNode.nodeName), eComponent);
      this.addDestroyFunc(this.destroyBean.bind(this, newComponent));
      this.swapInComponentForQuerySelectors(newComponent, childNode);
    }
    swapInComponentForQuerySelectors(newComponent, childNode) {
      const thisNoType = this;
      this.iterateOverQuerySelectors((querySelector) => {
        if (thisNoType[querySelector.attributeName] === childNode) {
          thisNoType[querySelector.attributeName] = newComponent;
        }
      });
    }
    iterateOverQuerySelectors(action) {
      let thisPrototype = Object.getPrototypeOf(this);
      while (thisPrototype != null) {
        const metaData = thisPrototype.__agComponentMetaData;
        const currentProtoName = getFunctionName(thisPrototype.constructor);
        if (metaData && metaData[currentProtoName] && metaData[currentProtoName].querySelectors) {
          metaData[currentProtoName].querySelectors.forEach((querySelector) => action(querySelector));
        }
        thisPrototype = Object.getPrototypeOf(thisPrototype);
      }
    }
    activateTabIndex(elements) {
      const tabIndex = this.gos.get("tabIndex");
      if (!elements) {
        elements = [];
      }
      if (!elements.length) {
        elements.push(this.getGui());
      }
      elements.forEach((el) => el.setAttribute("tabindex", tabIndex.toString()));
    }
    setTemplate(template, paramsMap) {
      const eGui = loadTemplate(template);
      this.setTemplateFromElement(eGui, paramsMap);
    }
    setTemplateFromElement(element, paramsMap) {
      this.eGui = element;
      this.eGui.__agComponent = this;
      this.wireQuerySelectors();
      if (!!this.getContext()) {
        this.createChildComponentsFromTags(this.getGui(), paramsMap);
      }
    }
    createChildComponentsPreConstruct() {
      if (!!this.getGui()) {
        this.createChildComponentsFromTags(this.getGui());
      }
    }
    wireQuerySelectors() {
      if (!this.eGui) {
        return;
      }
      const thisNoType = this;
      this.iterateOverQuerySelectors((querySelector) => {
        const setResult = (result) => thisNoType[querySelector.attributeName] = result;
        const topLevelRefMatch = querySelector.refSelector && this.getAttribute("ref") === querySelector.refSelector;
        if (topLevelRefMatch) {
          setResult(this.eGui);
        } else {
          const resultOfQuery = this.eGui.querySelector(querySelector.querySelector);
          if (resultOfQuery) {
            setResult(resultOfQuery.__agComponent || resultOfQuery);
          }
        }
      });
    }
    getGui() {
      return this.eGui;
    }
    getFocusableElement() {
      return this.eGui;
    }
    getAriaElement() {
      return this.getFocusableElement();
    }
    setParentComponent(component) {
      this.parentComponent = component;
    }
    getParentComponent() {
      return this.parentComponent;
    }
    // this method is for older code, that wants to provide the gui element,
    // it is not intended for this to be in ag-Stack
    setGui(eGui) {
      this.eGui = eGui;
    }
    queryForHtmlElement(cssSelector) {
      return this.eGui.querySelector(cssSelector);
    }
    queryForHtmlInputElement(cssSelector) {
      return this.eGui.querySelector(cssSelector);
    }
    appendChild(newChild, container) {
      if (newChild == null) {
        return;
      }
      if (!container) {
        container = this.eGui;
      }
      if (isNodeOrElement(newChild)) {
        container.appendChild(newChild);
      } else {
        const childComponent = newChild;
        container.appendChild(childComponent.getGui());
      }
    }
    isDisplayed() {
      return this.displayed;
    }
    setVisible(visible, options = {}) {
      if (visible !== this.visible) {
        this.visible = visible;
        const { skipAriaHidden } = options;
        setVisible(this.eGui, visible, { skipAriaHidden });
      }
    }
    setDisplayed(displayed, options = {}) {
      if (displayed !== this.displayed) {
        this.displayed = displayed;
        const { skipAriaHidden } = options;
        setDisplayed(this.eGui, displayed, { skipAriaHidden });
        const event = {
          type: _Component2.EVENT_DISPLAYED_CHANGED,
          visible: this.displayed
        };
        this.dispatchEvent(event);
      }
    }
    destroy() {
      if (this.parentComponent) {
        this.parentComponent = void 0;
      }
      if (this.tooltipFeature) {
        this.tooltipFeature = this.destroyBean(this.tooltipFeature);
      }
      const eGui = this.eGui;
      if (eGui && eGui.__agComponent) {
        eGui.__agComponent = void 0;
      }
      super.destroy();
    }
    addGuiEventListener(event, listener, options) {
      this.eGui.addEventListener(event, listener, options);
      this.addDestroyFunc(() => this.eGui.removeEventListener(event, listener));
    }
    addCssClass(className) {
      this.cssClassManager.addCssClass(className);
    }
    removeCssClass(className) {
      this.cssClassManager.removeCssClass(className);
    }
    containsCssClass(className) {
      return this.cssClassManager.containsCssClass(className);
    }
    addOrRemoveCssClass(className, addOrRemove) {
      this.cssClassManager.addOrRemoveCssClass(className, addOrRemove);
    }
    getAttribute(key) {
      const { eGui } = this;
      return eGui ? eGui.getAttribute(key) : null;
    }
    getRefElement(refName) {
      return this.queryForHtmlElement(`[ref="${refName}"]`);
    }
  };
  _Component.EVENT_DISPLAYED_CHANGED = "displayedChanged";
  __decorateClass([
    Autowired("agStackComponentsRegistry")
  ], _Component.prototype, "agStackComponentsRegistry", 2);
  __decorateClass([
    PreConstruct
  ], _Component.prototype, "preConstructOnComponent", 1);
  __decorateClass([
    PreConstruct
  ], _Component.prototype, "createChildComponentsPreConstruct", 1);
  var Component = _Component;
  function QuerySelector(selector) {
    return querySelectorFunc.bind(this, selector, void 0);
  }
  function RefSelector(ref2) {
    return querySelectorFunc.bind(this, `[ref=${ref2}]`, ref2);
  }
  function querySelectorFunc(selector, refSelector, classPrototype, methodOrAttributeName, index) {
    if (selector === null) {
      console.error("AG Grid: QuerySelector selector should not be null");
      return;
    }
    if (typeof index === "number") {
      console.error("AG Grid: QuerySelector should be on an attribute");
      return;
    }
    addToObjectProps(classPrototype, "querySelectors", {
      attributeName: methodOrAttributeName,
      querySelector: selector,
      refSelector
    });
  }
  function addToObjectProps(target, key, value) {
    const props = getOrCreateProps2(target, getFunctionName(target.constructor));
    if (!props[key]) {
      props[key] = [];
    }
    props[key].push(value);
  }
  function getOrCreateProps2(target, instanceName) {
    if (!target.__agComponentMetaData) {
      target.__agComponentMetaData = {};
    }
    if (!target.__agComponentMetaData[instanceName]) {
      target.__agComponentMetaData[instanceName] = {};
    }
    return target.__agComponentMetaData[instanceName];
  }
  var ReadOnlyFloatingFilter = class extends Component {
    constructor() {
      super(
        /* html */
        `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field ref="eFloatingFilterText"></ag-input-text-field>
            </div>`
      );
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
      super.destroy();
    }
    init(params) {
      this.params = params;
      const displayName = this.columnModel.getDisplayNameForColumn(params.column, "header", true);
      const translate = this.localeService.getLocaleTextFunc();
      this.eFloatingFilterText.setDisabled(true).setInputAriaLabel(`${displayName} ${translate("ariaFilterInput", "Filter Input")}`);
    }
    onParentModelChanged(parentModel) {
      if (parentModel == null) {
        this.eFloatingFilterText.setValue("");
        return;
      }
      this.params.parentFilterInstance((filterInstance) => {
        if (filterInstance.getModelAsString) {
          const modelAsString = filterInstance.getModelAsString(parentModel);
          this.eFloatingFilterText.setValue(modelAsString);
        }
      });
    }
    onParamsUpdated(params) {
      this.refresh(params);
    }
    refresh(params) {
      this.init(params);
    }
  };
  __decorateClass([
    RefSelector("eFloatingFilterText")
  ], ReadOnlyFloatingFilter.prototype, "eFloatingFilterText", 2);
  __decorateClass([
    Autowired("columnModel")
  ], ReadOnlyFloatingFilter.prototype, "columnModel", 2);
  var DateCompWrapper = class {
    constructor(context, userComponentFactory, dateComponentParams, eParent, onReady) {
      this.alive = true;
      this.context = context;
      this.eParent = eParent;
      const compDetails = userComponentFactory.getDateCompDetails(dateComponentParams);
      const promise = compDetails.newAgStackInstance();
      promise.then((dateComp) => {
        if (!this.alive) {
          context.destroyBean(dateComp);
          return;
        }
        this.dateComp = dateComp;
        if (!dateComp) {
          return;
        }
        eParent.appendChild(dateComp.getGui());
        if (dateComp.afterGuiAttached) {
          dateComp.afterGuiAttached();
        }
        if (this.tempValue) {
          dateComp.setDate(this.tempValue);
        }
        if (this.disabled != null) {
          this.setDateCompDisabled(this.disabled);
        }
        onReady == null ? void 0 : onReady(this);
      });
    }
    destroy() {
      this.alive = false;
      this.dateComp = this.context.destroyBean(this.dateComp);
    }
    getDate() {
      return this.dateComp ? this.dateComp.getDate() : this.tempValue;
    }
    setDate(value) {
      if (this.dateComp) {
        this.dateComp.setDate(value);
      } else {
        this.tempValue = value;
      }
    }
    setDisabled(disabled) {
      if (this.dateComp) {
        this.setDateCompDisabled(disabled);
      } else {
        this.disabled = disabled;
      }
    }
    setDisplayed(displayed) {
      setDisplayed(this.eParent, displayed);
    }
    setInputPlaceholder(placeholder) {
      if (this.dateComp && this.dateComp.setInputPlaceholder) {
        this.dateComp.setInputPlaceholder(placeholder);
      }
    }
    setInputAriaLabel(label) {
      if (this.dateComp && this.dateComp.setInputAriaLabel) {
        this.dateComp.setInputAriaLabel(label);
      }
    }
    afterGuiAttached(params) {
      if (this.dateComp && typeof this.dateComp.afterGuiAttached === "function") {
        this.dateComp.afterGuiAttached(params);
      }
    }
    updateParams(params) {
      var _a, _b;
      let hasRefreshed = false;
      if (((_a = this.dateComp) == null ? void 0 : _a.refresh) && typeof this.dateComp.refresh === "function") {
        const result = this.dateComp.refresh(params);
        if (result !== null) {
          hasRefreshed = true;
        }
      }
      if (!hasRefreshed && ((_b = this.dateComp) == null ? void 0 : _b.onParamsUpdated) && typeof this.dateComp.onParamsUpdated === "function") {
        const result = this.dateComp.onParamsUpdated(params);
        if (result !== null) {
          warnOnce(`Custom date component method 'onParamsUpdated' is deprecated. Use 'refresh' instead.`);
        }
      }
    }
    setDateCompDisabled(disabled) {
      if (this.dateComp == null) {
        return;
      }
      if (this.dateComp.setDisabled == null) {
        return;
      }
      this.dateComp.setDisabled(disabled);
    }
  };
  var OptionsFactory = class {
    constructor() {
      this.customFilterOptions = {};
    }
    init(params, defaultOptions2) {
      this.filterOptions = params.filterOptions || defaultOptions2;
      this.mapCustomOptions();
      this.selectDefaultItem(params);
    }
    getFilterOptions() {
      return this.filterOptions;
    }
    mapCustomOptions() {
      if (!this.filterOptions) {
        return;
      }
      this.filterOptions.forEach((filterOption) => {
        if (typeof filterOption === "string") {
          return;
        }
        const requiredProperties = [["displayKey"], ["displayName"], ["predicate", "test"]];
        const propertyCheck = (keys2) => {
          if (!keys2.some((key) => filterOption[key] != null)) {
            console.warn(`AG Grid: ignoring FilterOptionDef as it doesn't contain one of '${keys2}'`);
            return false;
          }
          return true;
        };
        if (!requiredProperties.every(propertyCheck)) {
          this.filterOptions = this.filterOptions.filter((v) => v === filterOption) || [];
          return;
        }
        this.customFilterOptions[filterOption.displayKey] = filterOption;
      });
    }
    selectDefaultItem(params) {
      if (params.defaultOption) {
        this.defaultOption = params.defaultOption;
      } else if (this.filterOptions.length >= 1) {
        const firstFilterOption = this.filterOptions[0];
        if (typeof firstFilterOption === "string") {
          this.defaultOption = firstFilterOption;
        } else if (firstFilterOption.displayKey) {
          this.defaultOption = firstFilterOption.displayKey;
        } else {
          console.warn(`AG Grid: invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'`);
        }
      } else {
        console.warn("AG Grid: no filter options for filter");
      }
    }
    getDefaultOption() {
      return this.defaultOption;
    }
    getCustomOption(name) {
      return this.customFilterOptions[name];
    }
  };
  var FILTER_LOCALE_TEXT = {
    applyFilter: "Apply",
    clearFilter: "Clear",
    resetFilter: "Reset",
    cancelFilter: "Cancel",
    textFilter: "Text Filter",
    numberFilter: "Number Filter",
    dateFilter: "Date Filter",
    setFilter: "Set Filter",
    filterOoo: "Filter...",
    empty: "Choose one",
    equals: "Equals",
    notEqual: "Does not equal",
    lessThan: "Less than",
    greaterThan: "Greater than",
    inRange: "Between",
    inRangeStart: "From",
    inRangeEnd: "To",
    lessThanOrEqual: "Less than or equal to",
    greaterThanOrEqual: "Greater than or equal to",
    contains: "Contains",
    notContains: "Does not contain",
    startsWith: "Begins with",
    endsWith: "Ends with",
    blank: "Blank",
    notBlank: "Not blank",
    before: "Before",
    after: "After",
    andCondition: "AND",
    orCondition: "OR",
    dateFormatOoo: "yyyy-mm-dd"
  };
  var _ManagedFocusFeature = class _ManagedFocusFeature2 extends BeanStub {
    constructor(eFocusableElement, callbacks = {}) {
      super();
      this.eFocusableElement = eFocusableElement;
      this.callbacks = callbacks;
      this.callbacks = __spreadValues({
        shouldStopEventPropagation: () => false,
        onTabKeyDown: (e) => {
          if (e.defaultPrevented) {
            return;
          }
          const nextRoot = this.focusService.findNextFocusableElement(this.eFocusableElement, false, e.shiftKey);
          if (!nextRoot) {
            return;
          }
          nextRoot.focus();
          e.preventDefault();
        }
      }, callbacks);
    }
    postConstruct() {
      this.eFocusableElement.classList.add(_ManagedFocusFeature2.FOCUS_MANAGED_CLASS);
      this.addKeyDownListeners(this.eFocusableElement);
      if (this.callbacks.onFocusIn) {
        this.addManagedListener(this.eFocusableElement, "focusin", this.callbacks.onFocusIn);
      }
      if (this.callbacks.onFocusOut) {
        this.addManagedListener(this.eFocusableElement, "focusout", this.callbacks.onFocusOut);
      }
    }
    addKeyDownListeners(eGui) {
      this.addManagedListener(eGui, "keydown", (e) => {
        if (e.defaultPrevented || isStopPropagationForAgGrid(e)) {
          return;
        }
        if (this.callbacks.shouldStopEventPropagation(e)) {
          stopPropagationForAgGrid(e);
          return;
        }
        if (e.key === KeyCode.TAB) {
          this.callbacks.onTabKeyDown(e);
        } else if (this.callbacks.handleKeyDown) {
          this.callbacks.handleKeyDown(e);
        }
      });
    }
  };
  _ManagedFocusFeature.FOCUS_MANAGED_CLASS = "ag-focus-managed";
  __decorateClass([
    Autowired("focusService")
  ], _ManagedFocusFeature.prototype, "focusService", 2);
  __decorateClass([
    PostConstruct
  ], _ManagedFocusFeature.prototype, "postConstruct", 1);
  var ManagedFocusFeature = _ManagedFocusFeature;
  var RESIZE_CONTAINER_STYLE = "ag-resizer-wrapper";
  var RESIZE_TEMPLATE = (
    /* html */
    `<div class="${RESIZE_CONTAINER_STYLE}">
        <div ref="eTopLeftResizer" class="ag-resizer ag-resizer-topLeft"></div>
        <div ref="eTopResizer" class="ag-resizer ag-resizer-top"></div>
        <div ref="eTopRightResizer" class="ag-resizer ag-resizer-topRight"></div>
        <div ref="eRightResizer" class="ag-resizer ag-resizer-right"></div>
        <div ref="eBottomRightResizer" class="ag-resizer ag-resizer-bottomRight"></div>
        <div ref="eBottomResizer" class="ag-resizer ag-resizer-bottom"></div>
        <div ref="eBottomLeftResizer" class="ag-resizer ag-resizer-bottomLeft"></div>
        <div ref="eLeftResizer" class="ag-resizer ag-resizer-left"></div>
    </div>`
  );
  var PositionableFeature = class extends BeanStub {
    constructor(element, config) {
      super();
      this.element = element;
      this.dragStartPosition = {
        x: 0,
        y: 0
      };
      this.position = {
        x: 0,
        y: 0
      };
      this.lastSize = {
        width: -1,
        height: -1
      };
      this.positioned = false;
      this.resizersAdded = false;
      this.resizeListeners = [];
      this.boundaryEl = null;
      this.isResizing = false;
      this.isMoving = false;
      this.resizable = {};
      this.movable = false;
      this.currentResizer = null;
      this.config = Object.assign({}, { popup: false }, config);
    }
    center() {
      const { clientHeight, clientWidth } = this.offsetParent;
      const x = clientWidth / 2 - this.getWidth() / 2;
      const y = clientHeight / 2 - this.getHeight() / 2;
      this.offsetElement(x, y);
    }
    initialisePosition() {
      if (this.positioned) {
        return;
      }
      const { centered, forcePopupParentAsOffsetParent, minWidth, width, minHeight, height, x, y } = this.config;
      if (!this.offsetParent) {
        this.setOffsetParent();
      }
      let computedMinHeight = 0;
      let computedMinWidth = 0;
      const isElementVisible = isVisible(this.element);
      if (isElementVisible) {
        const boundaryEl = this.findBoundaryElement();
        const offsetParentComputedStyles = window.getComputedStyle(boundaryEl);
        if (offsetParentComputedStyles.minWidth != null) {
          const paddingWidth = boundaryEl.offsetWidth - this.element.offsetWidth;
          computedMinWidth = parseInt(offsetParentComputedStyles.minWidth, 10) - paddingWidth;
        }
        if (offsetParentComputedStyles.minHeight != null) {
          const paddingHeight = boundaryEl.offsetHeight - this.element.offsetHeight;
          computedMinHeight = parseInt(offsetParentComputedStyles.minHeight, 10) - paddingHeight;
        }
      }
      this.minHeight = minHeight || computedMinHeight;
      this.minWidth = minWidth || computedMinWidth;
      if (width) {
        this.setWidth(width);
      }
      if (height) {
        this.setHeight(height);
      }
      if (!width || !height) {
        this.refreshSize();
      }
      if (centered) {
        this.center();
      } else if (x || y) {
        this.offsetElement(x, y);
      } else if (isElementVisible && forcePopupParentAsOffsetParent) {
        let boundaryEl = this.boundaryEl;
        let initialisedDuringPositioning = true;
        if (!boundaryEl) {
          boundaryEl = this.findBoundaryElement();
          initialisedDuringPositioning = false;
        }
        if (boundaryEl) {
          const top = parseFloat(boundaryEl.style.top);
          const left = parseFloat(boundaryEl.style.left);
          if (initialisedDuringPositioning) {
            this.offsetElement(
              isNaN(left) ? 0 : left,
              isNaN(top) ? 0 : top
            );
          } else {
            this.setPosition(left, top);
          }
        }
      }
      this.positioned = !!this.offsetParent;
    }
    isPositioned() {
      return this.positioned;
    }
    getPosition() {
      return this.position;
    }
    setMovable(movable, moveElement) {
      if (!this.config.popup || movable === this.movable) {
        return;
      }
      this.movable = movable;
      const params = this.moveElementDragListener || {
        eElement: moveElement,
        onDragStart: this.onMoveStart.bind(this),
        onDragging: this.onMove.bind(this),
        onDragStop: this.onMoveEnd.bind(this)
      };
      if (movable) {
        this.dragService.addDragSource(params);
        this.moveElementDragListener = params;
      } else {
        this.dragService.removeDragSource(params);
        this.moveElementDragListener = void 0;
      }
    }
    setResizable(resizable) {
      this.clearResizeListeners();
      if (resizable) {
        this.addResizers();
      } else {
        this.removeResizers();
      }
      if (typeof resizable === "boolean") {
        if (resizable === false) {
          return;
        }
        resizable = {
          topLeft: resizable,
          top: resizable,
          topRight: resizable,
          right: resizable,
          bottomRight: resizable,
          bottom: resizable,
          bottomLeft: resizable,
          left: resizable
        };
      }
      Object.keys(resizable).forEach((side) => {
        const resizableStructure = resizable;
        const isSideResizable = !!resizableStructure[side];
        const resizerEl = this.getResizerElement(side);
        const params = {
          dragStartPixels: 0,
          eElement: resizerEl,
          onDragStart: (e) => this.onResizeStart(e, side),
          onDragging: this.onResize.bind(this),
          onDragStop: (e) => this.onResizeEnd(e, side)
        };
        if (isSideResizable || !this.isAlive() && !isSideResizable) {
          if (isSideResizable) {
            this.dragService.addDragSource(params);
            this.resizeListeners.push(params);
            resizerEl.style.pointerEvents = "all";
          } else {
            resizerEl.style.pointerEvents = "none";
          }
          this.resizable[side] = isSideResizable;
        }
      });
    }
    removeSizeFromEl() {
      this.element.style.removeProperty("height");
      this.element.style.removeProperty("width");
      this.element.style.removeProperty("flex");
    }
    restoreLastSize() {
      this.element.style.flex = "0 0 auto";
      const { height, width } = this.lastSize;
      if (width !== -1) {
        this.element.style.width = `${width}px`;
      }
      if (height !== -1) {
        this.element.style.height = `${height}px`;
      }
    }
    getHeight() {
      return this.element.offsetHeight;
    }
    setHeight(height) {
      const { popup } = this.config;
      const eGui = this.element;
      let isPercent = false;
      if (typeof height === "string" && height.indexOf("%") !== -1) {
        setFixedHeight(eGui, height);
        height = getAbsoluteHeight(eGui);
        isPercent = true;
      } else {
        height = Math.max(this.minHeight, height);
        if (this.positioned) {
          const availableHeight = this.getAvailableHeight();
          if (availableHeight && height > availableHeight) {
            height = availableHeight;
          }
        }
      }
      if (this.getHeight() === height) {
        return;
      }
      if (!isPercent) {
        if (popup) {
          setFixedHeight(eGui, height);
        } else {
          eGui.style.height = `${height}px`;
          eGui.style.flex = "0 0 auto";
          this.lastSize.height = typeof height === "number" ? height : parseFloat(height);
        }
      } else {
        eGui.style.maxHeight = "unset";
        eGui.style.minHeight = "unset";
      }
    }
    getAvailableHeight() {
      const { popup, forcePopupParentAsOffsetParent } = this.config;
      if (!this.positioned) {
        this.initialisePosition();
      }
      const { clientHeight } = this.offsetParent;
      if (!clientHeight) {
        return null;
      }
      const elRect = this.element.getBoundingClientRect();
      const offsetParentRect = this.offsetParent.getBoundingClientRect();
      const yPosition = popup ? this.position.y : elRect.top;
      const parentTop = popup ? 0 : offsetParentRect.top;
      let additionalHeight = 0;
      if (forcePopupParentAsOffsetParent) {
        const parentEl = this.element.parentElement;
        if (parentEl) {
          const { bottom } = parentEl.getBoundingClientRect();
          additionalHeight = bottom - elRect.bottom;
        }
      }
      const availableHeight = clientHeight + parentTop - yPosition - additionalHeight;
      return availableHeight;
    }
    getWidth() {
      return this.element.offsetWidth;
    }
    setWidth(width) {
      const eGui = this.element;
      const { popup } = this.config;
      let isPercent = false;
      if (typeof width === "string" && width.indexOf("%") !== -1) {
        setFixedWidth(eGui, width);
        width = getAbsoluteWidth(eGui);
        isPercent = true;
      } else if (this.positioned) {
        width = Math.max(this.minWidth, width);
        const { clientWidth } = this.offsetParent;
        const xPosition = popup ? this.position.x : this.element.getBoundingClientRect().left;
        if (clientWidth && width + xPosition > clientWidth) {
          width = clientWidth - xPosition;
        }
      }
      if (this.getWidth() === width) {
        return;
      }
      if (!isPercent) {
        if (this.config.popup) {
          setFixedWidth(eGui, width);
        } else {
          eGui.style.width = `${width}px`;
          eGui.style.flex = " unset";
          this.lastSize.width = typeof width === "number" ? width : parseFloat(width);
        }
      } else {
        eGui.style.maxWidth = "unset";
        eGui.style.minWidth = "unset";
      }
    }
    offsetElement(x = 0, y = 0) {
      const { forcePopupParentAsOffsetParent } = this.config;
      const ePopup = forcePopupParentAsOffsetParent ? this.boundaryEl : this.element;
      if (!ePopup) {
        return;
      }
      this.popupService.positionPopup({
        ePopup,
        keepWithinBounds: true,
        skipObserver: this.movable || this.isResizable(),
        updatePosition: () => ({ x, y })
      });
      this.setPosition(
        parseFloat(ePopup.style.left),
        parseFloat(ePopup.style.top)
      );
    }
    constrainSizeToAvailableHeight(constrain) {
      if (!this.config.forcePopupParentAsOffsetParent) {
        return;
      }
      const applyMaxHeightToElement = () => {
        const availableHeight = this.getAvailableHeight();
        this.element.style.setProperty("max-height", `${availableHeight}px`);
      };
      if (constrain) {
        this.resizeObserverSubscriber = this.resizeObserverService.observeResize(
          this.popupService.getPopupParent(),
          applyMaxHeightToElement
        );
      } else {
        this.element.style.removeProperty("max-height");
        if (this.resizeObserverSubscriber) {
          this.resizeObserverSubscriber();
          this.resizeObserverSubscriber = void 0;
        }
      }
    }
    setPosition(x, y) {
      this.position.x = x;
      this.position.y = y;
    }
    updateDragStartPosition(x, y) {
      this.dragStartPosition = { x, y };
    }
    calculateMouseMovement(params) {
      const { e, isLeft, isTop, anywhereWithin, topBuffer } = params;
      const xDiff = e.clientX - this.dragStartPosition.x;
      const yDiff = e.clientY - this.dragStartPosition.y;
      const movementX = this.shouldSkipX(e, !!isLeft, !!anywhereWithin, xDiff) ? 0 : xDiff;
      const movementY = this.shouldSkipY(e, !!isTop, topBuffer, yDiff) ? 0 : yDiff;
      return { movementX, movementY };
    }
    shouldSkipX(e, isLeft, anywhereWithin, diff) {
      const elRect = this.element.getBoundingClientRect();
      const parentRect = this.offsetParent.getBoundingClientRect();
      const boundaryElRect = this.boundaryEl.getBoundingClientRect();
      const xPosition = this.config.popup ? this.position.x : elRect.left;
      let skipX = xPosition <= 0 && parentRect.left >= e.clientX || parentRect.right <= e.clientX && parentRect.right <= boundaryElRect.right;
      if (skipX) {
        return true;
      }
      if (isLeft) {
        skipX = // skip if we are moving to the left and the cursor
        // is positioned to the right of the left side anchor
        diff < 0 && e.clientX > xPosition + parentRect.left || // skip if we are moving to the right and the cursor
        // is positioned to the left of the dialog
        diff > 0 && e.clientX < xPosition + parentRect.left;
      } else {
        if (anywhereWithin) {
          skipX = diff < 0 && e.clientX > boundaryElRect.right || diff > 0 && e.clientX < xPosition + parentRect.left;
        } else {
          skipX = // if the movement is bound to the right side of the dialog
          // we skip if we are moving to the left and the cursor
          // is to the right of the dialog
          diff < 0 && e.clientX > boundaryElRect.right || // or skip if we are moving to the right and the cursor
          // is to the left of the right side anchor
          diff > 0 && e.clientX < boundaryElRect.right;
        }
      }
      return skipX;
    }
    shouldSkipY(e, isTop, topBuffer = 0, diff) {
      const elRect = this.element.getBoundingClientRect();
      const parentRect = this.offsetParent.getBoundingClientRect();
      const boundaryElRect = this.boundaryEl.getBoundingClientRect();
      const yPosition = this.config.popup ? this.position.y : elRect.top;
      let skipY = yPosition <= 0 && parentRect.top >= e.clientY || parentRect.bottom <= e.clientY && parentRect.bottom <= boundaryElRect.bottom;
      if (skipY) {
        return true;
      }
      if (isTop) {
        skipY = // skip if we are moving to towards top and the cursor is
        // below the top anchor + topBuffer
        // note: topBuffer is used when moving the dialog using the title bar
        diff < 0 && e.clientY > yPosition + parentRect.top + topBuffer || // skip if we are moving to the bottom and the cursor is
        // above the top anchor
        diff > 0 && e.clientY < yPosition + parentRect.top;
      } else {
        skipY = // skip if we are moving towards the top and the cursor
        // is below the bottom anchor
        diff < 0 && e.clientY > boundaryElRect.bottom || // skip if we are moving towards the bottom and the cursor
        // is above the bottom anchor
        diff > 0 && e.clientY < boundaryElRect.bottom;
      }
      return skipY;
    }
    createResizeMap() {
      const eGui = this.element;
      this.resizerMap = {
        topLeft: { element: eGui.querySelector("[ref=eTopLeftResizer]") },
        top: { element: eGui.querySelector("[ref=eTopResizer]") },
        topRight: { element: eGui.querySelector("[ref=eTopRightResizer]") },
        right: { element: eGui.querySelector("[ref=eRightResizer]") },
        bottomRight: { element: eGui.querySelector("[ref=eBottomRightResizer]") },
        bottom: { element: eGui.querySelector("[ref=eBottomResizer]") },
        bottomLeft: { element: eGui.querySelector("[ref=eBottomLeftResizer]") },
        left: { element: eGui.querySelector("[ref=eLeftResizer]") }
      };
    }
    addResizers() {
      if (this.resizersAdded) {
        return;
      }
      const eGui = this.element;
      if (!eGui) {
        return;
      }
      const parser = new DOMParser();
      const resizers = parser.parseFromString(RESIZE_TEMPLATE, "text/html").body;
      eGui.appendChild(resizers.firstChild);
      this.createResizeMap();
      this.resizersAdded = true;
    }
    removeResizers() {
      this.resizerMap = void 0;
      const resizerEl = this.element.querySelector(`.${RESIZE_CONTAINER_STYLE}`);
      if (resizerEl) {
        this.element.removeChild(resizerEl);
      }
      this.resizersAdded = false;
    }
    getResizerElement(side) {
      return this.resizerMap[side].element;
    }
    onResizeStart(e, side) {
      this.boundaryEl = this.findBoundaryElement();
      if (!this.positioned) {
        this.initialisePosition();
      }
      this.currentResizer = {
        isTop: !!side.match(/top/i),
        isRight: !!side.match(/right/i),
        isBottom: !!side.match(/bottom/i),
        isLeft: !!side.match(/left/i)
      };
      this.element.classList.add("ag-resizing");
      this.resizerMap[side].element.classList.add("ag-active");
      const { popup, forcePopupParentAsOffsetParent } = this.config;
      if (!popup && !forcePopupParentAsOffsetParent) {
        this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop);
      }
      this.isResizing = true;
      this.updateDragStartPosition(e.clientX, e.clientY);
    }
    getSiblings() {
      const element = this.element;
      const parent = element.parentElement;
      if (!parent) {
        return null;
      }
      return Array.prototype.slice.call(parent.children).filter((el) => !el.classList.contains("ag-hidden"));
    }
    getMinSizeOfSiblings() {
      const siblings = this.getSiblings() || [];
      let height = 0;
      let width = 0;
      for (let i = 0; i < siblings.length; i++) {
        const currentEl = siblings[i];
        const isFlex = !!currentEl.style.flex && currentEl.style.flex !== "0 0 auto";
        if (currentEl === this.element) {
          continue;
        }
        let nextHeight = this.minHeight || 0;
        let nextWidth = this.minWidth || 0;
        if (isFlex) {
          const computedStyle = window.getComputedStyle(currentEl);
          if (computedStyle.minHeight) {
            nextHeight = parseInt(computedStyle.minHeight, 10);
          }
          if (computedStyle.minWidth) {
            nextWidth = parseInt(computedStyle.minWidth, 10);
          }
        } else {
          nextHeight = currentEl.offsetHeight;
          nextWidth = currentEl.offsetWidth;
        }
        height += nextHeight;
        width += nextWidth;
      }
      return { height, width };
    }
    applySizeToSiblings(vertical) {
      let containerToFlex = null;
      const siblings = this.getSiblings();
      if (!siblings) {
        return;
      }
      for (let i = 0; i < siblings.length; i++) {
        const el = siblings[i];
        if (el === containerToFlex) {
          continue;
        }
        if (vertical) {
          el.style.height = `${el.offsetHeight}px`;
        } else {
          el.style.width = `${el.offsetWidth}px`;
        }
        el.style.flex = "0 0 auto";
        if (el === this.element) {
          containerToFlex = siblings[i + 1];
        }
      }
      if (containerToFlex) {
        containerToFlex.style.removeProperty("height");
        containerToFlex.style.removeProperty("min-height");
        containerToFlex.style.removeProperty("max-height");
        containerToFlex.style.flex = "1 1 auto";
      }
    }
    isResizable() {
      return Object.values(this.resizable).some((value) => value);
    }
    onResize(e) {
      if (!this.isResizing || !this.currentResizer) {
        return;
      }
      const { popup, forcePopupParentAsOffsetParent } = this.config;
      const { isTop, isRight, isBottom, isLeft } = this.currentResizer;
      const isHorizontal = isRight || isLeft;
      const isVertical = isBottom || isTop;
      const { movementX, movementY } = this.calculateMouseMovement({ e, isLeft, isTop });
      const xPosition = this.position.x;
      const yPosition = this.position.y;
      let offsetLeft = 0;
      let offsetTop = 0;
      if (isHorizontal && movementX) {
        const direction = isLeft ? -1 : 1;
        const oldWidth = this.getWidth();
        const newWidth = oldWidth + movementX * direction;
        let skipWidth = false;
        if (isLeft) {
          offsetLeft = oldWidth - newWidth;
          if (xPosition + offsetLeft <= 0 || newWidth <= this.minWidth) {
            skipWidth = true;
            offsetLeft = 0;
          }
        }
        if (!skipWidth) {
          this.setWidth(newWidth);
        }
      }
      if (isVertical && movementY) {
        const direction = isTop ? -1 : 1;
        const oldHeight = this.getHeight();
        const newHeight = oldHeight + movementY * direction;
        let skipHeight = false;
        if (isTop) {
          offsetTop = oldHeight - newHeight;
          if (yPosition + offsetTop <= 0 || newHeight <= this.minHeight) {
            skipHeight = true;
            offsetTop = 0;
          }
        } else {
          if (!this.config.popup && !this.config.forcePopupParentAsOffsetParent && oldHeight < newHeight && this.getMinSizeOfSiblings().height + newHeight > this.element.parentElement.offsetHeight) {
            skipHeight = true;
          }
        }
        if (!skipHeight) {
          this.setHeight(newHeight);
        }
      }
      this.updateDragStartPosition(e.clientX, e.clientY);
      if ((popup || forcePopupParentAsOffsetParent) && offsetLeft || offsetTop) {
        this.offsetElement(
          xPosition + offsetLeft,
          yPosition + offsetTop
        );
      }
    }
    onResizeEnd(e, side) {
      this.isResizing = false;
      this.currentResizer = null;
      this.boundaryEl = null;
      const params = {
        type: "resize"
      };
      this.element.classList.remove("ag-resizing");
      this.resizerMap[side].element.classList.remove("ag-active");
      this.dispatchEvent(params);
    }
    refreshSize() {
      const eGui = this.element;
      if (this.config.popup) {
        if (!this.config.width) {
          this.setWidth(eGui.offsetWidth);
        }
        if (!this.config.height) {
          this.setHeight(eGui.offsetHeight);
        }
      }
    }
    onMoveStart(e) {
      this.boundaryEl = this.findBoundaryElement();
      if (!this.positioned) {
        this.initialisePosition();
      }
      this.isMoving = true;
      this.element.classList.add("ag-moving");
      this.updateDragStartPosition(e.clientX, e.clientY);
    }
    onMove(e) {
      if (!this.isMoving) {
        return;
      }
      const { x, y } = this.position;
      let topBuffer;
      if (this.config.calculateTopBuffer) {
        topBuffer = this.config.calculateTopBuffer();
      }
      const { movementX, movementY } = this.calculateMouseMovement({
        e,
        isTop: true,
        anywhereWithin: true,
        topBuffer
      });
      this.offsetElement(x + movementX, y + movementY);
      this.updateDragStartPosition(e.clientX, e.clientY);
    }
    onMoveEnd() {
      this.isMoving = false;
      this.boundaryEl = null;
      this.element.classList.remove("ag-moving");
    }
    setOffsetParent() {
      if (this.config.forcePopupParentAsOffsetParent) {
        this.offsetParent = this.popupService.getPopupParent();
      } else {
        this.offsetParent = this.element.offsetParent;
      }
    }
    findBoundaryElement() {
      let el = this.element;
      while (el) {
        if (window.getComputedStyle(el).position !== "static") {
          return el;
        }
        el = el.parentElement;
      }
      return this.element;
    }
    clearResizeListeners() {
      while (this.resizeListeners.length) {
        const params = this.resizeListeners.pop();
        this.dragService.removeDragSource(params);
      }
    }
    destroy() {
      super.destroy();
      if (this.moveElementDragListener) {
        this.dragService.removeDragSource(this.moveElementDragListener);
      }
      this.constrainSizeToAvailableHeight(false);
      this.clearResizeListeners();
      this.removeResizers();
    }
  };
  __decorateClass([
    Autowired("popupService")
  ], PositionableFeature.prototype, "popupService", 2);
  __decorateClass([
    Autowired("resizeObserverService")
  ], PositionableFeature.prototype, "resizeObserverService", 2);
  __decorateClass([
    Autowired("dragService")
  ], PositionableFeature.prototype, "dragService", 2);
  var _ProvidedFilter = class _ProvidedFilter2 extends Component {
    constructor(filterNameKey) {
      super();
      this.filterNameKey = filterNameKey;
      this.applyActive = false;
      this.hidePopup = null;
      this.debouncePending = false;
      this.appliedModel = null;
      this.buttonListeners = [];
    }
    postConstruct() {
      this.resetTemplate();
      this.createManagedBean(new ManagedFocusFeature(
        this.getFocusableElement(),
        {
          handleKeyDown: this.handleKeyDown.bind(this)
        }
      ));
      this.positionableFeature = new PositionableFeature(
        this.getPositionableElement(),
        {
          forcePopupParentAsOffsetParent: true
        }
      );
      this.createBean(this.positionableFeature);
    }
    // override
    handleKeyDown(e) {
    }
    getFilterTitle() {
      return this.translate(this.filterNameKey);
    }
    isFilterActive() {
      return !!this.appliedModel;
    }
    resetTemplate(paramsMap) {
      let eGui = this.getGui();
      if (eGui) {
        eGui.removeEventListener("submit", this.onFormSubmit);
      }
      const templateString = (
        /* html */
        `
            <form class="ag-filter-wrapper">
                <div class="ag-filter-body-wrapper ag-${this.getCssIdentifier()}-body-wrapper" ref="eFilterBody">
                    ${this.createBodyTemplate()}
                </div>
            </form>`
      );
      this.setTemplate(templateString, paramsMap);
      eGui = this.getGui();
      if (eGui) {
        eGui.addEventListener("submit", this.onFormSubmit);
      }
    }
    isReadOnly() {
      return !!this.providedFilterParams.readOnly;
    }
    init(params) {
      this.setParams(params);
      this.resetUiToDefaults(true).then(() => {
        this.updateUiVisibility();
        this.setupOnBtApplyDebounce();
      });
    }
    setParams(params) {
      this.providedFilterParams = params;
      this.applyActive = _ProvidedFilter2.isUseApplyButton(params);
      this.resetButtonsPanel();
    }
    updateParams(params) {
      this.providedFilterParams = params;
      this.applyActive = _ProvidedFilter2.isUseApplyButton(params);
      this.resetUiToActiveModel(this.getModel(), () => {
        this.updateUiVisibility();
        this.setupOnBtApplyDebounce();
      });
    }
    resetButtonsPanel() {
      const { buttons } = this.providedFilterParams;
      const hasButtons = buttons && buttons.length > 0 && !this.isReadOnly();
      if (!this.eButtonsPanel) {
        if (hasButtons) {
          this.eButtonsPanel = document.createElement("div");
          this.eButtonsPanel.classList.add("ag-filter-apply-panel");
        }
      } else {
        clearElement(this.eButtonsPanel);
        this.buttonListeners.forEach((destroyFunc) => destroyFunc == null ? void 0 : destroyFunc());
        this.buttonListeners = [];
      }
      if (!hasButtons) {
        if (this.eButtonsPanel) {
          removeFromParent(this.eButtonsPanel);
        }
        return;
      }
      const fragment = document.createDocumentFragment();
      const addButton = (type) => {
        let text;
        let clickListener;
        switch (type) {
          case "apply":
            text = this.translate("applyFilter");
            clickListener = (e) => this.onBtApply(false, false, e);
            break;
          case "clear":
            text = this.translate("clearFilter");
            clickListener = () => this.onBtClear();
            break;
          case "reset":
            text = this.translate("resetFilter");
            clickListener = () => this.onBtReset();
            break;
          case "cancel":
            text = this.translate("cancelFilter");
            clickListener = (e) => {
              this.onBtCancel(e);
            };
            break;
          default:
            console.warn("AG Grid: Unknown button type specified");
            return;
        }
        const buttonType = type === "apply" ? "submit" : "button";
        const button = loadTemplate(
          /* html */
          `<button
                    type="${buttonType}"
                    ref="${type}FilterButton"
                    class="ag-button ag-standard-button ag-filter-apply-panel-button"
                >${text}
                </button>`
        );
        this.buttonListeners.push(this.addManagedListener(button, "click", clickListener));
        fragment.append(button);
      };
      convertToSet(buttons).forEach((type) => addButton(type));
      this.eButtonsPanel.append(fragment);
      this.getGui().appendChild(this.eButtonsPanel);
    }
    // subclasses can override this to provide alternative debounce defaults
    getDefaultDebounceMs() {
      return 0;
    }
    setupOnBtApplyDebounce() {
      const debounceMs = _ProvidedFilter2.getDebounceMs(this.providedFilterParams, this.getDefaultDebounceMs());
      const debounceFunc = debounce2(this.checkApplyDebounce.bind(this), debounceMs);
      this.onBtApplyDebounce = () => {
        this.debouncePending = true;
        debounceFunc();
      };
    }
    checkApplyDebounce() {
      if (this.debouncePending) {
        this.debouncePending = false;
        this.onBtApply();
      }
    }
    getModel() {
      return this.appliedModel ? this.appliedModel : null;
    }
    setModel(model) {
      const promise = model != null ? this.setModelIntoUi(model) : this.resetUiToDefaults();
      return promise.then(() => {
        this.updateUiVisibility();
        this.applyModel("api");
      });
    }
    onBtCancel(e) {
      this.resetUiToActiveModel(this.getModel(), () => {
        this.handleCancelEnd(e);
      });
    }
    handleCancelEnd(e) {
      if (this.providedFilterParams.closeOnApply) {
        this.close(e);
      }
    }
    resetUiToActiveModel(currentModel, afterUiUpdatedFunc) {
      const afterAppliedFunc = () => {
        this.onUiChanged(false, "prevent");
        afterUiUpdatedFunc == null ? void 0 : afterUiUpdatedFunc();
      };
      if (currentModel != null) {
        this.setModelIntoUi(currentModel).then(afterAppliedFunc);
      } else {
        this.resetUiToDefaults().then(afterAppliedFunc);
      }
    }
    onBtClear() {
      this.resetUiToDefaults().then(() => this.onUiChanged());
    }
    onBtReset() {
      this.onBtClear();
      this.onBtApply();
    }
    /**
     * Applies changes made in the UI to the filter, and returns true if the model has changed.
     */
    applyModel(source = "api") {
      const newModel = this.getModelFromUi();
      if (!this.isModelValid(newModel)) {
        return false;
      }
      const previousModel = this.appliedModel;
      this.appliedModel = newModel;
      return !this.areModelsEqual(previousModel, newModel);
    }
    isModelValid(model) {
      return true;
    }
    onFormSubmit(e) {
      e.preventDefault();
    }
    onBtApply(afterFloatingFilter = false, afterDataChange = false, e) {
      if (e) {
        e.preventDefault();
      }
      if (this.applyModel(afterDataChange ? "rowDataUpdated" : "ui")) {
        const source = "columnFilter";
        this.providedFilterParams.filterChangedCallback({ afterFloatingFilter, afterDataChange, source });
      }
      const { closeOnApply } = this.providedFilterParams;
      if (closeOnApply && this.applyActive && !afterFloatingFilter && !afterDataChange) {
        this.close(e);
      }
    }
    onNewRowsLoaded() {
    }
    close(e) {
      if (!this.hidePopup) {
        return;
      }
      const keyboardEvent = e;
      const key = keyboardEvent && keyboardEvent.key;
      let params;
      if (key === "Enter" || key === "Space") {
        params = { keyboardEvent };
      }
      this.hidePopup(params);
      this.hidePopup = null;
    }
    /**
     * By default, if the change came from a floating filter it will be applied immediately, otherwise if there is no
     * apply button it will be applied after a debounce, otherwise it will not be applied at all. This behaviour can
     * be adjusted by using the apply parameter.
     */
    onUiChanged(fromFloatingFilter = false, apply) {
      this.updateUiVisibility();
      this.providedFilterParams.filterModifiedCallback();
      if (this.applyActive && !this.isReadOnly()) {
        const isValid = this.isModelValid(this.getModelFromUi());
        const applyFilterButton = this.getRefElement("applyFilterButton");
        if (applyFilterButton) {
          setDisabled(applyFilterButton, !isValid);
        }
      }
      if (fromFloatingFilter && !apply || apply === "immediately") {
        this.onBtApply(fromFloatingFilter);
      } else if (!this.applyActive && !apply || apply === "debounce") {
        this.onBtApplyDebounce();
      }
    }
    afterGuiAttached(params) {
      if (params) {
        this.hidePopup = params.hidePopup;
      }
      this.refreshFilterResizer(params == null ? void 0 : params.container);
    }
    refreshFilterResizer(containerType) {
      if (!this.positionableFeature || containerType === "toolPanel") {
        return;
      }
      const isResizable = containerType === "floatingFilter" || containerType === "columnFilter";
      const { positionableFeature, gos } = this;
      if (isResizable) {
        positionableFeature.restoreLastSize();
        positionableFeature.setResizable(
          gos.get("enableRtl") ? { bottom: true, bottomLeft: true, left: true } : { bottom: true, bottomRight: true, right: true }
        );
      } else {
        this.positionableFeature.removeSizeFromEl();
        this.positionableFeature.setResizable(false);
      }
      this.positionableFeature.constrainSizeToAvailableHeight(true);
    }
    afterGuiDetached() {
      this.checkApplyDebounce();
      if (this.positionableFeature) {
        this.positionableFeature.constrainSizeToAvailableHeight(false);
      }
    }
    // static, as used by floating filter also
    static getDebounceMs(params, debounceDefault) {
      if (_ProvidedFilter2.isUseApplyButton(params)) {
        if (params.debounceMs != null) {
          console.warn("AG Grid: debounceMs is ignored when apply button is present");
        }
        return 0;
      }
      return params.debounceMs != null ? params.debounceMs : debounceDefault;
    }
    // static, as used by floating filter also
    static isUseApplyButton(params) {
      return !!params.buttons && params.buttons.indexOf("apply") >= 0;
    }
    refresh(newParams) {
      this.providedFilterParams = newParams;
      return true;
    }
    destroy() {
      const eGui = this.getGui();
      if (eGui) {
        eGui.removeEventListener("submit", this.onFormSubmit);
      }
      this.hidePopup = null;
      if (this.positionableFeature) {
        this.positionableFeature = this.destroyBean(this.positionableFeature);
      }
      this.appliedModel = null;
      super.destroy();
    }
    translate(key) {
      const translate = this.localeService.getLocaleTextFunc();
      return translate(key, FILTER_LOCALE_TEXT[key]);
    }
    getCellValue(rowNode) {
      return this.providedFilterParams.getValue(rowNode);
    }
    // override to control positionable feature
    getPositionableElement() {
      return this.eFilterBody;
    }
  };
  __decorateClass([
    Autowired("rowModel")
  ], _ProvidedFilter.prototype, "rowModel", 2);
  __decorateClass([
    RefSelector("eFilterBody")
  ], _ProvidedFilter.prototype, "eFilterBody", 2);
  __decorateClass([
    PostConstruct
  ], _ProvidedFilter.prototype, "postConstruct", 1);
  var ProvidedFilter = _ProvidedFilter;
  var AgAbstractLabel = class extends Component {
    constructor(config, template) {
      super(template);
      this.labelSeparator = "";
      this.labelAlignment = "left";
      this.disabled = false;
      this.label = "";
      this.config = config || {};
    }
    postConstruct() {
      this.addCssClass("ag-labeled");
      this.eLabel.classList.add("ag-label");
      const { labelSeparator, label, labelWidth, labelAlignment, disabled } = this.config;
      if (disabled != null) {
        this.setDisabled(disabled);
      }
      if (labelSeparator != null) {
        this.setLabelSeparator(labelSeparator);
      }
      if (label != null) {
        this.setLabel(label);
      }
      if (labelWidth != null) {
        this.setLabelWidth(labelWidth);
      }
      this.setLabelAlignment(labelAlignment || this.labelAlignment);
      this.refreshLabel();
    }
    refreshLabel() {
      clearElement(this.eLabel);
      if (typeof this.label === "string") {
        this.eLabel.innerText = this.label + this.labelSeparator;
      } else if (this.label) {
        this.eLabel.appendChild(this.label);
      }
      if (this.label === "") {
        setDisplayed(this.eLabel, false);
        setAriaRole(this.eLabel, "presentation");
      } else {
        setDisplayed(this.eLabel, true);
        setAriaRole(this.eLabel, null);
      }
    }
    setLabelSeparator(labelSeparator) {
      if (this.labelSeparator === labelSeparator) {
        return this;
      }
      this.labelSeparator = labelSeparator;
      if (this.label != null) {
        this.refreshLabel();
      }
      return this;
    }
    getLabelId() {
      this.eLabel.id = this.eLabel.id || `ag-${this.getCompId()}-label`;
      return this.eLabel.id;
    }
    getLabel() {
      return this.label;
    }
    setLabel(label) {
      if (this.label === label) {
        return this;
      }
      this.label = label;
      this.refreshLabel();
      return this;
    }
    setLabelAlignment(alignment) {
      const eGui = this.getGui();
      const eGuiClassList = eGui.classList;
      eGuiClassList.toggle("ag-label-align-left", alignment === "left");
      eGuiClassList.toggle("ag-label-align-right", alignment === "right");
      eGuiClassList.toggle("ag-label-align-top", alignment === "top");
      return this;
    }
    setLabelEllipsis(hasEllipsis) {
      this.eLabel.classList.toggle("ag-label-ellipsis", hasEllipsis);
      return this;
    }
    setLabelWidth(width) {
      if (this.label == null) {
        return this;
      }
      setElementWidth(this.eLabel, width);
      return this;
    }
    setDisabled(disabled) {
      disabled = !!disabled;
      const element = this.getGui();
      setDisabled(element, disabled);
      element.classList.toggle("ag-disabled", disabled);
      this.disabled = disabled;
      return this;
    }
    isDisabled() {
      return !!this.disabled;
    }
  };
  __decorateClass([
    PostConstruct
  ], AgAbstractLabel.prototype, "postConstruct", 1);
  var AgAbstractField = class extends AgAbstractLabel {
    constructor(config, template, className) {
      super(config, template);
      this.className = className;
    }
    postConstruct() {
      super.postConstruct();
      const { width, value, onValueChange } = this.config;
      if (width != null) {
        this.setWidth(width);
      }
      if (value != null) {
        this.setValue(value);
      }
      if (onValueChange != null) {
        this.onValueChange(onValueChange);
      }
      if (this.className) {
        this.addCssClass(this.className);
      }
      this.refreshAriaLabelledBy();
    }
    refreshAriaLabelledBy() {
      const ariaEl = this.getAriaElement();
      const labelId = this.getLabelId();
      if (getAriaLabel(ariaEl) !== null) {
        setAriaLabelledBy(ariaEl, "");
      } else {
        setAriaLabelledBy(ariaEl, labelId != null ? labelId : "");
      }
    }
    setAriaLabel(label) {
      setAriaLabel(this.getAriaElement(), label);
      this.refreshAriaLabelledBy();
      return this;
    }
    onValueChange(callbackFn) {
      this.addManagedListener(this, Events.EVENT_FIELD_VALUE_CHANGED, () => callbackFn(this.getValue()));
      return this;
    }
    getWidth() {
      return this.getGui().clientWidth;
    }
    setWidth(width) {
      setFixedWidth(this.getGui(), width);
      return this;
    }
    getPreviousValue() {
      return this.previousValue;
    }
    getValue() {
      return this.value;
    }
    setValue(value, silent) {
      if (this.value === value) {
        return this;
      }
      this.previousValue = this.value;
      this.value = value;
      if (!silent) {
        this.dispatchEvent({ type: Events.EVENT_FIELD_VALUE_CHANGED });
      }
      return this;
    }
  };
  var TEMPLATE = (
    /* html */
    `
    <div class="ag-picker-field" role="presentation">
        <div ref="eLabel"></div>
            <div ref="eWrapper" class="ag-wrapper ag-picker-field-wrapper ag-picker-collapsed">
            <div ref="eDisplayField" class="ag-picker-field-display"></div>
            <div ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
        </div>
    </div>`
  );
  var AgPickerField = class extends AgAbstractField {
    constructor(config) {
      super(config, (config == null ? void 0 : config.template) || TEMPLATE, config == null ? void 0 : config.className);
      this.isPickerDisplayed = false;
      this.skipClick = false;
      this.pickerGap = 4;
      this.hideCurrentPicker = null;
      this.ariaRole = config == null ? void 0 : config.ariaRole;
      this.onPickerFocusIn = this.onPickerFocusIn.bind(this);
      this.onPickerFocusOut = this.onPickerFocusOut.bind(this);
      if (!config) {
        return;
      }
      const { pickerGap, maxPickerHeight, variableWidth, minPickerWidth, maxPickerWidth } = config;
      if (pickerGap != null) {
        this.pickerGap = pickerGap;
      }
      this.variableWidth = !!variableWidth;
      if (maxPickerHeight != null) {
        this.setPickerMaxHeight(maxPickerHeight);
      }
      if (minPickerWidth != null) {
        this.setPickerMinWidth(minPickerWidth);
      }
      if (maxPickerWidth != null) {
        this.setPickerMaxWidth(maxPickerWidth);
      }
    }
    postConstruct() {
      super.postConstruct();
      this.setupAria();
      const displayId = `ag-${this.getCompId()}-display`;
      this.eDisplayField.setAttribute("id", displayId);
      const ariaEl = this.getAriaElement();
      this.addManagedListener(ariaEl, "keydown", this.onKeyDown.bind(this));
      this.addManagedListener(this.eLabel, "mousedown", this.onLabelOrWrapperMouseDown.bind(this));
      this.addManagedListener(this.eWrapper, "mousedown", this.onLabelOrWrapperMouseDown.bind(this));
      const { pickerIcon, inputWidth } = this.config;
      if (pickerIcon) {
        const icon = createIconNoSpan(pickerIcon, this.gos);
        if (icon) {
          this.eIcon.appendChild(icon);
        }
      }
      if (inputWidth != null) {
        this.setInputWidth(inputWidth);
      }
    }
    setupAria() {
      const ariaEl = this.getAriaElement();
      ariaEl.setAttribute("tabindex", this.gos.get("tabIndex").toString());
      setAriaExpanded(ariaEl, false);
      if (this.ariaRole) {
        setAriaRole(ariaEl, this.ariaRole);
      }
    }
    onLabelOrWrapperMouseDown(e) {
      if (e) {
        const focusableEl = this.getFocusableElement();
        if (focusableEl !== this.eWrapper && (e == null ? void 0 : e.target) === focusableEl) {
          return;
        }
        e.preventDefault();
        this.getFocusableElement().focus();
      }
      if (this.skipClick) {
        this.skipClick = false;
        return;
      }
      if (this.isDisabled()) {
        return;
      }
      if (this.isPickerDisplayed) {
        this.hidePicker();
      } else {
        this.showPicker();
      }
    }
    onKeyDown(e) {
      switch (e.key) {
        case KeyCode.UP:
        case KeyCode.DOWN:
        case KeyCode.ENTER:
        case KeyCode.SPACE:
          e.preventDefault();
          this.onLabelOrWrapperMouseDown();
          break;
        case KeyCode.ESCAPE:
          if (this.isPickerDisplayed) {
            e.preventDefault();
            e.stopPropagation();
            if (this.hideCurrentPicker) {
              this.hideCurrentPicker();
            }
          }
          break;
      }
    }
    showPicker() {
      this.isPickerDisplayed = true;
      if (!this.pickerComponent) {
        this.pickerComponent = this.createPickerComponent();
      }
      const pickerGui = this.pickerComponent.getGui();
      pickerGui.addEventListener("focusin", this.onPickerFocusIn);
      pickerGui.addEventListener("focusout", this.onPickerFocusOut);
      this.hideCurrentPicker = this.renderAndPositionPicker();
      this.toggleExpandedStyles(true);
    }
    renderAndPositionPicker() {
      const eDocument = this.gos.getDocument();
      const ePicker = this.pickerComponent.getGui();
      if (!this.gos.get("suppressScrollWhenPopupsAreOpen")) {
        this.destroyMouseWheelFunc = this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL, () => {
          this.hidePicker();
        });
      }
      const translate = this.localeService.getLocaleTextFunc();
      const { pickerAriaLabelKey, pickerAriaLabelValue, modalPicker = true } = this.config;
      const popupParams = {
        modal: modalPicker,
        eChild: ePicker,
        closeOnEsc: true,
        closedCallback: () => {
          const activeEl = this.gos.getActiveDomElement();
          const shouldRestoreFocus = !activeEl || activeEl === eDocument.body;
          this.beforeHidePicker();
          if (shouldRestoreFocus && this.isAlive()) {
            this.getFocusableElement().focus();
          }
        },
        ariaLabel: translate(pickerAriaLabelKey, pickerAriaLabelValue)
      };
      const addPopupRes = this.popupService.addPopup(popupParams);
      const { maxPickerHeight, minPickerWidth, maxPickerWidth, variableWidth } = this;
      if (variableWidth) {
        if (minPickerWidth) {
          ePicker.style.minWidth = minPickerWidth;
        }
        ePicker.style.width = formatSize(getAbsoluteWidth(this.eWrapper));
        if (maxPickerWidth) {
          ePicker.style.maxWidth = maxPickerWidth;
        }
      } else {
        setElementWidth(ePicker, maxPickerWidth != null ? maxPickerWidth : getAbsoluteWidth(this.eWrapper));
      }
      const maxHeight = maxPickerHeight != null ? maxPickerHeight : `${getInnerHeight(this.popupService.getPopupParent())}px`;
      ePicker.style.setProperty("max-height", maxHeight);
      ePicker.style.position = "absolute";
      this.alignPickerToComponent();
      return addPopupRes.hideFunc;
    }
    alignPickerToComponent() {
      if (!this.pickerComponent) {
        return;
      }
      const { pickerType } = this.config;
      const { pickerGap } = this;
      const alignSide = this.gos.get("enableRtl") ? "right" : "left";
      this.popupService.positionPopupByComponent({
        type: pickerType,
        eventSource: this.eWrapper,
        ePopup: this.pickerComponent.getGui(),
        position: "under",
        alignSide,
        keepWithinBounds: true,
        nudgeY: pickerGap
      });
    }
    beforeHidePicker() {
      if (this.destroyMouseWheelFunc) {
        this.destroyMouseWheelFunc();
        this.destroyMouseWheelFunc = void 0;
      }
      this.toggleExpandedStyles(false);
      const pickerGui = this.pickerComponent.getGui();
      pickerGui.removeEventListener("focusin", this.onPickerFocusIn);
      pickerGui.removeEventListener("focusout", this.onPickerFocusOut);
      this.isPickerDisplayed = false;
      this.pickerComponent = void 0;
      this.hideCurrentPicker = null;
    }
    toggleExpandedStyles(expanded) {
      if (!this.isAlive()) {
        return;
      }
      const ariaEl = this.getAriaElement();
      setAriaExpanded(ariaEl, expanded);
      this.eWrapper.classList.toggle("ag-picker-expanded", expanded);
      this.eWrapper.classList.toggle("ag-picker-collapsed", !expanded);
    }
    onPickerFocusIn() {
      this.togglePickerHasFocus(true);
    }
    onPickerFocusOut(e) {
      var _a;
      if (!((_a = this.pickerComponent) == null ? void 0 : _a.getGui().contains(e.relatedTarget))) {
        this.togglePickerHasFocus(false);
      }
    }
    togglePickerHasFocus(focused) {
      if (!this.pickerComponent) {
        return;
      }
      this.eWrapper.classList.toggle("ag-picker-has-focus", focused);
    }
    hidePicker() {
      if (this.hideCurrentPicker) {
        this.hideCurrentPicker();
      }
    }
    setInputWidth(width) {
      setElementWidth(this.eWrapper, width);
      return this;
    }
    getFocusableElement() {
      return this.eWrapper;
    }
    setPickerGap(gap) {
      this.pickerGap = gap;
      return this;
    }
    setPickerMinWidth(width) {
      if (typeof width === "number") {
        width = `${width}px`;
      }
      this.minPickerWidth = width == null ? void 0 : width;
      return this;
    }
    setPickerMaxWidth(width) {
      if (typeof width === "number") {
        width = `${width}px`;
      }
      this.maxPickerWidth = width == null ? void 0 : width;
      return this;
    }
    setPickerMaxHeight(height) {
      if (typeof height === "number") {
        height = `${height}px`;
      }
      this.maxPickerHeight = height == null ? void 0 : height;
      return this;
    }
    destroy() {
      this.hidePicker();
      super.destroy();
    }
  };
  __decorateClass([
    Autowired("popupService")
  ], AgPickerField.prototype, "popupService", 2);
  __decorateClass([
    RefSelector("eLabel")
  ], AgPickerField.prototype, "eLabel", 2);
  __decorateClass([
    RefSelector("eWrapper")
  ], AgPickerField.prototype, "eWrapper", 2);
  __decorateClass([
    RefSelector("eDisplayField")
  ], AgPickerField.prototype, "eDisplayField", 2);
  __decorateClass([
    RefSelector("eIcon")
  ], AgPickerField.prototype, "eIcon", 2);
  var _AgList = class _AgList2 extends Component {
    constructor(cssIdentifier = "default", unFocusable = false) {
      super(
        /* html */
        `<div class="ag-list ag-${cssIdentifier}-list" role="listbox"></div>`
      );
      this.cssIdentifier = cssIdentifier;
      this.unFocusable = unFocusable;
      this.options = [];
      this.itemEls = [];
    }
    init() {
      const eGui = this.getGui();
      this.addManagedListener(eGui, "mouseleave", () => this.clearHighlighted());
      if (this.unFocusable) {
        return;
      }
      this.addManagedListener(eGui, "keydown", this.handleKeyDown.bind(this));
    }
    handleKeyDown(e) {
      const key = e.key;
      switch (key) {
        case KeyCode.ENTER:
          if (!this.highlightedEl) {
            this.setValue(this.getValue());
          } else {
            const pos = this.itemEls.indexOf(this.highlightedEl);
            this.setValueByIndex(pos);
          }
          break;
        case KeyCode.DOWN:
        case KeyCode.UP:
          e.preventDefault();
          this.navigate(key);
          break;
        case KeyCode.PAGE_DOWN:
        case KeyCode.PAGE_UP:
        case KeyCode.PAGE_HOME:
        case KeyCode.PAGE_END:
          e.preventDefault();
          this.navigateToPage(key);
          break;
      }
    }
    navigate(key) {
      const isDown = key === KeyCode.DOWN;
      let itemToHighlight;
      if (!this.highlightedEl) {
        itemToHighlight = this.itemEls[isDown ? 0 : this.itemEls.length - 1];
      } else {
        const currentIdx = this.itemEls.indexOf(this.highlightedEl);
        let nextPos = currentIdx + (isDown ? 1 : -1);
        nextPos = Math.min(Math.max(nextPos, 0), this.itemEls.length - 1);
        itemToHighlight = this.itemEls[nextPos];
      }
      this.highlightItem(itemToHighlight);
    }
    navigateToPage(key) {
      if (!this.highlightedEl || this.itemEls.length === 0) {
        return;
      }
      const currentIdx = this.itemEls.indexOf(this.highlightedEl);
      const rowCount = this.options.length - 1;
      const itemHeight = this.itemEls[0].clientHeight;
      const pageSize = Math.floor(this.getGui().clientHeight / itemHeight);
      let newIndex = -1;
      if (key === KeyCode.PAGE_HOME) {
        newIndex = 0;
      } else if (key === KeyCode.PAGE_END) {
        newIndex = rowCount;
      } else if (key === KeyCode.PAGE_DOWN) {
        newIndex = Math.min(currentIdx + pageSize, rowCount);
      } else if (key === KeyCode.PAGE_UP) {
        newIndex = Math.max(currentIdx - pageSize, 0);
      }
      if (newIndex === -1) {
        return;
      }
      this.highlightItem(this.itemEls[newIndex]);
    }
    addOptions(listOptions) {
      listOptions.forEach((listOption) => this.addOption(listOption));
      return this;
    }
    addOption(listOption) {
      const { value, text } = listOption;
      const valueToRender = text || value;
      this.options.push({ value, text: valueToRender });
      this.renderOption(value, valueToRender);
      this.updateIndices();
      return this;
    }
    clearOptions() {
      this.options = [];
      this.reset(true);
      this.itemEls.forEach((itemEl) => {
        removeFromParent(itemEl);
      });
      this.itemEls = [];
    }
    updateIndices() {
      const options = this.getGui().querySelectorAll(".ag-list-item");
      options.forEach((option, idx) => {
        setAriaPosInSet(option, idx + 1);
        setAriaSetSize(option, options.length);
      });
    }
    renderOption(value, text) {
      const eDocument = this.gos.getDocument();
      const itemEl = eDocument.createElement("div");
      setAriaRole(itemEl, "option");
      itemEl.classList.add("ag-list-item", `ag-${this.cssIdentifier}-list-item`);
      const span = eDocument.createElement("span");
      itemEl.appendChild(span);
      span.textContent = text;
      if (!this.unFocusable) {
        itemEl.tabIndex = -1;
      }
      this.itemEls.push(itemEl);
      this.addManagedListener(itemEl, "mousemove", () => this.highlightItem(itemEl));
      this.addManagedListener(itemEl, "mousedown", (e) => {
        e.preventDefault();
        this.setValue(value);
      });
      this.createManagedBean(new TooltipFeature({
        getTooltipValue: () => text,
        getGui: () => itemEl,
        getLocation: () => "UNKNOWN",
        // only show tooltips for items where the text cannot be fully displayed
        shouldDisplayTooltip: () => span.scrollWidth > span.clientWidth
      }));
      this.getGui().appendChild(itemEl);
    }
    setValue(value, silent) {
      if (this.value === value) {
        this.fireItemSelected();
        return this;
      }
      if (value == null) {
        this.reset(silent);
        return this;
      }
      const idx = this.options.findIndex((option) => option.value === value);
      if (idx !== -1) {
        const option = this.options[idx];
        this.value = option.value;
        this.displayValue = option.text;
        this.highlightItem(this.itemEls[idx]);
        if (!silent) {
          this.fireChangeEvent();
        }
      }
      return this;
    }
    setValueByIndex(idx) {
      return this.setValue(this.options[idx].value);
    }
    getValue() {
      return this.value;
    }
    getDisplayValue() {
      return this.displayValue;
    }
    refreshHighlighted() {
      this.clearHighlighted();
      const idx = this.options.findIndex((option) => option.value === this.value);
      if (idx !== -1) {
        this.highlightItem(this.itemEls[idx]);
      }
    }
    reset(silent) {
      this.value = null;
      this.displayValue = null;
      this.clearHighlighted();
      if (!silent) {
        this.fireChangeEvent();
      }
    }
    highlightItem(el) {
      if (!isVisible(el)) {
        return;
      }
      this.clearHighlighted();
      this.highlightedEl = el;
      this.highlightedEl.classList.add(_AgList2.ACTIVE_CLASS);
      setAriaSelected(this.highlightedEl, true);
      const eGui = this.getGui();
      const { scrollTop, clientHeight } = eGui;
      const { offsetTop, offsetHeight } = el;
      if (offsetTop + offsetHeight > scrollTop + clientHeight || offsetTop < scrollTop) {
        this.highlightedEl.scrollIntoView({ block: "nearest" });
      }
      if (!this.unFocusable) {
        this.highlightedEl.focus();
      }
    }
    clearHighlighted() {
      if (!this.highlightedEl || !isVisible(this.highlightedEl)) {
        return;
      }
      this.highlightedEl.classList.remove(_AgList2.ACTIVE_CLASS);
      setAriaSelected(this.highlightedEl, false);
      this.highlightedEl = null;
    }
    fireChangeEvent() {
      this.dispatchEvent({ type: Events.EVENT_FIELD_VALUE_CHANGED });
      this.fireItemSelected();
    }
    fireItemSelected() {
      this.dispatchEvent({ type: _AgList2.EVENT_ITEM_SELECTED });
    }
  };
  _AgList.EVENT_ITEM_SELECTED = "selectedItem";
  _AgList.ACTIVE_CLASS = "ag-active-item";
  __decorateClass([
    PostConstruct
  ], _AgList.prototype, "init", 1);
  var AgList = _AgList;
  var _AgSelect = class _AgSelect2 extends AgPickerField {
    constructor(config) {
      super(__spreadValues({
        pickerAriaLabelKey: "ariaLabelSelectField",
        pickerAriaLabelValue: "Select Field",
        pickerType: "ag-list",
        className: "ag-select",
        pickerIcon: "smallDown",
        ariaRole: "combobox"
      }, config));
    }
    postConstruct() {
      super.postConstruct();
      this.createListComponent();
      this.eWrapper.tabIndex = this.gos.get("tabIndex");
      const { options, value, placeholder } = this.config;
      if (options != null) {
        this.addOptions(options);
      }
      if (value != null) {
        this.setValue(value, true);
      }
      if (placeholder && value == null) {
        this.eDisplayField.textContent = placeholder;
      }
      this.addManagedListener(this.eWrapper, "focusout", this.onWrapperFocusOut.bind(this));
    }
    onWrapperFocusOut(e) {
      if (!this.eWrapper.contains(e.relatedTarget)) {
        this.hidePicker();
      }
    }
    createListComponent() {
      this.listComponent = this.createBean(new AgList("select", true));
      this.listComponent.setParentComponent(this);
      const eListAriaEl = this.listComponent.getAriaElement();
      const listId = `ag-select-list-${this.listComponent.getCompId()}`;
      eListAriaEl.setAttribute("id", listId);
      setAriaControls(this.getAriaElement(), eListAriaEl);
      this.listComponent.addManagedListener(
        this.listComponent,
        AgList.EVENT_ITEM_SELECTED,
        () => {
          this.hidePicker();
          this.dispatchEvent({ type: _AgSelect2.EVENT_ITEM_SELECTED });
        }
      );
      this.listComponent.addManagedListener(
        this.listComponent,
        Events.EVENT_FIELD_VALUE_CHANGED,
        () => {
          if (!this.listComponent) {
            return;
          }
          this.setValue(this.listComponent.getValue(), false, true);
          this.hidePicker();
        }
      );
    }
    createPickerComponent() {
      return this.listComponent;
    }
    onKeyDown(e) {
      var _a;
      const { key } = e;
      if (key === KeyCode.TAB) {
        this.hidePicker();
      }
      switch (key) {
        case KeyCode.ENTER:
        case KeyCode.UP:
        case KeyCode.DOWN:
        case KeyCode.PAGE_UP:
        case KeyCode.PAGE_DOWN:
        case KeyCode.PAGE_HOME:
        case KeyCode.PAGE_END:
          e.preventDefault();
          if (this.isPickerDisplayed) {
            (_a = this.listComponent) == null ? void 0 : _a.handleKeyDown(e);
          } else {
            super.onKeyDown(e);
          }
          break;
        case KeyCode.ESCAPE:
          super.onKeyDown(e);
          break;
      }
    }
    showPicker() {
      if (!this.listComponent) {
        return;
      }
      super.showPicker();
      this.listComponent.refreshHighlighted();
    }
    addOptions(options) {
      options.forEach((option) => this.addOption(option));
      return this;
    }
    addOption(option) {
      this.listComponent.addOption(option);
      return this;
    }
    clearOptions() {
      var _a;
      (_a = this.listComponent) == null ? void 0 : _a.clearOptions();
      return this;
    }
    setValue(value, silent, fromPicker) {
      if (this.value === value || !this.listComponent) {
        return this;
      }
      if (!fromPicker) {
        this.listComponent.setValue(value, true);
      }
      const newValue = this.listComponent.getValue();
      if (newValue === this.getValue()) {
        return this;
      }
      let displayValue = this.listComponent.getDisplayValue();
      if (displayValue == null && this.config.placeholder) {
        displayValue = this.config.placeholder;
      }
      this.eDisplayField.textContent = displayValue;
      this.setTooltip({
        newTooltipText: displayValue != null ? displayValue : null,
        shouldDisplayTooltip: () => this.eDisplayField.scrollWidth > this.eDisplayField.clientWidth
      });
      return super.setValue(value, silent);
    }
    destroy() {
      if (this.listComponent) {
        this.destroyBean(this.listComponent);
        this.listComponent = void 0;
      }
      super.destroy();
    }
  };
  _AgSelect.EVENT_ITEM_SELECTED = "selectedItem";
  var AgSelect = _AgSelect;
  var AgAbstractInputField = class extends AgAbstractField {
    constructor(config, className, inputType = "text", displayFieldTag = "input") {
      super(
        config,
        /* html */
        `
            <div role="presentation">
                <div ref="eLabel" class="ag-input-field-label"></div>
                <div ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">
                    <${displayFieldTag} ref="eInput" class="ag-input-field-input"></${displayFieldTag}>
                </div>
            </div>`,
        className
      );
      this.inputType = inputType;
      this.displayFieldTag = displayFieldTag;
    }
    postConstruct() {
      super.postConstruct();
      this.setInputType();
      this.eLabel.classList.add(`${this.className}-label`);
      this.eWrapper.classList.add(`${this.className}-input-wrapper`);
      this.eInput.classList.add(`${this.className}-input`);
      this.addCssClass("ag-input-field");
      this.eInput.id = this.eInput.id || `ag-${this.getCompId()}-input`;
      const { inputName, inputWidth } = this.config;
      if (inputName != null) {
        this.setInputName(inputName);
      }
      if (inputWidth != null) {
        this.setInputWidth(inputWidth);
      }
      this.addInputListeners();
      this.activateTabIndex([this.eInput]);
    }
    addInputListeners() {
      this.addManagedListener(this.eInput, "input", (e) => this.setValue(e.target.value));
    }
    setInputType() {
      if (this.displayFieldTag === "input") {
        this.eInput.setAttribute("type", this.inputType);
      }
    }
    getInputElement() {
      return this.eInput;
    }
    setInputWidth(width) {
      setElementWidth(this.eWrapper, width);
      return this;
    }
    setInputName(name) {
      this.getInputElement().setAttribute("name", name);
      return this;
    }
    getFocusableElement() {
      return this.eInput;
    }
    setMaxLength(length) {
      const eInput = this.eInput;
      eInput.maxLength = length;
      return this;
    }
    setInputPlaceholder(placeholder) {
      addOrRemoveAttribute(this.eInput, "placeholder", placeholder);
      return this;
    }
    setInputAriaLabel(label) {
      setAriaLabel(this.eInput, label);
      this.refreshAriaLabelledBy();
      return this;
    }
    setDisabled(disabled) {
      setDisabled(this.eInput, disabled);
      return super.setDisabled(disabled);
    }
    setAutoComplete(value) {
      if (value === true) {
        addOrRemoveAttribute(this.eInput, "autocomplete", null);
      } else {
        const autoCompleteValue = typeof value === "string" ? value : "off";
        addOrRemoveAttribute(this.eInput, "autocomplete", autoCompleteValue);
      }
      return this;
    }
  };
  __decorateClass([
    RefSelector("eLabel")
  ], AgAbstractInputField.prototype, "eLabel", 2);
  __decorateClass([
    RefSelector("eWrapper")
  ], AgAbstractInputField.prototype, "eWrapper", 2);
  __decorateClass([
    RefSelector("eInput")
  ], AgAbstractInputField.prototype, "eInput", 2);
  var AgCheckbox = class extends AgAbstractInputField {
    constructor(config, className = "ag-checkbox", inputType = "checkbox") {
      super(config, className, inputType);
      this.labelAlignment = "right";
      this.selected = false;
      this.readOnly = false;
      this.passive = false;
    }
    postConstruct() {
      super.postConstruct();
      const { readOnly, passive } = this.config;
      if (typeof readOnly === "boolean")
        this.setReadOnly(readOnly);
      if (typeof passive === "boolean")
        this.setPassive(passive);
    }
    addInputListeners() {
      this.addManagedListener(this.eInput, "click", this.onCheckboxClick.bind(this));
      this.addManagedListener(this.eLabel, "click", this.toggle.bind(this));
    }
    getNextValue() {
      return this.selected === void 0 ? true : !this.selected;
    }
    setPassive(passive) {
      this.passive = passive;
    }
    isReadOnly() {
      return this.readOnly;
    }
    setReadOnly(readOnly) {
      this.eWrapper.classList.toggle("ag-disabled", readOnly);
      this.eInput.disabled = readOnly;
      this.readOnly = readOnly;
    }
    setDisabled(disabled) {
      this.eWrapper.classList.toggle("ag-disabled", disabled);
      return super.setDisabled(disabled);
    }
    toggle() {
      if (this.eInput.disabled) {
        return;
      }
      const previousValue = this.isSelected();
      const nextValue = this.getNextValue();
      if (this.passive) {
        this.dispatchChange(nextValue, previousValue);
      } else {
        this.setValue(nextValue);
      }
    }
    getValue() {
      return this.isSelected();
    }
    setValue(value, silent) {
      this.refreshSelectedClass(value);
      this.setSelected(value, silent);
      return this;
    }
    setName(name) {
      const input = this.getInputElement();
      input.name = name;
      return this;
    }
    isSelected() {
      return this.selected;
    }
    setSelected(selected, silent) {
      if (this.isSelected() === selected) {
        return;
      }
      this.previousValue = this.isSelected();
      selected = this.selected = typeof selected === "boolean" ? selected : void 0;
      this.eInput.checked = selected;
      this.eInput.indeterminate = selected === void 0;
      if (!silent) {
        this.dispatchChange(this.selected, this.previousValue);
      }
    }
    dispatchChange(selected, previousValue, event) {
      this.dispatchEvent({ type: Events.EVENT_FIELD_VALUE_CHANGED, selected, previousValue, event });
      const input = this.getInputElement();
      const checkboxChangedEvent = {
        type: Events.EVENT_CHECKBOX_CHANGED,
        id: input.id,
        name: input.name,
        selected,
        previousValue
      };
      this.eventService.dispatchEvent(checkboxChangedEvent);
    }
    onCheckboxClick(e) {
      if (this.passive || this.eInput.disabled) {
        return;
      }
      const previousValue = this.isSelected();
      const selected = this.selected = e.target.checked;
      this.refreshSelectedClass(selected);
      this.dispatchChange(selected, previousValue, e);
    }
    refreshSelectedClass(value) {
      this.eWrapper.classList.toggle("ag-checked", value === true);
      this.eWrapper.classList.toggle("ag-indeterminate", value == null);
    }
  };
  var AgRadioButton = class extends AgCheckbox {
    constructor(config) {
      super(config, "ag-radio-button", "radio");
    }
    isSelected() {
      return this.eInput.checked;
    }
    toggle() {
      if (this.eInput.disabled) {
        return;
      }
      if (!this.isSelected()) {
        this.setValue(true);
      }
    }
    addInputListeners() {
      super.addInputListeners();
      this.addManagedListener(this.eventService, Events.EVENT_CHECKBOX_CHANGED, this.onChange.bind(this));
    }
    /**
     * This ensures that if another radio button in the same named group is selected, we deselect this radio button.
     * By default the browser does this for you, but we are managing classes ourselves in order to ensure input
     * elements are styled correctly in IE11, and the DOM 'changed' event is only fired when a button is selected,
     * not deselected, so we need to use our own event.
     */
    onChange(event) {
      if (event.selected && event.name && this.eInput.name && this.eInput.name === event.name && event.id && this.eInput.id !== event.id) {
        this.setValue(false, true);
      }
    }
  };
  var SimpleFilterModelFormatter = class {
    constructor(localeService, optionsFactory, valueFormatter) {
      this.localeService = localeService;
      this.optionsFactory = optionsFactory;
      this.valueFormatter = valueFormatter;
    }
    // used by:
    // 1) NumberFloatingFilter & TextFloatingFilter: Always, for both when editable and read only.
    // 2) DateFloatingFilter: Only when read only (as we show text rather than a date picker when read only)
    getModelAsString(model) {
      if (!model) {
        return null;
      }
      const isCombined = model.operator != null;
      const translate = this.localeService.getLocaleTextFunc();
      if (isCombined) {
        const combinedModel = model;
        let { conditions } = combinedModel;
        if (!conditions) {
          const { condition1, condition2 } = combinedModel;
          conditions = [condition1, condition2];
        }
        const customOptions = conditions.map((condition) => this.getModelAsString(condition));
        const joinOperatorTranslateKey = combinedModel.operator === "AND" ? "andCondition" : "orCondition";
        return customOptions.join(` ${translate(joinOperatorTranslateKey, FILTER_LOCALE_TEXT[joinOperatorTranslateKey])} `);
      } else if (model.type === SimpleFilter.BLANK || model.type === SimpleFilter.NOT_BLANK) {
        return translate(model.type, model.type);
      } else {
        const condition = model;
        const customOption = this.optionsFactory.getCustomOption(condition.type);
        const { displayKey, displayName, numberOfInputs } = customOption || {};
        if (displayKey && displayName && numberOfInputs === 0) {
          translate(displayKey, displayName);
          return displayName;
        }
        return this.conditionToString(condition, customOption);
      }
    }
    updateParams(params) {
      this.optionsFactory = params.optionsFactory;
    }
    formatValue(value) {
      var _a;
      return this.valueFormatter ? (_a = this.valueFormatter(value != null ? value : null)) != null ? _a : "" : String(value);
    }
  };
  var _SimpleFilter = class _SimpleFilter2 extends ProvidedFilter {
    constructor() {
      super(...arguments);
      this.eTypes = [];
      this.eJoinOperatorPanels = [];
      this.eJoinOperatorsAnd = [];
      this.eJoinOperatorsOr = [];
      this.eConditionBodies = [];
      this.listener = () => this.onUiChanged();
      this.lastUiCompletePosition = null;
      this.joinOperatorId = 0;
    }
    getNumberOfInputs(type) {
      const customOpts = this.optionsFactory.getCustomOption(type);
      if (customOpts) {
        const { numberOfInputs } = customOpts;
        return numberOfInputs != null ? numberOfInputs : 1;
      }
      const zeroInputTypes = [
        _SimpleFilter2.EMPTY,
        _SimpleFilter2.NOT_BLANK,
        _SimpleFilter2.BLANK
      ];
      if (type && zeroInputTypes.indexOf(type) >= 0) {
        return 0;
      } else if (type === _SimpleFilter2.IN_RANGE) {
        return 2;
      }
      return 1;
    }
    // floating filter calls this when user applies filter from floating filter
    onFloatingFilterChanged(type, value) {
      this.setTypeFromFloatingFilter(type);
      this.setValueFromFloatingFilter(value);
      this.onUiChanged(true);
    }
    setTypeFromFloatingFilter(type) {
      this.eTypes.forEach((eType, position) => {
        if (position === 0) {
          eType.setValue(type, true);
        } else {
          eType.setValue(this.optionsFactory.getDefaultOption(), true);
        }
      });
    }
    getModelFromUi() {
      const conditions = this.getUiCompleteConditions();
      if (conditions.length === 0) {
        return null;
      }
      if (this.maxNumConditions > 1 && conditions.length > 1) {
        return {
          filterType: this.getFilterType(),
          operator: this.getJoinOperator(),
          condition1: conditions[0],
          condition2: conditions[1],
          conditions
        };
      }
      return conditions[0];
    }
    getConditionTypes() {
      return this.eTypes.map((eType) => eType.getValue());
    }
    getConditionType(position) {
      return this.eTypes[position].getValue();
    }
    getJoinOperator() {
      if (this.eJoinOperatorsOr.length === 0) {
        return this.defaultJoinOperator;
      }
      return this.eJoinOperatorsOr[0].getValue() === true ? "OR" : "AND";
    }
    areModelsEqual(a, b) {
      if (!a && !b) {
        return true;
      }
      if (!a && b || a && !b) {
        return false;
      }
      const aIsSimple = !a.operator;
      const bIsSimple = !b.operator;
      const oneSimpleOneCombined = !aIsSimple && bIsSimple || aIsSimple && !bIsSimple;
      if (oneSimpleOneCombined) {
        return false;
      }
      let res;
      if (aIsSimple) {
        const aSimple = a;
        const bSimple = b;
        res = this.areSimpleModelsEqual(aSimple, bSimple);
      } else {
        const aCombined = a;
        const bCombined = b;
        res = aCombined.operator === bCombined.operator && areEqual(aCombined.conditions, bCombined.conditions, (aModel, bModel) => this.areSimpleModelsEqual(aModel, bModel));
      }
      return res;
    }
    shouldRefresh(newParams) {
      var _a, _b, _c;
      const model = this.getModel();
      const conditions = model ? (_a = model.conditions) != null ? _a : [model] : null;
      const newOptionsList = (_c = (_b = newParams.filterOptions) == null ? void 0 : _b.map(
        (option) => typeof option === "string" ? option : option.displayKey
      )) != null ? _c : this.getDefaultFilterOptions();
      const allConditionsExistInNewOptionsList = !conditions || conditions.every((condition) => newOptionsList.find((option) => option === condition.type) !== void 0);
      if (!allConditionsExistInNewOptionsList) {
        return false;
      }
      if (typeof newParams.maxNumConditions === "number" && conditions && conditions.length > newParams.maxNumConditions) {
        return false;
      }
      return true;
    }
    refresh(newParams) {
      if (!this.shouldRefresh(newParams)) {
        return false;
      }
      const parentRefreshed = super.refresh(newParams);
      if (!parentRefreshed) {
        return false;
      }
      this.setParams(newParams);
      this.removeConditionsAndOperators(0);
      this.createOption();
      this.setModel(this.getModel());
      return true;
    }
    setModelIntoUi(model) {
      const isCombined = model.operator;
      if (isCombined) {
        let combinedModel = model;
        if (!combinedModel.conditions) {
          combinedModel.conditions = [
            combinedModel.condition1,
            combinedModel.condition2
          ];
        }
        const numConditions = this.validateAndUpdateConditions(combinedModel.conditions);
        const numPrevConditions = this.getNumConditions();
        if (numConditions < numPrevConditions) {
          this.removeConditionsAndOperators(numConditions);
        } else if (numConditions > numPrevConditions) {
          for (let i = numPrevConditions; i < numConditions; i++) {
            this.createJoinOperatorPanel();
            this.createOption();
          }
        }
        const orChecked = combinedModel.operator === "OR";
        this.eJoinOperatorsAnd.forEach((eJoinOperatorAnd) => eJoinOperatorAnd.setValue(!orChecked, true));
        this.eJoinOperatorsOr.forEach((eJoinOperatorOr) => eJoinOperatorOr.setValue(orChecked, true));
        combinedModel.conditions.forEach((condition, position) => {
          this.eTypes[position].setValue(condition.type, true);
          this.setConditionIntoUi(condition, position);
        });
      } else {
        const simpleModel = model;
        if (this.getNumConditions() > 1) {
          this.removeConditionsAndOperators(1);
        }
        this.eTypes[0].setValue(simpleModel.type, true);
        this.setConditionIntoUi(simpleModel, 0);
      }
      this.lastUiCompletePosition = this.getNumConditions() - 1;
      this.createMissingConditionsAndOperators();
      this.onUiChanged();
      return AgPromise.resolve();
    }
    validateAndUpdateConditions(conditions) {
      let numConditions = conditions.length;
      if (numConditions > this.maxNumConditions) {
        conditions.splice(this.maxNumConditions);
        warnOnce('Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.');
        numConditions = this.maxNumConditions;
      }
      return numConditions;
    }
    doesFilterPass(params) {
      var _a;
      const model = this.getModel();
      if (model == null) {
        return true;
      }
      const { operator } = model;
      const models = [];
      if (operator) {
        const combinedModel = model;
        models.push(...(_a = combinedModel.conditions) != null ? _a : []);
      } else {
        models.push(model);
      }
      const combineFunction = operator && operator === "OR" ? "some" : "every";
      return models[combineFunction]((m) => this.individualConditionPasses(params, m));
    }
    setParams(params) {
      super.setParams(params);
      this.setNumConditions(params);
      this.defaultJoinOperator = this.getDefaultJoinOperator(params.defaultJoinOperator);
      this.filterPlaceholder = params.filterPlaceholder;
      this.optionsFactory = new OptionsFactory();
      this.optionsFactory.init(params, this.getDefaultFilterOptions());
      this.createFilterListOptions();
      this.createOption();
      this.createMissingConditionsAndOperators();
      if (this.isReadOnly()) {
        this.eFilterBody.setAttribute("tabindex", "-1");
      }
    }
    setNumConditions(params) {
      var _a, _b;
      if (params.suppressAndOrCondition != null) {
        warnOnce('Since v29.2 "filterParams.suppressAndOrCondition" is deprecated. Use "filterParams.maxNumConditions = 1" instead.');
      }
      if (params.alwaysShowBothConditions != null) {
        warnOnce('Since v29.2 "filterParams.alwaysShowBothConditions" is deprecated. Use "filterParams.numAlwaysVisibleConditions = 2" instead.');
      }
      this.maxNumConditions = (_a = params.maxNumConditions) != null ? _a : params.suppressAndOrCondition ? 1 : 2;
      if (this.maxNumConditions < 1) {
        warnOnce('"filterParams.maxNumConditions" must be greater than or equal to zero.');
        this.maxNumConditions = 1;
      }
      this.numAlwaysVisibleConditions = (_b = params.numAlwaysVisibleConditions) != null ? _b : params.alwaysShowBothConditions ? 2 : 1;
      if (this.numAlwaysVisibleConditions < 1) {
        warnOnce('"filterParams.numAlwaysVisibleConditions" must be greater than or equal to zero.');
        this.numAlwaysVisibleConditions = 1;
      }
      if (this.numAlwaysVisibleConditions > this.maxNumConditions) {
        warnOnce('"filterParams.numAlwaysVisibleConditions" cannot be greater than "filterParams.maxNumConditions".');
        this.numAlwaysVisibleConditions = this.maxNumConditions;
      }
    }
    createOption() {
      const eType = this.createManagedBean(new AgSelect());
      this.eTypes.push(eType);
      eType.addCssClass("ag-filter-select");
      this.eFilterBody.appendChild(eType.getGui());
      const eConditionBody = this.createValueElement();
      this.eConditionBodies.push(eConditionBody);
      this.eFilterBody.appendChild(eConditionBody);
      this.putOptionsIntoDropdown(eType);
      this.resetType(eType);
      const position = this.getNumConditions() - 1;
      this.forEachPositionInput(position, (element) => this.resetInput(element));
      this.addChangedListeners(eType, position);
    }
    createJoinOperatorPanel() {
      const eJoinOperatorPanel = document.createElement("div");
      this.eJoinOperatorPanels.push(eJoinOperatorPanel);
      eJoinOperatorPanel.classList.add("ag-filter-condition");
      const eJoinOperatorAnd = this.createJoinOperator(this.eJoinOperatorsAnd, eJoinOperatorPanel, "and");
      const eJoinOperatorOr = this.createJoinOperator(this.eJoinOperatorsOr, eJoinOperatorPanel, "or");
      this.eFilterBody.appendChild(eJoinOperatorPanel);
      const index = this.eJoinOperatorPanels.length - 1;
      const uniqueGroupId = this.joinOperatorId++;
      this.resetJoinOperatorAnd(eJoinOperatorAnd, index, uniqueGroupId);
      this.resetJoinOperatorOr(eJoinOperatorOr, index, uniqueGroupId);
      if (!this.isReadOnly()) {
        eJoinOperatorAnd.onValueChange(this.listener);
        eJoinOperatorOr.onValueChange(this.listener);
      }
    }
    createJoinOperator(eJoinOperators, eJoinOperatorPanel, andOr) {
      const eJoinOperator = this.createManagedBean(new AgRadioButton());
      eJoinOperators.push(eJoinOperator);
      eJoinOperator.addCssClass("ag-filter-condition-operator");
      eJoinOperator.addCssClass(`ag-filter-condition-operator-${andOr}`);
      eJoinOperatorPanel.appendChild(eJoinOperator.getGui());
      return eJoinOperator;
    }
    getDefaultJoinOperator(defaultJoinOperator) {
      return defaultJoinOperator === "AND" || defaultJoinOperator === "OR" ? defaultJoinOperator : "AND";
    }
    createFilterListOptions() {
      const filterOptions = this.optionsFactory.getFilterOptions();
      this.filterListOptions = filterOptions.map(
        (option) => typeof option === "string" ? this.createBoilerplateListOption(option) : this.createCustomListOption(option)
      );
    }
    putOptionsIntoDropdown(eType) {
      this.filterListOptions.forEach((listOption) => {
        eType.addOption(listOption);
      });
      eType.setDisabled(this.filterListOptions.length <= 1);
    }
    createBoilerplateListOption(option) {
      return { value: option, text: this.translate(option) };
    }
    createCustomListOption(option) {
      const { displayKey } = option;
      const customOption = this.optionsFactory.getCustomOption(option.displayKey);
      return {
        value: displayKey,
        text: customOption ? this.localeService.getLocaleTextFunc()(customOption.displayKey, customOption.displayName) : this.translate(displayKey)
      };
    }
    /**
     * @deprecated As of v29.2 filters can have more than two conditions. Check `colDef.filterParams.maxNumConditions` instead.
     */
    isAllowTwoConditions() {
      return this.maxNumConditions >= 2;
    }
    createBodyTemplate() {
      return "";
    }
    getCssIdentifier() {
      return "simple-filter";
    }
    updateUiVisibility() {
      const joinOperator = this.getJoinOperator();
      this.updateNumConditions();
      this.updateConditionStatusesAndValues(this.lastUiCompletePosition, joinOperator);
    }
    updateNumConditions() {
      var _a;
      let lastUiCompletePosition = -1;
      let areAllConditionsUiComplete = true;
      for (let position = 0; position < this.getNumConditions(); position++) {
        if (this.isConditionUiComplete(position)) {
          lastUiCompletePosition = position;
        } else {
          areAllConditionsUiComplete = false;
        }
      }
      if (this.shouldAddNewConditionAtEnd(areAllConditionsUiComplete)) {
        this.createJoinOperatorPanel();
        this.createOption();
      } else {
        const activePosition = (_a = this.lastUiCompletePosition) != null ? _a : this.getNumConditions() - 2;
        if (lastUiCompletePosition < activePosition) {
          this.removeConditionsAndOperators(activePosition + 1);
          const removeStartPosition = lastUiCompletePosition + 1;
          const numConditionsToRemove = activePosition - removeStartPosition;
          if (numConditionsToRemove > 0) {
            this.removeConditionsAndOperators(removeStartPosition, numConditionsToRemove);
          }
          this.createMissingConditionsAndOperators();
        }
      }
      this.lastUiCompletePosition = lastUiCompletePosition;
    }
    updateConditionStatusesAndValues(lastUiCompletePosition, joinOperator) {
      this.eTypes.forEach((eType, position) => {
        const disabled = this.isConditionDisabled(position, lastUiCompletePosition);
        eType.setDisabled(disabled || this.filterListOptions.length <= 1);
        if (position === 1) {
          setDisabled(this.eJoinOperatorPanels[0], disabled);
          this.eJoinOperatorsAnd[0].setDisabled(disabled);
          this.eJoinOperatorsOr[0].setDisabled(disabled);
        }
      });
      this.eConditionBodies.forEach((element, index) => {
        setDisplayed(element, this.isConditionBodyVisible(index));
      });
      const orChecked = (joinOperator != null ? joinOperator : this.getJoinOperator()) === "OR";
      this.eJoinOperatorsAnd.forEach((eJoinOperatorAnd, index) => {
        eJoinOperatorAnd.setValue(!orChecked, true);
      });
      this.eJoinOperatorsOr.forEach((eJoinOperatorOr, index) => {
        eJoinOperatorOr.setValue(orChecked, true);
      });
      this.forEachInput((element, index, position, numberOfInputs) => {
        this.setElementDisplayed(element, index < numberOfInputs);
        this.setElementDisabled(element, this.isConditionDisabled(position, lastUiCompletePosition));
      });
      this.resetPlaceholder();
    }
    shouldAddNewConditionAtEnd(areAllConditionsUiComplete) {
      return areAllConditionsUiComplete && this.getNumConditions() < this.maxNumConditions && !this.isReadOnly();
    }
    removeConditionsAndOperators(startPosition, deleteCount) {
      if (startPosition >= this.getNumConditions()) {
        return;
      }
      this.removeComponents(this.eTypes, startPosition, deleteCount);
      this.removeElements(this.eConditionBodies, startPosition, deleteCount);
      this.removeValueElements(startPosition, deleteCount);
      const joinOperatorIndex = Math.max(startPosition - 1, 0);
      this.removeElements(this.eJoinOperatorPanels, joinOperatorIndex, deleteCount);
      this.removeComponents(this.eJoinOperatorsAnd, joinOperatorIndex, deleteCount);
      this.removeComponents(this.eJoinOperatorsOr, joinOperatorIndex, deleteCount);
    }
    removeElements(elements, startPosition, deleteCount) {
      const removedElements = this.removeItems(elements, startPosition, deleteCount);
      removedElements.forEach((element) => removeFromParent(element));
    }
    removeComponents(components, startPosition, deleteCount) {
      const removedComponents = this.removeItems(components, startPosition, deleteCount);
      removedComponents.forEach((comp) => {
        removeFromParent(comp.getGui());
        this.destroyBean(comp);
      });
    }
    removeItems(items, startPosition, deleteCount) {
      return deleteCount == null ? items.splice(startPosition) : items.splice(startPosition, deleteCount);
    }
    afterGuiAttached(params) {
      super.afterGuiAttached(params);
      this.resetPlaceholder();
      if (!(params == null ? void 0 : params.suppressFocus)) {
        if (this.isReadOnly()) {
          this.eFilterBody.focus();
        } else {
          const firstInput = this.getInputs(0)[0];
          if (!firstInput) {
            return;
          }
          if (firstInput instanceof AgAbstractInputField) {
            firstInput.getInputElement().focus();
          }
        }
      }
    }
    afterGuiDetached() {
      super.afterGuiDetached();
      const appliedModel = this.getModel();
      this.resetUiToActiveModel(appliedModel);
      let lastUiCompletePosition = -1;
      let updatedLastUiCompletePosition = -1;
      let conditionsRemoved = false;
      const joinOperator = this.getJoinOperator();
      for (let position = this.getNumConditions() - 1; position >= 0; position--) {
        if (this.isConditionUiComplete(position)) {
          if (lastUiCompletePosition === -1) {
            lastUiCompletePosition = position;
            updatedLastUiCompletePosition = position;
          }
        } else {
          const shouldRemovePositionAtEnd = position >= this.numAlwaysVisibleConditions && !this.isConditionUiComplete(position - 1);
          const positionBeforeLastUiCompletePosition = position < lastUiCompletePosition;
          if (shouldRemovePositionAtEnd || positionBeforeLastUiCompletePosition) {
            this.removeConditionsAndOperators(position, 1);
            conditionsRemoved = true;
            if (positionBeforeLastUiCompletePosition) {
              updatedLastUiCompletePosition--;
            }
          }
        }
      }
      let shouldUpdateConditionStatusesAndValues = false;
      if (this.getNumConditions() < this.numAlwaysVisibleConditions) {
        this.createMissingConditionsAndOperators();
        shouldUpdateConditionStatusesAndValues = true;
      }
      if (this.shouldAddNewConditionAtEnd(updatedLastUiCompletePosition === this.getNumConditions() - 1)) {
        this.createJoinOperatorPanel();
        this.createOption();
        shouldUpdateConditionStatusesAndValues = true;
      }
      if (shouldUpdateConditionStatusesAndValues) {
        this.updateConditionStatusesAndValues(updatedLastUiCompletePosition, joinOperator);
      }
      if (conditionsRemoved) {
        this.updateJoinOperatorsDisabled();
      }
      this.lastUiCompletePosition = updatedLastUiCompletePosition;
    }
    getPlaceholderText(defaultPlaceholder, position) {
      let placeholder = this.translate(defaultPlaceholder);
      if (isFunction(this.filterPlaceholder)) {
        const filterPlaceholderFn = this.filterPlaceholder;
        const filterOptionKey = this.eTypes[position].getValue();
        const filterOption = this.translate(filterOptionKey);
        placeholder = filterPlaceholderFn({
          filterOptionKey,
          filterOption,
          placeholder
        });
      } else if (typeof this.filterPlaceholder === "string") {
        placeholder = this.filterPlaceholder;
      }
      return placeholder;
    }
    // allow sub-classes to reset HTML placeholders after UI update.
    resetPlaceholder() {
      const globalTranslate = this.localeService.getLocaleTextFunc();
      this.forEachInput((element, index, position, numberOfInputs) => {
        if (!(element instanceof AgAbstractInputField)) {
          return;
        }
        const placeholder = index === 0 && numberOfInputs > 1 ? "inRangeStart" : index === 0 ? "filterOoo" : "inRangeEnd";
        const ariaLabel = index === 0 && numberOfInputs > 1 ? globalTranslate("ariaFilterFromValue", "Filter from value") : index === 0 ? globalTranslate("ariaFilterValue", "Filter Value") : globalTranslate("ariaFilterToValue", "Filter to Value");
        element.setInputPlaceholder(this.getPlaceholderText(placeholder, position));
        element.setInputAriaLabel(ariaLabel);
      });
    }
    setElementValue(element, value, fromFloatingFilter) {
      if (element instanceof AgAbstractInputField) {
        element.setValue(value != null ? String(value) : null, true);
      }
    }
    setElementDisplayed(element, displayed) {
      if (element instanceof Component) {
        setDisplayed(element.getGui(), displayed);
      }
    }
    setElementDisabled(element, disabled) {
      if (element instanceof Component) {
        setDisabled(element.getGui(), disabled);
      }
    }
    attachElementOnChange(element, listener) {
      if (element instanceof AgAbstractInputField) {
        element.onValueChange(listener);
      }
    }
    forEachInput(cb) {
      this.getConditionTypes().forEach((type, position) => {
        this.forEachPositionTypeInput(position, type, cb);
      });
    }
    forEachPositionInput(position, cb) {
      const type = this.getConditionType(position);
      this.forEachPositionTypeInput(position, type, cb);
    }
    forEachPositionTypeInput(position, type, cb) {
      const numberOfInputs = this.getNumberOfInputs(type);
      const inputs = this.getInputs(position);
      for (let index = 0; index < inputs.length; index++) {
        const input = inputs[index];
        if (input != null) {
          cb(input, index, position, numberOfInputs);
        }
      }
    }
    isConditionDisabled(position, lastUiCompletePosition) {
      if (this.isReadOnly()) {
        return true;
      }
      if (position === 0) {
        return false;
      }
      return position > lastUiCompletePosition + 1;
    }
    isConditionBodyVisible(position) {
      const type = this.getConditionType(position);
      const numberOfInputs = this.getNumberOfInputs(type);
      return numberOfInputs > 0;
    }
    // returns true if the UI represents a working filter, eg all parts are filled out.
    // eg if text filter and textfield blank then returns false.
    isConditionUiComplete(position) {
      if (position >= this.getNumConditions()) {
        return false;
      }
      const type = this.getConditionType(position);
      if (type === _SimpleFilter2.EMPTY) {
        return false;
      }
      if (this.getValues(position).some((v) => v == null)) {
        return false;
      }
      return true;
    }
    getNumConditions() {
      return this.eTypes.length;
    }
    getUiCompleteConditions() {
      const conditions = [];
      for (let position = 0; position < this.getNumConditions(); position++) {
        if (this.isConditionUiComplete(position)) {
          conditions.push(this.createCondition(position));
        }
      }
      return conditions;
    }
    createMissingConditionsAndOperators() {
      if (this.isReadOnly()) {
        return;
      }
      for (let i = this.getNumConditions(); i < this.numAlwaysVisibleConditions; i++) {
        this.createJoinOperatorPanel();
        this.createOption();
      }
    }
    resetUiToDefaults(silent) {
      this.removeConditionsAndOperators(this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions);
      this.eTypes.forEach((eType) => this.resetType(eType));
      this.eJoinOperatorsAnd.forEach((eJoinOperatorAnd, index) => this.resetJoinOperatorAnd(eJoinOperatorAnd, index, this.joinOperatorId + index));
      this.eJoinOperatorsOr.forEach((eJoinOperatorOr, index) => this.resetJoinOperatorOr(eJoinOperatorOr, index, this.joinOperatorId + index));
      this.joinOperatorId++;
      this.forEachInput((element) => this.resetInput(element));
      this.resetPlaceholder();
      this.createMissingConditionsAndOperators();
      this.lastUiCompletePosition = null;
      if (!silent) {
        this.onUiChanged();
      }
      return AgPromise.resolve();
    }
    resetType(eType) {
      const translate = this.localeService.getLocaleTextFunc();
      const filteringLabel = translate("ariaFilteringOperator", "Filtering operator");
      eType.setValue(this.optionsFactory.getDefaultOption(), true).setAriaLabel(filteringLabel).setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1);
    }
    resetJoinOperatorAnd(eJoinOperatorAnd, index, uniqueGroupId) {
      this.resetJoinOperator(eJoinOperatorAnd, index, this.isDefaultOperator("AND"), this.translate("andCondition"), uniqueGroupId);
    }
    resetJoinOperatorOr(eJoinOperatorOr, index, uniqueGroupId) {
      this.resetJoinOperator(eJoinOperatorOr, index, this.isDefaultOperator("OR"), this.translate("orCondition"), uniqueGroupId);
    }
    resetJoinOperator(eJoinOperator, index, value, label, uniqueGroupId) {
      this.updateJoinOperatorDisabled(
        eJoinOperator.setValue(value, true).setName(`ag-simple-filter-and-or-${this.getCompId()}-${uniqueGroupId}`).setLabel(label),
        index
      );
    }
    updateJoinOperatorsDisabled() {
      this.eJoinOperatorsAnd.forEach((eJoinOperator, index) => this.updateJoinOperatorDisabled(eJoinOperator, index));
      this.eJoinOperatorsOr.forEach((eJoinOperator, index) => this.updateJoinOperatorDisabled(eJoinOperator, index));
    }
    updateJoinOperatorDisabled(eJoinOperator, index) {
      eJoinOperator.setDisabled(this.isReadOnly() || index > 0);
    }
    resetInput(element) {
      this.setElementValue(element, null);
      this.setElementDisabled(element, this.isReadOnly());
    }
    // puts model values into the UI
    setConditionIntoUi(model, position) {
      const values2 = this.mapValuesFromModel(model);
      this.forEachInput((element, index, elPosition, _2) => {
        if (elPosition !== position) {
          return;
        }
        this.setElementValue(element, values2[index] != null ? values2[index] : null);
      });
    }
    // after floating filter changes, this sets the 'value' section. this is implemented by the base class
    // (as that's where value is controlled), the 'type' part from the floating filter is dealt with in this class.
    setValueFromFloatingFilter(value) {
      this.forEachInput((element, index, position, _2) => {
        this.setElementValue(element, index === 0 && position === 0 ? value : null, true);
      });
    }
    isDefaultOperator(operator) {
      return operator === this.defaultJoinOperator;
    }
    addChangedListeners(eType, position) {
      if (this.isReadOnly()) {
        return;
      }
      eType.onValueChange(this.listener);
      this.forEachPositionInput(position, (element) => {
        this.attachElementOnChange(element, this.listener);
      });
    }
    /** returns true if the row passes the said condition */
    individualConditionPasses(params, filterModel) {
      const cellValue = this.getCellValue(params.node);
      const values2 = this.mapValuesFromModel(filterModel);
      const customFilterOption = this.optionsFactory.getCustomOption(filterModel.type);
      const customFilterResult = this.evaluateCustomFilter(customFilterOption, values2, cellValue);
      if (customFilterResult != null) {
        return customFilterResult;
      }
      if (cellValue == null) {
        return this.evaluateNullValue(filterModel.type);
      }
      return this.evaluateNonNullValue(values2, cellValue, filterModel, params);
    }
    evaluateCustomFilter(customFilterOption, values2, cellValue) {
      if (customFilterOption == null) {
        return;
      }
      const { predicate } = customFilterOption;
      if (predicate != null && !values2.some((v) => v == null)) {
        return predicate(values2, cellValue);
      }
      return;
    }
    isBlank(cellValue) {
      return cellValue == null || typeof cellValue === "string" && cellValue.trim().length === 0;
    }
    hasInvalidInputs() {
      return false;
    }
  };
  _SimpleFilter.EMPTY = "empty";
  _SimpleFilter.BLANK = "blank";
  _SimpleFilter.NOT_BLANK = "notBlank";
  _SimpleFilter.EQUALS = "equals";
  _SimpleFilter.NOT_EQUAL = "notEqual";
  _SimpleFilter.LESS_THAN = "lessThan";
  _SimpleFilter.LESS_THAN_OR_EQUAL = "lessThanOrEqual";
  _SimpleFilter.GREATER_THAN = "greaterThan";
  _SimpleFilter.GREATER_THAN_OR_EQUAL = "greaterThanOrEqual";
  _SimpleFilter.IN_RANGE = "inRange";
  _SimpleFilter.CONTAINS = "contains";
  _SimpleFilter.NOT_CONTAINS = "notContains";
  _SimpleFilter.STARTS_WITH = "startsWith";
  _SimpleFilter.ENDS_WITH = "endsWith";
  var SimpleFilter = _SimpleFilter;
  var ScalarFilter = class _ScalarFilter extends SimpleFilter {
    setParams(params) {
      super.setParams(params);
      this.scalarFilterParams = params;
    }
    evaluateNullValue(filterType) {
      switch (filterType) {
        case _ScalarFilter.EQUALS:
        case _ScalarFilter.NOT_EQUAL:
          if (this.scalarFilterParams.includeBlanksInEquals) {
            return true;
          }
          break;
        case _ScalarFilter.GREATER_THAN:
        case _ScalarFilter.GREATER_THAN_OR_EQUAL:
          if (this.scalarFilterParams.includeBlanksInGreaterThan) {
            return true;
          }
          break;
        case _ScalarFilter.LESS_THAN:
        case _ScalarFilter.LESS_THAN_OR_EQUAL:
          if (this.scalarFilterParams.includeBlanksInLessThan) {
            return true;
          }
          break;
        case _ScalarFilter.IN_RANGE:
          if (this.scalarFilterParams.includeBlanksInRange) {
            return true;
          }
          break;
        case _ScalarFilter.BLANK:
          return true;
        case _ScalarFilter.NOT_BLANK:
          return false;
      }
      return false;
    }
    evaluateNonNullValue(values2, cellValue, filterModel) {
      const comparator2 = this.comparator();
      const compareResult = values2[0] != null ? comparator2(values2[0], cellValue) : 0;
      switch (filterModel.type) {
        case _ScalarFilter.EQUALS:
          return compareResult === 0;
        case _ScalarFilter.NOT_EQUAL:
          return compareResult !== 0;
        case _ScalarFilter.GREATER_THAN:
          return compareResult > 0;
        case _ScalarFilter.GREATER_THAN_OR_EQUAL:
          return compareResult >= 0;
        case _ScalarFilter.LESS_THAN:
          return compareResult < 0;
        case _ScalarFilter.LESS_THAN_OR_EQUAL:
          return compareResult <= 0;
        case _ScalarFilter.IN_RANGE: {
          const compareToResult = comparator2(values2[1], cellValue);
          return this.scalarFilterParams.inRangeInclusive ? compareResult >= 0 && compareToResult <= 0 : compareResult > 0 && compareToResult < 0;
        }
        case _ScalarFilter.BLANK:
          return this.isBlank(cellValue);
        case _ScalarFilter.NOT_BLANK:
          return !this.isBlank(cellValue);
        default:
          console.warn('AG Grid: Unexpected type of filter "' + filterModel.type + '", it looks like the filter was configured with incorrect Filter Options');
          return true;
      }
    }
  };
  var DEFAULT_MIN_YEAR = 1e3;
  var DEFAULT_MAX_YEAR = Infinity;
  var DateFilterModelFormatter = class extends SimpleFilterModelFormatter {
    constructor(dateFilterParams, localeService, optionsFactory) {
      super(localeService, optionsFactory);
      this.dateFilterParams = dateFilterParams;
    }
    conditionToString(condition, options) {
      const { type } = condition;
      const { numberOfInputs } = options || {};
      const isRange = type == SimpleFilter.IN_RANGE || numberOfInputs === 2;
      const dateFrom = parseDateTimeFromString(condition.dateFrom);
      const dateTo = parseDateTimeFromString(condition.dateTo);
      const format = this.dateFilterParams.inRangeFloatingFilterDateFormat;
      if (isRange) {
        const formattedFrom = dateFrom !== null ? dateToFormattedString(dateFrom, format) : "null";
        const formattedTo = dateTo !== null ? dateToFormattedString(dateTo, format) : "null";
        return `${formattedFrom}-${formattedTo}`;
      }
      if (dateFrom != null) {
        return dateToFormattedString(dateFrom, format);
      }
      return `${type}`;
    }
    updateParams(params) {
      super.updateParams(params);
      this.dateFilterParams = params.dateFilterParams;
    }
  };
  var _DateFilter = class _DateFilter2 extends ScalarFilter {
    constructor() {
      super("dateFilter");
      this.eConditionPanelsFrom = [];
      this.eConditionPanelsTo = [];
      this.dateConditionFromComps = [];
      this.dateConditionToComps = [];
      this.minValidYear = DEFAULT_MIN_YEAR;
      this.maxValidYear = DEFAULT_MAX_YEAR;
      this.minValidDate = null;
      this.maxValidDate = null;
    }
    afterGuiAttached(params) {
      super.afterGuiAttached(params);
      this.dateConditionFromComps[0].afterGuiAttached(params);
    }
    mapValuesFromModel(filterModel) {
      const { dateFrom, dateTo, type } = filterModel || {};
      return [
        dateFrom && parseDateTimeFromString(dateFrom) || null,
        dateTo && parseDateTimeFromString(dateTo) || null
      ].slice(0, this.getNumberOfInputs(type));
    }
    comparator() {
      return this.dateFilterParams.comparator ? this.dateFilterParams.comparator : this.defaultComparator.bind(this);
    }
    defaultComparator(filterDate, cellValue) {
      const cellAsDate = cellValue;
      if (cellValue == null || cellAsDate < filterDate) {
        return -1;
      }
      if (cellAsDate > filterDate) {
        return 1;
      }
      return 0;
    }
    setParams(params) {
      this.dateFilterParams = params;
      super.setParams(params);
      const yearParser = (param, fallback) => {
        if (params[param] != null) {
          if (!isNaN(params[param])) {
            return params[param] == null ? fallback : Number(params[param]);
          } else {
            console.warn(`AG Grid: DateFilter ${param} is not a number`);
          }
        }
        return fallback;
      };
      this.minValidYear = yearParser("minValidYear", DEFAULT_MIN_YEAR);
      this.maxValidYear = yearParser("maxValidYear", DEFAULT_MAX_YEAR);
      if (this.minValidYear > this.maxValidYear) {
        console.warn(`AG Grid: DateFilter minValidYear should be <= maxValidYear`);
      }
      if (params.minValidDate) {
        this.minValidDate = params.minValidDate instanceof Date ? params.minValidDate : parseDateTimeFromString(params.minValidDate);
      } else {
        this.minValidDate = null;
      }
      if (params.maxValidDate) {
        this.maxValidDate = params.maxValidDate instanceof Date ? params.maxValidDate : parseDateTimeFromString(params.maxValidDate);
      } else {
        this.maxValidDate = null;
      }
      if (this.minValidDate && this.maxValidDate && this.minValidDate > this.maxValidDate) {
        console.warn(`AG Grid: DateFilter minValidDate should be <= maxValidDate`);
      }
      this.filterModelFormatter = new DateFilterModelFormatter(this.dateFilterParams, this.localeService, this.optionsFactory);
    }
    createDateCompWrapper(element) {
      const dateCompWrapper = new DateCompWrapper(
        this.getContext(),
        this.userComponentFactory,
        {
          onDateChanged: () => this.onUiChanged(),
          filterParams: this.dateFilterParams
        },
        element
      );
      this.addDestroyFunc(() => dateCompWrapper.destroy());
      return dateCompWrapper;
    }
    setElementValue(element, value) {
      element.setDate(value);
    }
    setElementDisplayed(element, displayed) {
      element.setDisplayed(displayed);
    }
    setElementDisabled(element, disabled) {
      element.setDisabled(disabled);
    }
    getDefaultFilterOptions() {
      return _DateFilter2.DEFAULT_FILTER_OPTIONS;
    }
    createValueElement() {
      const eDocument = this.gos.getDocument();
      const eCondition = eDocument.createElement("div");
      eCondition.classList.add("ag-filter-body");
      this.createFromToElement(eCondition, this.eConditionPanelsFrom, this.dateConditionFromComps, "from");
      this.createFromToElement(eCondition, this.eConditionPanelsTo, this.dateConditionToComps, "to");
      return eCondition;
    }
    createFromToElement(eCondition, eConditionPanels, dateConditionComps, fromTo) {
      const eDocument = this.gos.getDocument();
      const eConditionPanel = eDocument.createElement("div");
      eConditionPanel.classList.add(`ag-filter-${fromTo}`);
      eConditionPanel.classList.add(`ag-filter-date-${fromTo}`);
      eConditionPanels.push(eConditionPanel);
      eCondition.appendChild(eConditionPanel);
      dateConditionComps.push(this.createDateCompWrapper(eConditionPanel));
    }
    removeValueElements(startPosition, deleteCount) {
      this.removeDateComps(this.dateConditionFromComps, startPosition, deleteCount);
      this.removeDateComps(this.dateConditionToComps, startPosition, deleteCount);
      this.removeItems(this.eConditionPanelsFrom, startPosition, deleteCount);
      this.removeItems(this.eConditionPanelsTo, startPosition, deleteCount);
    }
    removeDateComps(components, startPosition, deleteCount) {
      const removedComponents = this.removeItems(components, startPosition, deleteCount);
      removedComponents.forEach((comp) => comp.destroy());
    }
    isValidDateValue(value) {
      if (value === null) {
        return false;
      }
      if (this.minValidDate) {
        if (value < this.minValidDate) {
          return false;
        }
      } else {
        if (value.getUTCFullYear() < this.minValidYear) {
          return false;
        }
      }
      if (this.maxValidDate) {
        if (value > this.maxValidDate) {
          return false;
        }
      } else {
        if (value.getUTCFullYear() > this.maxValidYear) {
          return false;
        }
      }
      return true;
    }
    isConditionUiComplete(position) {
      if (!super.isConditionUiComplete(position)) {
        return false;
      }
      let valid = true;
      this.forEachInput((element, index, elPosition, numberOfInputs) => {
        if (elPosition !== position || !valid || index >= numberOfInputs) {
          return;
        }
        valid = valid && this.isValidDateValue(element.getDate());
      });
      return valid;
    }
    areSimpleModelsEqual(aSimple, bSimple) {
      return aSimple.dateFrom === bSimple.dateFrom && aSimple.dateTo === bSimple.dateTo && aSimple.type === bSimple.type;
    }
    getFilterType() {
      return "date";
    }
    createCondition(position) {
      const type = this.getConditionType(position);
      const model = {};
      const values2 = this.getValues(position);
      if (values2.length > 0) {
        model.dateFrom = serialiseDate(values2[0]);
      }
      if (values2.length > 1) {
        model.dateTo = serialiseDate(values2[1]);
      }
      return __spreadValues({
        dateFrom: null,
        dateTo: null,
        filterType: this.getFilterType(),
        type
      }, model);
    }
    resetPlaceholder() {
      const globalTranslate = this.localeService.getLocaleTextFunc();
      const placeholder = this.translate("dateFormatOoo");
      const ariaLabel = globalTranslate("ariaFilterValue", "Filter Value");
      this.forEachInput((element) => {
        element.setInputPlaceholder(placeholder);
        element.setInputAriaLabel(ariaLabel);
      });
    }
    getInputs(position) {
      if (position >= this.dateConditionFromComps.length) {
        return [null, null];
      }
      return [this.dateConditionFromComps[position], this.dateConditionToComps[position]];
    }
    getValues(position) {
      const result = [];
      this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs) => {
        if (index < numberOfInputs) {
          result.push(element.getDate());
        }
      });
      return result;
    }
    translate(key) {
      if (key === ScalarFilter.LESS_THAN) {
        return super.translate("before");
      }
      if (key === ScalarFilter.GREATER_THAN) {
        return super.translate("after");
      }
      return super.translate(key);
    }
    getModelAsString(model) {
      var _a;
      return (_a = this.filterModelFormatter.getModelAsString(model)) != null ? _a : "";
    }
  };
  _DateFilter.DEFAULT_FILTER_OPTIONS = [
    ScalarFilter.EQUALS,
    ScalarFilter.NOT_EQUAL,
    ScalarFilter.LESS_THAN,
    ScalarFilter.GREATER_THAN,
    ScalarFilter.IN_RANGE,
    ScalarFilter.BLANK,
    ScalarFilter.NOT_BLANK
  ];
  __decorateClass([
    Autowired("userComponentFactory")
  ], _DateFilter.prototype, "userComponentFactory", 2);
  var DateFilter = _DateFilter;
  var SimpleFloatingFilter = class extends Component {
    getDefaultDebounceMs() {
      return 0;
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
      super.destroy();
    }
    isEventFromFloatingFilter(event) {
      return event && event.afterFloatingFilter;
    }
    isEventFromDataChange(event) {
      return event == null ? void 0 : event.afterDataChange;
    }
    getLastType() {
      return this.lastType;
    }
    isReadOnly() {
      return this.readOnly;
    }
    setLastTypeFromModel(model) {
      if (!model) {
        this.lastType = this.optionsFactory.getDefaultOption();
        return;
      }
      const isCombined = model.operator;
      let condition;
      if (isCombined) {
        const combinedModel = model;
        condition = combinedModel.conditions[0];
      } else {
        condition = model;
      }
      this.lastType = condition.type;
    }
    canWeEditAfterModelFromParentFilter(model) {
      if (!model) {
        return this.isTypeEditable(this.lastType);
      }
      const isCombined = model.operator;
      if (isCombined) {
        return false;
      }
      const simpleModel = model;
      return this.isTypeEditable(simpleModel.type);
    }
    init(params) {
      this.setSimpleParams(params, false);
    }
    setSimpleParams(params, update = true) {
      this.optionsFactory = new OptionsFactory();
      this.optionsFactory.init(params.filterParams, this.getDefaultFilterOptions());
      if (!update) {
        this.lastType = this.optionsFactory.getDefaultOption();
      }
      this.readOnly = !!params.filterParams.readOnly;
      const editable = this.isTypeEditable(this.optionsFactory.getDefaultOption());
      this.setEditable(editable);
    }
    onParamsUpdated(params) {
      this.refresh(params);
    }
    refresh(params) {
      this.setSimpleParams(params);
    }
    doesFilterHaveSingleInput(filterType) {
      const customFilterOption = this.optionsFactory.getCustomOption(filterType);
      const { numberOfInputs } = customFilterOption || {};
      return numberOfInputs == null || numberOfInputs == 1;
    }
    isTypeEditable(type) {
      const uneditableTypes = [
        SimpleFilter.IN_RANGE,
        SimpleFilter.EMPTY,
        SimpleFilter.BLANK,
        SimpleFilter.NOT_BLANK
      ];
      return !!type && !this.isReadOnly() && this.doesFilterHaveSingleInput(type) && uneditableTypes.indexOf(type) < 0;
    }
    getAriaLabel(params) {
      const displayName = this.columnModel.getDisplayNameForColumn(params.column, "header", true);
      const translate = this.localeService.getLocaleTextFunc();
      return `${displayName} ${translate("ariaFilterInput", "Filter Input")}`;
    }
  };
  __decorateClass([
    Autowired("columnModel")
  ], SimpleFloatingFilter.prototype, "columnModel", 2);
  var DateFloatingFilter = class extends SimpleFloatingFilter {
    constructor() {
      super(
        /* html */
        `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field ref="eReadOnlyText"></ag-input-text-field>
                <div ref="eDateWrapper" style="display: flex;"></div>
            </div>`
      );
    }
    getDefaultFilterOptions() {
      return DateFilter.DEFAULT_FILTER_OPTIONS;
    }
    init(params) {
      super.init(params);
      this.params = params;
      this.filterParams = params.filterParams;
      this.createDateComponent();
      this.filterModelFormatter = new DateFilterModelFormatter(this.filterParams, this.localeService, this.optionsFactory);
      const translate = this.localeService.getLocaleTextFunc();
      this.eReadOnlyText.setDisabled(true).setInputAriaLabel(translate("ariaDateFilterInput", "Date Filter Input"));
    }
    onParamsUpdated(params) {
      this.refresh(params);
    }
    refresh(params) {
      super.refresh(params);
      this.params = params;
      this.filterParams = params.filterParams;
      this.updateDateComponent();
      this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory, dateFilterParams: this.filterParams });
      this.updateCompOnModelChange(params.currentParentModel());
    }
    updateCompOnModelChange(model) {
      const allowEditing = !this.isReadOnly() && this.canWeEditAfterModelFromParentFilter(model);
      this.setEditable(allowEditing);
      if (allowEditing) {
        if (model) {
          const dateModel = model;
          this.dateComp.setDate(parseDateTimeFromString(dateModel.dateFrom));
        } else {
          this.dateComp.setDate(null);
        }
        this.eReadOnlyText.setValue("");
      } else {
        this.eReadOnlyText.setValue(this.filterModelFormatter.getModelAsString(model));
        this.dateComp.setDate(null);
      }
    }
    setEditable(editable) {
      setDisplayed(this.eDateWrapper, editable);
      setDisplayed(this.eReadOnlyText.getGui(), !editable);
    }
    onParentModelChanged(model, event) {
      if (this.isEventFromFloatingFilter(event) || this.isEventFromDataChange(event)) {
        return;
      }
      super.setLastTypeFromModel(model);
      this.updateCompOnModelChange(model);
    }
    onDateChanged() {
      const filterValueDate = this.dateComp.getDate();
      const filterValueText = serialiseDate(filterValueDate);
      this.params.parentFilterInstance((filterInstance) => {
        if (filterInstance) {
          const date = parseDateTimeFromString(filterValueText);
          filterInstance.onFloatingFilterChanged(this.getLastType() || null, date);
        }
      });
    }
    getDateComponentParams() {
      const debounceMs = ProvidedFilter.getDebounceMs(this.params.filterParams, this.getDefaultDebounceMs());
      return {
        onDateChanged: debounce2(this.onDateChanged.bind(this), debounceMs),
        filterParams: this.params.column.getColDef().filterParams
      };
    }
    createDateComponent() {
      this.dateComp = new DateCompWrapper(this.getContext(), this.userComponentFactory, this.getDateComponentParams(), this.eDateWrapper, (dateComp) => {
        dateComp.setInputAriaLabel(this.getAriaLabel(this.params));
      });
      this.addDestroyFunc(() => this.dateComp.destroy());
    }
    updateDateComponent() {
      const params = this.gos.addGridCommonParams(this.getDateComponentParams());
      this.dateComp.updateParams(params);
    }
    getFilterModelFormatter() {
      return this.filterModelFormatter;
    }
  };
  __decorateClass([
    Autowired("userComponentFactory")
  ], DateFloatingFilter.prototype, "userComponentFactory", 2);
  __decorateClass([
    RefSelector("eReadOnlyText")
  ], DateFloatingFilter.prototype, "eReadOnlyText", 2);
  __decorateClass([
    RefSelector("eDateWrapper")
  ], DateFloatingFilter.prototype, "eDateWrapper", 2);
  var DefaultDateComponent = class extends Component {
    constructor() {
      super(
        /* html */
        `
            <div class="ag-filter-filter">
                <ag-input-text-field class="ag-date-filter" ref="eDateInput"></ag-input-text-field>
            </div>`
      );
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
      super.destroy();
    }
    init(params) {
      this.params = params;
      this.setParams(params);
      const inputElement = this.eDateInput.getInputElement();
      this.addManagedListener(inputElement, "mousedown", () => {
        if (this.eDateInput.isDisabled() || this.usingSafariDatePicker) {
          return;
        }
        inputElement.focus();
      });
      this.addManagedListener(inputElement, "input", (e) => {
        if (e.target !== this.gos.getActiveDomElement()) {
          return;
        }
        if (this.eDateInput.isDisabled()) {
          return;
        }
        this.params.onDateChanged();
      });
    }
    setParams(params) {
      const inputElement = this.eDateInput.getInputElement();
      const shouldUseBrowserDatePicker = this.shouldUseBrowserDatePicker(params);
      this.usingSafariDatePicker = shouldUseBrowserDatePicker && isBrowserSafari();
      inputElement.type = shouldUseBrowserDatePicker ? "date" : "text";
      const {
        minValidYear,
        maxValidYear,
        minValidDate,
        maxValidDate
      } = params.filterParams || {};
      if (minValidDate && minValidYear) {
        warnOnce("DateFilter should not have both minValidDate and minValidYear parameters set at the same time! minValidYear will be ignored.");
      }
      if (maxValidDate && maxValidYear) {
        warnOnce("DateFilter should not have both maxValidDate and maxValidYear parameters set at the same time! maxValidYear will be ignored.");
      }
      if (minValidDate && maxValidDate) {
        const [parsedMinValidDate, parsedMaxValidDate] = [minValidDate, maxValidDate].map((v) => v instanceof Date ? v : parseDateTimeFromString(v));
        if (parsedMinValidDate && parsedMaxValidDate && parsedMinValidDate.getTime() > parsedMaxValidDate.getTime()) {
          warnOnce("DateFilter parameter minValidDate should always be lower than or equal to parameter maxValidDate.");
        }
      }
      if (minValidDate) {
        if (minValidDate instanceof Date) {
          inputElement.min = dateToFormattedString(minValidDate);
        } else {
          inputElement.min = minValidDate;
        }
      } else {
        if (minValidYear) {
          inputElement.min = `${minValidYear}-01-01`;
        }
      }
      if (maxValidDate) {
        if (maxValidDate instanceof Date) {
          inputElement.max = dateToFormattedString(maxValidDate);
        } else {
          inputElement.max = maxValidDate;
        }
      } else {
        if (maxValidYear) {
          inputElement.max = `${maxValidYear}-12-31`;
        }
      }
    }
    onParamsUpdated(params) {
      this.refresh(params);
    }
    refresh(params) {
      this.params = params;
      this.setParams(params);
    }
    getDate() {
      return parseDateTimeFromString(this.eDateInput.getValue());
    }
    setDate(date) {
      this.eDateInput.setValue(serialiseDate(date, false));
    }
    setInputPlaceholder(placeholder) {
      this.eDateInput.setInputPlaceholder(placeholder);
    }
    setInputAriaLabel(ariaLabel) {
      this.eDateInput.setAriaLabel(ariaLabel);
    }
    setDisabled(disabled) {
      this.eDateInput.setDisabled(disabled);
    }
    afterGuiAttached(params) {
      if (!params || !params.suppressFocus) {
        this.eDateInput.getInputElement().focus();
      }
    }
    shouldUseBrowserDatePicker(params) {
      if (params.filterParams && params.filterParams.browserDatePicker != null) {
        return params.filterParams.browserDatePicker;
      }
      return isBrowserChrome() || isBrowserFirefox() || isBrowserSafari() && getSafariVersion() >= 14.1;
    }
  };
  __decorateClass([
    RefSelector("eDateInput")
  ], DefaultDateComponent.prototype, "eDateInput", 2);
  var AgInputTextField = class extends AgAbstractInputField {
    constructor(config, className = "ag-text-field", inputType = "text") {
      super(config, className, inputType);
    }
    postConstruct() {
      super.postConstruct();
      if (this.config.allowedCharPattern) {
        this.preventDisallowedCharacters();
      }
    }
    setValue(value, silent) {
      if (this.eInput.value !== value) {
        this.eInput.value = exists(value) ? value : "";
      }
      return super.setValue(value, silent);
    }
    /** Used to set an initial value into the input without necessarily setting `this.value` or triggering events (e.g. to set an invalid value) */
    setStartValue(value) {
      this.setValue(value, true);
    }
    preventDisallowedCharacters() {
      const pattern = new RegExp(`[${this.config.allowedCharPattern}]`);
      const preventCharacters = (event) => {
        if (!isEventFromPrintableCharacter(event)) {
          return;
        }
        if (event.key && !pattern.test(event.key)) {
          event.preventDefault();
        }
      };
      this.addManagedListener(this.eInput, "keydown", preventCharacters);
      this.addManagedListener(this.eInput, "paste", (e) => {
        var _a;
        const text = (_a = e.clipboardData) == null ? void 0 : _a.getData("text");
        if (text && text.split("").some((c) => !pattern.test(c))) {
          e.preventDefault();
        }
      });
    }
  };
  var AgInputNumberField = class extends AgInputTextField {
    constructor(config) {
      super(config, "ag-number-field", "number");
    }
    postConstruct() {
      super.postConstruct();
      this.addManagedListener(this.eInput, "blur", () => {
        const floatedValue = parseFloat(this.eInput.value);
        const value = isNaN(floatedValue) ? "" : this.normalizeValue(floatedValue.toString());
        if (this.value !== value) {
          this.setValue(value);
        }
      });
      this.addManagedListener(this.eInput, "wheel", this.onWheel.bind(this));
      this.eInput.step = "any";
      const { precision, min, max, step } = this.config;
      if (typeof precision === "number")
        this.setPrecision(precision);
      if (typeof min === "number")
        this.setMin(min);
      if (typeof max === "number")
        this.setMax(max);
      if (typeof step === "number")
        this.setStep(step);
    }
    onWheel(e) {
      if (this.gos.getActiveDomElement() === this.eInput) {
        e.preventDefault();
      }
    }
    normalizeValue(value) {
      if (value === "") {
        return "";
      }
      if (this.precision != null) {
        value = this.adjustPrecision(value);
      }
      const val = parseFloat(value);
      if (this.min != null && val < this.min) {
        value = this.min.toString();
      } else if (this.max != null && val > this.max) {
        value = this.max.toString();
      }
      return value;
    }
    adjustPrecision(value, isScientificNotation) {
      if (this.precision == null) {
        return value;
      }
      if (isScientificNotation) {
        const floatString = parseFloat(value).toFixed(this.precision);
        return parseFloat(floatString).toString();
      }
      const parts = String(value).split(".");
      if (parts.length > 1) {
        if (parts[1].length <= this.precision) {
          return value;
        } else if (this.precision > 0) {
          return `${parts[0]}.${parts[1].slice(0, this.precision)}`;
        }
      }
      return parts[0];
    }
    setMin(min) {
      if (this.min === min) {
        return this;
      }
      this.min = min;
      addOrRemoveAttribute(this.eInput, "min", min);
      return this;
    }
    setMax(max) {
      if (this.max === max) {
        return this;
      }
      this.max = max;
      addOrRemoveAttribute(this.eInput, "max", max);
      return this;
    }
    setPrecision(precision) {
      this.precision = precision;
      return this;
    }
    setStep(step) {
      if (this.step === step) {
        return this;
      }
      this.step = step;
      addOrRemoveAttribute(this.eInput, "step", step);
      return this;
    }
    setValue(value, silent) {
      return this.setValueOrInputValue((v) => super.setValue(v, silent), () => this, value);
    }
    setStartValue(value) {
      return this.setValueOrInputValue(
        (v) => super.setValue(v, true),
        (v) => {
          this.eInput.value = v;
        },
        value
      );
    }
    setValueOrInputValue(setValueFunc, setInputValueOnlyFunc, value) {
      if (exists(value)) {
        let setInputValueOnly = this.isScientificNotation(value);
        if (setInputValueOnly && this.eInput.validity.valid) {
          return setValueFunc(value);
        }
        if (!setInputValueOnly) {
          value = this.adjustPrecision(value);
          const normalizedValue = this.normalizeValue(value);
          setInputValueOnly = value != normalizedValue;
        }
        if (setInputValueOnly) {
          return setInputValueOnlyFunc(value);
        }
      }
      return setValueFunc(value);
    }
    getValue() {
      if (!this.eInput.validity.valid) {
        return void 0;
      }
      const inputValue = this.eInput.value;
      if (this.isScientificNotation(inputValue)) {
        return this.adjustPrecision(inputValue, true);
      }
      return super.getValue();
    }
    isScientificNotation(value) {
      return typeof value === "string" && value.includes("e");
    }
  };
  var NumberFilterModelFormatter = class extends SimpleFilterModelFormatter {
    conditionToString(condition, options) {
      const { numberOfInputs } = options || {};
      const isRange = condition.type == SimpleFilter.IN_RANGE || numberOfInputs === 2;
      if (isRange) {
        return `${this.formatValue(condition.filter)}-${this.formatValue(condition.filterTo)}`;
      }
      if (condition.filter != null) {
        return this.formatValue(condition.filter);
      }
      return `${condition.type}`;
    }
  };
  function getAllowedCharPattern(filterParams) {
    const { allowedCharPattern } = filterParams != null ? filterParams : {};
    return allowedCharPattern != null ? allowedCharPattern : null;
  }
  var _NumberFilter = class _NumberFilter2 extends ScalarFilter {
    constructor() {
      super("numberFilter");
      this.eValuesFrom = [];
      this.eValuesTo = [];
    }
    refresh(params) {
      if (this.numberFilterParams.allowedCharPattern !== params.allowedCharPattern) {
        return false;
      }
      return super.refresh(params);
    }
    mapValuesFromModel(filterModel) {
      const { filter, filterTo, type } = filterModel || {};
      return [
        this.processValue(filter),
        this.processValue(filterTo)
      ].slice(0, this.getNumberOfInputs(type));
    }
    getDefaultDebounceMs() {
      return 500;
    }
    comparator() {
      return (left, right) => {
        if (left === right) {
          return 0;
        }
        return left < right ? 1 : -1;
      };
    }
    setParams(params) {
      this.numberFilterParams = params;
      super.setParams(params);
      this.filterModelFormatter = new NumberFilterModelFormatter(this.localeService, this.optionsFactory, this.numberFilterParams.numberFormatter);
    }
    getDefaultFilterOptions() {
      return _NumberFilter2.DEFAULT_FILTER_OPTIONS;
    }
    setElementValue(element, value, fromFloatingFilter) {
      const valueToSet = !fromFloatingFilter && this.numberFilterParams.numberFormatter ? this.numberFilterParams.numberFormatter(value != null ? value : null) : value;
      super.setElementValue(element, valueToSet);
    }
    createValueElement() {
      const allowedCharPattern = getAllowedCharPattern(this.numberFilterParams);
      const eCondition = document.createElement("div");
      eCondition.classList.add("ag-filter-body");
      setAriaRole(eCondition, "presentation");
      this.createFromToElement(eCondition, this.eValuesFrom, "from", allowedCharPattern);
      this.createFromToElement(eCondition, this.eValuesTo, "to", allowedCharPattern);
      return eCondition;
    }
    createFromToElement(eCondition, eValues, fromTo, allowedCharPattern) {
      const eValue = this.createManagedBean(allowedCharPattern ? new AgInputTextField({ allowedCharPattern }) : new AgInputNumberField());
      eValue.addCssClass(`ag-filter-${fromTo}`);
      eValue.addCssClass("ag-filter-filter");
      eValues.push(eValue);
      eCondition.appendChild(eValue.getGui());
    }
    removeValueElements(startPosition, deleteCount) {
      this.removeComponents(this.eValuesFrom, startPosition, deleteCount);
      this.removeComponents(this.eValuesTo, startPosition, deleteCount);
    }
    getValues(position) {
      const result = [];
      this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs) => {
        if (index < numberOfInputs) {
          result.push(this.processValue(this.stringToFloat(element.getValue())));
        }
      });
      return result;
    }
    areSimpleModelsEqual(aSimple, bSimple) {
      return aSimple.filter === bSimple.filter && aSimple.filterTo === bSimple.filterTo && aSimple.type === bSimple.type;
    }
    getFilterType() {
      return "number";
    }
    processValue(value) {
      if (value == null) {
        return null;
      }
      return isNaN(value) ? null : value;
    }
    stringToFloat(value) {
      if (typeof value === "number") {
        return value;
      }
      let filterText = makeNull(value);
      if (filterText != null && filterText.trim() === "") {
        filterText = null;
      }
      if (this.numberFilterParams.numberParser) {
        return this.numberFilterParams.numberParser(filterText);
      }
      return filterText == null || filterText.trim() === "-" ? null : parseFloat(filterText);
    }
    createCondition(position) {
      const type = this.getConditionType(position);
      const model = {
        filterType: this.getFilterType(),
        type
      };
      const values2 = this.getValues(position);
      if (values2.length > 0) {
        model.filter = values2[0];
      }
      if (values2.length > 1) {
        model.filterTo = values2[1];
      }
      return model;
    }
    getInputs(position) {
      if (position >= this.eValuesFrom.length) {
        return [null, null];
      }
      return [this.eValuesFrom[position], this.eValuesTo[position]];
    }
    getModelAsString(model) {
      var _a;
      return (_a = this.filterModelFormatter.getModelAsString(model)) != null ? _a : "";
    }
    hasInvalidInputs() {
      let invalidInputs = false;
      this.forEachInput((element) => {
        if (!element.getInputElement().validity.valid) {
          invalidInputs = true;
          return;
        }
      });
      return invalidInputs;
    }
  };
  _NumberFilter.DEFAULT_FILTER_OPTIONS = [
    ScalarFilter.EQUALS,
    ScalarFilter.NOT_EQUAL,
    ScalarFilter.GREATER_THAN,
    ScalarFilter.GREATER_THAN_OR_EQUAL,
    ScalarFilter.LESS_THAN,
    ScalarFilter.LESS_THAN_OR_EQUAL,
    ScalarFilter.IN_RANGE,
    ScalarFilter.BLANK,
    ScalarFilter.NOT_BLANK
  ];
  var NumberFilter = _NumberFilter;
  var TextFilterModelFormatter = class extends SimpleFilterModelFormatter {
    conditionToString(condition, options) {
      const { numberOfInputs } = options || {};
      const isRange = condition.type == SimpleFilter.IN_RANGE || numberOfInputs === 2;
      if (isRange) {
        return `${condition.filter}-${condition.filterTo}`;
      }
      if (condition.filter != null) {
        return `${condition.filter}`;
      }
      return `${condition.type}`;
    }
  };
  var _TextFilter = class _TextFilter2 extends SimpleFilter {
    constructor() {
      super("textFilter");
      this.eValuesFrom = [];
      this.eValuesTo = [];
    }
    static trimInput(value) {
      const trimmedInput = value && value.trim();
      return trimmedInput === "" ? value : trimmedInput;
    }
    getDefaultDebounceMs() {
      return 500;
    }
    setParams(params) {
      this.textFilterParams = params;
      super.setParams(params);
      this.matcher = this.getTextMatcher();
      this.formatter = this.textFilterParams.textFormatter || (this.textFilterParams.caseSensitive ? _TextFilter2.DEFAULT_FORMATTER : _TextFilter2.DEFAULT_LOWERCASE_FORMATTER);
      this.filterModelFormatter = new TextFilterModelFormatter(this.localeService, this.optionsFactory);
    }
    getTextMatcher() {
      const legacyComparator = this.textFilterParams.textCustomComparator;
      if (legacyComparator) {
        _.warnOnce("textCustomComparator is deprecated, use textMatcher instead.");
        return ({ filterOption, value, filterText }) => legacyComparator(filterOption, value, filterText);
      }
      return this.textFilterParams.textMatcher || _TextFilter2.DEFAULT_MATCHER;
    }
    createCondition(position) {
      const type = this.getConditionType(position);
      const model = {
        filterType: this.getFilterType(),
        type
      };
      const values2 = this.getValuesWithSideEffects(position, true);
      if (values2.length > 0) {
        model.filter = values2[0];
      }
      if (values2.length > 1) {
        model.filterTo = values2[1];
      }
      return model;
    }
    getFilterType() {
      return "text";
    }
    areSimpleModelsEqual(aSimple, bSimple) {
      return aSimple.filter === bSimple.filter && aSimple.filterTo === bSimple.filterTo && aSimple.type === bSimple.type;
    }
    getInputs(position) {
      if (position >= this.eValuesFrom.length) {
        return [null, null];
      }
      return [this.eValuesFrom[position], this.eValuesTo[position]];
    }
    getValues(position) {
      return this.getValuesWithSideEffects(position, false);
    }
    getValuesWithSideEffects(position, applySideEffects) {
      const result = [];
      this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs) => {
        var _a;
        if (index < numberOfInputs) {
          let value = makeNull(element.getValue());
          if (applySideEffects && this.textFilterParams.trimInput) {
            value = (_a = _TextFilter2.trimInput(value)) != null ? _a : null;
            element.setValue(value, true);
          }
          result.push(value);
        }
      });
      return result;
    }
    getDefaultFilterOptions() {
      return _TextFilter2.DEFAULT_FILTER_OPTIONS;
    }
    createValueElement() {
      const eCondition = document.createElement("div");
      eCondition.classList.add("ag-filter-body");
      setAriaRole(eCondition, "presentation");
      this.createFromToElement(eCondition, this.eValuesFrom, "from");
      this.createFromToElement(eCondition, this.eValuesTo, "to");
      return eCondition;
    }
    createFromToElement(eCondition, eValues, fromTo) {
      const eValue = this.createManagedBean(new AgInputTextField());
      eValue.addCssClass(`ag-filter-${fromTo}`);
      eValue.addCssClass("ag-filter-filter");
      eValues.push(eValue);
      eCondition.appendChild(eValue.getGui());
    }
    removeValueElements(startPosition, deleteCount) {
      this.removeComponents(this.eValuesFrom, startPosition, deleteCount);
      this.removeComponents(this.eValuesTo, startPosition, deleteCount);
    }
    mapValuesFromModel(filterModel) {
      const { filter, filterTo, type } = filterModel || {};
      return [
        filter || null,
        filterTo || null
      ].slice(0, this.getNumberOfInputs(type));
    }
    evaluateNullValue(filterType) {
      const filterTypesAllowNulls = [
        SimpleFilter.NOT_EQUAL,
        SimpleFilter.NOT_CONTAINS,
        SimpleFilter.BLANK
      ];
      return filterType ? filterTypesAllowNulls.indexOf(filterType) >= 0 : false;
    }
    evaluateNonNullValue(values2, cellValue, filterModel, params) {
      const formattedValues = values2.map((v) => this.formatter(v)) || [];
      const cellValueFormatted = this.formatter(cellValue);
      const { api, colDef, column, columnApi, context, textFormatter } = this.textFilterParams;
      if (filterModel.type === SimpleFilter.BLANK) {
        return this.isBlank(cellValue);
      } else if (filterModel.type === SimpleFilter.NOT_BLANK) {
        return !this.isBlank(cellValue);
      }
      const matcherParams = {
        api,
        colDef,
        column,
        columnApi,
        context,
        node: params.node,
        data: params.data,
        filterOption: filterModel.type,
        value: cellValueFormatted,
        textFormatter
      };
      return formattedValues.some((v) => this.matcher(__spreadProps(__spreadValues({}, matcherParams), { filterText: v })));
    }
    getModelAsString(model) {
      var _a;
      return (_a = this.filterModelFormatter.getModelAsString(model)) != null ? _a : "";
    }
  };
  _TextFilter.DEFAULT_FILTER_OPTIONS = [
    SimpleFilter.CONTAINS,
    SimpleFilter.NOT_CONTAINS,
    SimpleFilter.EQUALS,
    SimpleFilter.NOT_EQUAL,
    SimpleFilter.STARTS_WITH,
    SimpleFilter.ENDS_WITH,
    SimpleFilter.BLANK,
    SimpleFilter.NOT_BLANK
  ];
  _TextFilter.DEFAULT_FORMATTER = (from) => from;
  _TextFilter.DEFAULT_LOWERCASE_FORMATTER = (from) => from == null ? null : from.toString().toLowerCase();
  _TextFilter.DEFAULT_MATCHER = ({ filterOption, value, filterText }) => {
    if (filterText == null) {
      return false;
    }
    switch (filterOption) {
      case _TextFilter.CONTAINS:
        return value.indexOf(filterText) >= 0;
      case _TextFilter.NOT_CONTAINS:
        return value.indexOf(filterText) < 0;
      case _TextFilter.EQUALS:
        return value === filterText;
      case _TextFilter.NOT_EQUAL:
        return value != filterText;
      case _TextFilter.STARTS_WITH:
        return value.indexOf(filterText) === 0;
      case _TextFilter.ENDS_WITH:
        const index = value.lastIndexOf(filterText);
        return index >= 0 && index === value.length - filterText.length;
      default:
        return false;
    }
  };
  var TextFilter = _TextFilter;
  var FloatingFilterTextInputService = class extends BeanStub {
    constructor(params) {
      super();
      this.params = params;
      this.valueChangedListener = () => {
      };
    }
    setupGui(parentElement) {
      var _a;
      this.eFloatingFilterTextInput = this.createManagedBean(new AgInputTextField((_a = this.params) == null ? void 0 : _a.config));
      const eInput = this.eFloatingFilterTextInput.getGui();
      parentElement.appendChild(eInput);
      this.addManagedListener(eInput, "input", (e) => this.valueChangedListener(e));
      this.addManagedListener(eInput, "keydown", (e) => this.valueChangedListener(e));
    }
    setEditable(editable) {
      this.eFloatingFilterTextInput.setDisabled(!editable);
    }
    setAutoComplete(autoComplete) {
      this.eFloatingFilterTextInput.setAutoComplete(autoComplete);
    }
    getValue() {
      return this.eFloatingFilterTextInput.getValue();
    }
    setValue(value, silent) {
      this.eFloatingFilterTextInput.setValue(value, silent);
    }
    setValueChangedListener(listener) {
      this.valueChangedListener = listener;
    }
    setParams(params) {
      this.setAriaLabel(params.ariaLabel);
      if (params.autoComplete !== void 0) {
        this.setAutoComplete(params.autoComplete);
      }
    }
    setAriaLabel(ariaLabel) {
      this.eFloatingFilterTextInput.setInputAriaLabel(ariaLabel);
    }
  };
  var TextInputFloatingFilter = class extends SimpleFloatingFilter {
    postConstruct() {
      this.setTemplate(
        /* html */
        `
            <div class="ag-floating-filter-input" role="presentation" ref="eFloatingFilterInputContainer"></div>
        `
      );
    }
    getDefaultDebounceMs() {
      return 500;
    }
    onParentModelChanged(model, event) {
      if (this.isEventFromFloatingFilter(event) || this.isEventFromDataChange(event)) {
        return;
      }
      this.setLastTypeFromModel(model);
      this.setEditable(this.canWeEditAfterModelFromParentFilter(model));
      this.floatingFilterInputService.setValue(this.getFilterModelFormatter().getModelAsString(model));
    }
    init(params) {
      this.setupFloatingFilterInputService(params);
      super.init(params);
      this.setTextInputParams(params);
    }
    setupFloatingFilterInputService(params) {
      this.floatingFilterInputService = this.createFloatingFilterInputService(params);
      this.floatingFilterInputService.setupGui(this.eFloatingFilterInputContainer);
    }
    setTextInputParams(params) {
      var _a;
      this.params = params;
      const autoComplete = (_a = params.browserAutoComplete) != null ? _a : false;
      this.floatingFilterInputService.setParams({
        ariaLabel: this.getAriaLabel(params),
        autoComplete
      });
      this.applyActive = ProvidedFilter.isUseApplyButton(this.params.filterParams);
      if (!this.isReadOnly()) {
        const debounceMs = ProvidedFilter.getDebounceMs(this.params.filterParams, this.getDefaultDebounceMs());
        const toDebounce = debounce2(this.syncUpWithParentFilter.bind(this), debounceMs);
        this.floatingFilterInputService.setValueChangedListener(toDebounce);
      }
    }
    onParamsUpdated(params) {
      this.refresh(params);
    }
    refresh(params) {
      super.refresh(params);
      this.setTextInputParams(params);
    }
    recreateFloatingFilterInputService(params) {
      const value = this.floatingFilterInputService.getValue();
      clearElement(this.eFloatingFilterInputContainer);
      this.destroyBean(this.floatingFilterInputService);
      this.setupFloatingFilterInputService(params);
      this.floatingFilterInputService.setValue(value, true);
    }
    syncUpWithParentFilter(e) {
      const isEnterKey = e.key === KeyCode.ENTER;
      if (this.applyActive && !isEnterKey) {
        return;
      }
      let value = this.floatingFilterInputService.getValue();
      if (this.params.filterParams.trimInput) {
        value = TextFilter.trimInput(value);
        this.floatingFilterInputService.setValue(value, true);
      }
      this.params.parentFilterInstance((filterInstance) => {
        if (filterInstance) {
          filterInstance.onFloatingFilterChanged(this.getLastType() || null, value || null);
        }
      });
    }
    setEditable(editable) {
      this.floatingFilterInputService.setEditable(editable);
    }
  };
  __decorateClass([
    RefSelector("eFloatingFilterInputContainer")
  ], TextInputFloatingFilter.prototype, "eFloatingFilterInputContainer", 2);
  __decorateClass([
    PostConstruct
  ], TextInputFloatingFilter.prototype, "postConstruct", 1);
  var FloatingFilterNumberInputService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.valueChangedListener = () => {
      };
      this.numberInputActive = true;
    }
    setupGui(parentElement) {
      this.eFloatingFilterNumberInput = this.createManagedBean(new AgInputNumberField());
      this.eFloatingFilterTextInput = this.createManagedBean(new AgInputTextField());
      this.eFloatingFilterTextInput.setDisabled(true);
      const eNumberInput = this.eFloatingFilterNumberInput.getGui();
      const eTextInput = this.eFloatingFilterTextInput.getGui();
      parentElement.appendChild(eNumberInput);
      parentElement.appendChild(eTextInput);
      this.setupListeners(eNumberInput, (e) => this.valueChangedListener(e));
      this.setupListeners(eTextInput, (e) => this.valueChangedListener(e));
    }
    setEditable(editable) {
      this.numberInputActive = editable;
      this.eFloatingFilterNumberInput.setDisplayed(this.numberInputActive);
      this.eFloatingFilterTextInput.setDisplayed(!this.numberInputActive);
    }
    setAutoComplete(autoComplete) {
      this.eFloatingFilterNumberInput.setAutoComplete(autoComplete);
      this.eFloatingFilterTextInput.setAutoComplete(autoComplete);
    }
    getValue() {
      return this.getActiveInputElement().getValue();
    }
    setValue(value, silent) {
      this.getActiveInputElement().setValue(value, silent);
    }
    getActiveInputElement() {
      return this.numberInputActive ? this.eFloatingFilterNumberInput : this.eFloatingFilterTextInput;
    }
    setValueChangedListener(listener) {
      this.valueChangedListener = listener;
    }
    setupListeners(element, listener) {
      this.addManagedListener(element, "input", listener);
      this.addManagedListener(element, "keydown", listener);
    }
    setParams(params) {
      this.setAriaLabel(params.ariaLabel);
      if (params.autoComplete !== void 0) {
        this.setAutoComplete(params.autoComplete);
      }
    }
    setAriaLabel(ariaLabel) {
      this.eFloatingFilterNumberInput.setInputAriaLabel(ariaLabel);
      this.eFloatingFilterTextInput.setInputAriaLabel(ariaLabel);
    }
  };
  var NumberFloatingFilter = class extends TextInputFloatingFilter {
    init(params) {
      var _a;
      super.init(params);
      this.filterModelFormatter = new NumberFilterModelFormatter(
        this.localeService,
        this.optionsFactory,
        (_a = params.filterParams) == null ? void 0 : _a.numberFormatter
      );
    }
    onParamsUpdated(params) {
      this.refresh(params);
    }
    refresh(params) {
      const allowedCharPattern = getAllowedCharPattern(params.filterParams);
      if (allowedCharPattern !== this.allowedCharPattern) {
        this.recreateFloatingFilterInputService(params);
      }
      super.refresh(params);
      this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
    }
    getDefaultFilterOptions() {
      return NumberFilter.DEFAULT_FILTER_OPTIONS;
    }
    getFilterModelFormatter() {
      return this.filterModelFormatter;
    }
    createFloatingFilterInputService(params) {
      this.allowedCharPattern = getAllowedCharPattern(params.filterParams);
      if (this.allowedCharPattern) {
        return this.createManagedBean(new FloatingFilterTextInputService({
          config: { allowedCharPattern: this.allowedCharPattern }
        }));
      }
      return this.createManagedBean(new FloatingFilterNumberInputService());
    }
  };
  var TextFloatingFilter = class extends TextInputFloatingFilter {
    init(params) {
      super.init(params);
      this.filterModelFormatter = new TextFilterModelFormatter(this.localeService, this.optionsFactory);
    }
    onParamsUpdated(params) {
      this.refresh(params);
    }
    refresh(params) {
      super.refresh(params);
      this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
    }
    getDefaultFilterOptions() {
      return TextFilter.DEFAULT_FILTER_OPTIONS;
    }
    getFilterModelFormatter() {
      return this.filterModelFormatter;
    }
    createFloatingFilterInputService() {
      return this.createManagedBean(new FloatingFilterTextInputService());
    }
  };
  var _TouchListener = class _TouchListener2 {
    constructor(eElement, preventMouseClick = false) {
      this.destroyFuncs = [];
      this.touching = false;
      this.eventService = new EventService();
      this.eElement = eElement;
      this.preventMouseClick = preventMouseClick;
      const startListener = this.onTouchStart.bind(this);
      const moveListener = this.onTouchMove.bind(this);
      const endListener = this.onTouchEnd.bind(this);
      this.eElement.addEventListener("touchstart", startListener, { passive: true });
      this.eElement.addEventListener("touchmove", moveListener, { passive: true });
      this.eElement.addEventListener("touchend", endListener, { passive: false });
      this.destroyFuncs.push(() => {
        this.eElement.removeEventListener("touchstart", startListener, { passive: true });
        this.eElement.removeEventListener("touchmove", moveListener, { passive: true });
        this.eElement.removeEventListener("touchend", endListener, { passive: false });
      });
    }
    getActiveTouch(touchList) {
      for (let i = 0; i < touchList.length; i++) {
        const matches2 = touchList[i].identifier === this.touchStart.identifier;
        if (matches2) {
          return touchList[i];
        }
      }
      return null;
    }
    addEventListener(eventType, listener) {
      this.eventService.addEventListener(eventType, listener);
    }
    removeEventListener(eventType, listener) {
      this.eventService.removeEventListener(eventType, listener);
    }
    onTouchStart(touchEvent) {
      if (this.touching) {
        return;
      }
      this.touchStart = touchEvent.touches[0];
      this.touching = true;
      this.moved = false;
      const touchStartCopy = this.touchStart;
      window.setTimeout(() => {
        const touchesMatch = this.touchStart === touchStartCopy;
        if (this.touching && touchesMatch && !this.moved) {
          this.moved = true;
          const event = {
            type: _TouchListener2.EVENT_LONG_TAP,
            touchStart: this.touchStart,
            touchEvent
          };
          this.eventService.dispatchEvent(event);
        }
      }, 500);
    }
    onTouchMove(touchEvent) {
      if (!this.touching) {
        return;
      }
      const touch = this.getActiveTouch(touchEvent.touches);
      if (!touch) {
        return;
      }
      const eventIsFarAway = !areEventsNear(touch, this.touchStart, 4);
      if (eventIsFarAway) {
        this.moved = true;
      }
    }
    onTouchEnd(touchEvent) {
      if (!this.touching) {
        return;
      }
      if (!this.moved) {
        const event = {
          type: _TouchListener2.EVENT_TAP,
          touchStart: this.touchStart
        };
        this.eventService.dispatchEvent(event);
        this.checkForDoubleTap();
      }
      if (this.preventMouseClick && touchEvent.cancelable) {
        touchEvent.preventDefault();
      }
      this.touching = false;
    }
    checkForDoubleTap() {
      const now2 = (/* @__PURE__ */ new Date()).getTime();
      if (this.lastTapTime && this.lastTapTime > 0) {
        const interval = now2 - this.lastTapTime;
        if (interval > _TouchListener2.DOUBLE_TAP_MILLIS) {
          const event = {
            type: _TouchListener2.EVENT_DOUBLE_TAP,
            touchStart: this.touchStart
          };
          this.eventService.dispatchEvent(event);
          this.lastTapTime = null;
        } else {
          this.lastTapTime = now2;
        }
      } else {
        this.lastTapTime = now2;
      }
    }
    destroy() {
      this.destroyFuncs.forEach((func) => func());
    }
  };
  _TouchListener.EVENT_TAP = "tap";
  _TouchListener.EVENT_DOUBLE_TAP = "doubleTap";
  _TouchListener.EVENT_LONG_TAP = "longTap";
  _TouchListener.DOUBLE_TAP_MILLIS = 500;
  var TouchListener = _TouchListener;
  var _SortIndicatorComp = class _SortIndicatorComp2 extends Component {
    constructor(skipTemplate) {
      super();
      if (!skipTemplate) {
        this.setTemplate(_SortIndicatorComp2.TEMPLATE);
      }
    }
    attachCustomElements(eSortOrder, eSortAsc, eSortDesc, eSortMixed, eSortNone) {
      this.eSortOrder = eSortOrder;
      this.eSortAsc = eSortAsc;
      this.eSortDesc = eSortDesc;
      this.eSortMixed = eSortMixed;
      this.eSortNone = eSortNone;
    }
    setupSort(column, suppressOrder = false) {
      this.column = column;
      this.suppressOrder = suppressOrder;
      this.setupMultiSortIndicator();
      if (!this.column.isSortable() && !this.column.getColDef().showRowGroup) {
        return;
      }
      this.addInIcon("sortAscending", this.eSortAsc, column);
      this.addInIcon("sortDescending", this.eSortDesc, column);
      this.addInIcon("sortUnSort", this.eSortNone, column);
      this.addManagedPropertyListener("unSortIcon", () => this.updateIcons());
      this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, () => this.updateIcons());
      this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, () => this.onSortChanged());
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.onSortChanged());
      this.onSortChanged();
    }
    addInIcon(iconName, eParent, column) {
      if (eParent == null) {
        return;
      }
      const eIcon = createIconNoSpan(iconName, this.gos, column);
      if (eIcon) {
        eParent.appendChild(eIcon);
      }
    }
    onSortChanged() {
      this.updateIcons();
      if (!this.suppressOrder) {
        this.updateSortOrder();
      }
    }
    updateIcons() {
      const sortDirection = this.sortController.getDisplaySortForColumn(this.column);
      if (this.eSortAsc) {
        const isAscending = sortDirection === "asc";
        setDisplayed(this.eSortAsc, isAscending, { skipAriaHidden: true });
      }
      if (this.eSortDesc) {
        const isDescending = sortDirection === "desc";
        setDisplayed(this.eSortDesc, isDescending, { skipAriaHidden: true });
      }
      if (this.eSortNone) {
        const alwaysHideNoSort = !this.column.getColDef().unSortIcon && !this.gos.get("unSortIcon");
        const isNone = sortDirection === null || sortDirection === void 0;
        setDisplayed(this.eSortNone, !alwaysHideNoSort && isNone, { skipAriaHidden: true });
      }
    }
    setupMultiSortIndicator() {
      this.addInIcon("sortUnSort", this.eSortMixed, this.column);
      const isColumnShowingRowGroup = this.column.getColDef().showRowGroup;
      const areGroupsCoupled = this.gos.isColumnsSortingCoupledToGroup();
      if (areGroupsCoupled && isColumnShowingRowGroup) {
        this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, () => this.updateMultiSortIndicator());
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.updateMultiSortIndicator());
        this.updateMultiSortIndicator();
      }
    }
    updateMultiSortIndicator() {
      if (this.eSortMixed) {
        const isMixedSort = this.sortController.getDisplaySortForColumn(this.column) === "mixed";
        setDisplayed(this.eSortMixed, isMixedSort, { skipAriaHidden: true });
      }
    }
    // we listen here for global sort events, NOT column sort events, as we want to do this
    // when sorting has been set on all column (if we listened just for our col (where we
    // set the asc / desc icons) then it's possible other cols are yet to get their sorting state.
    updateSortOrder() {
      var _a;
      if (!this.eSortOrder) {
        return;
      }
      const allColumnsWithSorting = this.sortController.getColumnsWithSortingOrdered();
      const indexThisCol = (_a = this.sortController.getDisplaySortIndexForColumn(this.column)) != null ? _a : -1;
      const moreThanOneColSorting = allColumnsWithSorting.some((col) => {
        var _a2;
        return (_a2 = this.sortController.getDisplaySortIndexForColumn(col)) != null ? _a2 : -1 >= 1;
      });
      const showIndex = indexThisCol >= 0 && moreThanOneColSorting;
      setDisplayed(this.eSortOrder, showIndex, { skipAriaHidden: true });
      if (indexThisCol >= 0) {
        this.eSortOrder.textContent = (indexThisCol + 1).toString();
      } else {
        clearElement(this.eSortOrder);
      }
    }
  };
  _SortIndicatorComp.TEMPLATE = /* html */
  `<span class="ag-sort-indicator-container">
            <span ref="eSortOrder" class="ag-sort-indicator-icon ag-sort-order ag-hidden" aria-hidden="true"></span>
            <span ref="eSortAsc" class="ag-sort-indicator-icon ag-sort-ascending-icon ag-hidden" aria-hidden="true"></span>
            <span ref="eSortDesc" class="ag-sort-indicator-icon ag-sort-descending-icon ag-hidden" aria-hidden="true"></span>
            <span ref="eSortMixed" class="ag-sort-indicator-icon ag-sort-mixed-icon ag-hidden" aria-hidden="true"></span>
            <span ref="eSortNone" class="ag-sort-indicator-icon ag-sort-none-icon ag-hidden" aria-hidden="true"></span>
        </span>`;
  __decorateClass([
    RefSelector("eSortOrder")
  ], _SortIndicatorComp.prototype, "eSortOrder", 2);
  __decorateClass([
    RefSelector("eSortAsc")
  ], _SortIndicatorComp.prototype, "eSortAsc", 2);
  __decorateClass([
    RefSelector("eSortDesc")
  ], _SortIndicatorComp.prototype, "eSortDesc", 2);
  __decorateClass([
    RefSelector("eSortMixed")
  ], _SortIndicatorComp.prototype, "eSortMixed", 2);
  __decorateClass([
    RefSelector("eSortNone")
  ], _SortIndicatorComp.prototype, "eSortNone", 2);
  __decorateClass([
    Autowired("columnModel")
  ], _SortIndicatorComp.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("sortController")
  ], _SortIndicatorComp.prototype, "sortController", 2);
  var SortIndicatorComp = _SortIndicatorComp;
  var _HeaderComp = class _HeaderComp2 extends Component {
    constructor() {
      super(...arguments);
      this.lastMovingChanged = 0;
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
      super.destroy();
    }
    refresh(params) {
      const oldParams = this.params;
      this.params = params;
      if (this.workOutTemplate() != this.currentTemplate || this.workOutShowMenu() != this.currentShowMenu || this.workOutSort() != this.currentSort || this.shouldSuppressMenuHide() != this.currentSuppressMenuHide || oldParams.enableFilterButton != params.enableFilterButton || oldParams.enableFilterIcon != params.enableFilterIcon) {
        return false;
      }
      this.setDisplayName(params);
      return true;
    }
    workOutTemplate() {
      var _a;
      let template = (_a = this.params.template) != null ? _a : _HeaderComp2.TEMPLATE;
      template = template && template.trim ? template.trim() : template;
      return template;
    }
    init(params) {
      this.params = params;
      this.currentTemplate = this.workOutTemplate();
      this.setTemplate(this.currentTemplate);
      this.setupTap();
      this.setMenu();
      this.setupSort();
      this.setupFilterIcon();
      this.setupFilterButton();
      this.setDisplayName(params);
    }
    setDisplayName(params) {
      if (this.currentDisplayName != params.displayName) {
        this.currentDisplayName = params.displayName;
        const displayNameSanitised = escapeString(this.currentDisplayName, true);
        if (this.eText) {
          this.eText.textContent = displayNameSanitised;
        }
      }
    }
    addInIcon(iconName, eParent, column) {
      if (eParent == null) {
        return;
      }
      const eIcon = createIconNoSpan(iconName, this.gos, column);
      if (eIcon) {
        eParent.appendChild(eIcon);
      }
    }
    setupTap() {
      const { gos } = this;
      if (gos.get("suppressTouch")) {
        return;
      }
      const touchListener = new TouchListener(this.getGui(), true);
      const suppressMenuHide = this.shouldSuppressMenuHide();
      const tapMenuButton = suppressMenuHide && exists(this.eMenu);
      const menuTouchListener = tapMenuButton ? new TouchListener(this.eMenu, true) : touchListener;
      if (this.params.enableMenu) {
        const eventType = tapMenuButton ? "EVENT_TAP" : "EVENT_LONG_TAP";
        const showMenuFn = (event) => this.params.showColumnMenuAfterMouseClick(event.touchStart);
        this.addManagedListener(menuTouchListener, TouchListener[eventType], showMenuFn);
      }
      if (this.params.enableSorting) {
        const tapListener = (event) => {
          var _a, _b;
          const target = event.touchStart.target;
          if (suppressMenuHide && (((_a = this.eMenu) == null ? void 0 : _a.contains(target)) || ((_b = this.eFilterButton) == null ? void 0 : _b.contains(target)))) {
            return;
          }
          this.sortController.progressSort(this.params.column, false, "uiColumnSorted");
        };
        this.addManagedListener(touchListener, TouchListener.EVENT_TAP, tapListener);
      }
      if (this.params.enableFilterButton) {
        const filterButtonTouchListener = new TouchListener(this.eFilterButton, true);
        this.addManagedListener(filterButtonTouchListener, "tap", () => this.params.showFilter(this.eFilterButton));
        this.addDestroyFunc(() => filterButtonTouchListener.destroy());
      }
      this.addDestroyFunc(() => touchListener.destroy());
      if (tapMenuButton) {
        this.addDestroyFunc(() => menuTouchListener.destroy());
      }
    }
    workOutShowMenu() {
      return this.params.enableMenu && this.menuService.isHeaderMenuButtonEnabled();
    }
    shouldSuppressMenuHide() {
      return this.menuService.isHeaderMenuButtonAlwaysShowEnabled();
    }
    setMenu() {
      if (!this.eMenu) {
        return;
      }
      this.currentShowMenu = this.workOutShowMenu();
      if (!this.currentShowMenu) {
        removeFromParent(this.eMenu);
        this.eMenu = void 0;
        return;
      }
      const isLegacyMenu = this.menuService.isLegacyMenuEnabled();
      this.addInIcon(isLegacyMenu ? "menu" : "menuAlt", this.eMenu, this.params.column);
      this.eMenu.classList.toggle("ag-header-menu-icon", !isLegacyMenu);
      this.currentSuppressMenuHide = this.shouldSuppressMenuHide();
      this.addManagedListener(this.eMenu, "click", () => this.params.showColumnMenu(this.eMenu));
      this.eMenu.classList.toggle("ag-header-menu-always-show", this.currentSuppressMenuHide);
    }
    onMenuKeyboardShortcut(isFilterShortcut) {
      var _a, _b, _c, _d;
      const { column } = this.params;
      const isLegacyMenuEnabled = this.menuService.isLegacyMenuEnabled();
      if (isFilterShortcut && !isLegacyMenuEnabled) {
        if (this.menuService.isFilterMenuInHeaderEnabled(column)) {
          this.params.showFilter((_b = (_a = this.eFilterButton) != null ? _a : this.eMenu) != null ? _b : this.getGui());
          return true;
        }
      } else if (this.params.enableMenu) {
        this.params.showColumnMenu((_d = (_c = this.eMenu) != null ? _c : this.eFilterButton) != null ? _d : this.getGui());
        return true;
      }
      return false;
    }
    workOutSort() {
      return this.params.enableSorting;
    }
    setupSort() {
      this.currentSort = this.params.enableSorting;
      if (!this.eSortIndicator) {
        this.eSortIndicator = this.context.createBean(new SortIndicatorComp(true));
        this.eSortIndicator.attachCustomElements(
          this.eSortOrder,
          this.eSortAsc,
          this.eSortDesc,
          this.eSortMixed,
          this.eSortNone
        );
      }
      this.eSortIndicator.setupSort(this.params.column);
      if (!this.currentSort) {
        return;
      }
      this.addManagedListener(this.params.column, Column.EVENT_MOVING_CHANGED, () => {
        this.lastMovingChanged = (/* @__PURE__ */ new Date()).getTime();
      });
      if (this.eLabel) {
        this.addManagedListener(this.eLabel, "click", (event) => {
          const moving = this.params.column.isMoving();
          const nowTime = (/* @__PURE__ */ new Date()).getTime();
          const movedRecently = nowTime - this.lastMovingChanged < 50;
          const columnMoving = moving || movedRecently;
          if (!columnMoving) {
            const sortUsingCtrl = this.gos.get("multiSortKey") === "ctrl";
            const multiSort = sortUsingCtrl ? event.ctrlKey || event.metaKey : event.shiftKey;
            this.params.progressSort(multiSort);
          }
        });
      }
      const onSortingChanged = () => {
        this.addOrRemoveCssClass("ag-header-cell-sorted-asc", this.params.column.isSortAscending());
        this.addOrRemoveCssClass("ag-header-cell-sorted-desc", this.params.column.isSortDescending());
        this.addOrRemoveCssClass("ag-header-cell-sorted-none", this.params.column.isSortNone());
        if (this.params.column.getColDef().showRowGroup) {
          const sourceColumns = this.columnModel.getSourceColumnsForGroupColumn(this.params.column);
          const sortDirectionsMatch = sourceColumns == null ? void 0 : sourceColumns.every((sourceCol) => this.params.column.getSort() == sourceCol.getSort());
          const isMultiSorting = !sortDirectionsMatch;
          this.addOrRemoveCssClass("ag-header-cell-sorted-mixed", isMultiSorting);
        }
      };
      this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, onSortingChanged);
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, onSortingChanged);
    }
    setupFilterIcon() {
      if (!this.eFilter) {
        return;
      }
      this.configureFilter(this.params.enableFilterIcon, this.eFilter, this.onFilterChangedIcon.bind(this));
    }
    setupFilterButton() {
      if (!this.eFilterButton) {
        return;
      }
      const configured = this.configureFilter(
        this.params.enableFilterButton,
        this.eFilterButton,
        this.onFilterChangedButton.bind(this)
      );
      if (configured) {
        this.addManagedListener(this.eFilterButton, "click", () => this.params.showFilter(this.eFilterButton));
      } else {
        this.eFilterButton = void 0;
      }
    }
    configureFilter(enabled, element, filterChangedCallback) {
      if (!enabled) {
        removeFromParent(element);
        return false;
      }
      const { column } = this.params;
      this.addInIcon("filter", element, column);
      this.addManagedListener(column, Column.EVENT_FILTER_CHANGED, filterChangedCallback);
      filterChangedCallback();
      return true;
    }
    onFilterChangedIcon() {
      const filterPresent = this.params.column.isFilterActive();
      setDisplayed(this.eFilter, filterPresent, { skipAriaHidden: true });
    }
    onFilterChangedButton() {
      const filterPresent = this.params.column.isFilterActive();
      this.eFilterButton.classList.toggle("ag-filter-active", filterPresent);
    }
    getAnchorElementForMenu(isFilter) {
      var _a, _b, _c, _d;
      if (isFilter) {
        return (_b = (_a = this.eFilterButton) != null ? _a : this.eMenu) != null ? _b : this.getGui();
      }
      return (_d = (_c = this.eMenu) != null ? _c : this.eFilterButton) != null ? _d : this.getGui();
    }
  };
  _HeaderComp.TEMPLATE = /* html */
  `<div class="ag-cell-label-container" role="presentation">
            <span ref="eMenu" class="ag-header-icon ag-header-cell-menu-button" aria-hidden="true"></span>
            <span ref="eFilterButton" class="ag-header-icon ag-header-cell-filter-button" aria-hidden="true"></span>
            <div ref="eLabel" class="ag-header-cell-label" role="presentation">
                <span ref="eText" class="ag-header-cell-text"></span>
                <span ref="eFilter" class="ag-header-icon ag-header-label-icon ag-filter-icon" aria-hidden="true"></span>
                <ag-sort-indicator ref="eSortIndicator"></ag-sort-indicator>
            </div>
        </div>`;
  __decorateClass([
    Autowired("sortController")
  ], _HeaderComp.prototype, "sortController", 2);
  __decorateClass([
    Autowired("menuService")
  ], _HeaderComp.prototype, "menuService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], _HeaderComp.prototype, "columnModel", 2);
  __decorateClass([
    RefSelector("eFilter")
  ], _HeaderComp.prototype, "eFilter", 2);
  __decorateClass([
    RefSelector("eFilterButton")
  ], _HeaderComp.prototype, "eFilterButton", 2);
  __decorateClass([
    RefSelector("eSortIndicator")
  ], _HeaderComp.prototype, "eSortIndicator", 2);
  __decorateClass([
    RefSelector("eMenu")
  ], _HeaderComp.prototype, "eMenu", 2);
  __decorateClass([
    RefSelector("eLabel")
  ], _HeaderComp.prototype, "eLabel", 2);
  __decorateClass([
    RefSelector("eText")
  ], _HeaderComp.prototype, "eText", 2);
  __decorateClass([
    RefSelector("eSortOrder")
  ], _HeaderComp.prototype, "eSortOrder", 2);
  __decorateClass([
    RefSelector("eSortAsc")
  ], _HeaderComp.prototype, "eSortAsc", 2);
  __decorateClass([
    RefSelector("eSortDesc")
  ], _HeaderComp.prototype, "eSortDesc", 2);
  __decorateClass([
    RefSelector("eSortMixed")
  ], _HeaderComp.prototype, "eSortMixed", 2);
  __decorateClass([
    RefSelector("eSortNone")
  ], _HeaderComp.prototype, "eSortNone", 2);
  var HeaderComp = _HeaderComp;
  var _HeaderGroupComp = class _HeaderGroupComp2 extends Component {
    constructor() {
      super(_HeaderGroupComp2.TEMPLATE);
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
      super.destroy();
    }
    init(params) {
      this.params = params;
      this.checkWarnings();
      this.setupLabel();
      this.addGroupExpandIcon();
      this.setupExpandIcons();
    }
    checkWarnings() {
      const paramsAny = this.params;
      if (paramsAny.template) {
        warnOnce(`A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)`);
      }
    }
    setupExpandIcons() {
      this.addInIcon("columnGroupOpened", "agOpened");
      this.addInIcon("columnGroupClosed", "agClosed");
      const expandAction = (event) => {
        if (isStopPropagationForAgGrid(event)) {
          return;
        }
        const newExpandedValue = !this.params.columnGroup.isExpanded();
        this.columnModel.setColumnGroupOpened(this.params.columnGroup.getProvidedColumnGroup(), newExpandedValue, "uiColumnExpanded");
      };
      this.addTouchAndClickListeners(this.eCloseIcon, expandAction);
      this.addTouchAndClickListeners(this.eOpenIcon, expandAction);
      const stopPropagationAction = (event) => {
        stopPropagationForAgGrid(event);
      };
      this.addManagedListener(this.eCloseIcon, "dblclick", stopPropagationAction);
      this.addManagedListener(this.eOpenIcon, "dblclick", stopPropagationAction);
      this.addManagedListener(this.getGui(), "dblclick", expandAction);
      this.updateIconVisibility();
      const providedColumnGroup = this.params.columnGroup.getProvidedColumnGroup();
      this.addManagedListener(providedColumnGroup, ProvidedColumnGroup.EVENT_EXPANDED_CHANGED, this.updateIconVisibility.bind(this));
      this.addManagedListener(providedColumnGroup, ProvidedColumnGroup.EVENT_EXPANDABLE_CHANGED, this.updateIconVisibility.bind(this));
    }
    addTouchAndClickListeners(eElement, action) {
      const touchListener = new TouchListener(eElement, true);
      this.addManagedListener(touchListener, TouchListener.EVENT_TAP, action);
      this.addDestroyFunc(() => touchListener.destroy());
      this.addManagedListener(eElement, "click", action);
    }
    updateIconVisibility() {
      const columnGroup = this.params.columnGroup;
      if (columnGroup.isExpandable()) {
        const expanded = this.params.columnGroup.isExpanded();
        setDisplayed(this.eOpenIcon, expanded);
        setDisplayed(this.eCloseIcon, !expanded);
      } else {
        setDisplayed(this.eOpenIcon, false);
        setDisplayed(this.eCloseIcon, false);
      }
    }
    addInIcon(iconName, refName) {
      const eIcon = createIconNoSpan(iconName, this.gos, null);
      if (eIcon) {
        this.getRefElement(refName).appendChild(eIcon);
      }
    }
    addGroupExpandIcon() {
      if (!this.params.columnGroup.isExpandable()) {
        setDisplayed(this.eOpenIcon, false);
        setDisplayed(this.eCloseIcon, false);
        return;
      }
    }
    setupLabel() {
      var _a;
      const { displayName, columnGroup } = this.params;
      if (exists(displayName)) {
        const displayNameSanitised = escapeString(displayName, true);
        this.getRefElement("agLabel").textContent = displayNameSanitised;
      }
      this.addOrRemoveCssClass("ag-sticky-label", !((_a = columnGroup.getColGroupDef()) == null ? void 0 : _a.suppressStickyLabel));
    }
  };
  _HeaderGroupComp.TEMPLATE = /* html */
  `<div class="ag-header-group-cell-label" ref="agContainer" role="presentation">
            <span ref="agLabel" class="ag-header-group-text" role="presentation"></span>
            <span ref="agOpened" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded"></span>
            <span ref="agClosed" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed"></span>
        </div>`;
  __decorateClass([
    Autowired("columnModel")
  ], _HeaderGroupComp.prototype, "columnModel", 2);
  __decorateClass([
    RefSelector("agOpened")
  ], _HeaderGroupComp.prototype, "eOpenIcon", 2);
  __decorateClass([
    RefSelector("agClosed")
  ], _HeaderGroupComp.prototype, "eCloseIcon", 2);
  var HeaderGroupComp = _HeaderGroupComp;
  var PopupComponent = class extends Component {
    isPopup() {
      return true;
    }
    setParentComponent(container) {
      container.addCssClass("ag-has-popup");
      super.setParentComponent(container);
    }
    destroy() {
      const parentComp = this.parentComponent;
      const hasParent = parentComp && parentComp.isAlive();
      if (hasParent) {
        parentComp.getGui().classList.remove("ag-has-popup");
      }
      super.destroy();
    }
  };
  var _LargeTextCellEditor = class _LargeTextCellEditor2 extends PopupComponent {
    constructor() {
      super(_LargeTextCellEditor2.TEMPLATE);
    }
    init(params) {
      this.params = params;
      this.focusAfterAttached = params.cellStartedEdit;
      this.eTextArea.setMaxLength(params.maxLength || 200).setCols(params.cols || 60).setRows(params.rows || 10);
      if (exists(params.value, true)) {
        this.eTextArea.setValue(params.value.toString(), true);
      }
      this.addGuiEventListener("keydown", this.onKeyDown.bind(this));
      this.activateTabIndex();
    }
    onKeyDown(event) {
      const key = event.key;
      if (key === KeyCode.LEFT || key === KeyCode.UP || key === KeyCode.RIGHT || key === KeyCode.DOWN || event.shiftKey && key === KeyCode.ENTER) {
        event.stopPropagation();
      }
    }
    afterGuiAttached() {
      const translate = this.localeService.getLocaleTextFunc();
      this.eTextArea.setInputAriaLabel(translate("ariaInputEditor", "Input Editor"));
      if (this.focusAfterAttached) {
        this.eTextArea.getFocusableElement().focus();
      }
    }
    getValue() {
      const value = this.eTextArea.getValue();
      if (!exists(value) && !exists(this.params.value)) {
        return this.params.value;
      }
      return this.params.parseValue(value);
    }
  };
  _LargeTextCellEditor.TEMPLATE = /* html */
  `<div class="ag-large-text">
            <ag-input-text-area ref="eTextArea" class="ag-large-text-input"></ag-input-text-area>
        </div>`;
  __decorateClass([
    RefSelector("eTextArea")
  ], _LargeTextCellEditor.prototype, "eTextArea", 2);
  var LargeTextCellEditor = _LargeTextCellEditor;
  var SelectCellEditor = class extends PopupComponent {
    constructor() {
      super(
        /* html */
        `<div class="ag-cell-edit-wrapper">
                <ag-select class="ag-cell-editor" ref="eSelect"></ag-select>
            </div>`
      );
      this.startedByEnter = false;
    }
    init(params) {
      this.focusAfterAttached = params.cellStartedEdit;
      const { eSelect, valueService, gos } = this;
      const { values: values2, value, eventKey } = params;
      if (missing(values2)) {
        console.warn("AG Grid: no values found for select cellEditor");
        return;
      }
      this.startedByEnter = eventKey != null ? eventKey === KeyCode.ENTER : false;
      let hasValue = false;
      values2.forEach((currentValue) => {
        const option = { value: currentValue };
        const valueFormatted = valueService.formatValue(params.column, null, currentValue);
        const valueFormattedExits = valueFormatted !== null && valueFormatted !== void 0;
        option.text = valueFormattedExits ? valueFormatted : currentValue;
        eSelect.addOption(option);
        hasValue = hasValue || value === currentValue;
      });
      if (hasValue) {
        eSelect.setValue(params.value, true);
      } else if (params.values.length) {
        eSelect.setValue(params.values[0], true);
      }
      const { valueListGap, valueListMaxWidth, valueListMaxHeight } = params;
      if (valueListGap != null) {
        eSelect.setPickerGap(valueListGap);
      }
      if (valueListMaxHeight != null) {
        eSelect.setPickerMaxHeight(valueListMaxHeight);
      }
      if (valueListMaxWidth != null) {
        eSelect.setPickerMaxWidth(valueListMaxWidth);
      }
      if (gos.get("editType") !== "fullRow") {
        this.addManagedListener(this.eSelect, AgSelect.EVENT_ITEM_SELECTED, () => params.stopEditing());
      }
    }
    afterGuiAttached() {
      if (this.focusAfterAttached) {
        this.eSelect.getFocusableElement().focus();
      }
      if (this.startedByEnter) {
        setTimeout(() => {
          if (this.isAlive()) {
            this.eSelect.showPicker();
          }
        });
      }
    }
    focusIn() {
      this.eSelect.getFocusableElement().focus();
    }
    getValue() {
      return this.eSelect.getValue();
    }
    isPopup() {
      return false;
    }
  };
  __decorateClass([
    Autowired("valueService")
  ], SelectCellEditor.prototype, "valueService", 2);
  __decorateClass([
    RefSelector("eSelect")
  ], SelectCellEditor.prototype, "eSelect", 2);
  var SimpleCellEditor = class extends PopupComponent {
    constructor(cellEditorInput) {
      super(
        /* html */
        `
            <div class="ag-cell-edit-wrapper">
                ${cellEditorInput.getTemplate()}
            </div>`
      );
      this.cellEditorInput = cellEditorInput;
    }
    init(params) {
      this.params = params;
      const eInput = this.eInput;
      this.cellEditorInput.init(eInput, params);
      let startValue;
      if (params.cellStartedEdit) {
        this.focusAfterAttached = true;
        const eventKey = params.eventKey;
        if (eventKey === KeyCode.BACKSPACE || params.eventKey === KeyCode.DELETE) {
          startValue = "";
        } else if (eventKey && eventKey.length === 1) {
          startValue = eventKey;
        } else {
          startValue = this.cellEditorInput.getStartValue();
          if (eventKey !== KeyCode.F2) {
            this.highlightAllOnFocus = true;
          }
        }
      } else {
        this.focusAfterAttached = false;
        startValue = this.cellEditorInput.getStartValue();
      }
      if (startValue != null) {
        eInput.setStartValue(startValue);
      }
      this.addManagedListener(eInput.getGui(), "keydown", (event) => {
        const { key } = event;
        if (key === KeyCode.PAGE_UP || key === KeyCode.PAGE_DOWN) {
          event.preventDefault();
        }
      });
    }
    afterGuiAttached() {
      var _a, _b;
      const translate = this.localeService.getLocaleTextFunc();
      const eInput = this.eInput;
      eInput.setInputAriaLabel(translate("ariaInputEditor", "Input Editor"));
      if (!this.focusAfterAttached) {
        return;
      }
      if (!isBrowserSafari()) {
        eInput.getFocusableElement().focus();
      }
      const inputEl = eInput.getInputElement();
      if (this.highlightAllOnFocus) {
        inputEl.select();
      } else {
        (_b = (_a = this.cellEditorInput).setCaret) == null ? void 0 : _b.call(_a);
      }
    }
    // gets called when tabbing through cells and in full row edit mode
    focusIn() {
      const eInput = this.eInput;
      const focusEl = eInput.getFocusableElement();
      const inputEl = eInput.getInputElement();
      focusEl.focus();
      inputEl.select();
    }
    getValue() {
      return this.cellEditorInput.getValue();
    }
    isPopup() {
      return false;
    }
  };
  __decorateClass([
    RefSelector("eInput")
  ], SimpleCellEditor.prototype, "eInput", 2);
  var TextCellEditorInput = class {
    getTemplate() {
      return (
        /* html */
        `<ag-input-text-field class="ag-cell-editor" ref="eInput"></ag-input-text-field>`
      );
    }
    init(eInput, params) {
      this.eInput = eInput;
      this.params = params;
      if (params.maxLength != null) {
        eInput.setMaxLength(params.maxLength);
      }
    }
    getValue() {
      const value = this.eInput.getValue();
      if (!exists(value) && !exists(this.params.value)) {
        return this.params.value;
      }
      return this.params.parseValue(value);
    }
    getStartValue() {
      const formatValue = this.params.useFormatter || this.params.column.getColDef().refData;
      return formatValue ? this.params.formatValue(this.params.value) : this.params.value;
    }
    setCaret() {
      const value = this.eInput.getValue();
      const len = exists(value) && value.length || 0;
      if (len) {
        this.eInput.getInputElement().setSelectionRange(len, len);
      }
    }
  };
  var TextCellEditor = class extends SimpleCellEditor {
    constructor() {
      super(new TextCellEditorInput());
    }
  };
  var ARROW_UP = "\u2191";
  var ARROW_DOWN = "\u2193";
  var AnimateShowChangeCellRenderer = class extends Component {
    constructor() {
      super();
      this.refreshCount = 0;
      const template = document.createElement("span");
      const delta = document.createElement("span");
      delta.setAttribute("class", "ag-value-change-delta");
      const value = document.createElement("span");
      value.setAttribute("class", "ag-value-change-value");
      template.appendChild(delta);
      template.appendChild(value);
      this.setTemplateFromElement(template);
    }
    init(params) {
      this.eValue = this.queryForHtmlElement(".ag-value-change-value");
      this.eDelta = this.queryForHtmlElement(".ag-value-change-delta");
      this.refresh(params, true);
    }
    showDelta(params, delta) {
      const absDelta = Math.abs(delta);
      const valueFormatted = params.formatValue(absDelta);
      const valueToUse = exists(valueFormatted) ? valueFormatted : absDelta;
      const deltaUp = delta >= 0;
      if (deltaUp) {
        this.eDelta.textContent = ARROW_UP + valueToUse;
      } else {
        this.eDelta.textContent = ARROW_DOWN + valueToUse;
      }
      this.eDelta.classList.toggle("ag-value-change-delta-up", deltaUp);
      this.eDelta.classList.toggle("ag-value-change-delta-down", !deltaUp);
    }
    setTimerToRemoveDelta() {
      this.refreshCount++;
      const refreshCountCopy = this.refreshCount;
      this.getFrameworkOverrides().wrapIncoming(() => {
        window.setTimeout(() => {
          if (refreshCountCopy === this.refreshCount) {
            this.hideDeltaValue();
          }
        }, 2e3);
      });
    }
    hideDeltaValue() {
      this.eValue.classList.remove("ag-value-change-value-highlight");
      clearElement(this.eDelta);
    }
    refresh(params, isInitialRender = false) {
      const value = params.value;
      if (value === this.lastValue) {
        return false;
      }
      if (exists(params.valueFormatted)) {
        this.eValue.textContent = params.valueFormatted;
      } else if (exists(params.value)) {
        this.eValue.textContent = value;
      } else {
        clearElement(this.eValue);
      }
      if (this.filterManager.isSuppressFlashingCellsBecauseFiltering()) {
        return false;
      }
      if (typeof value === "number" && typeof this.lastValue === "number") {
        const delta = value - this.lastValue;
        this.showDelta(params, delta);
      }
      if (this.lastValue) {
        this.eValue.classList.add("ag-value-change-value-highlight");
      }
      if (!isInitialRender) {
        this.setTimerToRemoveDelta();
      }
      this.lastValue = value;
      return true;
    }
  };
  __decorateClass([
    Autowired("filterManager")
  ], AnimateShowChangeCellRenderer.prototype, "filterManager", 2);
  var AnimateSlideCellRenderer = class extends Component {
    constructor() {
      super();
      this.refreshCount = 0;
      const template = document.createElement("span");
      const slide = document.createElement("span");
      slide.setAttribute("class", "ag-value-slide-current");
      template.appendChild(slide);
      this.setTemplateFromElement(template);
      this.eCurrent = this.queryForHtmlElement(".ag-value-slide-current");
    }
    init(params) {
      this.refresh(params, true);
    }
    addSlideAnimation() {
      this.refreshCount++;
      const refreshCountCopy = this.refreshCount;
      if (this.ePrevious) {
        this.getGui().removeChild(this.ePrevious);
      }
      const prevElement = document.createElement("span");
      prevElement.setAttribute("class", "ag-value-slide-previous ag-value-slide-out");
      this.ePrevious = prevElement;
      this.ePrevious.textContent = this.eCurrent.textContent;
      this.getGui().insertBefore(this.ePrevious, this.eCurrent);
      this.getFrameworkOverrides().wrapIncoming(() => {
        window.setTimeout(() => {
          if (refreshCountCopy !== this.refreshCount) {
            return;
          }
          this.ePrevious.classList.add("ag-value-slide-out-end");
        }, 50);
        window.setTimeout(() => {
          if (refreshCountCopy !== this.refreshCount) {
            return;
          }
          this.getGui().removeChild(this.ePrevious);
          this.ePrevious = null;
        }, 3e3);
      });
    }
    refresh(params, isInitialRender = false) {
      let value = params.value;
      if (missing(value)) {
        value = "";
      }
      if (value === this.lastValue) {
        return false;
      }
      if (this.filterManager.isSuppressFlashingCellsBecauseFiltering()) {
        return false;
      }
      if (!isInitialRender) {
        this.addSlideAnimation();
      }
      this.lastValue = value;
      if (exists(params.valueFormatted)) {
        this.eCurrent.textContent = params.valueFormatted;
      } else if (exists(params.value)) {
        this.eCurrent.textContent = value;
      } else {
        clearElement(this.eCurrent);
      }
      return true;
    }
  };
  __decorateClass([
    Autowired("filterManager")
  ], AnimateSlideCellRenderer.prototype, "filterManager", 2);
  var _RowNode = class _RowNode2 {
    constructor(beans) {
      this.rowIndex = null;
      this.key = null;
      this.childrenMapped = {};
      this.displayed = false;
      this.rowTop = null;
      this.oldRowTop = null;
      this.selectable = true;
      this.__objectId = _RowNode2.OBJECT_ID_SEQUENCE++;
      this.__autoHeights = {};
      this.alreadyRendered = false;
      this.highlighted = null;
      this.hovered = false;
      this.selected = false;
      this.beans = beans;
    }
    /**
     * Replaces the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
     */
    setData(data) {
      this.setDataCommon(data, false);
    }
    // similar to setRowData, however it is expected that the data is the same data item. this
    // is intended to be used with Redux type stores, where the whole data can be changed. we are
    // guaranteed that the data is the same entity (so grid doesn't need to worry about the id of the
    // underlying data changing, hence doesn't need to worry about selection). the grid, upon receiving
    // dataChanged event, will refresh the cells rather than rip them all out (so user can show transitions).
    /**
     * Updates the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
     */
    updateData(data) {
      this.setDataCommon(data, true);
    }
    setDataCommon(data, update) {
      const oldData = this.data;
      this.data = data;
      this.beans.valueCache.onDataChanged();
      this.updateDataOnDetailNode();
      this.checkRowSelectable();
      this.resetQuickFilterAggregateText();
      const event = this.createDataChangedEvent(data, oldData, update);
      this.dispatchLocalEvent(event);
    }
    // when we are doing master / detail, the detail node is lazy created, but then kept around.
    // so if we show / hide the detail, the same detail rowNode is used. so we need to keep the data
    // in sync, otherwise expand/collapse of the detail would still show the old values.
    updateDataOnDetailNode() {
      if (this.detailNode) {
        this.detailNode.data = this.data;
      }
    }
    createDataChangedEvent(newData, oldData, update) {
      return {
        type: _RowNode2.EVENT_DATA_CHANGED,
        node: this,
        oldData,
        newData,
        update
      };
    }
    createLocalRowEvent(type) {
      return {
        type,
        node: this
      };
    }
    getRowIndexString() {
      if (this.rowPinned === "top") {
        return "t-" + this.rowIndex;
      }
      if (this.rowPinned === "bottom") {
        return "b-" + this.rowIndex;
      }
      return this.rowIndex.toString();
    }
    createDaemonNode() {
      const oldNode = new _RowNode2(this.beans);
      oldNode.id = this.id;
      oldNode.data = this.data;
      oldNode.__daemon = true;
      oldNode.selected = this.selected;
      oldNode.level = this.level;
      return oldNode;
    }
    setDataAndId(data, id) {
      const oldNode = exists(this.id) ? this.createDaemonNode() : null;
      const oldData = this.data;
      this.data = data;
      this.updateDataOnDetailNode();
      this.setId(id);
      this.checkRowSelectable();
      this.beans.selectionService.syncInRowNode(this, oldNode);
      const event = this.createDataChangedEvent(data, oldData, false);
      this.dispatchLocalEvent(event);
    }
    checkRowSelectable() {
      const isRowSelectableFunc = this.beans.gos.get("isRowSelectable");
      this.setRowSelectable(isRowSelectableFunc ? isRowSelectableFunc(this) : true);
    }
    setRowSelectable(newVal, suppressSelectionUpdate) {
      if (this.selectable !== newVal) {
        this.selectable = newVal;
        if (this.eventService) {
          this.eventService.dispatchEvent(this.createLocalRowEvent(_RowNode2.EVENT_SELECTABLE_CHANGED));
        }
        if (suppressSelectionUpdate) {
          return;
        }
        const isGroupSelectsChildren = this.beans.gos.get("groupSelectsChildren");
        if (isGroupSelectsChildren) {
          const selected = this.calculateSelectedFromChildren();
          this.setSelectedParams({
            newValue: selected != null ? selected : false,
            source: "selectableChanged"
          });
          return;
        }
        if (this.isSelected() && !this.selectable) {
          this.setSelectedParams({
            newValue: false,
            source: "selectableChanged"
          });
        }
      }
    }
    setId(id) {
      const getRowIdFunc = this.beans.gos.getCallback("getRowId");
      if (getRowIdFunc) {
        if (this.data) {
          const parentKeys = this.getGroupKeys(true);
          this.id = getRowIdFunc({
            data: this.data,
            parentKeys: parentKeys.length > 0 ? parentKeys : void 0,
            level: this.level
          });
          if (this.id !== null && typeof this.id === "string" && this.id.startsWith(_RowNode2.ID_PREFIX_ROW_GROUP)) {
            console.error(`AG Grid: Row IDs cannot start with ${_RowNode2.ID_PREFIX_ROW_GROUP}, this is a reserved prefix for AG Grid's row grouping feature.`);
          }
          if (this.id !== null && typeof this.id !== "string") {
            this.id = "" + this.id;
          }
        } else {
          this.id = void 0;
        }
      } else {
        this.id = id;
      }
    }
    getGroupKeys(excludeSelf = false) {
      const keys2 = [];
      let pointer = this;
      if (excludeSelf) {
        pointer = pointer.parent;
      }
      while (pointer && pointer.level >= 0) {
        keys2.push(pointer.key);
        pointer = pointer.parent;
      }
      keys2.reverse();
      return keys2;
    }
    isPixelInRange(pixel) {
      if (!exists(this.rowTop) || !exists(this.rowHeight)) {
        return false;
      }
      return pixel >= this.rowTop && pixel < this.rowTop + this.rowHeight;
    }
    setFirstChild(firstChild) {
      if (this.firstChild === firstChild) {
        return;
      }
      this.firstChild = firstChild;
      if (this.eventService) {
        this.eventService.dispatchEvent(this.createLocalRowEvent(_RowNode2.EVENT_FIRST_CHILD_CHANGED));
      }
    }
    setLastChild(lastChild) {
      if (this.lastChild === lastChild) {
        return;
      }
      this.lastChild = lastChild;
      if (this.eventService) {
        this.eventService.dispatchEvent(this.createLocalRowEvent(_RowNode2.EVENT_LAST_CHILD_CHANGED));
      }
    }
    setChildIndex(childIndex) {
      if (this.childIndex === childIndex) {
        return;
      }
      this.childIndex = childIndex;
      if (this.eventService) {
        this.eventService.dispatchEvent(this.createLocalRowEvent(_RowNode2.EVENT_CHILD_INDEX_CHANGED));
      }
    }
    setRowTop(rowTop) {
      this.oldRowTop = this.rowTop;
      if (this.rowTop === rowTop) {
        return;
      }
      this.rowTop = rowTop;
      if (this.eventService) {
        this.eventService.dispatchEvent(this.createLocalRowEvent(_RowNode2.EVENT_TOP_CHANGED));
      }
      this.setDisplayed(rowTop !== null);
    }
    clearRowTopAndRowIndex() {
      this.oldRowTop = null;
      this.setRowTop(null);
      this.setRowIndex(null);
    }
    setDisplayed(displayed) {
      if (this.displayed === displayed) {
        return;
      }
      this.displayed = displayed;
      if (this.eventService) {
        this.eventService.dispatchEvent(this.createLocalRowEvent(_RowNode2.EVENT_DISPLAYED_CHANGED));
      }
    }
    setDragging(dragging) {
      if (this.dragging === dragging) {
        return;
      }
      this.dragging = dragging;
      if (this.eventService) {
        this.eventService.dispatchEvent(this.createLocalRowEvent(_RowNode2.EVENT_DRAGGING_CHANGED));
      }
    }
    setHighlighted(highlighted) {
      if (highlighted === this.highlighted) {
        return;
      }
      this.highlighted = highlighted;
      if (this.eventService) {
        this.eventService.dispatchEvent(this.createLocalRowEvent(_RowNode2.EVENT_HIGHLIGHT_CHANGED));
      }
    }
    setHovered(hovered) {
      if (this.hovered === hovered) {
        return;
      }
      this.hovered = hovered;
    }
    isHovered() {
      return this.hovered;
    }
    setAllChildrenCount(allChildrenCount) {
      if (this.allChildrenCount === allChildrenCount) {
        return;
      }
      this.allChildrenCount = allChildrenCount;
      if (this.eventService) {
        this.eventService.dispatchEvent(this.createLocalRowEvent(_RowNode2.EVENT_ALL_CHILDREN_COUNT_CHANGED));
      }
    }
    setMaster(master) {
      if (this.master === master) {
        return;
      }
      if (this.master && !master) {
        this.expanded = false;
      }
      this.master = master;
      if (this.eventService) {
        this.eventService.dispatchEvent(this.createLocalRowEvent(_RowNode2.EVENT_MASTER_CHANGED));
      }
    }
    setGroup(group) {
      if (this.group === group) {
        return;
      }
      if (this.group && !group) {
        this.expanded = false;
      }
      this.group = group;
      this.updateHasChildren();
      if (this.eventService) {
        this.eventService.dispatchEvent(this.createLocalRowEvent(_RowNode2.EVENT_GROUP_CHANGED));
      }
    }
    /**
     * Sets the row height.
     * Call if you want to change the height initially assigned to the row.
     * After calling, you must call `api.onRowHeightChanged()` so the grid knows it needs to work out the placement of the rows. */
    setRowHeight(rowHeight, estimated = false) {
      this.rowHeight = rowHeight;
      this.rowHeightEstimated = estimated;
      if (this.eventService) {
        this.eventService.dispatchEvent(this.createLocalRowEvent(_RowNode2.EVENT_HEIGHT_CHANGED));
      }
    }
    setRowAutoHeight(cellHeight, column) {
      if (!this.__autoHeights) {
        this.__autoHeights = {};
      }
      this.__autoHeights[column.getId()] = cellHeight;
      if (cellHeight != null) {
        if (this.checkAutoHeightsDebounced == null) {
          this.checkAutoHeightsDebounced = debounce2(this.checkAutoHeights.bind(this), 1);
        }
        this.checkAutoHeightsDebounced();
      }
    }
    checkAutoHeights() {
      let notAllPresent = false;
      let nonePresent = true;
      let newRowHeight = 0;
      const autoHeights = this.__autoHeights;
      if (autoHeights == null) {
        return;
      }
      const displayedAutoHeightCols = this.beans.columnModel.getAllDisplayedAutoHeightCols();
      displayedAutoHeightCols.forEach((col) => {
        let cellHeight = autoHeights[col.getId()];
        if (cellHeight == null) {
          if (this.beans.columnModel.isColSpanActive()) {
            let activeColsForRow = [];
            switch (col.getPinned()) {
              case "left":
                activeColsForRow = this.beans.columnModel.getDisplayedLeftColumnsForRow(this);
                break;
              case "right":
                activeColsForRow = this.beans.columnModel.getDisplayedRightColumnsForRow(this);
                break;
              case null:
                activeColsForRow = this.beans.columnModel.getViewportCenterColumnsForRow(this);
                break;
            }
            if (activeColsForRow.includes(col)) {
              notAllPresent = true;
              return;
            }
            cellHeight = -1;
          } else {
            notAllPresent = true;
            return;
          }
        } else {
          nonePresent = false;
        }
        if (cellHeight > newRowHeight) {
          newRowHeight = cellHeight;
        }
      });
      if (notAllPresent) {
        return;
      }
      if (nonePresent || newRowHeight < 10) {
        newRowHeight = this.beans.gos.getRowHeightForNode(this).height;
      }
      if (newRowHeight == this.rowHeight) {
        return;
      }
      this.setRowHeight(newRowHeight);
      const rowModel = this.beans.rowModel;
      if (rowModel.onRowHeightChangedDebounced) {
        rowModel.onRowHeightChangedDebounced();
      }
    }
    setRowIndex(rowIndex) {
      if (this.rowIndex === rowIndex) {
        return;
      }
      this.rowIndex = rowIndex;
      if (this.eventService) {
        this.eventService.dispatchEvent(this.createLocalRowEvent(_RowNode2.EVENT_ROW_INDEX_CHANGED));
      }
    }
    setUiLevel(uiLevel) {
      if (this.uiLevel === uiLevel) {
        return;
      }
      this.uiLevel = uiLevel;
      if (this.eventService) {
        this.eventService.dispatchEvent(this.createLocalRowEvent(_RowNode2.EVENT_UI_LEVEL_CHANGED));
      }
    }
    /**
     * Set the expanded state of this rowNode. Pass `true` to expand and `false` to collapse.
     */
    setExpanded(expanded, e, forceSync) {
      if (this.expanded === expanded) {
        return;
      }
      this.expanded = expanded;
      if (this.eventService) {
        this.eventService.dispatchEvent(this.createLocalRowEvent(_RowNode2.EVENT_EXPANDED_CHANGED));
      }
      const event = Object.assign({}, this.createGlobalRowEvent(Events.EVENT_ROW_GROUP_OPENED), {
        expanded,
        event: e || null
      });
      this.beans.rowNodeEventThrottle.dispatchExpanded(event, forceSync);
      this.beans.rowRenderer.refreshCells({ rowNodes: [this] });
    }
    createGlobalRowEvent(type) {
      return this.beans.gos.addGridCommonParams({
        type,
        node: this,
        data: this.data,
        rowIndex: this.rowIndex,
        rowPinned: this.rowPinned
      });
    }
    dispatchLocalEvent(event) {
      if (this.eventService) {
        this.eventService.dispatchEvent(event);
      }
    }
    /**
     * Replaces the value on the `rowNode` for the specified column. When complete,
     * the grid will refresh the rendered cell on the required row only.
     * **Note**: This method only fires `onCellEditRequest` when the Grid is in **Read Only** mode.
     *
     * @param colKey The column where the value should be updated
     * @param newValue The new value
     * @param eventSource The source of the event
     * @returns `true` if the value was changed, otherwise `false`.
     */
    setDataValue(colKey, newValue, eventSource) {
      const getColumnFromKey = () => {
        var _a;
        if (typeof colKey !== "string") {
          return colKey;
        }
        return (_a = this.beans.columnModel.getGridColumn(colKey)) != null ? _a : this.beans.columnModel.getPrimaryColumn(colKey);
      };
      const column = getColumnFromKey();
      const oldValue = this.getValueFromValueService(column);
      if (this.beans.gos.get("readOnlyEdit")) {
        this.dispatchEventForSaveValueReadOnly(column, oldValue, newValue, eventSource);
        return false;
      }
      const valueChanged = this.beans.valueService.setValue(this, column, newValue, eventSource);
      this.dispatchCellChangedEvent(column, newValue, oldValue);
      this.checkRowSelectable();
      return valueChanged;
    }
    getValueFromValueService(column) {
      var _a, _b;
      const lockedClosedGroup = this.leafGroup && this.beans.columnModel.isPivotMode();
      const isOpenGroup = this.group && this.expanded && !this.footer && !lockedClosedGroup;
      let includeFooter = false;
      const groupIncludeFooterOpt = (_a = this.beans.gos.get("groupTotalRow")) != null ? _a : this.beans.gos.get("groupIncludeFooter");
      if (typeof groupIncludeFooterOpt !== "function") {
        includeFooter = !!groupIncludeFooterOpt;
      } else {
        const groupIncludeFooterCb = (_b = this.beans.gos.getCallback("groupTotalRow")) != null ? _b : this.beans.gos.getCallback("groupIncludeFooter");
        includeFooter = !!groupIncludeFooterCb({ node: this });
      }
      const groupAlwaysShowAggData = this.beans.gos.get("groupSuppressBlankHeader");
      const ignoreAggData = isOpenGroup && includeFooter && !groupAlwaysShowAggData;
      const value = this.beans.valueService.getValue(column, this, false, ignoreAggData);
      return value;
    }
    dispatchEventForSaveValueReadOnly(column, oldValue, newValue, eventSource) {
      const event = this.beans.gos.addGridCommonParams({
        type: Events.EVENT_CELL_EDIT_REQUEST,
        event: null,
        rowIndex: this.rowIndex,
        rowPinned: this.rowPinned,
        column,
        colDef: column.getColDef(),
        data: this.data,
        node: this,
        oldValue,
        newValue,
        value: newValue,
        source: eventSource
      });
      this.beans.eventService.dispatchEvent(event);
    }
    setGroupValue(colKey, newValue) {
      const column = this.beans.columnModel.getGridColumn(colKey);
      if (missing(this.groupData)) {
        this.groupData = {};
      }
      const columnId = column.getColId();
      const oldValue = this.groupData[columnId];
      if (oldValue === newValue) {
        return;
      }
      this.groupData[columnId] = newValue;
      this.dispatchCellChangedEvent(column, newValue, oldValue);
    }
    // sets the data for an aggregation
    setAggData(newAggData) {
      const oldAggData = this.aggData;
      this.aggData = newAggData;
      if (this.eventService) {
        const eventFunc = (colId) => {
          const value = this.aggData ? this.aggData[colId] : void 0;
          const oldValue = oldAggData ? oldAggData[colId] : void 0;
          if (value === oldValue) {
            return;
          }
          const column = this.beans.columnModel.lookupGridColumn(colId);
          if (!column) {
            return;
          }
          this.dispatchCellChangedEvent(column, value, oldValue);
        };
        for (const key in this.aggData) {
          eventFunc(key);
        }
        for (const key in newAggData) {
          if (key in this.aggData) {
            continue;
          }
          eventFunc(key);
        }
      }
    }
    updateHasChildren() {
      let newValue = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
      const isSsrm = this.beans.gos.isRowModelType("serverSide");
      if (isSsrm) {
        const isTreeData = this.beans.gos.get("treeData");
        const isGroupFunc = this.beans.gos.get("isServerSideGroup");
        newValue = !this.stub && !this.footer && (isTreeData ? !!isGroupFunc && isGroupFunc(this.data) : !!this.group);
      }
      if (newValue !== this.__hasChildren) {
        this.__hasChildren = !!newValue;
        if (this.eventService) {
          this.eventService.dispatchEvent(this.createLocalRowEvent(_RowNode2.EVENT_HAS_CHILDREN_CHANGED));
        }
      }
    }
    hasChildren() {
      if (this.__hasChildren == null) {
        this.updateHasChildren();
      }
      return this.__hasChildren;
    }
    isEmptyRowGroupNode() {
      return this.group && missingOrEmpty(this.childrenAfterGroup);
    }
    dispatchCellChangedEvent(column, newValue, oldValue) {
      const cellChangedEvent = {
        type: _RowNode2.EVENT_CELL_CHANGED,
        node: this,
        column,
        newValue,
        oldValue
      };
      this.dispatchLocalEvent(cellChangedEvent);
    }
    /**
     * The first time `quickFilter` runs, the grid creates a one-off string representation of the row.
     * This string is then used for the quick filter instead of hitting each column separately.
     * When you edit, using grid editing, this string gets cleared down.
     * However if you edit without using grid editing, you will need to clear this string down for the row to be updated with the new values.
     * Otherwise new values will not work with the `quickFilter`. */
    resetQuickFilterAggregateText() {
      this.quickFilterAggregateText = null;
    }
    /** Returns:
    * - `true` if the node can be expanded, i.e it is a group or master row.
    * - `false` if the node cannot be expanded
    */
    isExpandable() {
      if (this.footer) {
        return false;
      }
      if (this.beans.columnModel.isPivotMode()) {
        return this.hasChildren() && !this.leafGroup;
      }
      return this.hasChildren() || !!this.master;
    }
    /** Returns:
     * - `true` if node is selected,
     * - `false` if the node isn't selected
     * - `undefined` if it's partially selected (group where not all children are selected). */
    isSelected() {
      if (this.footer) {
        return this.sibling.isSelected();
      }
      return this.selected;
    }
    /** Perform a depth-first search of this node and its children. */
    depthFirstSearch(callback) {
      if (this.childrenAfterGroup) {
        this.childrenAfterGroup.forEach((child) => child.depthFirstSearch(callback));
      }
      callback(this);
    }
    // + selectionController.calculatedSelectedForAllGroupNodes()
    calculateSelectedFromChildren() {
      var _a;
      let atLeastOneSelected = false;
      let atLeastOneDeSelected = false;
      let atLeastOneMixed = false;
      if (!((_a = this.childrenAfterGroup) == null ? void 0 : _a.length)) {
        return this.selectable ? this.selected : null;
      }
      for (let i = 0; i < this.childrenAfterGroup.length; i++) {
        const child = this.childrenAfterGroup[i];
        let childState = child.isSelected();
        if (!child.selectable) {
          const selectable = child.calculateSelectedFromChildren();
          if (selectable === null) {
            continue;
          }
          childState = selectable;
        }
        switch (childState) {
          case true:
            atLeastOneSelected = true;
            break;
          case false:
            atLeastOneDeSelected = true;
            break;
          default:
            atLeastOneMixed = true;
            break;
        }
      }
      if (atLeastOneMixed || atLeastOneSelected && atLeastOneDeSelected) {
        return void 0;
      }
      if (atLeastOneSelected) {
        return true;
      }
      if (atLeastOneDeSelected) {
        return false;
      }
      if (!this.selectable) {
        return null;
      }
      return this.selected;
    }
    setSelectedInitialValue(selected) {
      this.selected = selected;
    }
    selectThisNode(newValue, e, source = "api") {
      const selectionNotAllowed = !this.selectable && newValue;
      const selectionNotChanged = this.selected === newValue;
      if (selectionNotAllowed || selectionNotChanged) {
        return false;
      }
      this.selected = newValue;
      if (this.eventService) {
        this.dispatchLocalEvent(this.createLocalRowEvent(_RowNode2.EVENT_ROW_SELECTED));
      }
      const sibling = this.sibling;
      if (sibling && sibling.footer && sibling.eventService) {
        sibling.dispatchLocalEvent(sibling.createLocalRowEvent(_RowNode2.EVENT_ROW_SELECTED));
      }
      const event = __spreadProps(__spreadValues({}, this.createGlobalRowEvent(Events.EVENT_ROW_SELECTED)), {
        event: e || null,
        source
      });
      this.beans.eventService.dispatchEvent(event);
      return true;
    }
    /**
     * Select (or deselect) the node.
     * @param newValue -`true` for selection, `false` for deselection.
     * @param clearSelection - If selecting, then passing `true` will select the node exclusively (i.e. NOT do multi select). If doing deselection, `clearSelection` has no impact.
     * @param source - Source property that will appear in the `selectionChanged` event.
     */
    setSelected(newValue, clearSelection = false, source = "api") {
      if (typeof source === "boolean") {
        console.warn("AG Grid: since version v30, rowNode.setSelected() property `suppressFinishActions` has been removed, please use `gridApi.setNodesSelected()` for bulk actions, and the event `source` property for ignoring events instead.");
        return;
      }
      this.setSelectedParams({
        newValue,
        clearSelection,
        rangeSelect: false,
        source
      });
    }
    // this is for internal use only. To make calling code more readable, this is the same method as setSelected except it takes names parameters
    setSelectedParams(params) {
      if (this.rowPinned) {
        console.warn("AG Grid: cannot select pinned rows");
        return 0;
      }
      if (this.id === void 0) {
        console.warn("AG Grid: cannot select node until id for node is known");
        return 0;
      }
      return this.beans.selectionService.setNodesSelected(__spreadProps(__spreadValues({}, params), { nodes: [this.footer ? this.sibling : this] }));
    }
    /**
     * Returns:
     * - `true` if node is either pinned to the `top` or `bottom`
     * - `false` if the node isn't pinned
     */
    isRowPinned() {
      return this.rowPinned === "top" || this.rowPinned === "bottom";
    }
    isParentOfNode(potentialParent) {
      let parentNode = this.parent;
      while (parentNode) {
        if (parentNode === potentialParent) {
          return true;
        }
        parentNode = parentNode.parent;
      }
      return false;
    }
    /** Add an event listener. */
    addEventListener(eventType, userListener) {
      var _a, _b;
      if (!this.eventService) {
        this.eventService = new EventService();
      }
      if (this.beans.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService) {
        this.eventService.setFrameworkOverrides(this.beans.frameworkOverrides);
        this.frameworkEventListenerService = new FrameworkEventListenerService(this.beans.frameworkOverrides);
      }
      const listener = (_b = (_a = this.frameworkEventListenerService) == null ? void 0 : _a.wrap(userListener)) != null ? _b : userListener;
      this.eventService.addEventListener(eventType, listener);
    }
    /** Remove event listener. */
    removeEventListener(eventType, userListener) {
      var _a, _b;
      if (!this.eventService) {
        return;
      }
      const listener = (_b = (_a = this.frameworkEventListenerService) == null ? void 0 : _a.unwrap(userListener)) != null ? _b : userListener;
      this.eventService.removeEventListener(eventType, listener);
      if (this.eventService.noRegisteredListenersExist()) {
        this.eventService = null;
      }
    }
    onMouseEnter() {
      this.dispatchLocalEvent(this.createLocalRowEvent(_RowNode2.EVENT_MOUSE_ENTER));
    }
    onMouseLeave() {
      this.dispatchLocalEvent(this.createLocalRowEvent(_RowNode2.EVENT_MOUSE_LEAVE));
    }
    getFirstChildOfFirstChild(rowGroupColumn) {
      let currentRowNode = this;
      let isCandidate = true;
      let foundFirstChildPath = false;
      let nodeToSwapIn = null;
      while (isCandidate && !foundFirstChildPath) {
        const parentRowNode = currentRowNode.parent;
        const firstChild = exists(parentRowNode) && currentRowNode.firstChild;
        if (firstChild) {
          if (parentRowNode.rowGroupColumn === rowGroupColumn) {
            foundFirstChildPath = true;
            nodeToSwapIn = parentRowNode;
          }
        } else {
          isCandidate = false;
        }
        currentRowNode = parentRowNode;
      }
      return foundFirstChildPath ? nodeToSwapIn : null;
    }
    /**
     * Returns:
     * - `true` if the node is a full width cell
     * - `false` if the node is not a full width cell
     */
    isFullWidthCell() {
      if (this.detail) {
        return true;
      }
      const isFullWidthCellFunc = this.beans.gos.getCallback("isFullWidthRow");
      return isFullWidthCellFunc ? isFullWidthCellFunc({ rowNode: this }) : false;
    }
    /**
     * Returns the route of the row node. If the Row Node is a group, it returns the route to that Row Node.
     * If the Row Node is not a group, it returns `undefined`.
     */
    getRoute() {
      if (this.key == null) {
        return;
      }
      const res = [];
      let pointer = this;
      while (pointer.key != null) {
        res.push(pointer.key);
        pointer = pointer.parent;
      }
      return res.reverse();
    }
    createFooter() {
      if (this.sibling) {
        return;
      }
      const ignoredProperties = /* @__PURE__ */ new Set([
        "eventService",
        "__objectId",
        "sticky"
      ]);
      const footerNode = new _RowNode2(this.beans);
      Object.keys(this).forEach((key) => {
        if (ignoredProperties.has(key)) {
          return;
        }
        footerNode[key] = this[key];
      });
      footerNode.footer = true;
      footerNode.setRowTop(null);
      footerNode.setRowIndex(null);
      footerNode.oldRowTop = null;
      footerNode.id = "rowGroupFooter_" + this.id;
      footerNode.sibling = this;
      this.sibling = footerNode;
    }
    // Only used by SSRM. In CSRM this is never used as footers should always be present for
    // the purpose of exporting collapsed groups. In SSRM it is not possible to export collapsed
    // groups anyway, so can destroy footers.
    destroyFooter() {
      if (!this.sibling) {
        return;
      }
      this.sibling.setRowTop(null);
      this.sibling.setRowIndex(null);
      this.sibling = void 0;
    }
  };
  _RowNode.ID_PREFIX_ROW_GROUP = "row-group-";
  _RowNode.ID_PREFIX_TOP_PINNED = "t-";
  _RowNode.ID_PREFIX_BOTTOM_PINNED = "b-";
  _RowNode.OBJECT_ID_SEQUENCE = 0;
  _RowNode.EVENT_ROW_SELECTED = "rowSelected";
  _RowNode.EVENT_DATA_CHANGED = "dataChanged";
  _RowNode.EVENT_CELL_CHANGED = "cellChanged";
  _RowNode.EVENT_ALL_CHILDREN_COUNT_CHANGED = "allChildrenCountChanged";
  _RowNode.EVENT_MASTER_CHANGED = "masterChanged";
  _RowNode.EVENT_GROUP_CHANGED = "groupChanged";
  _RowNode.EVENT_MOUSE_ENTER = "mouseEnter";
  _RowNode.EVENT_MOUSE_LEAVE = "mouseLeave";
  _RowNode.EVENT_HEIGHT_CHANGED = "heightChanged";
  _RowNode.EVENT_TOP_CHANGED = "topChanged";
  _RowNode.EVENT_DISPLAYED_CHANGED = "displayedChanged";
  _RowNode.EVENT_FIRST_CHILD_CHANGED = "firstChildChanged";
  _RowNode.EVENT_LAST_CHILD_CHANGED = "lastChildChanged";
  _RowNode.EVENT_CHILD_INDEX_CHANGED = "childIndexChanged";
  _RowNode.EVENT_ROW_INDEX_CHANGED = "rowIndexChanged";
  _RowNode.EVENT_EXPANDED_CHANGED = "expandedChanged";
  _RowNode.EVENT_HAS_CHILDREN_CHANGED = "hasChildrenChanged";
  _RowNode.EVENT_SELECTABLE_CHANGED = "selectableChanged";
  _RowNode.EVENT_UI_LEVEL_CHANGED = "uiLevelChanged";
  _RowNode.EVENT_HIGHLIGHT_CHANGED = "rowHighlightChanged";
  _RowNode.EVENT_DRAGGING_CHANGED = "draggingChanged";
  var RowNode = _RowNode;
  var CheckboxSelectionComponent = class extends Component {
    constructor() {
      super(
        /* html*/
        `
            <div class="ag-selection-checkbox" role="presentation">
                <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>
            </div>`
      );
    }
    postConstruct() {
      this.eCheckbox.setPassive(true);
    }
    getCheckboxId() {
      return this.eCheckbox.getInputElement().id;
    }
    onDataChanged() {
      this.onSelectionChanged();
    }
    onSelectableChanged() {
      this.showOrHideSelect();
    }
    onSelectionChanged() {
      const translate = this.localeService.getLocaleTextFunc();
      const state = this.rowNode.isSelected();
      const stateName = getAriaCheckboxStateName(translate, state);
      const [ariaKey, ariaLabel] = this.rowNode.selectable ? ["ariaRowToggleSelection", "Press Space to toggle row selection"] : ["ariaRowSelectionDisabled", "Row Selection is disabled for this row"];
      const translatedLabel = translate(ariaKey, ariaLabel);
      this.eCheckbox.setValue(state, true);
      this.eCheckbox.setInputAriaLabel(`${translatedLabel} (${stateName})`);
    }
    onClicked(newValue, groupSelectsFiltered, event) {
      return this.rowNode.setSelectedParams({ newValue, rangeSelect: event.shiftKey, groupSelectsFiltered, event, source: "checkboxSelected" });
    }
    init(params) {
      this.rowNode = params.rowNode;
      this.column = params.column;
      this.overrides = params.overrides;
      this.onSelectionChanged();
      this.addManagedListener(this.eCheckbox.getInputElement(), "dblclick", (event) => {
        stopPropagationForAgGrid(event);
      });
      this.addManagedListener(this.eCheckbox.getInputElement(), "click", (event) => {
        stopPropagationForAgGrid(event);
        const groupSelectsFiltered = this.gos.get("groupSelectsFiltered");
        const isSelected = this.eCheckbox.getValue();
        if (this.shouldHandleIndeterminateState(isSelected, groupSelectsFiltered)) {
          const result = this.onClicked(true, groupSelectsFiltered, event || {});
          if (result === 0) {
            this.onClicked(false, groupSelectsFiltered, event);
          }
        } else if (isSelected) {
          this.onClicked(false, groupSelectsFiltered, event);
        } else {
          this.onClicked(true, groupSelectsFiltered, event || {});
        }
      });
      this.addManagedListener(this.rowNode, RowNode.EVENT_ROW_SELECTED, this.onSelectionChanged.bind(this));
      this.addManagedListener(this.rowNode, RowNode.EVENT_DATA_CHANGED, this.onDataChanged.bind(this));
      this.addManagedListener(this.rowNode, RowNode.EVENT_SELECTABLE_CHANGED, this.onSelectableChanged.bind(this));
      const isRowSelectableFunc = this.gos.get("isRowSelectable");
      const checkboxVisibleIsDynamic = isRowSelectableFunc || typeof this.getIsVisible() === "function";
      if (checkboxVisibleIsDynamic) {
        const showOrHideSelectListener = this.showOrHideSelect.bind(this);
        this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, showOrHideSelectListener);
        this.addManagedListener(this.rowNode, RowNode.EVENT_DATA_CHANGED, showOrHideSelectListener);
        this.addManagedListener(this.rowNode, RowNode.EVENT_CELL_CHANGED, showOrHideSelectListener);
        this.showOrHideSelect();
      }
      this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
    }
    shouldHandleIndeterminateState(isSelected, groupSelectsFiltered) {
      return groupSelectsFiltered && (this.eCheckbox.getPreviousValue() === void 0 || isSelected === void 0) && this.gos.isRowModelType("clientSide");
    }
    showOrHideSelect() {
      var _a, _b, _c;
      let selectable = this.rowNode.selectable;
      const isVisible2 = this.getIsVisible();
      if (selectable) {
        if (typeof isVisible2 === "function") {
          const extraParams = (_a = this.overrides) == null ? void 0 : _a.callbackParams;
          if (!this.column) {
            selectable = isVisible2(__spreadProps(__spreadValues({}, extraParams), { node: this.rowNode, data: this.rowNode.data }));
          } else {
            const params = this.column.createColumnFunctionCallbackParams(this.rowNode);
            selectable = isVisible2(__spreadValues(__spreadValues({}, extraParams), params));
          }
        } else {
          selectable = isVisible2 != null ? isVisible2 : false;
        }
      }
      const disableInsteadOfHide = (_b = this.column) == null ? void 0 : _b.getColDef().showDisabledCheckboxes;
      if (disableInsteadOfHide) {
        this.eCheckbox.setDisabled(!selectable);
        this.setVisible(true);
        this.setDisplayed(true);
        return;
      }
      if ((_c = this.overrides) == null ? void 0 : _c.removeHidden) {
        this.setDisplayed(selectable);
        return;
      }
      this.setVisible(selectable);
    }
    getIsVisible() {
      var _a, _b;
      if (this.overrides) {
        return this.overrides.isVisible;
      }
      return (_b = (_a = this.column) == null ? void 0 : _a.getColDef()) == null ? void 0 : _b.checkboxSelection;
    }
  };
  __decorateClass([
    RefSelector("eCheckbox")
  ], CheckboxSelectionComponent.prototype, "eCheckbox", 2);
  __decorateClass([
    PostConstruct
  ], CheckboxSelectionComponent.prototype, "postConstruct", 1);
  var VerticalDirection = /* @__PURE__ */ ((VerticalDirection2) => {
    VerticalDirection2[VerticalDirection2["Up"] = 0] = "Up";
    VerticalDirection2[VerticalDirection2["Down"] = 1] = "Down";
    return VerticalDirection2;
  })(VerticalDirection || {});
  var HorizontalDirection = /* @__PURE__ */ ((HorizontalDirection2) => {
    HorizontalDirection2[HorizontalDirection2["Left"] = 0] = "Left";
    HorizontalDirection2[HorizontalDirection2["Right"] = 1] = "Right";
    return HorizontalDirection2;
  })(HorizontalDirection || {});
  var DragSourceType = /* @__PURE__ */ ((DragSourceType4) => {
    DragSourceType4[DragSourceType4["ToolPanel"] = 0] = "ToolPanel";
    DragSourceType4[DragSourceType4["HeaderCell"] = 1] = "HeaderCell";
    DragSourceType4[DragSourceType4["RowDrag"] = 2] = "RowDrag";
    DragSourceType4[DragSourceType4["ChartPanel"] = 3] = "ChartPanel";
    DragSourceType4[DragSourceType4["AdvancedFilterBuilder"] = 4] = "AdvancedFilterBuilder";
    return DragSourceType4;
  })(DragSourceType || {});
  var DragAndDropService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.dragSourceAndParamsList = [];
      this.dropTargets = [];
    }
    init() {
      this.ePinnedIcon = createIcon("columnMovePin", this.gos, null);
      this.eHideIcon = createIcon("columnMoveHide", this.gos, null);
      this.eMoveIcon = createIcon("columnMoveMove", this.gos, null);
      this.eLeftIcon = createIcon("columnMoveLeft", this.gos, null);
      this.eRightIcon = createIcon("columnMoveRight", this.gos, null);
      this.eGroupIcon = createIcon("columnMoveGroup", this.gos, null);
      this.eAggregateIcon = createIcon("columnMoveValue", this.gos, null);
      this.ePivotIcon = createIcon("columnMovePivot", this.gos, null);
      this.eDropNotAllowedIcon = createIcon("dropNotAllowed", this.gos, null);
    }
    addDragSource(dragSource, allowTouch = false) {
      const params = {
        eElement: dragSource.eElement,
        dragStartPixels: dragSource.dragStartPixels,
        onDragStart: this.onDragStart.bind(this, dragSource),
        onDragStop: this.onDragStop.bind(this),
        onDragging: this.onDragging.bind(this),
        includeTouch: allowTouch
      };
      this.dragSourceAndParamsList.push({ params, dragSource });
      this.dragService.addDragSource(params);
    }
    removeDragSource(dragSource) {
      const sourceAndParams = this.dragSourceAndParamsList.find((item) => item.dragSource === dragSource);
      if (sourceAndParams) {
        this.dragService.removeDragSource(sourceAndParams.params);
        removeFromArray(this.dragSourceAndParamsList, sourceAndParams);
      }
    }
    clearDragSourceParamsList() {
      this.dragSourceAndParamsList.forEach((sourceAndParams) => this.dragService.removeDragSource(sourceAndParams.params));
      this.dragSourceAndParamsList.length = 0;
      this.dropTargets.length = 0;
    }
    nudge() {
      if (this.dragging) {
        this.onDragging(this.eventLastTime, true);
      }
    }
    onDragStart(dragSource, mouseEvent) {
      this.dragging = true;
      this.dragSource = dragSource;
      this.eventLastTime = mouseEvent;
      this.dragItem = this.dragSource.getDragItem();
      this.lastDropTarget = void 0;
      if (this.dragSource.onDragStarted) {
        this.dragSource.onDragStarted();
      }
      this.createGhost();
    }
    onDragStop(mouseEvent) {
      this.eventLastTime = null;
      this.dragging = false;
      if (this.dragSource.onDragStopped) {
        this.dragSource.onDragStopped();
      }
      if (this.lastDropTarget && this.lastDropTarget.onDragStop) {
        const draggingEvent = this.createDropTargetEvent(this.lastDropTarget, mouseEvent, null, null, false);
        this.lastDropTarget.onDragStop(draggingEvent);
      }
      this.lastDropTarget = null;
      this.dragItem = null;
      this.removeGhost();
    }
    onDragging(mouseEvent, fromNudge) {
      var _a, _b, _c, _d;
      const hDirection = this.getHorizontalDirection(mouseEvent);
      const vDirection = this.getVerticalDirection(mouseEvent);
      this.eventLastTime = mouseEvent;
      this.positionGhost(mouseEvent);
      const validDropTargets = this.dropTargets.filter((target) => this.isMouseOnDropTarget(mouseEvent, target));
      const dropTarget = this.findCurrentDropTarget(mouseEvent, validDropTargets);
      if (dropTarget !== this.lastDropTarget) {
        this.leaveLastTargetIfExists(mouseEvent, hDirection, vDirection, fromNudge);
        if (this.lastDropTarget !== null && dropTarget === null) {
          (_b = (_a = this.dragSource).onGridExit) == null ? void 0 : _b.call(_a, this.dragItem);
        }
        if (this.lastDropTarget === null && dropTarget !== null) {
          (_d = (_c = this.dragSource).onGridEnter) == null ? void 0 : _d.call(_c, this.dragItem);
        }
        this.enterDragTargetIfExists(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
        this.lastDropTarget = dropTarget;
      } else if (dropTarget && dropTarget.onDragging) {
        const draggingEvent = this.createDropTargetEvent(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
        dropTarget.onDragging(draggingEvent);
      }
    }
    getAllContainersFromDropTarget(dropTarget) {
      const secondaryContainers = dropTarget.getSecondaryContainers ? dropTarget.getSecondaryContainers() : null;
      const containers = [[dropTarget.getContainer()]];
      return secondaryContainers ? containers.concat(secondaryContainers) : containers;
    }
    allContainersIntersect(mouseEvent, containers) {
      for (const container of containers) {
        const rect = container.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) {
          return false;
        }
        const horizontalFit = mouseEvent.clientX >= rect.left && mouseEvent.clientX < rect.right;
        const verticalFit = mouseEvent.clientY >= rect.top && mouseEvent.clientY < rect.bottom;
        if (!horizontalFit || !verticalFit) {
          return false;
        }
      }
      return true;
    }
    // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
    isMouseOnDropTarget(mouseEvent, dropTarget) {
      const allContainersFromDropTarget = this.getAllContainersFromDropTarget(dropTarget);
      let mouseOverTarget = false;
      for (const currentContainers of allContainersFromDropTarget) {
        if (this.allContainersIntersect(mouseEvent, currentContainers)) {
          mouseOverTarget = true;
          break;
        }
      }
      if (dropTarget.targetContainsSource && !dropTarget.getContainer().contains(this.dragSource.eElement)) {
        return false;
      }
      return mouseOverTarget && dropTarget.isInterestedIn(this.dragSource.type, this.dragSource.eElement);
    }
    findCurrentDropTarget(mouseEvent, validDropTargets) {
      const len = validDropTargets.length;
      if (len === 0) {
        return null;
      }
      if (len === 1) {
        return validDropTargets[0];
      }
      const rootNode = this.gos.getRootNode();
      const elementStack = rootNode.elementsFromPoint(mouseEvent.clientX, mouseEvent.clientY);
      for (const el of elementStack) {
        for (const dropTarget of validDropTargets) {
          const containers = flatten(this.getAllContainersFromDropTarget(dropTarget));
          if (containers.indexOf(el) !== -1) {
            return dropTarget;
          }
        }
      }
      return null;
    }
    enterDragTargetIfExists(dropTarget, mouseEvent, hDirection, vDirection, fromNudge) {
      if (!dropTarget) {
        return;
      }
      if (dropTarget.onDragEnter) {
        const dragEnterEvent = this.createDropTargetEvent(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
        dropTarget.onDragEnter(dragEnterEvent);
      }
      this.setGhostIcon(dropTarget.getIconName ? dropTarget.getIconName() : null);
    }
    leaveLastTargetIfExists(mouseEvent, hDirection, vDirection, fromNudge) {
      if (!this.lastDropTarget) {
        return;
      }
      if (this.lastDropTarget.onDragLeave) {
        const dragLeaveEvent = this.createDropTargetEvent(this.lastDropTarget, mouseEvent, hDirection, vDirection, fromNudge);
        this.lastDropTarget.onDragLeave(dragLeaveEvent);
      }
      this.setGhostIcon(null);
    }
    addDropTarget(dropTarget) {
      this.dropTargets.push(dropTarget);
    }
    removeDropTarget(dropTarget) {
      this.dropTargets = this.dropTargets.filter((target) => target.getContainer() !== dropTarget.getContainer());
    }
    hasExternalDropZones() {
      return this.dropTargets.some((zones) => zones.external);
    }
    findExternalZone(params) {
      const externalTargets = this.dropTargets.filter((target) => target.external);
      return externalTargets.find((zone) => zone.getContainer() === params.getContainer()) || null;
    }
    getHorizontalDirection(event) {
      const clientX = this.eventLastTime && this.eventLastTime.clientX;
      const eClientX = event.clientX;
      if (clientX === eClientX) {
        return null;
      }
      return clientX > eClientX ? 0 : 1;
    }
    getVerticalDirection(event) {
      const clientY = this.eventLastTime && this.eventLastTime.clientY;
      const eClientY = event.clientY;
      if (clientY === eClientY) {
        return null;
      }
      return clientY > eClientY ? 0 : 1;
    }
    createDropTargetEvent(dropTarget, event, hDirection, vDirection, fromNudge) {
      const dropZoneTarget = dropTarget.getContainer();
      const rect = dropZoneTarget.getBoundingClientRect();
      const { gridApi: api, columnApi, dragItem, dragSource } = this;
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      return { event, x, y, vDirection, hDirection, dragSource, fromNudge, dragItem, api, columnApi, dropZoneTarget };
    }
    positionGhost(event) {
      const ghost = this.eGhost;
      if (!ghost) {
        return;
      }
      const ghostRect = ghost.getBoundingClientRect();
      const ghostHeight = ghostRect.height;
      const browserWidth = getBodyWidth() - 2;
      const browserHeight = getBodyHeight() - 2;
      const offsetParentSize = getElementRectWithOffset(ghost.offsetParent);
      const { clientY, clientX } = event;
      let top = clientY - offsetParentSize.top - ghostHeight / 2;
      let left = clientX - offsetParentSize.left - 10;
      const eDocument = this.gos.getDocument();
      const win = eDocument.defaultView || window;
      const windowScrollY = win.pageYOffset || eDocument.documentElement.scrollTop;
      const windowScrollX = win.pageXOffset || eDocument.documentElement.scrollLeft;
      if (browserWidth > 0 && left + ghost.clientWidth > browserWidth + windowScrollX) {
        left = browserWidth + windowScrollX - ghost.clientWidth;
      }
      if (left < 0) {
        left = 0;
      }
      if (browserHeight > 0 && top + ghost.clientHeight > browserHeight + windowScrollY) {
        top = browserHeight + windowScrollY - ghost.clientHeight;
      }
      if (top < 0) {
        top = 0;
      }
      ghost.style.left = `${left}px`;
      ghost.style.top = `${top}px`;
    }
    removeGhost() {
      if (this.eGhost && this.eGhostParent) {
        this.eGhostParent.removeChild(this.eGhost);
      }
      this.eGhost = null;
    }
    createGhost() {
      this.eGhost = loadTemplate(DragAndDropService.GHOST_TEMPLATE);
      this.mouseEventService.stampTopLevelGridCompWithGridInstance(this.eGhost);
      const { theme } = this.environment.getTheme();
      if (theme) {
        this.eGhost.classList.add(theme);
      }
      this.eGhostIcon = this.eGhost.querySelector(".ag-dnd-ghost-icon");
      this.setGhostIcon(null);
      const eText = this.eGhost.querySelector(".ag-dnd-ghost-label");
      let dragItemName = this.dragSource.dragItemName;
      if (isFunction(dragItemName)) {
        dragItemName = dragItemName();
      }
      eText.innerHTML = escapeString(dragItemName) || "";
      this.eGhost.style.height = "25px";
      this.eGhost.style.top = "20px";
      this.eGhost.style.left = "20px";
      const eDocument = this.gos.getDocument();
      let rootNode = null;
      let targetEl = null;
      try {
        rootNode = eDocument.fullscreenElement;
      } catch (e) {
      } finally {
        if (!rootNode) {
          rootNode = this.gos.getRootNode();
        }
        const body = rootNode.querySelector("body");
        if (body) {
          targetEl = body;
        } else if (rootNode instanceof ShadowRoot) {
          targetEl = rootNode;
        } else if (rootNode instanceof Document) {
          targetEl = rootNode == null ? void 0 : rootNode.documentElement;
        } else {
          targetEl = rootNode;
        }
      }
      this.eGhostParent = targetEl;
      if (!this.eGhostParent) {
        console.warn("AG Grid: could not find document body, it is needed for dragging columns");
      } else {
        this.eGhostParent.appendChild(this.eGhost);
      }
    }
    setGhostIcon(iconName, shake = false) {
      clearElement(this.eGhostIcon);
      let eIcon = null;
      if (!iconName) {
        iconName = this.dragSource.getDefaultIconName ? this.dragSource.getDefaultIconName() : DragAndDropService.ICON_NOT_ALLOWED;
      }
      switch (iconName) {
        case DragAndDropService.ICON_PINNED:
          eIcon = this.ePinnedIcon;
          break;
        case DragAndDropService.ICON_MOVE:
          eIcon = this.eMoveIcon;
          break;
        case DragAndDropService.ICON_LEFT:
          eIcon = this.eLeftIcon;
          break;
        case DragAndDropService.ICON_RIGHT:
          eIcon = this.eRightIcon;
          break;
        case DragAndDropService.ICON_GROUP:
          eIcon = this.eGroupIcon;
          break;
        case DragAndDropService.ICON_AGGREGATE:
          eIcon = this.eAggregateIcon;
          break;
        case DragAndDropService.ICON_PIVOT:
          eIcon = this.ePivotIcon;
          break;
        case DragAndDropService.ICON_NOT_ALLOWED:
          eIcon = this.eDropNotAllowedIcon;
          break;
        case DragAndDropService.ICON_HIDE:
          eIcon = this.eHideIcon;
          break;
      }
      this.eGhostIcon.classList.toggle("ag-shake-left-to-right", shake);
      if (eIcon === this.eHideIcon && this.gos.get("suppressDragLeaveHidesColumns")) {
        return;
      }
      if (eIcon) {
        this.eGhostIcon.appendChild(eIcon);
      }
    }
  };
  DragAndDropService.ICON_PINNED = "pinned";
  DragAndDropService.ICON_MOVE = "move";
  DragAndDropService.ICON_LEFT = "left";
  DragAndDropService.ICON_RIGHT = "right";
  DragAndDropService.ICON_GROUP = "group";
  DragAndDropService.ICON_AGGREGATE = "aggregate";
  DragAndDropService.ICON_PIVOT = "pivot";
  DragAndDropService.ICON_NOT_ALLOWED = "notAllowed";
  DragAndDropService.ICON_HIDE = "hide";
  DragAndDropService.GHOST_TEMPLATE = /* html */
  `<div class="ag-dnd-ghost ag-unselectable">
            <span class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>
            <div class="ag-dnd-ghost-label"></div>
        </div>`;
  __decorateClass([
    Autowired("dragService")
  ], DragAndDropService.prototype, "dragService", 2);
  __decorateClass([
    Autowired("mouseEventService")
  ], DragAndDropService.prototype, "mouseEventService", 2);
  __decorateClass([
    Autowired("columnApi")
  ], DragAndDropService.prototype, "columnApi", 2);
  __decorateClass([
    Autowired("gridApi")
  ], DragAndDropService.prototype, "gridApi", 2);
  __decorateClass([
    PostConstruct
  ], DragAndDropService.prototype, "init", 1);
  __decorateClass([
    PreDestroy
  ], DragAndDropService.prototype, "clearDragSourceParamsList", 1);
  DragAndDropService = __decorateClass([
    Bean("dragAndDropService")
  ], DragAndDropService);
  var RowDragComp = class extends Component {
    constructor(cellValueFn, rowNode, column, customGui, dragStartPixels, suppressVisibilityChange) {
      super();
      this.cellValueFn = cellValueFn;
      this.rowNode = rowNode;
      this.column = column;
      this.customGui = customGui;
      this.dragStartPixels = dragStartPixels;
      this.suppressVisibilityChange = suppressVisibilityChange;
      this.dragSource = null;
    }
    isCustomGui() {
      return this.customGui != null;
    }
    postConstruct() {
      if (!this.customGui) {
        this.setTemplate(
          /* html */
          `<div class="ag-drag-handle ag-row-drag" aria-hidden="true"></div>`
        );
        this.getGui().appendChild(createIconNoSpan("rowDrag", this.gos, null));
        this.addDragSource();
      } else {
        this.setDragElement(this.customGui, this.dragStartPixels);
      }
      this.checkCompatibility();
      if (!this.suppressVisibilityChange) {
        const strategy = this.gos.get("rowDragManaged") ? new ManagedVisibilityStrategy(this, this.beans, this.rowNode, this.column) : new NonManagedVisibilityStrategy(this, this.beans, this.rowNode, this.column);
        this.createManagedBean(strategy, this.beans.context);
      }
    }
    setDragElement(dragElement, dragStartPixels) {
      this.setTemplateFromElement(dragElement);
      this.addDragSource(dragStartPixels);
    }
    getSelectedNodes() {
      const isRowDragMultiRow = this.gos.get("rowDragMultiRow");
      if (!isRowDragMultiRow) {
        return [this.rowNode];
      }
      const selection = this.beans.selectionService.getSelectedNodes();
      return selection.indexOf(this.rowNode) !== -1 ? selection : [this.rowNode];
    }
    // returns true if all compatibility items work out
    checkCompatibility() {
      const managed = this.gos.get("rowDragManaged");
      const treeData = this.gos.get("treeData");
      if (treeData && managed) {
        warnOnce("If using row drag with tree data, you cannot have rowDragManaged=true");
      }
    }
    getDragItem() {
      return {
        rowNode: this.rowNode,
        rowNodes: this.getSelectedNodes(),
        columns: this.column ? [this.column] : void 0,
        defaultTextValue: this.cellValueFn()
      };
    }
    getRowDragText(column) {
      if (column) {
        const colDef = column.getColDef();
        if (colDef.rowDragText) {
          return colDef.rowDragText;
        }
      }
      return this.gos.get("rowDragText");
    }
    addDragSource(dragStartPixels = 4) {
      if (this.dragSource) {
        this.removeDragSource();
      }
      const translate = this.localeService.getLocaleTextFunc();
      this.dragSource = {
        type: 2,
        eElement: this.getGui(),
        dragItemName: () => {
          var _a;
          const dragItem = this.getDragItem();
          const dragItemCount = ((_a = dragItem.rowNodes) == null ? void 0 : _a.length) || 1;
          const rowDragText = this.getRowDragText(this.column);
          if (rowDragText) {
            return rowDragText(dragItem, dragItemCount);
          }
          return dragItemCount === 1 ? this.cellValueFn() : `${dragItemCount} ${translate("rowDragRows", "rows")}`;
        },
        getDragItem: () => this.getDragItem(),
        dragStartPixels,
        dragSourceDomDataKey: this.gos.getDomDataKey()
      };
      this.beans.dragAndDropService.addDragSource(this.dragSource, true);
    }
    removeDragSource() {
      if (this.dragSource) {
        this.beans.dragAndDropService.removeDragSource(this.dragSource);
      }
      this.dragSource = null;
    }
  };
  __decorateClass([
    Autowired("beans")
  ], RowDragComp.prototype, "beans", 2);
  __decorateClass([
    PostConstruct
  ], RowDragComp.prototype, "postConstruct", 1);
  __decorateClass([
    PreDestroy
  ], RowDragComp.prototype, "removeDragSource", 1);
  var VisibilityStrategy = class extends BeanStub {
    constructor(parent, rowNode, column) {
      super();
      this.parent = parent;
      this.rowNode = rowNode;
      this.column = column;
    }
    setDisplayedOrVisible(neverDisplayed) {
      const displayedOptions = { skipAriaHidden: true };
      if (neverDisplayed) {
        this.parent.setDisplayed(false, displayedOptions);
      } else {
        let shown = true;
        let isShownSometimes = false;
        if (this.column) {
          shown = this.column.isRowDrag(this.rowNode) || this.parent.isCustomGui();
          isShownSometimes = isFunction(this.column.getColDef().rowDrag);
        }
        if (isShownSometimes) {
          this.parent.setDisplayed(true, displayedOptions);
          this.parent.setVisible(shown, displayedOptions);
        } else {
          this.parent.setDisplayed(shown, displayedOptions);
          this.parent.setVisible(true, displayedOptions);
        }
      }
    }
  };
  var NonManagedVisibilityStrategy = class extends VisibilityStrategy {
    constructor(parent, beans, rowNode, column) {
      super(parent, rowNode, column);
      this.beans = beans;
    }
    postConstruct() {
      this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this));
      this.addManagedListener(this.rowNode, RowNode.EVENT_DATA_CHANGED, this.workOutVisibility.bind(this));
      this.addManagedListener(this.rowNode, RowNode.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this));
      this.addManagedListener(this.rowNode, RowNode.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this));
      this.addManagedListener(this.beans.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.workOutVisibility.bind(this));
      this.workOutVisibility();
    }
    onSuppressRowDrag() {
      this.workOutVisibility();
    }
    workOutVisibility() {
      const neverDisplayed = this.gos.get("suppressRowDrag");
      this.setDisplayedOrVisible(neverDisplayed);
    }
  };
  __decorateClass([
    PostConstruct
  ], NonManagedVisibilityStrategy.prototype, "postConstruct", 1);
  var ManagedVisibilityStrategy = class extends VisibilityStrategy {
    constructor(parent, beans, rowNode, column) {
      super(parent, rowNode, column);
      this.beans = beans;
    }
    postConstruct() {
      this.addManagedListener(this.beans.eventService, Events.EVENT_SORT_CHANGED, this.workOutVisibility.bind(this));
      this.addManagedListener(this.beans.eventService, Events.EVENT_FILTER_CHANGED, this.workOutVisibility.bind(this));
      this.addManagedListener(this.beans.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.workOutVisibility.bind(this));
      this.addManagedListener(this.beans.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.workOutVisibility.bind(this));
      this.addManagedListener(this.rowNode, RowNode.EVENT_DATA_CHANGED, this.workOutVisibility.bind(this));
      this.addManagedListener(this.rowNode, RowNode.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this));
      this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this));
      this.workOutVisibility();
    }
    onSuppressRowDrag() {
      this.workOutVisibility();
    }
    workOutVisibility() {
      const gridBodyCon = this.beans.ctrlsService.getGridBodyCtrl();
      const rowDragFeature = gridBodyCon.getRowDragFeature();
      const shouldPreventRowMove = rowDragFeature && rowDragFeature.shouldPreventRowMove();
      const suppressRowDrag = this.gos.get("suppressRowDrag");
      const hasExternalDropZones = this.beans.dragAndDropService.hasExternalDropZones();
      const neverDisplayed = shouldPreventRowMove && !hasExternalDropZones || suppressRowDrag;
      this.setDisplayedOrVisible(neverDisplayed);
    }
  };
  __decorateClass([
    PostConstruct
  ], ManagedVisibilityStrategy.prototype, "postConstruct", 1);
  var GroupCellRendererCtrl = class extends BeanStub {
    init(comp, eGui, eCheckbox, eExpanded, eContracted, compClass, params) {
      var _a, _b, _c, _d;
      this.params = params;
      this.eGui = eGui;
      this.eCheckbox = eCheckbox;
      this.eExpanded = eExpanded;
      this.eContracted = eContracted;
      this.comp = comp;
      this.compClass = compClass;
      const { node, value, colDef } = params;
      const topLevelFooter = this.isTopLevelFooter();
      if (!topLevelFooter) {
        const embeddedRowMismatch = this.isEmbeddedRowMismatch();
        if (embeddedRowMismatch) {
          return;
        }
        if (node.footer && this.gos.get("groupHideOpenParents")) {
          const showRowGroup = colDef && colDef.showRowGroup;
          const rowGroupColumnId = node.rowGroupColumn && node.rowGroupColumn.getColId();
          if (showRowGroup !== rowGroupColumnId) {
            return;
          }
        }
      }
      this.setupShowingValueForOpenedParent();
      this.findDisplayedGroupNode();
      if (!topLevelFooter) {
        const showingFooterTotal = params.node.footer && params.node.rowGroupIndex === this.columnModel.getRowGroupColumns().findIndex((c) => {
          var _a2;
          return c.getColId() === ((_a2 = params.colDef) == null ? void 0 : _a2.showRowGroup);
        });
        const isAlwaysShowing = this.gos.get("groupDisplayType") != "multipleColumns" || this.gos.get("treeData");
        const showOpenGroupValue = isAlwaysShowing || this.gos.get("showOpenedGroup") && !params.node.footer && (!params.node.group || params.node.rowGroupIndex != null && params.node.rowGroupIndex > this.columnModel.getRowGroupColumns().findIndex((c) => {
          var _a2;
          return c.getColId() === ((_a2 = params.colDef) == null ? void 0 : _a2.showRowGroup);
        }));
        const leafWithValues = !node.group && (((_a = this.params.colDef) == null ? void 0 : _a.field) || ((_b = this.params.colDef) == null ? void 0 : _b.valueGetter));
        const isExpandable = this.isExpandable();
        const showPivotModeLeafValue = this.columnModel.isPivotMode() && node.leafGroup && ((_c = node.rowGroupColumn) == null ? void 0 : _c.getColId()) === ((_d = params.column) == null ? void 0 : _d.getColDef().showRowGroup);
        const canSkipRenderingCell = !this.showingValueForOpenedParent && !isExpandable && !leafWithValues && !showOpenGroupValue && !showingFooterTotal && !showPivotModeLeafValue;
        if (canSkipRenderingCell) {
          return;
        }
      }
      this.addExpandAndContract();
      this.addFullWidthRowDraggerIfNeeded();
      this.addCheckboxIfNeeded();
      this.addValueElement();
      this.setupIndent();
      this.refreshAriaExpanded();
    }
    getCellAriaRole() {
      var _a, _b;
      const colDefAriaRole = (_a = this.params.colDef) == null ? void 0 : _a.cellAriaRole;
      const columnColDefAriaRole = (_b = this.params.column) == null ? void 0 : _b.getColDef().cellAriaRole;
      return colDefAriaRole || columnColDefAriaRole || "gridcell";
    }
    destroy() {
      super.destroy();
      this.expandListener = null;
    }
    refreshAriaExpanded() {
      const { node, eGridCell } = this.params;
      if (this.expandListener) {
        this.expandListener = this.expandListener();
      }
      if (!this.isExpandable()) {
        removeAriaExpanded(eGridCell);
        return;
      }
      const listener = () => {
        setAriaExpanded(eGridCell, !!node.expanded);
      };
      this.expandListener = this.addManagedListener(node, RowNode.EVENT_EXPANDED_CHANGED, listener) || null;
      listener();
    }
    isTopLevelFooter() {
      const totalRow = this.gos.getGrandTotalRow();
      if (!totalRow) {
        return false;
      }
      if (this.params.value != null || this.params.node.level != -1) {
        return false;
      }
      const colDef = this.params.colDef;
      const doingFullWidth = colDef == null;
      if (doingFullWidth) {
        return true;
      }
      if (colDef.showRowGroup === true) {
        return true;
      }
      const rowGroupCols = this.columnModel.getRowGroupColumns();
      if (!rowGroupCols || rowGroupCols.length === 0) {
        return true;
      }
      const firstRowGroupCol = rowGroupCols[0];
      return firstRowGroupCol.getId() === colDef.showRowGroup;
    }
    // if we are doing embedded full width rows, we only show the renderer when
    // in the body, or if pinning in the pinned section, or if pinning and RTL,
    // in the right section. otherwise we would have the cell repeated in each section.
    isEmbeddedRowMismatch() {
      if (!this.params.fullWidth || !this.gos.get("embedFullWidthRows")) {
        return false;
      }
      const pinnedLeftCell = this.params.pinned === "left";
      const pinnedRightCell = this.params.pinned === "right";
      const bodyCell = !pinnedLeftCell && !pinnedRightCell;
      if (this.gos.get("enableRtl")) {
        if (this.columnModel.isPinningLeft()) {
          return !pinnedRightCell;
        }
        return !bodyCell;
      }
      if (this.columnModel.isPinningLeft()) {
        return !pinnedLeftCell;
      }
      return !bodyCell;
    }
    findDisplayedGroupNode() {
      const column = this.params.column;
      const rowNode = this.params.node;
      if (this.showingValueForOpenedParent) {
        let pointer = rowNode.parent;
        while (pointer != null) {
          if (pointer.rowGroupColumn && column.isRowGroupDisplayed(pointer.rowGroupColumn.getId())) {
            this.displayedGroupNode = pointer;
            break;
          }
          pointer = pointer.parent;
        }
      }
      if (missing(this.displayedGroupNode)) {
        this.displayedGroupNode = rowNode;
      }
    }
    setupShowingValueForOpenedParent() {
      const rowNode = this.params.node;
      const column = this.params.column;
      if (!this.gos.get("groupHideOpenParents")) {
        this.showingValueForOpenedParent = false;
        return;
      }
      if (!rowNode.groupData) {
        this.showingValueForOpenedParent = false;
        return;
      }
      const showingGroupNode = rowNode.rowGroupColumn != null;
      if (showingGroupNode) {
        const keyOfGroupingColumn = rowNode.rowGroupColumn.getId();
        const configuredToShowThisGroupLevel = column.isRowGroupDisplayed(keyOfGroupingColumn);
        if (configuredToShowThisGroupLevel) {
          this.showingValueForOpenedParent = false;
          return;
        }
      }
      const valPresent = rowNode.groupData[column.getId()] != null;
      this.showingValueForOpenedParent = valPresent;
    }
    addValueElement() {
      if (this.displayedGroupNode.footer) {
        this.addFooterValue();
      } else {
        this.addGroupValue();
        this.addChildCount();
      }
    }
    addGroupValue() {
      var _a;
      const paramsAdjusted = this.adjustParamsWithDetailsFromRelatedColumn();
      const innerCompDetails = this.getInnerCompDetails(paramsAdjusted);
      const { valueFormatted, value } = paramsAdjusted;
      let valueWhenNoRenderer = valueFormatted;
      if (valueWhenNoRenderer == null) {
        const isGroupColForNode = this.displayedGroupNode.rowGroupColumn && ((_a = this.params.column) == null ? void 0 : _a.isRowGroupDisplayed(this.displayedGroupNode.rowGroupColumn.getId()));
        if (this.displayedGroupNode.key === "" && this.displayedGroupNode.group && isGroupColForNode) {
          const localeTextFunc = this.localeService.getLocaleTextFunc();
          valueWhenNoRenderer = localeTextFunc("blanks", "(Blanks)");
        } else {
          valueWhenNoRenderer = value != null ? value : null;
        }
      }
      this.comp.setInnerRenderer(innerCompDetails, valueWhenNoRenderer);
    }
    adjustParamsWithDetailsFromRelatedColumn() {
      const relatedColumn = this.displayedGroupNode.rowGroupColumn;
      const column = this.params.column;
      if (!relatedColumn) {
        return this.params;
      }
      const notFullWidth = column != null;
      if (notFullWidth) {
        const showingThisRowGroup = column.isRowGroupDisplayed(relatedColumn.getId());
        if (!showingThisRowGroup) {
          return this.params;
        }
      }
      const params = this.params;
      const { value, node } = this.params;
      const valueFormatted = this.valueService.formatValue(relatedColumn, node, value);
      const paramsAdjusted = __spreadProps(__spreadValues({}, params), {
        valueFormatted
      });
      return paramsAdjusted;
    }
    addFooterValue() {
      let footerValueGetter = this.params.totalValueGetter;
      if (!footerValueGetter) {
        const legacyGetter = this.params.footerValueGetter;
        if (legacyGetter) {
          footerValueGetter = legacyGetter;
          warnOnce("As of v31.3, footerValueGetter is deprecated. Use `totalValueGetter` instead.");
        }
      }
      let footerValue = "";
      if (footerValueGetter) {
        const paramsClone = cloneObject(this.params);
        paramsClone.value = this.params.value;
        if (typeof footerValueGetter === "function") {
          footerValue = footerValueGetter(paramsClone);
        } else if (typeof footerValueGetter === "string") {
          footerValue = this.expressionService.evaluate(footerValueGetter, paramsClone);
        } else {
          console.warn("AG Grid: footerValueGetter should be either a function or a string (expression)");
        }
      } else {
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const footerTotalPrefix = localeTextFunc("footerTotal", "Total");
        footerValue = footerTotalPrefix + " " + (this.params.value != null ? this.params.value : "");
      }
      const innerCompDetails = this.getInnerCompDetails(this.params);
      this.comp.setInnerRenderer(innerCompDetails, footerValue);
    }
    getInnerCompDetails(params) {
      if (params.fullWidth) {
        return this.userComponentFactory.getFullWidthGroupRowInnerCellRenderer(
          this.gos.get("groupRowRendererParams"),
          params
        );
      }
      const innerCompDetails = this.userComponentFactory.getInnerRendererDetails(params, params);
      const isGroupRowRenderer = (details) => details && details.componentClass == this.compClass;
      if (innerCompDetails && !isGroupRowRenderer(innerCompDetails)) {
        return innerCompDetails;
      }
      const relatedColumn = this.displayedGroupNode.rowGroupColumn;
      const relatedColDef = relatedColumn ? relatedColumn.getColDef() : void 0;
      if (!relatedColDef) {
        return;
      }
      const relatedCompDetails = this.userComponentFactory.getCellRendererDetails(relatedColDef, params);
      if (relatedCompDetails && !isGroupRowRenderer(relatedCompDetails)) {
        return relatedCompDetails;
      }
      if (isGroupRowRenderer(relatedCompDetails) && relatedColDef.cellRendererParams && relatedColDef.cellRendererParams.innerRenderer) {
        const res = this.userComponentFactory.getInnerRendererDetails(relatedColDef.cellRendererParams, params);
        return res;
      }
    }
    addChildCount() {
      if (this.params.suppressCount) {
        return;
      }
      this.addManagedListener(this.displayedGroupNode, RowNode.EVENT_ALL_CHILDREN_COUNT_CHANGED, this.updateChildCount.bind(this));
      this.updateChildCount();
    }
    updateChildCount() {
      const allChildrenCount = this.displayedGroupNode.allChildrenCount;
      const showingGroupForThisNode = this.isShowRowGroupForThisRow();
      const showCount = showingGroupForThisNode && allChildrenCount != null && allChildrenCount >= 0;
      const countString = showCount ? `(${allChildrenCount})` : ``;
      this.comp.setChildCount(countString);
    }
    isShowRowGroupForThisRow() {
      if (this.gos.get("treeData")) {
        return true;
      }
      const rowGroupColumn = this.displayedGroupNode.rowGroupColumn;
      if (!rowGroupColumn) {
        return false;
      }
      const column = this.params.column;
      const thisColumnIsInterested = column == null || column.isRowGroupDisplayed(rowGroupColumn.getId());
      return thisColumnIsInterested;
    }
    addExpandAndContract() {
      var _a;
      const params = this.params;
      const eExpandedIcon = createIconNoSpan("groupExpanded", this.gos, null);
      const eContractedIcon = createIconNoSpan("groupContracted", this.gos, null);
      if (eExpandedIcon) {
        this.eExpanded.appendChild(eExpandedIcon);
      }
      if (eContractedIcon) {
        this.eContracted.appendChild(eContractedIcon);
      }
      const eGroupCell = params.eGridCell;
      const isDoubleClickEdit = ((_a = this.params.column) == null ? void 0 : _a.isCellEditable(params.node)) && this.gos.get("enableGroupEdit");
      if (!isDoubleClickEdit && this.isExpandable() && !params.suppressDoubleClickExpand) {
        this.addManagedListener(eGroupCell, "dblclick", this.onCellDblClicked.bind(this));
      }
      this.addManagedListener(this.eExpanded, "click", this.onExpandClicked.bind(this));
      this.addManagedListener(this.eContracted, "click", this.onExpandClicked.bind(this));
      this.addManagedListener(eGroupCell, "keydown", this.onKeyDown.bind(this));
      this.addManagedListener(params.node, RowNode.EVENT_EXPANDED_CHANGED, this.showExpandAndContractIcons.bind(this));
      this.showExpandAndContractIcons();
      const expandableChangedListener = this.onRowNodeIsExpandableChanged.bind(this);
      this.addManagedListener(this.displayedGroupNode, RowNode.EVENT_ALL_CHILDREN_COUNT_CHANGED, expandableChangedListener);
      this.addManagedListener(this.displayedGroupNode, RowNode.EVENT_MASTER_CHANGED, expandableChangedListener);
      this.addManagedListener(this.displayedGroupNode, RowNode.EVENT_GROUP_CHANGED, expandableChangedListener);
      this.addManagedListener(this.displayedGroupNode, RowNode.EVENT_HAS_CHILDREN_CHANGED, expandableChangedListener);
    }
    onExpandClicked(mouseEvent) {
      if (isStopPropagationForAgGrid(mouseEvent)) {
        return;
      }
      stopPropagationForAgGrid(mouseEvent);
      this.onExpandOrContract(mouseEvent);
    }
    onExpandOrContract(e) {
      const rowNode = this.displayedGroupNode;
      const nextExpandState = !rowNode.expanded;
      if (!nextExpandState && rowNode.sticky) {
        this.scrollToStickyNode(rowNode);
      }
      rowNode.setExpanded(nextExpandState, e);
    }
    scrollToStickyNode(rowNode) {
      const gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();
      const scrollFeature = gridBodyCtrl.getScrollFeature();
      scrollFeature.setVerticalScrollPosition(rowNode.rowTop - rowNode.stickyRowTop);
    }
    isExpandable() {
      if (this.showingValueForOpenedParent) {
        return true;
      }
      const rowNode = this.displayedGroupNode;
      const reducedLeafNode = this.columnModel.isPivotMode() && rowNode.leafGroup;
      const expandableGroup = rowNode.isExpandable() && !rowNode.footer && !reducedLeafNode;
      if (!expandableGroup) {
        return false;
      }
      const column = this.params.column;
      const displayingForOneColumnOnly = column != null && typeof column.getColDef().showRowGroup === "string";
      if (displayingForOneColumnOnly) {
        const showing = this.isShowRowGroupForThisRow();
        return showing;
      }
      return true;
    }
    showExpandAndContractIcons() {
      const { params, displayedGroupNode: displayedGroup, columnModel } = this;
      const { node } = params;
      const isExpandable = this.isExpandable();
      if (isExpandable) {
        const expanded = this.showingValueForOpenedParent ? true : node.expanded;
        this.comp.setExpandedDisplayed(expanded);
        this.comp.setContractedDisplayed(!expanded);
      } else {
        this.comp.setExpandedDisplayed(false);
        this.comp.setContractedDisplayed(false);
      }
      const pivotMode = columnModel.isPivotMode();
      const pivotModeAndLeafGroup = pivotMode && displayedGroup.leafGroup;
      const addExpandableCss = isExpandable && !pivotModeAndLeafGroup;
      const isTotalFooterNode = node.footer && node.level === -1;
      this.comp.addOrRemoveCssClass("ag-cell-expandable", addExpandableCss);
      this.comp.addOrRemoveCssClass("ag-row-group", addExpandableCss);
      if (pivotMode) {
        this.comp.addOrRemoveCssClass("ag-pivot-leaf-group", pivotModeAndLeafGroup);
      } else if (!isTotalFooterNode) {
        this.comp.addOrRemoveCssClass("ag-row-group-leaf-indent", !addExpandableCss);
      }
    }
    onRowNodeIsExpandableChanged() {
      this.showExpandAndContractIcons();
      this.setIndent();
      this.refreshAriaExpanded();
    }
    setupIndent() {
      const node = this.params.node;
      const suppressPadding = this.params.suppressPadding;
      if (!suppressPadding) {
        this.addManagedListener(node, RowNode.EVENT_UI_LEVEL_CHANGED, this.setIndent.bind(this));
        this.setIndent();
      }
    }
    setIndent() {
      if (this.gos.get("groupHideOpenParents")) {
        return;
      }
      const params = this.params;
      const rowNode = params.node;
      const fullWithRow = !!params.colDef;
      const treeData = this.gos.get("treeData");
      const manyDimensionThisColumn = !fullWithRow || treeData || params.colDef.showRowGroup === true;
      const paddingCount = manyDimensionThisColumn ? rowNode.uiLevel : 0;
      if (this.indentClass) {
        this.comp.addOrRemoveCssClass(this.indentClass, false);
      }
      this.indentClass = "ag-row-group-indent-" + paddingCount;
      this.comp.addOrRemoveCssClass(this.indentClass, true);
    }
    addFullWidthRowDraggerIfNeeded() {
      if (!this.params.fullWidth || !this.params.rowDrag) {
        return;
      }
      const rowDragComp = new RowDragComp(() => this.params.value, this.params.node);
      this.createManagedBean(rowDragComp, this.context);
      this.eGui.insertAdjacentElement("afterbegin", rowDragComp.getGui());
    }
    isUserWantsSelected() {
      const paramsCheckbox = this.params.checkbox;
      return typeof paramsCheckbox === "function" || paramsCheckbox === true;
    }
    addCheckboxIfNeeded() {
      const rowNode = this.displayedGroupNode;
      const checkboxNeeded = this.isUserWantsSelected() && // footers cannot be selected
      !rowNode.footer && // pinned rows cannot be selected
      !rowNode.rowPinned && // details cannot be selected
      !rowNode.detail;
      if (checkboxNeeded) {
        const cbSelectionComponent = new CheckboxSelectionComponent();
        this.getContext().createBean(cbSelectionComponent);
        cbSelectionComponent.init({
          rowNode: this.params.node,
          // when groupHideOpenParents = true and group expanded, we want the checkbox to refer to leaf node state (not group node state)
          column: this.params.column,
          overrides: {
            isVisible: this.params.checkbox,
            callbackParams: this.params,
            removeHidden: true
          }
        });
        this.eCheckbox.appendChild(cbSelectionComponent.getGui());
        this.addDestroyFunc(() => this.getContext().destroyBean(cbSelectionComponent));
      }
      this.comp.setCheckboxVisible(checkboxNeeded);
    }
    onKeyDown(event) {
      const isEnterKey = event.key === KeyCode.ENTER;
      if (!isEnterKey || this.params.suppressEnterExpand) {
        return;
      }
      const cellEditable = this.params.column && this.params.column.isCellEditable(this.params.node);
      if (cellEditable) {
        return;
      }
      this.onExpandOrContract(event);
    }
    onCellDblClicked(mouseEvent) {
      if (isStopPropagationForAgGrid(mouseEvent)) {
        return;
      }
      const targetIsExpandIcon = isElementInEventPath(this.eExpanded, mouseEvent) || isElementInEventPath(this.eContracted, mouseEvent);
      if (!targetIsExpandIcon) {
        this.onExpandOrContract(mouseEvent);
      }
    }
  };
  __decorateClass([
    Autowired("expressionService")
  ], GroupCellRendererCtrl.prototype, "expressionService", 2);
  __decorateClass([
    Autowired("valueService")
  ], GroupCellRendererCtrl.prototype, "valueService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], GroupCellRendererCtrl.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("userComponentFactory")
  ], GroupCellRendererCtrl.prototype, "userComponentFactory", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], GroupCellRendererCtrl.prototype, "ctrlsService", 2);
  var _GroupCellRenderer = class _GroupCellRenderer2 extends Component {
    constructor() {
      super(_GroupCellRenderer2.TEMPLATE);
    }
    init(params) {
      const compProxy = {
        setInnerRenderer: (compDetails, valueToDisplay) => this.setRenderDetails(compDetails, valueToDisplay),
        setChildCount: (count) => this.eChildCount.textContent = count,
        addOrRemoveCssClass: (cssClass, value) => this.addOrRemoveCssClass(cssClass, value),
        setContractedDisplayed: (expanded) => setDisplayed(this.eContracted, expanded),
        setExpandedDisplayed: (expanded) => setDisplayed(this.eExpanded, expanded),
        setCheckboxVisible: (visible) => this.eCheckbox.classList.toggle("ag-invisible", !visible)
      };
      const ctrl = this.createManagedBean(new GroupCellRendererCtrl());
      const fullWidth = !params.colDef;
      const eGui = this.getGui();
      ctrl.init(compProxy, eGui, this.eCheckbox, this.eExpanded, this.eContracted, this.constructor, params);
      if (fullWidth) {
        setAriaRole(eGui, ctrl.getCellAriaRole());
      }
    }
    setRenderDetails(compDetails, valueToDisplay) {
      if (compDetails) {
        const componentPromise = compDetails.newAgStackInstance();
        if (!componentPromise) {
          return;
        }
        componentPromise.then((comp) => {
          if (!comp) {
            return;
          }
          const destroyComp = () => this.context.destroyBean(comp);
          if (this.isAlive()) {
            this.eValue.appendChild(comp.getGui());
            this.addDestroyFunc(destroyComp);
          } else {
            destroyComp();
          }
        });
      } else {
        this.eValue.innerText = valueToDisplay;
      }
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to have public here instead of private or protected
    destroy() {
      this.getContext().destroyBean(this.innerCellRenderer);
      super.destroy();
    }
    refresh() {
      return false;
    }
  };
  _GroupCellRenderer.TEMPLATE = /* html */
  `<span class="ag-cell-wrapper">
            <span class="ag-group-expanded" ref="eExpanded"></span>
            <span class="ag-group-contracted" ref="eContracted"></span>
            <span class="ag-group-checkbox ag-invisible" ref="eCheckbox"></span>
            <span class="ag-group-value" ref="eValue"></span>
            <span class="ag-group-child-count" ref="eChildCount"></span>
        </span>`;
  __decorateClass([
    RefSelector("eExpanded")
  ], _GroupCellRenderer.prototype, "eExpanded", 2);
  __decorateClass([
    RefSelector("eContracted")
  ], _GroupCellRenderer.prototype, "eContracted", 2);
  __decorateClass([
    RefSelector("eCheckbox")
  ], _GroupCellRenderer.prototype, "eCheckbox", 2);
  __decorateClass([
    RefSelector("eValue")
  ], _GroupCellRenderer.prototype, "eValue", 2);
  __decorateClass([
    RefSelector("eChildCount")
  ], _GroupCellRenderer.prototype, "eChildCount", 2);
  var GroupCellRenderer = _GroupCellRenderer;
  var _LoadingCellRenderer = class _LoadingCellRenderer2 extends Component {
    constructor() {
      super(_LoadingCellRenderer2.TEMPLATE);
    }
    init(params) {
      params.node.failedLoad ? this.setupFailed() : this.setupLoading();
    }
    setupFailed() {
      const localeTextFunc = this.localeService.getLocaleTextFunc();
      this.eLoadingText.innerText = localeTextFunc("loadingError", "ERR");
    }
    setupLoading() {
      const eLoadingIcon = createIconNoSpan("groupLoading", this.gos, null);
      if (eLoadingIcon) {
        this.eLoadingIcon.appendChild(eLoadingIcon);
      }
      const localeTextFunc = this.localeService.getLocaleTextFunc();
      this.eLoadingText.innerText = localeTextFunc("loadingOoo", "Loading");
    }
    refresh(params) {
      return false;
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
      super.destroy();
    }
  };
  _LoadingCellRenderer.TEMPLATE = `<div class="ag-loading">
            <span class="ag-loading-icon" ref="eLoadingIcon"></span>
            <span class="ag-loading-text" ref="eLoadingText"></span>
        </div>`;
  __decorateClass([
    RefSelector("eLoadingIcon")
  ], _LoadingCellRenderer.prototype, "eLoadingIcon", 2);
  __decorateClass([
    RefSelector("eLoadingText")
  ], _LoadingCellRenderer.prototype, "eLoadingText", 2);
  var LoadingCellRenderer = _LoadingCellRenderer;
  var _SkeletonCellRenderer = class _SkeletonCellRenderer2 extends Component {
    constructor() {
      super(_SkeletonCellRenderer2.TEMPLATE);
    }
    init(params) {
      const id = `ag-cell-skeleton-renderer-${this.getCompId()}`;
      this.getGui().setAttribute("id", id);
      this.addDestroyFunc(() => setAriaLabelledBy(params.eParentOfValue));
      setAriaLabelledBy(params.eParentOfValue, id);
      params.node.failedLoad ? this.setupFailed() : this.setupLoading();
    }
    setupFailed() {
      const localeTextFunc = this.localeService.getLocaleTextFunc();
      this.getGui().innerText = localeTextFunc("loadingError", "ERR");
      const ariaFailed = localeTextFunc("ariaSkeletonCellLoadingFailed", "Row failed to load");
      setAriaLabel(this.getGui(), ariaFailed);
    }
    setupLoading() {
      const eDocument = this.gos.getDocument();
      const skeletonEffect = eDocument.createElement("div");
      skeletonEffect.classList.add("ag-skeleton-effect");
      this.getGui().appendChild(skeletonEffect);
      const localeTextFunc = this.localeService.getLocaleTextFunc();
      const ariaLoading = localeTextFunc("ariaSkeletonCellLoading", "Row data is loading");
      setAriaLabel(this.getGui(), ariaLoading);
    }
    refresh(params) {
      return false;
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
      super.destroy();
    }
  };
  _SkeletonCellRenderer.TEMPLATE = `<div class="ag-skeleton-container"></div>`;
  var SkeletonCellRenderer = _SkeletonCellRenderer;
  var _LoadingOverlayComponent = class _LoadingOverlayComponent2 extends Component {
    constructor() {
      super();
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
      super.destroy();
    }
    init(params) {
      const customTemplate = this.gos.get("overlayLoadingTemplate");
      this.setTemplate(customTemplate != null ? customTemplate : _LoadingOverlayComponent2.DEFAULT_LOADING_OVERLAY_TEMPLATE);
      if (!customTemplate) {
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        setTimeout(() => {
          this.getGui().textContent = localeTextFunc("loadingOoo", "Loading...");
        });
      }
    }
  };
  _LoadingOverlayComponent.DEFAULT_LOADING_OVERLAY_TEMPLATE = /* html */
  `<span aria-live="polite" aria-atomic="true" class="ag-overlay-loading-center"></span>`;
  var LoadingOverlayComponent = _LoadingOverlayComponent;
  var _NoRowsOverlayComponent = class _NoRowsOverlayComponent2 extends Component {
    constructor() {
      super();
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
      super.destroy();
    }
    init(params) {
      const customTemplate = this.gos.get("overlayNoRowsTemplate");
      this.setTemplate(customTemplate != null ? customTemplate : _NoRowsOverlayComponent2.DEFAULT_NO_ROWS_TEMPLATE);
      if (!customTemplate) {
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        setTimeout(() => {
          this.getGui().textContent = localeTextFunc("noRowsToShow", "No Rows To Show");
        });
      }
    }
  };
  _NoRowsOverlayComponent.DEFAULT_NO_ROWS_TEMPLATE = /* html */
  `<span class="ag-overlay-no-rows-center"></span>`;
  var NoRowsOverlayComponent = _NoRowsOverlayComponent;
  var TooltipComponent = class extends PopupComponent {
    constructor() {
      super(
        /* html */
        `<div class="ag-tooltip"></div>`
      );
    }
    // will need to type params
    init(params) {
      const { value } = params;
      this.getGui().textContent = escapeString(value, true);
    }
  };
  var NumberCellEditorInput = class {
    getTemplate() {
      return (
        /* html */
        `<ag-input-number-field class="ag-cell-editor" ref="eInput"></ag-input-number-field>`
      );
    }
    init(eInput, params) {
      this.eInput = eInput;
      this.params = params;
      if (params.max != null) {
        eInput.setMax(params.max);
      }
      if (params.min != null) {
        eInput.setMin(params.min);
      }
      if (params.precision != null) {
        eInput.setPrecision(params.precision);
      }
      if (params.step != null) {
        eInput.setStep(params.step);
      }
      const inputEl = eInput.getInputElement();
      if (params.preventStepping) {
        eInput.addManagedListener(inputEl, "keydown", this.preventStepping);
      } else if (params.showStepperButtons) {
        inputEl.classList.add("ag-number-field-input-stepper");
      }
    }
    preventStepping(e) {
      if (e.key === KeyCode.UP || e.key === KeyCode.DOWN) {
        e.preventDefault();
      }
    }
    getValue() {
      const value = this.eInput.getValue();
      if (!exists(value) && !exists(this.params.value)) {
        return this.params.value;
      }
      let parsedValue = this.params.parseValue(value);
      if (parsedValue == null) {
        return parsedValue;
      }
      if (typeof parsedValue === "string") {
        if (parsedValue === "") {
          return null;
        }
        parsedValue = Number(parsedValue);
      }
      return isNaN(parsedValue) ? null : parsedValue;
    }
    getStartValue() {
      return this.params.value;
    }
  };
  var NumberCellEditor = class extends SimpleCellEditor {
    constructor() {
      super(new NumberCellEditorInput());
    }
  };
  var DateCellEditorInput = class {
    getTemplate() {
      return (
        /* html */
        `<ag-input-date-field class="ag-cell-editor" ref="eInput"></ag-input-date-field>`
      );
    }
    init(eInput, params) {
      this.eInput = eInput;
      this.params = params;
      if (params.min != null) {
        eInput.setMin(params.min);
      }
      if (params.max != null) {
        eInput.setMax(params.max);
      }
      if (params.step != null) {
        eInput.setStep(params.step);
      }
    }
    getValue() {
      const value = this.eInput.getDate();
      if (!exists(value) && !exists(this.params.value)) {
        return this.params.value;
      }
      return value != null ? value : null;
    }
    getStartValue() {
      const { value } = this.params;
      if (!(value instanceof Date)) {
        return void 0;
      }
      return serialiseDate(value, false);
    }
  };
  var DateCellEditor = class extends SimpleCellEditor {
    constructor() {
      super(new DateCellEditorInput());
    }
  };
  var DateStringCellEditorInput = class {
    constructor(getDataTypeService) {
      this.getDataTypeService = getDataTypeService;
    }
    getTemplate() {
      return (
        /* html */
        `<ag-input-date-field class="ag-cell-editor" ref="eInput"></ag-input-date-field>`
      );
    }
    init(eInput, params) {
      this.eInput = eInput;
      this.params = params;
      if (params.min != null) {
        eInput.setMin(params.min);
      }
      if (params.max != null) {
        eInput.setMax(params.max);
      }
      if (params.step != null) {
        eInput.setStep(params.step);
      }
    }
    getValue() {
      const value = this.formatDate(this.eInput.getDate());
      if (!exists(value) && !exists(this.params.value)) {
        return this.params.value;
      }
      return this.params.parseValue(value != null ? value : "");
    }
    getStartValue() {
      var _a, _b;
      return serialiseDate((_b = this.parseDate((_a = this.params.value) != null ? _a : void 0)) != null ? _b : null, false);
    }
    parseDate(value) {
      return this.getDataTypeService().getDateParserFunction(this.params.column)(value);
    }
    formatDate(value) {
      return this.getDataTypeService().getDateFormatterFunction(this.params.column)(value);
    }
  };
  var DateStringCellEditor = class extends SimpleCellEditor {
    constructor() {
      super(new DateStringCellEditorInput(() => this.dataTypeService));
    }
  };
  __decorateClass([
    Autowired("dataTypeService")
  ], DateStringCellEditor.prototype, "dataTypeService", 2);
  var _CheckboxCellRenderer = class _CheckboxCellRenderer2 extends Component {
    constructor() {
      super(_CheckboxCellRenderer2.TEMPLATE);
    }
    init(params) {
      this.params = params;
      this.updateCheckbox(params);
      const inputEl = this.eCheckbox.getInputElement();
      inputEl.setAttribute("tabindex", "-1");
      setAriaLive(inputEl, "polite");
      this.addManagedListener(inputEl, "click", (event) => {
        stopPropagationForAgGrid(event);
        if (this.eCheckbox.isDisabled()) {
          return;
        }
        const isSelected = this.eCheckbox.getValue();
        this.onCheckboxChanged(isSelected);
      });
      this.addManagedListener(inputEl, "dblclick", (event) => {
        stopPropagationForAgGrid(event);
      });
      this.addManagedListener(this.params.eGridCell, "keydown", (event) => {
        if (event.key === KeyCode.SPACE && !this.eCheckbox.isDisabled()) {
          if (this.params.eGridCell === this.gos.getActiveDomElement()) {
            this.eCheckbox.toggle();
          }
          const isSelected = this.eCheckbox.getValue();
          this.onCheckboxChanged(isSelected);
          event.preventDefault();
        }
      });
    }
    refresh(params) {
      this.params = params;
      this.updateCheckbox(params);
      return true;
    }
    updateCheckbox(params) {
      var _a, _b, _c;
      let isSelected;
      let displayed = true;
      if (params.node.group && params.column) {
        const colId = params.column.getColId();
        if (colId.startsWith(GROUP_AUTO_COLUMN_ID)) {
          isSelected = params.value == null || params.value === "" ? void 0 : params.value === "true";
        } else if (params.node.aggData && params.node.aggData[colId] !== void 0) {
          isSelected = (_a = params.value) != null ? _a : void 0;
        } else {
          displayed = false;
        }
      } else {
        isSelected = (_b = params.value) != null ? _b : void 0;
      }
      if (!displayed) {
        this.eCheckbox.setDisplayed(false);
        return;
      }
      this.eCheckbox.setValue(isSelected);
      const disabled = params.disabled != null ? params.disabled : !((_c = params.column) == null ? void 0 : _c.isCellEditable(params.node));
      this.eCheckbox.setDisabled(disabled);
      const translate = this.localeService.getLocaleTextFunc();
      const stateName = getAriaCheckboxStateName(translate, isSelected);
      const ariaLabel = disabled ? stateName : `${translate("ariaToggleCellValue", "Press SPACE to toggle cell value")} (${stateName})`;
      this.eCheckbox.setInputAriaLabel(ariaLabel);
    }
    onCheckboxChanged(isSelected) {
      const { column, node, rowIndex, value } = this.params;
      const eventStarted = {
        type: Events.EVENT_CELL_EDITING_STARTED,
        column,
        colDef: column == null ? void 0 : column.getColDef(),
        data: node.data,
        node,
        rowIndex,
        rowPinned: node.rowPinned,
        value
      };
      this.eventService.dispatchEvent(eventStarted);
      const valueChanged = this.params.node.setDataValue(this.params.column, isSelected, "edit");
      const eventStopped = {
        type: Events.EVENT_CELL_EDITING_STOPPED,
        column,
        colDef: column == null ? void 0 : column.getColDef(),
        data: node.data,
        node,
        rowIndex,
        rowPinned: node.rowPinned,
        value,
        oldValue: value,
        newValue: isSelected,
        valueChanged
      };
      this.eventService.dispatchEvent(eventStopped);
    }
  };
  _CheckboxCellRenderer.TEMPLATE = /* html*/
  `
        <div class="ag-cell-wrapper ag-checkbox-cell" role="presentation">
            <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>
        </div>`;
  __decorateClass([
    RefSelector("eCheckbox")
  ], _CheckboxCellRenderer.prototype, "eCheckbox", 2);
  var CheckboxCellRenderer = _CheckboxCellRenderer;
  var CheckboxCellEditor = class extends PopupComponent {
    constructor() {
      super(
        /* html */
        `
            <div class="ag-cell-wrapper ag-cell-edit-wrapper ag-checkbox-edit">
                <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>
            </div>`
      );
    }
    init(params) {
      var _a;
      this.params = params;
      const isSelected = (_a = params.value) != null ? _a : void 0;
      this.eCheckbox.setValue(isSelected);
      const inputEl = this.eCheckbox.getInputElement();
      inputEl.setAttribute("tabindex", "-1");
      this.setAriaLabel(isSelected);
      this.addManagedListener(
        this.eCheckbox,
        Events.EVENT_FIELD_VALUE_CHANGED,
        (event) => this.setAriaLabel(event.selected)
      );
    }
    getValue() {
      return this.eCheckbox.getValue();
    }
    focusIn() {
      this.eCheckbox.getFocusableElement().focus();
    }
    afterGuiAttached() {
      if (this.params.cellStartedEdit) {
        this.focusIn();
      }
    }
    isPopup() {
      return false;
    }
    setAriaLabel(isSelected) {
      const translate = this.localeService.getLocaleTextFunc();
      const stateName = getAriaCheckboxStateName(translate, isSelected);
      const ariaLabel = translate("ariaToggleCellValue", "Press SPACE to toggle cell value");
      this.eCheckbox.setInputAriaLabel(`${ariaLabel} (${stateName})`);
    }
  };
  __decorateClass([
    RefSelector("eCheckbox")
  ], CheckboxCellEditor.prototype, "eCheckbox", 2);
  var AgMenuItemRenderer = class extends Component {
    constructor() {
      super();
      this.setTemplate(
        /* html */
        `<div></div>`
      );
    }
    init(params) {
      var _a;
      this.params = params;
      this.cssClassPrefix = (_a = this.params.cssClassPrefix) != null ? _a : "ag-menu-option";
      this.addIcon();
      this.addName();
      this.addShortcut();
      this.addSubMenu();
    }
    configureDefaults() {
      return true;
    }
    addIcon() {
      if (this.params.isCompact) {
        return;
      }
      const icon = loadTemplate(
        /* html */
        `<span ref="eIcon" class="${this.getClassName("part")} ${this.getClassName("icon")}" role="presentation"></span>`
      );
      if (this.params.checked) {
        icon.appendChild(createIconNoSpan("check", this.gos));
      } else if (this.params.icon) {
        if (isNodeOrElement(this.params.icon)) {
          icon.appendChild(this.params.icon);
        } else if (typeof this.params.icon === "string") {
          icon.innerHTML = this.params.icon;
        } else {
          console.warn("AG Grid: menu item icon must be DOM node or string");
        }
      }
      this.getGui().appendChild(icon);
    }
    addName() {
      const name = loadTemplate(
        /* html */
        `<span ref="eName" class="${this.getClassName("part")} ${this.getClassName("text")}">${this.params.name || ""}</span>`
      );
      this.getGui().appendChild(name);
    }
    addShortcut() {
      if (this.params.isCompact) {
        return;
      }
      const shortcut = loadTemplate(
        /* html */
        `<span ref="eShortcut" class="${this.getClassName("part")} ${this.getClassName("shortcut")}">${this.params.shortcut || ""}</span>`
      );
      this.getGui().appendChild(shortcut);
    }
    addSubMenu() {
      const pointer = loadTemplate(
        /* html */
        `<span ref="ePopupPointer" class="${this.getClassName("part")} ${this.getClassName("popup-pointer")}"></span>`
      );
      const eGui = this.getGui();
      if (this.params.subMenu) {
        const iconName = this.gos.get("enableRtl") ? "smallLeft" : "smallRight";
        setAriaExpanded(eGui, false);
        pointer.appendChild(createIconNoSpan(iconName, this.gos));
      }
      eGui.appendChild(pointer);
    }
    getClassName(suffix) {
      return `${this.cssClassPrefix}-${suffix}`;
    }
    destroy() {
      super.destroy();
    }
  };
  var UserComponentRegistry = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.agGridDefaults = {
        //date
        agDateInput: DefaultDateComponent,
        //header
        agColumnHeader: HeaderComp,
        agColumnGroupHeader: HeaderGroupComp,
        agSortIndicator: SortIndicatorComp,
        //floating filters
        agTextColumnFloatingFilter: TextFloatingFilter,
        agNumberColumnFloatingFilter: NumberFloatingFilter,
        agDateColumnFloatingFilter: DateFloatingFilter,
        agReadOnlyFloatingFilter: ReadOnlyFloatingFilter,
        // renderers
        agAnimateShowChangeCellRenderer: AnimateShowChangeCellRenderer,
        agAnimateSlideCellRenderer: AnimateSlideCellRenderer,
        agGroupCellRenderer: GroupCellRenderer,
        agGroupRowRenderer: GroupCellRenderer,
        agLoadingCellRenderer: LoadingCellRenderer,
        agSkeletonCellRenderer: SkeletonCellRenderer,
        agCheckboxCellRenderer: CheckboxCellRenderer,
        //editors
        agCellEditor: TextCellEditor,
        agTextCellEditor: TextCellEditor,
        agNumberCellEditor: NumberCellEditor,
        agDateCellEditor: DateCellEditor,
        agDateStringCellEditor: DateStringCellEditor,
        agSelectCellEditor: SelectCellEditor,
        agLargeTextCellEditor: LargeTextCellEditor,
        agCheckboxCellEditor: CheckboxCellEditor,
        //filter
        agTextColumnFilter: TextFilter,
        agNumberColumnFilter: NumberFilter,
        agDateColumnFilter: DateFilter,
        //overlays
        agLoadingOverlay: LoadingOverlayComponent,
        agNoRowsOverlay: NoRowsOverlayComponent,
        // tooltips
        agTooltipComponent: TooltipComponent,
        // menu item
        agMenuItem: AgMenuItemRenderer
      };
      this.enterpriseAgDefaultCompsModule = {
        agSetColumnFilter: "@ag-grid-enterprise/set-filter",
        agSetColumnFloatingFilter: "@ag-grid-enterprise/set-filter",
        agMultiColumnFilter: "@ag-grid-enterprise/multi-filter",
        agMultiColumnFloatingFilter: "@ag-grid-enterprise/multi-filter",
        agGroupColumnFilter: "@ag-grid-enterprise/row-grouping",
        agGroupColumnFloatingFilter: "@ag-grid-enterprise/row-grouping",
        agRichSelect: "@ag-grid-enterprise/rich-select",
        agRichSelectCellEditor: "@ag-grid-enterprise/rich-select",
        agDetailCellRenderer: "@ag-grid-enterprise/master-detail",
        agSparklineCellRenderer: "@ag-grid-enterprise/sparklines"
        /* SparklinesModule */
      };
      this.jsComps = {};
    }
    init() {
      const comps = this.gos.get("components");
      if (comps != null) {
        iterateObject(comps, (key, component) => this.registerJsComponent(key, component));
      }
    }
    registerDefaultComponent(name, component) {
      if (this.agGridDefaults[name]) {
        console.error(`Trying to overwrite a default component. You should call registerComponent`);
        return;
      }
      this.agGridDefaults[name] = component;
    }
    registerJsComponent(name, component) {
      this.jsComps[name] = component;
    }
    retrieve(propertyName, name) {
      const createResult = (component, componentFromFramework) => ({ componentFromFramework, component });
      const registeredViaFrameworkComp = this.getFrameworkOverrides().frameworkComponent(name, this.gos.get("components"));
      if (registeredViaFrameworkComp != null) {
        return createResult(registeredViaFrameworkComp, true);
      }
      const jsComponent = this.jsComps[name];
      if (jsComponent) {
        const isFwkComp = this.getFrameworkOverrides().isFrameworkComponent(jsComponent);
        return createResult(jsComponent, isFwkComp);
      }
      const defaultComponent = this.agGridDefaults[name];
      if (defaultComponent) {
        return createResult(defaultComponent, false);
      }
      const moduleForComponent = this.enterpriseAgDefaultCompsModule[name];
      if (moduleForComponent) {
        ModuleRegistry.__assertRegistered(moduleForComponent, `AG Grid '${propertyName}' component: ${name}`, this.context.getGridId());
      } else {
        doOnce(() => {
          this.warnAboutMissingComponent(propertyName, name);
        }, "MissingComp" + name);
      }
      return null;
    }
    warnAboutMissingComponent(propertyName, componentName) {
      const validComponents = [
        // Don't include the old names / internals in potential suggestions
        ...Object.keys(this.agGridDefaults).filter((k) => !["agCellEditor", "agGroupRowRenderer", "agSortIndicator"].includes(k)),
        ...Object.keys(this.jsComps)
      ];
      const suggestions = fuzzySuggestions(componentName, validComponents, true, 0.8).values;
      console.warn(`AG Grid: Could not find '${componentName}' component. It was configured as "${propertyName}: '${componentName}'" but it wasn't found in the list of registered components.`);
      if (suggestions.length > 0) {
        console.warn(`         Did you mean: [${suggestions.slice(0, 3)}]?`);
      }
      console.warn(`If using a custom component check it has been registered as described in: ${this.getFrameworkOverrides().getDocLink("components/")}`);
    }
  };
  __decorateClass([
    PostConstruct
  ], UserComponentRegistry.prototype, "init", 1);
  UserComponentRegistry = __decorateClass([
    Bean("userComponentRegistry")
  ], UserComponentRegistry);
  var DateComponent = {
    propertyName: "dateComponent",
    cellRenderer: false
  };
  var HeaderComponent = {
    propertyName: "headerComponent",
    cellRenderer: false
  };
  var HeaderGroupComponent = {
    propertyName: "headerGroupComponent",
    cellRenderer: false
  };
  var CellRendererComponent = {
    propertyName: "cellRenderer",
    cellRenderer: true
  };
  var LoadingCellRendererComponent = {
    propertyName: "loadingCellRenderer",
    cellRenderer: true
  };
  var CellEditorComponent = {
    propertyName: "cellEditor",
    cellRenderer: false
  };
  var InnerRendererComponent = {
    propertyName: "innerRenderer",
    cellRenderer: true
  };
  var LoadingOverlayComponent2 = {
    propertyName: "loadingOverlayComponent",
    cellRenderer: false
  };
  var NoRowsOverlayComponent2 = {
    propertyName: "noRowsOverlayComponent",
    cellRenderer: false
  };
  var TooltipComponent2 = {
    propertyName: "tooltipComponent",
    cellRenderer: false
  };
  var FilterComponent = {
    propertyName: "filter",
    cellRenderer: false
  };
  var FloatingFilterComponent = {
    propertyName: "floatingFilterComponent",
    cellRenderer: false
  };
  var ToolPanelComponent = {
    propertyName: "toolPanel",
    cellRenderer: false
  };
  var StatusPanelComponent = {
    propertyName: "statusPanel",
    cellRenderer: false
  };
  var FullWidth = {
    propertyName: "fullWidthCellRenderer",
    cellRenderer: true
  };
  var FullWidthLoading = {
    propertyName: "loadingCellRenderer",
    cellRenderer: true
  };
  var FullWidthGroup = {
    propertyName: "groupRowRenderer",
    cellRenderer: true
  };
  var FullWidthDetail = {
    propertyName: "detailCellRenderer",
    cellRenderer: true
  };
  var MenuItemComponent = {
    propertyName: "menuItem",
    cellRenderer: false
  };
  var FloatingFilterMapper = class {
    static getFloatingFilterType(filterType) {
      return this.filterToFloatingFilterMapping[filterType];
    }
  };
  FloatingFilterMapper.filterToFloatingFilterMapping = {
    set: "agSetColumnFloatingFilter",
    agSetColumnFilter: "agSetColumnFloatingFilter",
    multi: "agMultiColumnFloatingFilter",
    agMultiColumnFilter: "agMultiColumnFloatingFilter",
    group: "agGroupColumnFloatingFilter",
    agGroupColumnFilter: "agGroupColumnFloatingFilter",
    number: "agNumberColumnFloatingFilter",
    agNumberColumnFilter: "agNumberColumnFloatingFilter",
    date: "agDateColumnFloatingFilter",
    agDateColumnFilter: "agDateColumnFloatingFilter",
    text: "agTextColumnFloatingFilter",
    agTextColumnFilter: "agTextColumnFloatingFilter"
  };
  var UserComponentFactory = class extends BeanStub {
    getHeaderCompDetails(colDef, params) {
      return this.getCompDetails(colDef, HeaderComponent, "agColumnHeader", params);
    }
    getHeaderGroupCompDetails(params) {
      const colGroupDef = params.columnGroup.getColGroupDef();
      return this.getCompDetails(colGroupDef, HeaderGroupComponent, "agColumnGroupHeader", params);
    }
    // this one is unusual, as it can be LoadingCellRenderer, DetailCellRenderer, FullWidthCellRenderer or GroupRowRenderer.
    // so we have to pass the type in.
    getFullWidthCellRendererDetails(params) {
      return this.getCompDetails(this.gridOptions, FullWidth, null, params, true);
    }
    getFullWidthLoadingCellRendererDetails(params) {
      return this.getCompDetails(this.gridOptions, FullWidthLoading, "agLoadingCellRenderer", params, true);
    }
    getFullWidthGroupCellRendererDetails(params) {
      return this.getCompDetails(this.gridOptions, FullWidthGroup, "agGroupRowRenderer", params, true);
    }
    getFullWidthDetailCellRendererDetails(params) {
      return this.getCompDetails(this.gridOptions, FullWidthDetail, "agDetailCellRenderer", params, true);
    }
    // CELL RENDERER
    getInnerRendererDetails(def2, params) {
      return this.getCompDetails(def2, InnerRendererComponent, null, params);
    }
    getFullWidthGroupRowInnerCellRenderer(def2, params) {
      return this.getCompDetails(def2, InnerRendererComponent, null, params);
    }
    getCellRendererDetails(def2, params) {
      return this.getCompDetails(def2, CellRendererComponent, null, params);
    }
    getLoadingCellRendererDetails(def2, params) {
      return this.getCompDetails(def2, LoadingCellRendererComponent, "agSkeletonCellRenderer", params, true);
    }
    // CELL EDITOR
    getCellEditorDetails(def2, params) {
      return this.getCompDetails(def2, CellEditorComponent, "agCellEditor", params, true);
    }
    // FILTER
    getFilterDetails(def2, params, defaultFilter) {
      return this.getCompDetails(def2, FilterComponent, defaultFilter, params, true);
    }
    getDateCompDetails(params) {
      return this.getCompDetails(this.gridOptions, DateComponent, "agDateInput", params, true);
    }
    getLoadingOverlayCompDetails(params) {
      return this.getCompDetails(this.gridOptions, LoadingOverlayComponent2, "agLoadingOverlay", params, true);
    }
    getNoRowsOverlayCompDetails(params) {
      return this.getCompDetails(this.gridOptions, NoRowsOverlayComponent2, "agNoRowsOverlay", params, true);
    }
    getTooltipCompDetails(params) {
      return this.getCompDetails(params.colDef, TooltipComponent2, "agTooltipComponent", params, true);
    }
    getSetFilterCellRendererDetails(def2, params) {
      return this.getCompDetails(def2, CellRendererComponent, null, params);
    }
    getFloatingFilterCompDetails(def2, params, defaultFloatingFilter) {
      return this.getCompDetails(def2, FloatingFilterComponent, defaultFloatingFilter, params);
    }
    getToolPanelCompDetails(toolPanelDef, params) {
      return this.getCompDetails(toolPanelDef, ToolPanelComponent, null, params, true);
    }
    getStatusPanelCompDetails(def2, params) {
      return this.getCompDetails(def2, StatusPanelComponent, null, params, true);
    }
    getMenuItemCompDetails(def2, params) {
      return this.getCompDetails(def2, MenuItemComponent, "agMenuItem", params, true);
    }
    getCompDetails(defObject, type, defaultName, params, mandatory = false) {
      const { propertyName, cellRenderer } = type;
      let { compName, jsComp, fwComp, paramsFromSelector, popupFromSelector, popupPositionFromSelector } = this.getCompKeys(defObject, type, params);
      const lookupFromRegistry = (key) => {
        const item = this.userComponentRegistry.retrieve(propertyName, key);
        if (item) {
          jsComp = !item.componentFromFramework ? item.component : void 0;
          fwComp = item.componentFromFramework ? item.component : void 0;
        }
      };
      if (compName != null) {
        lookupFromRegistry(compName);
      }
      if (jsComp == null && fwComp == null && defaultName != null) {
        lookupFromRegistry(defaultName);
      }
      if (jsComp && cellRenderer && !this.agComponentUtils.doesImplementIComponent(jsComp)) {
        jsComp = this.agComponentUtils.adaptFunction(propertyName, jsComp);
      }
      if (!jsComp && !fwComp) {
        if (mandatory) {
          console.error(`AG Grid: Could not find component ${compName}, did you forget to configure this component?`);
        }
        return;
      }
      const paramsMerged = this.mergeParamsWithApplicationProvidedParams(defObject, type, params, paramsFromSelector);
      const componentFromFramework = jsComp == null;
      const componentClass = jsComp ? jsComp : fwComp;
      return {
        componentFromFramework,
        componentClass,
        params: paramsMerged,
        type,
        popupFromSelector,
        popupPositionFromSelector,
        newAgStackInstance: () => this.newAgStackInstance(componentClass, componentFromFramework, paramsMerged, type)
      };
    }
    getCompKeys(defObject, type, params) {
      const { propertyName } = type;
      let compName;
      let jsComp;
      let fwComp;
      let paramsFromSelector;
      let popupFromSelector;
      let popupPositionFromSelector;
      if (defObject) {
        const defObjectAny = defObject;
        const selectorFunc = defObjectAny[propertyName + "Selector"];
        const selectorRes = selectorFunc ? selectorFunc(params) : null;
        const assignComp = (providedJsComp) => {
          if (typeof providedJsComp === "string") {
            compName = providedJsComp;
          } else if (providedJsComp != null && providedJsComp !== true) {
            const isFwkComp = this.getFrameworkOverrides().isFrameworkComponent(providedJsComp);
            if (isFwkComp) {
              fwComp = providedJsComp;
            } else {
              jsComp = providedJsComp;
            }
          }
        };
        if (selectorRes) {
          assignComp(selectorRes.component);
          paramsFromSelector = selectorRes.params;
          popupFromSelector = selectorRes.popup;
          popupPositionFromSelector = selectorRes.popupPosition;
        } else {
          assignComp(defObjectAny[propertyName]);
        }
      }
      return { compName, jsComp, fwComp, paramsFromSelector, popupFromSelector, popupPositionFromSelector };
    }
    newAgStackInstance(ComponentClass, componentFromFramework, params, type) {
      const propertyName = type.propertyName;
      const jsComponent = !componentFromFramework;
      let instance;
      if (jsComponent) {
        instance = new ComponentClass();
      } else {
        const thisComponentConfig = this.componentMetadataProvider.retrieve(propertyName);
        instance = this.frameworkComponentWrapper.wrap(
          ComponentClass,
          thisComponentConfig.mandatoryMethodList,
          thisComponentConfig.optionalMethodList,
          type
        );
      }
      const deferredInit = this.initComponent(instance, params);
      if (deferredInit == null) {
        return AgPromise.resolve(instance);
      }
      return deferredInit.then(() => instance);
    }
    // used by Floating Filter
    mergeParamsWithApplicationProvidedParams(defObject, type, paramsFromGrid, paramsFromSelector = null) {
      const params = this.gos.getGridCommonParams();
      mergeDeep(params, paramsFromGrid);
      const defObjectAny = defObject;
      const userParams = defObjectAny && defObjectAny[type.propertyName + "Params"];
      if (typeof userParams === "function") {
        const userParamsFromFunc = userParams(paramsFromGrid);
        mergeDeep(params, userParamsFromFunc);
      } else if (typeof userParams === "object") {
        mergeDeep(params, userParams);
      }
      mergeDeep(params, paramsFromSelector);
      return params;
    }
    initComponent(component, params) {
      this.context.createBean(component);
      if (component.init == null) {
        return;
      }
      return component.init(params);
    }
    getDefaultFloatingFilterType(def2, getFromDefault) {
      if (def2 == null) {
        return null;
      }
      let defaultFloatingFilterType = null;
      let { compName, jsComp, fwComp } = this.getCompKeys(def2, FilterComponent);
      if (compName) {
        defaultFloatingFilterType = FloatingFilterMapper.getFloatingFilterType(compName);
      } else {
        const usingDefaultFilter = jsComp == null && fwComp == null && def2.filter === true;
        if (usingDefaultFilter) {
          defaultFloatingFilterType = getFromDefault();
        }
      }
      return defaultFloatingFilterType;
    }
  };
  __decorateClass([
    Autowired("gridOptions")
  ], UserComponentFactory.prototype, "gridOptions", 2);
  __decorateClass([
    Autowired("agComponentUtils")
  ], UserComponentFactory.prototype, "agComponentUtils", 2);
  __decorateClass([
    Autowired("componentMetadataProvider")
  ], UserComponentFactory.prototype, "componentMetadataProvider", 2);
  __decorateClass([
    Autowired("userComponentRegistry")
  ], UserComponentFactory.prototype, "userComponentRegistry", 2);
  __decorateClass([
    Optional("frameworkComponentWrapper")
  ], UserComponentFactory.prototype, "frameworkComponentWrapper", 2);
  UserComponentFactory = __decorateClass([
    Bean("userComponentFactory")
  ], UserComponentFactory);
  var ExcelFactoryMode = /* @__PURE__ */ ((ExcelFactoryMode2) => {
    ExcelFactoryMode2[ExcelFactoryMode2["SINGLE_SHEET"] = 0] = "SINGLE_SHEET";
    ExcelFactoryMode2[ExcelFactoryMode2["MULTI_SHEET"] = 1] = "MULTI_SHEET";
    return ExcelFactoryMode2;
  })(ExcelFactoryMode || {});
  var RowHighlightPosition = /* @__PURE__ */ ((RowHighlightPosition2) => {
    RowHighlightPosition2[RowHighlightPosition2["Above"] = 0] = "Above";
    RowHighlightPosition2[RowHighlightPosition2["Below"] = 1] = "Below";
    return RowHighlightPosition2;
  })(RowHighlightPosition || {});
  var AutoScrollService = class {
    constructor(params) {
      this.tickingInterval = null;
      this.onScrollCallback = null;
      this.scrollContainer = params.scrollContainer;
      this.scrollHorizontally = params.scrollAxis.indexOf("x") !== -1;
      this.scrollVertically = params.scrollAxis.indexOf("y") !== -1;
      this.scrollByTick = params.scrollByTick != null ? params.scrollByTick : 20;
      if (params.onScrollCallback) {
        this.onScrollCallback = params.onScrollCallback;
      }
      if (this.scrollVertically) {
        this.getVerticalPosition = params.getVerticalPosition;
        this.setVerticalPosition = params.setVerticalPosition;
      }
      if (this.scrollHorizontally) {
        this.getHorizontalPosition = params.getHorizontalPosition;
        this.setHorizontalPosition = params.setHorizontalPosition;
      }
      this.shouldSkipVerticalScroll = params.shouldSkipVerticalScroll || (() => false);
      this.shouldSkipHorizontalScroll = params.shouldSkipHorizontalScroll || (() => false);
    }
    check(mouseEvent, forceSkipVerticalScroll = false) {
      const skipVerticalScroll = forceSkipVerticalScroll || this.shouldSkipVerticalScroll();
      if (skipVerticalScroll && this.shouldSkipHorizontalScroll()) {
        return;
      }
      const rect = this.scrollContainer.getBoundingClientRect();
      const scrollTick = this.scrollByTick;
      this.tickLeft = mouseEvent.clientX < rect.left + scrollTick;
      this.tickRight = mouseEvent.clientX > rect.right - scrollTick;
      this.tickUp = mouseEvent.clientY < rect.top + scrollTick && !skipVerticalScroll;
      this.tickDown = mouseEvent.clientY > rect.bottom - scrollTick && !skipVerticalScroll;
      if (this.tickLeft || this.tickRight || this.tickUp || this.tickDown) {
        this.ensureTickingStarted();
      } else {
        this.ensureCleared();
      }
    }
    ensureTickingStarted() {
      if (this.tickingInterval === null) {
        this.tickingInterval = window.setInterval(this.doTick.bind(this), 100);
        this.tickCount = 0;
      }
    }
    doTick() {
      this.tickCount++;
      let tickAmount;
      tickAmount = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40;
      if (this.scrollVertically) {
        const vScrollPosition = this.getVerticalPosition();
        if (this.tickUp) {
          this.setVerticalPosition(vScrollPosition - tickAmount);
        }
        if (this.tickDown) {
          this.setVerticalPosition(vScrollPosition + tickAmount);
        }
      }
      if (this.scrollHorizontally) {
        const hScrollPosition = this.getHorizontalPosition();
        if (this.tickLeft) {
          this.setHorizontalPosition(hScrollPosition - tickAmount);
        }
        if (this.tickRight) {
          this.setHorizontalPosition(hScrollPosition + tickAmount);
        }
      }
      if (this.onScrollCallback) {
        this.onScrollCallback();
      }
    }
    ensureCleared() {
      if (this.tickingInterval) {
        window.clearInterval(this.tickingInterval);
        this.tickingInterval = null;
      }
    }
  };
  var RowDragFeature = class extends BeanStub {
    constructor(eContainer) {
      super();
      this.eContainer = eContainer;
    }
    postConstruct() {
      if (this.gos.isRowModelType("clientSide")) {
        this.clientSideRowModel = this.rowModel;
      }
      this.ctrlsService.whenReady((p2) => {
        const gridBodyCon = p2.gridBodyCtrl;
        this.autoScrollService = new AutoScrollService({
          scrollContainer: gridBodyCon.getBodyViewportElement(),
          scrollAxis: "y",
          getVerticalPosition: () => gridBodyCon.getScrollFeature().getVScrollPosition().top,
          setVerticalPosition: (position) => gridBodyCon.getScrollFeature().setVerticalScrollPosition(position),
          onScrollCallback: () => {
            this.onDragging(this.lastDraggingEvent);
          }
        });
      });
    }
    getContainer() {
      return this.eContainer;
    }
    isInterestedIn(type) {
      return type === 2;
    }
    getIconName() {
      const managedDrag = this.gos.get("rowDragManaged");
      if (managedDrag && this.shouldPreventRowMove()) {
        return DragAndDropService.ICON_NOT_ALLOWED;
      }
      return DragAndDropService.ICON_MOVE;
    }
    shouldPreventRowMove() {
      const rowGroupCols = this.columnModel.getRowGroupColumns();
      if (rowGroupCols.length) {
        return true;
      }
      const isFilterPresent = this.filterManager.isAnyFilterPresent();
      if (isFilterPresent) {
        return true;
      }
      const isSortActive = this.sortController.isSortActive();
      if (isSortActive) {
        return true;
      }
      return false;
    }
    getRowNodes(draggingEvent) {
      if (!this.isFromThisGrid(draggingEvent)) {
        return draggingEvent.dragItem.rowNodes || [];
      }
      const currentNode = draggingEvent.dragItem.rowNode;
      const isRowDragMultiRow = this.gos.get("rowDragMultiRow");
      if (isRowDragMultiRow) {
        const selectedNodes = [...this.selectionService.getSelectedNodes()].sort(
          (a, b) => {
            if (a.rowIndex == null || b.rowIndex == null) {
              return 0;
            }
            return this.getRowIndexNumber(a) - this.getRowIndexNumber(b);
          }
        );
        if (selectedNodes.indexOf(currentNode) !== -1) {
          return selectedNodes;
        }
      }
      return [currentNode];
    }
    onDragEnter(draggingEvent) {
      draggingEvent.dragItem.rowNodes = this.getRowNodes(draggingEvent);
      this.dispatchGridEvent(Events.EVENT_ROW_DRAG_ENTER, draggingEvent);
      this.getRowNodes(draggingEvent).forEach((rowNode) => {
        rowNode.setDragging(true);
      });
      this.onEnterOrDragging(draggingEvent);
    }
    onDragging(draggingEvent) {
      this.onEnterOrDragging(draggingEvent);
    }
    isFromThisGrid(draggingEvent) {
      const { dragSourceDomDataKey } = draggingEvent.dragSource;
      return dragSourceDomDataKey === this.gos.getDomDataKey();
    }
    isDropZoneWithinThisGrid(draggingEvent) {
      const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
      const gridGui = gridBodyCon.getGui();
      const { dropZoneTarget } = draggingEvent;
      return !gridGui.contains(dropZoneTarget);
    }
    onEnterOrDragging(draggingEvent) {
      this.dispatchGridEvent(Events.EVENT_ROW_DRAG_MOVE, draggingEvent);
      this.lastDraggingEvent = draggingEvent;
      const pixel = this.mouseEventService.getNormalisedPosition(draggingEvent).y;
      const managedDrag = this.gos.get("rowDragManaged");
      if (managedDrag) {
        this.doManagedDrag(draggingEvent, pixel);
      }
      this.autoScrollService.check(draggingEvent.event);
    }
    doManagedDrag(draggingEvent, pixel) {
      const isFromThisGrid = this.isFromThisGrid(draggingEvent);
      const managedDrag = this.gos.get("rowDragManaged");
      const rowNodes = draggingEvent.dragItem.rowNodes;
      if (managedDrag && this.shouldPreventRowMove()) {
        return;
      }
      if (this.gos.get("suppressMoveWhenRowDragging") || !isFromThisGrid) {
        if (!this.isDropZoneWithinThisGrid(draggingEvent)) {
          this.clientSideRowModel.highlightRowAtPixel(rowNodes[0], pixel);
        }
      } else {
        this.moveRows(rowNodes, pixel);
      }
    }
    getRowIndexNumber(rowNode) {
      return parseInt(last(rowNode.getRowIndexString().split("-")), 10);
    }
    moveRowAndClearHighlight(draggingEvent) {
      const lastHighlightedRowNode = this.clientSideRowModel.getLastHighlightedRowNode();
      const isBelow = lastHighlightedRowNode && lastHighlightedRowNode.highlighted === 1;
      const pixel = this.mouseEventService.getNormalisedPosition(draggingEvent).y;
      const rowNodes = draggingEvent.dragItem.rowNodes;
      let increment = isBelow ? 1 : 0;
      if (this.isFromThisGrid(draggingEvent)) {
        rowNodes.forEach((rowNode) => {
          if (rowNode.rowTop < pixel) {
            increment -= 1;
          }
        });
        this.moveRows(rowNodes, pixel, increment);
      } else {
        const getRowIdFunc = this.gos.getCallback("getRowId");
        let addIndex = this.clientSideRowModel.getRowIndexAtPixel(pixel) + 1;
        if (this.clientSideRowModel.getHighlightPosition(pixel) === 0) {
          addIndex--;
        }
        this.clientSideRowModel.updateRowData({
          add: rowNodes.map((node) => node.data).filter(
            (data) => !this.clientSideRowModel.getRowNode(
              getRowIdFunc ? getRowIdFunc({ data, level: 0 }) : data.id
            )
          ),
          addIndex
        });
      }
      this.clearRowHighlight();
    }
    clearRowHighlight() {
      this.clientSideRowModel.highlightRowAtPixel(null);
    }
    moveRows(rowNodes, pixel, increment = 0) {
      var _a;
      const rowWasMoved = this.clientSideRowModel.ensureRowsAtPixel(rowNodes, pixel, increment);
      if (rowWasMoved) {
        this.focusService.clearFocusedCell();
        (_a = this.rangeService) == null ? void 0 : _a.removeAllCellRanges();
      }
    }
    addRowDropZone(params) {
      if (!params.getContainer()) {
        warnOnce("addRowDropZone - A container target needs to be provided");
        return;
      }
      if (this.dragAndDropService.findExternalZone(params)) {
        console.warn("AG Grid: addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again.");
        return;
      }
      let processedParams = {
        getContainer: params.getContainer
      };
      if (params.fromGrid) {
        processedParams = params;
      } else {
        if (params.onDragEnter) {
          processedParams.onDragEnter = (e) => {
            params.onDragEnter(this.draggingToRowDragEvent(Events.EVENT_ROW_DRAG_ENTER, e));
          };
        }
        if (params.onDragLeave) {
          processedParams.onDragLeave = (e) => {
            params.onDragLeave(this.draggingToRowDragEvent(Events.EVENT_ROW_DRAG_LEAVE, e));
          };
        }
        if (params.onDragging) {
          processedParams.onDragging = (e) => {
            params.onDragging(this.draggingToRowDragEvent(Events.EVENT_ROW_DRAG_MOVE, e));
          };
        }
        if (params.onDragStop) {
          processedParams.onDragStop = (e) => {
            params.onDragStop(this.draggingToRowDragEvent(Events.EVENT_ROW_DRAG_END, e));
          };
        }
      }
      this.dragAndDropService.addDropTarget(__spreadValues({
        isInterestedIn: (type) => type === 2,
        getIconName: () => DragAndDropService.ICON_MOVE,
        external: true
      }, processedParams));
    }
    getRowDropZone(events) {
      const getContainer = this.getContainer.bind(this);
      const onDragEnter = this.onDragEnter.bind(this);
      const onDragLeave = this.onDragLeave.bind(this);
      const onDragging = this.onDragging.bind(this);
      const onDragStop = this.onDragStop.bind(this);
      if (!events) {
        return {
          getContainer,
          onDragEnter,
          onDragLeave,
          onDragging,
          onDragStop,
          /* @private */
          fromGrid: true
        };
      }
      return {
        getContainer,
        onDragEnter: events.onDragEnter ? (e) => {
          onDragEnter(e);
          events.onDragEnter(this.draggingToRowDragEvent(Events.EVENT_ROW_DRAG_ENTER, e));
        } : onDragEnter,
        onDragLeave: events.onDragLeave ? (e) => {
          onDragLeave(e);
          events.onDragLeave(this.draggingToRowDragEvent(Events.EVENT_ROW_DRAG_LEAVE, e));
        } : onDragLeave,
        onDragging: events.onDragging ? (e) => {
          onDragging(e);
          events.onDragging(this.draggingToRowDragEvent(Events.EVENT_ROW_DRAG_MOVE, e));
        } : onDragging,
        onDragStop: events.onDragStop ? (e) => {
          onDragStop(e);
          events.onDragStop(this.draggingToRowDragEvent(Events.EVENT_ROW_DRAG_END, e));
        } : onDragStop,
        fromGrid: true
        /* @private */
      };
    }
    draggingToRowDragEvent(type, draggingEvent) {
      const yNormalised = this.mouseEventService.getNormalisedPosition(draggingEvent).y;
      const mouseIsPastLastRow = yNormalised > this.paginationProxy.getCurrentPageHeight();
      let overIndex = -1;
      let overNode;
      if (!mouseIsPastLastRow) {
        overIndex = this.rowModel.getRowIndexAtPixel(yNormalised);
        overNode = this.rowModel.getRow(overIndex);
      }
      let vDirectionString;
      switch (draggingEvent.vDirection) {
        case 1:
          vDirectionString = "down";
          break;
        case 0:
          vDirectionString = "up";
          break;
        default:
          vDirectionString = null;
          break;
      }
      const event = this.gos.addGridCommonParams({
        type,
        event: draggingEvent.event,
        node: draggingEvent.dragItem.rowNode,
        nodes: draggingEvent.dragItem.rowNodes,
        overIndex,
        overNode,
        y: yNormalised,
        vDirection: vDirectionString
      });
      return event;
    }
    dispatchGridEvent(type, draggingEvent) {
      const event = this.draggingToRowDragEvent(type, draggingEvent);
      this.eventService.dispatchEvent(event);
    }
    onDragLeave(draggingEvent) {
      this.dispatchGridEvent(Events.EVENT_ROW_DRAG_LEAVE, draggingEvent);
      this.stopDragging(draggingEvent);
      if (this.gos.get("rowDragManaged")) {
        this.clearRowHighlight();
      }
    }
    onDragStop(draggingEvent) {
      this.dispatchGridEvent(Events.EVENT_ROW_DRAG_END, draggingEvent);
      this.stopDragging(draggingEvent);
      if (this.gos.get("rowDragManaged") && (this.gos.get("suppressMoveWhenRowDragging") || !this.isFromThisGrid(draggingEvent)) && !this.isDropZoneWithinThisGrid(draggingEvent)) {
        this.moveRowAndClearHighlight(draggingEvent);
      }
    }
    stopDragging(draggingEvent) {
      this.autoScrollService.ensureCleared();
      this.getRowNodes(draggingEvent).forEach((rowNode) => {
        rowNode.setDragging(false);
      });
    }
  };
  __decorateClass([
    Autowired("dragAndDropService")
  ], RowDragFeature.prototype, "dragAndDropService", 2);
  __decorateClass([
    Autowired("rowModel")
  ], RowDragFeature.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("paginationProxy")
  ], RowDragFeature.prototype, "paginationProxy", 2);
  __decorateClass([
    Autowired("columnModel")
  ], RowDragFeature.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("focusService")
  ], RowDragFeature.prototype, "focusService", 2);
  __decorateClass([
    Autowired("sortController")
  ], RowDragFeature.prototype, "sortController", 2);
  __decorateClass([
    Autowired("filterManager")
  ], RowDragFeature.prototype, "filterManager", 2);
  __decorateClass([
    Autowired("selectionService")
  ], RowDragFeature.prototype, "selectionService", 2);
  __decorateClass([
    Autowired("mouseEventService")
  ], RowDragFeature.prototype, "mouseEventService", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], RowDragFeature.prototype, "ctrlsService", 2);
  __decorateClass([
    Optional("rangeService")
  ], RowDragFeature.prototype, "rangeService", 2);
  __decorateClass([
    PostConstruct
  ], RowDragFeature.prototype, "postConstruct", 1);
  var DragService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.dragEndFunctions = [];
      this.dragSources = [];
    }
    removeAllListeners() {
      this.dragSources.forEach(this.removeListener.bind(this));
      this.dragSources.length = 0;
    }
    removeListener(dragSourceAndListener) {
      const element = dragSourceAndListener.dragSource.eElement;
      const mouseDownListener = dragSourceAndListener.mouseDownListener;
      element.removeEventListener("mousedown", mouseDownListener);
      if (dragSourceAndListener.touchEnabled) {
        const touchStartListener = dragSourceAndListener.touchStartListener;
        element.removeEventListener("touchstart", touchStartListener, { passive: true });
      }
    }
    removeDragSource(params) {
      const dragSourceAndListener = this.dragSources.find((item) => item.dragSource === params);
      if (!dragSourceAndListener) {
        return;
      }
      this.removeListener(dragSourceAndListener);
      removeFromArray(this.dragSources, dragSourceAndListener);
    }
    isDragging() {
      return this.dragging;
    }
    addDragSource(params) {
      const mouseListener = this.onMouseDown.bind(this, params);
      const { eElement, includeTouch, stopPropagationForTouch } = params;
      eElement.addEventListener("mousedown", mouseListener);
      let touchListener = null;
      const suppressTouch = this.gos.get("suppressTouch");
      if (includeTouch && !suppressTouch) {
        touchListener = (touchEvent) => {
          if (isFocusableFormField(touchEvent.target)) {
            return;
          }
          if (touchEvent.cancelable) {
            touchEvent.preventDefault();
            if (stopPropagationForTouch) {
              touchEvent.stopPropagation();
            }
          }
          this.onTouchStart(params, touchEvent);
        };
        eElement.addEventListener("touchstart", touchListener, { passive: false });
      }
      this.dragSources.push({
        dragSource: params,
        mouseDownListener: mouseListener,
        touchStartListener: touchListener,
        touchEnabled: !!includeTouch
      });
    }
    getStartTarget() {
      return this.startTarget;
    }
    // gets called whenever mouse down on any drag source
    onTouchStart(params, touchEvent) {
      this.currentDragParams = params;
      this.dragging = false;
      const touch = touchEvent.touches[0];
      this.touchLastTime = touch;
      this.touchStart = touch;
      const touchMoveEvent = (e) => this.onTouchMove(e, params.eElement);
      const touchEndEvent = (e) => this.onTouchUp(e, params.eElement);
      const documentTouchMove = (e) => {
        if (e.cancelable) {
          e.preventDefault();
        }
      };
      const target = touchEvent.target;
      const events = [
        // Prevents the page document from moving while we are dragging items around.
        // preventDefault needs to be called in the touchmove listener and never inside the
        // touchstart, because using touchstart causes the click event to be cancelled on touch devices.
        { target: this.gos.getRootNode(), type: "touchmove", listener: documentTouchMove, options: { passive: false } },
        { target, type: "touchmove", listener: touchMoveEvent, options: { passive: true } },
        { target, type: "touchend", listener: touchEndEvent, options: { passive: true } },
        { target, type: "touchcancel", listener: touchEndEvent, options: { passive: true } }
      ];
      this.addTemporaryEvents(events);
      if (params.dragStartPixels === 0) {
        this.onCommonMove(touch, this.touchStart, params.eElement);
      }
    }
    // gets called whenever mouse down on any drag source
    onMouseDown(params, mouseEvent) {
      const e = mouseEvent;
      if (params.skipMouseEvent && params.skipMouseEvent(mouseEvent)) {
        return;
      }
      if (e._alreadyProcessedByDragService) {
        return;
      }
      e._alreadyProcessedByDragService = true;
      if (mouseEvent.button !== 0) {
        return;
      }
      if (this.shouldPreventMouseEvent(mouseEvent)) {
        mouseEvent.preventDefault();
      }
      this.currentDragParams = params;
      this.dragging = false;
      this.mouseStartEvent = mouseEvent;
      this.startTarget = mouseEvent.target;
      const mouseMoveEvent = (event) => this.onMouseMove(event, params.eElement);
      const mouseUpEvent = (event) => this.onMouseUp(event, params.eElement);
      const contextEvent = (event) => event.preventDefault();
      const target = this.gos.getRootNode();
      const events = [
        { target, type: "mousemove", listener: mouseMoveEvent },
        { target, type: "mouseup", listener: mouseUpEvent },
        { target, type: "contextmenu", listener: contextEvent }
      ];
      this.addTemporaryEvents(events);
      if (params.dragStartPixels === 0) {
        this.onMouseMove(mouseEvent, params.eElement);
      }
    }
    addTemporaryEvents(events) {
      events.forEach((currentEvent) => {
        const { target, type, listener, options } = currentEvent;
        target.addEventListener(type, listener, options);
      });
      this.dragEndFunctions.push(() => {
        events.forEach((currentEvent) => {
          const { target, type, listener, options } = currentEvent;
          target.removeEventListener(type, listener, options);
        });
      });
    }
    // returns true if the event is close to the original event by X pixels either vertically or horizontally.
    // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
    isEventNearStartEvent(currentEvent, startEvent) {
      const { dragStartPixels } = this.currentDragParams;
      const requiredPixelDiff = exists(dragStartPixels) ? dragStartPixels : 4;
      return areEventsNear(currentEvent, startEvent, requiredPixelDiff);
    }
    getFirstActiveTouch(touchList) {
      for (let i = 0; i < touchList.length; i++) {
        if (touchList[i].identifier === this.touchStart.identifier) {
          return touchList[i];
        }
      }
      return null;
    }
    onCommonMove(currentEvent, startEvent, el) {
      if (!this.dragging) {
        if (!this.dragging && this.isEventNearStartEvent(currentEvent, startEvent)) {
          return;
        }
        this.dragging = true;
        const event = {
          type: Events.EVENT_DRAG_STARTED,
          target: el
        };
        this.eventService.dispatchEvent(event);
        this.currentDragParams.onDragStart(startEvent);
        this.currentDragParams.onDragging(startEvent);
      }
      this.currentDragParams.onDragging(currentEvent);
    }
    onTouchMove(touchEvent, el) {
      const touch = this.getFirstActiveTouch(touchEvent.touches);
      if (!touch) {
        return;
      }
      this.onCommonMove(touch, this.touchStart, el);
    }
    // only gets called after a mouse down - as this is only added after mouseDown
    // and is removed when mouseUp happens
    onMouseMove(mouseEvent, el) {
      var _a;
      if (isBrowserSafari()) {
        const eDocument = this.gos.getDocument();
        (_a = eDocument.getSelection()) == null ? void 0 : _a.removeAllRanges();
      }
      if (this.shouldPreventMouseEvent(mouseEvent)) {
        mouseEvent.preventDefault();
      }
      this.onCommonMove(mouseEvent, this.mouseStartEvent, el);
    }
    shouldPreventMouseEvent(mouseEvent) {
      const isEnableCellTextSelect = this.gos.get("enableCellTextSelection");
      const isMouseMove = mouseEvent.type === "mousemove";
      return (
        // when `isEnableCellTextSelect` is `true`, we need to preventDefault on mouseMove
        // to avoid the grid text being selected while dragging components.
        isEnableCellTextSelect && isMouseMove && mouseEvent.cancelable && this.mouseEventService.isEventFromThisGrid(mouseEvent) && !this.isOverFormFieldElement(mouseEvent)
      );
    }
    isOverFormFieldElement(mouseEvent) {
      const el = mouseEvent.target;
      const tagName = el == null ? void 0 : el.tagName.toLocaleLowerCase();
      return !!(tagName == null ? void 0 : tagName.match("^a$|textarea|input|select|button"));
    }
    onTouchUp(touchEvent, el) {
      let touch = this.getFirstActiveTouch(touchEvent.changedTouches);
      if (!touch) {
        touch = this.touchLastTime;
      }
      this.onUpCommon(touch, el);
    }
    onMouseUp(mouseEvent, el) {
      this.onUpCommon(mouseEvent, el);
    }
    onUpCommon(eventOrTouch, el) {
      if (this.dragging) {
        this.dragging = false;
        this.currentDragParams.onDragStop(eventOrTouch);
        const event = {
          type: Events.EVENT_DRAG_STOPPED,
          target: el
        };
        this.eventService.dispatchEvent(event);
      }
      this.mouseStartEvent = null;
      this.startTarget = null;
      this.touchStart = null;
      this.touchLastTime = null;
      this.currentDragParams = null;
      this.dragEndFunctions.forEach((func) => func());
      this.dragEndFunctions.length = 0;
    }
  };
  __decorateClass([
    Autowired("mouseEventService")
  ], DragService.prototype, "mouseEventService", 2);
  __decorateClass([
    PreDestroy
  ], DragService.prototype, "removeAllListeners", 1);
  DragService = __decorateClass([
    Bean("dragService")
  ], DragService);
  var LIST_ITEM_HOVERED = "ag-list-item-hovered";
  var VirtualListDragFeature = class extends BeanStub {
    constructor(comp, virtualList, params) {
      super();
      this.comp = comp;
      this.virtualList = virtualList;
      this.params = params;
      this.currentDragValue = null;
      this.lastHoveredListItem = null;
    }
    postConstruct() {
      this.addManagedListener(this.params.eventSource, this.params.listItemDragStartEvent, this.listItemDragStart.bind(this));
      this.addManagedListener(this.params.eventSource, this.params.listItemDragEndEvent, this.listItemDragEnd.bind(this));
      this.createDropTarget();
      this.createAutoScrollService();
    }
    listItemDragStart(event) {
      this.currentDragValue = this.params.getCurrentDragValue(event);
      this.moveBlocked = this.params.isMoveBlocked(this.currentDragValue);
    }
    listItemDragEnd() {
      window.setTimeout(() => {
        this.currentDragValue = null;
        this.moveBlocked = false;
      }, 10);
    }
    createDropTarget() {
      const dropTarget = {
        isInterestedIn: (type) => type === this.params.dragSourceType,
        getIconName: () => this.moveBlocked ? DragAndDropService.ICON_PINNED : DragAndDropService.ICON_MOVE,
        getContainer: () => this.comp.getGui(),
        onDragging: (e) => this.onDragging(e),
        onDragStop: () => this.onDragStop(),
        onDragLeave: () => this.onDragLeave()
      };
      this.dragAndDropService.addDropTarget(dropTarget);
    }
    createAutoScrollService() {
      const virtualListGui = this.virtualList.getGui();
      this.autoScrollService = new AutoScrollService({
        scrollContainer: virtualListGui,
        scrollAxis: "y",
        getVerticalPosition: () => virtualListGui.scrollTop,
        setVerticalPosition: (position) => virtualListGui.scrollTop = position
      });
    }
    onDragging(e) {
      if (!this.currentDragValue || this.moveBlocked) {
        return;
      }
      const hoveredListItem = this.getListDragItem(e);
      const comp = this.virtualList.getComponentAt(hoveredListItem.rowIndex);
      if (!comp) {
        return;
      }
      const el = comp.getGui().parentElement;
      if (this.lastHoveredListItem && this.lastHoveredListItem.rowIndex === hoveredListItem.rowIndex && this.lastHoveredListItem.position === hoveredListItem.position) {
        return;
      }
      this.autoScrollService.check(e.event);
      this.clearHoveredItems();
      this.lastHoveredListItem = hoveredListItem;
      radioCssClass(el, LIST_ITEM_HOVERED);
      radioCssClass(el, `ag-item-highlight-${hoveredListItem.position}`);
    }
    getListDragItem(e) {
      const virtualListGui = this.virtualList.getGui();
      const paddingTop = parseFloat(window.getComputedStyle(virtualListGui).paddingTop);
      const rowHeight = this.virtualList.getRowHeight();
      const scrollTop = this.virtualList.getScrollTop();
      const rowIndex = Math.max(0, (e.y - paddingTop + scrollTop) / rowHeight);
      const maxLen = this.params.getNumRows(this.comp) - 1;
      const normalizedRowIndex = Math.min(maxLen, rowIndex) | 0;
      return {
        rowIndex: normalizedRowIndex,
        position: Math.round(rowIndex) > rowIndex || rowIndex > maxLen ? "bottom" : "top",
        component: this.virtualList.getComponentAt(normalizedRowIndex)
      };
    }
    onDragStop() {
      if (this.moveBlocked) {
        return;
      }
      this.params.moveItem(this.currentDragValue, this.lastHoveredListItem);
      this.clearHoveredItems();
      this.autoScrollService.ensureCleared();
    }
    onDragLeave() {
      this.clearHoveredItems();
      this.autoScrollService.ensureCleared();
    }
    clearHoveredItems() {
      const virtualListGui = this.virtualList.getGui();
      virtualListGui.querySelectorAll(`.${LIST_ITEM_HOVERED}`).forEach((el) => {
        [
          LIST_ITEM_HOVERED,
          "ag-item-highlight-top",
          "ag-item-highlight-bottom"
        ].forEach((cls) => {
          el.classList.remove(cls);
        });
      });
      this.lastHoveredListItem = null;
    }
  };
  __decorateClass([
    Autowired("dragAndDropService")
  ], VirtualListDragFeature.prototype, "dragAndDropService", 2);
  __decorateClass([
    PostConstruct
  ], VirtualListDragFeature.prototype, "postConstruct", 1);
  function unwrapUserComp(comp) {
    const compAsAny = comp;
    const isProxy2 = compAsAny != null && compAsAny.getFrameworkComponentInstance != null;
    return isProxy2 ? compAsAny.getFrameworkComponentInstance() : comp;
  }
  var GridApi = class {
    constructor() {
      this.detailGridInfoMap = {};
      this.destroyCalled = false;
    }
    init() {
      switch (this.rowModel.getType()) {
        case "clientSide":
          this.clientSideRowModel = this.rowModel;
          break;
        case "infinite":
          this.infiniteRowModel = this.rowModel;
          break;
        case "serverSide":
          this.serverSideRowModel = this.rowModel;
          break;
      }
      this.ctrlsService.whenReady((p2) => {
        this.gridBodyCtrl = p2.gridBodyCtrl;
      });
    }
    /** Used internally by grid. Not intended to be used by the client. Interface may change between releases. */
    __getAlignedGridService() {
      return this.alignedGridsService;
    }
    /** Returns the `gridId` for the current grid as specified via the gridOptions property `gridId` or the auto assigned grid id if none was provided. */
    getGridId() {
      return this.context.getGridId();
    }
    /** Register a detail grid with the master grid when it is created. */
    addDetailGridInfo(id, gridInfo) {
      this.detailGridInfoMap[id] = gridInfo;
    }
    /** Unregister a detail grid from the master grid when it is destroyed. */
    removeDetailGridInfo(id) {
      delete this.detailGridInfoMap[id];
    }
    /** Returns the `DetailGridInfo` corresponding to the supplied `detailGridId`. */
    getDetailGridInfo(id) {
      return this.detailGridInfoMap[id];
    }
    /** Iterates through each `DetailGridInfo` in the grid and calls the supplied callback on each. */
    forEachDetailGridInfo(callback) {
      let index = 0;
      iterateObject(this.detailGridInfoMap, (id, gridInfo) => {
        if (exists(gridInfo)) {
          callback(gridInfo, index);
          index++;
        }
      });
    }
    /** Similar to `exportDataAsCsv`, except returns the result as a string rather than download it. */
    getDataAsCsv(params) {
      if (ModuleRegistry.__assertRegistered("@ag-grid-community/csv-export", "api.getDataAsCsv", this.context.getGridId())) {
        return this.csvCreator.getDataAsCsv(params);
      }
    }
    /** Downloads a CSV export of the grid's data. */
    exportDataAsCsv(params) {
      if (ModuleRegistry.__assertRegistered("@ag-grid-community/csv-export", "api.exportDataAsCsv", this.context.getGridId())) {
        this.csvCreator.exportDataAsCsv(params);
      }
    }
    assertNotExcelMultiSheet(method, params) {
      if (!ModuleRegistry.__assertRegistered("@ag-grid-enterprise/excel-export", "api." + method, this.context.getGridId())) {
        return false;
      }
      if (this.excelCreator.getFactoryMode() === 1) {
        console.warn("AG Grid: The Excel Exporter is currently on Multi Sheet mode. End that operation by calling 'api.getMultipleSheetAsExcel()' or 'api.exportMultipleSheetsAsExcel()'");
        return false;
      }
      return true;
    }
    /** Similar to `exportDataAsExcel`, except instead of downloading a file, it will return a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob) to be processed by the user. */
    getDataAsExcel(params) {
      if (this.assertNotExcelMultiSheet("getDataAsExcel", params)) {
        return this.excelCreator.getDataAsExcel(params);
      }
    }
    /** Downloads an Excel export of the grid's data. */
    exportDataAsExcel(params) {
      if (this.assertNotExcelMultiSheet("exportDataAsExcel", params)) {
        this.excelCreator.exportDataAsExcel(params);
      }
    }
    /** This is method to be used to get the grid's data as a sheet, that will later be exported either by `getMultipleSheetsAsExcel()` or `exportMultipleSheetsAsExcel()`. */
    getSheetDataForExcel(params) {
      if (!ModuleRegistry.__assertRegistered("@ag-grid-enterprise/excel-export", "api.getSheetDataForExcel", this.context.getGridId())) {
        return;
      }
      this.excelCreator.setFactoryMode(
        1
        /* MULTI_SHEET */
      );
      return this.excelCreator.getSheetDataForExcel(params);
    }
    /** Similar to `exportMultipleSheetsAsExcel`, except instead of downloading a file, it will return a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob) to be processed by the user. */
    getMultipleSheetsAsExcel(params) {
      if (ModuleRegistry.__assertRegistered("@ag-grid-enterprise/excel-export", "api.getMultipleSheetsAsExcel", this.context.getGridId())) {
        return this.excelCreator.getMultipleSheetsAsExcel(params);
      }
    }
    /** Downloads an Excel export of multiple sheets in one file. */
    exportMultipleSheetsAsExcel(params) {
      if (ModuleRegistry.__assertRegistered("@ag-grid-enterprise/excel-export", "api.exportMultipleSheetsAsExcel", this.context.getGridId())) {
        this.excelCreator.exportMultipleSheetsAsExcel(params);
      }
    }
    /**
     * Sets an ARIA property in the grid panel (element with `role=\"grid\"`), and removes an ARIA property when the value is null.
     *
     * Example: `api.setGridAriaProperty('label', 'my grid')` will set `aria-label=\"my grid\"`.
     *
     * `api.setGridAriaProperty('label', null)` will remove the `aria-label` attribute from the grid element.
     */
    setGridAriaProperty(property, value) {
      if (!property) {
        return;
      }
      const eGrid = this.ctrlsService.getGridBodyCtrl().getGui();
      const ariaProperty = `aria-${property}`;
      if (value === null) {
        eGrid.removeAttribute(ariaProperty);
      } else {
        eGrid.setAttribute(ariaProperty, value);
      }
    }
    logMissingRowModel(apiMethod, ...requiredRowModels) {
      console.error(`AG Grid: api.${apiMethod} can only be called when gridOptions.rowModelType is ${requiredRowModels.join(" or ")}`);
    }
    logDeprecation(version2, apiMethod, replacement, message) {
      warnOnce(`Since ${version2} api.${apiMethod} is deprecated. Please use ${replacement} instead. ${message != null ? message : ""}`);
    }
    /** Gets the number of top pinned rows. */
    getPinnedTopRowCount() {
      return this.pinnedRowModel.getPinnedTopRowCount();
    }
    /** Gets the number of bottom pinned rows. */
    getPinnedBottomRowCount() {
      return this.pinnedRowModel.getPinnedBottomRowCount();
    }
    /** Gets the top pinned row with the specified index. */
    getPinnedTopRow(index) {
      return this.pinnedRowModel.getPinnedTopRow(index);
    }
    /** Gets the bottom pinned row with the specified index. */
    getPinnedBottomRow(index) {
      return this.pinnedRowModel.getPinnedBottomRow(index);
    }
    expireValueCache() {
      this.valueCache.expire();
    }
    /**
     * Returns an object with two properties:
     *  - `top`: The top pixel position of the current scroll in the grid
     *  - `bottom`: The bottom pixel position of the current scroll in the grid
     */
    getVerticalPixelRange() {
      return this.gridBodyCtrl.getScrollFeature().getVScrollPosition();
    }
    /**
     * Returns an object with two properties:
     * - `left`: The left pixel position of the current scroll in the grid
     * - `right`: The right pixel position of the current scroll in the grid
     */
    getHorizontalPixelRange() {
      return this.gridBodyCtrl.getScrollFeature().getHScrollPosition();
    }
    /** Performs change detection on all cells, refreshing cells where required. */
    refreshCells(params = {}) {
      this.frameworkOverrides.wrapIncoming(() => this.rowRenderer.refreshCells(params));
    }
    /** Flash rows, columns or individual cells. */
    flashCells(params = {}) {
      const warning = (prop) => warnOnce(`Since v31.1 api.flashCells parameter '${prop}Delay' is deprecated. Please use '${prop}Duration' instead.`);
      if (exists(params.fadeDelay)) {
        warning("fade");
      }
      if (exists(params.flashDelay)) {
        warning("flash");
      }
      this.frameworkOverrides.wrapIncoming(() => this.rowRenderer.flashCells(params));
    }
    /** Remove row(s) from the DOM and recreate them again from scratch. */
    redrawRows(params = {}) {
      const rowNodes = params ? params.rowNodes : void 0;
      this.frameworkOverrides.wrapIncoming(() => this.rowRenderer.redrawRows(rowNodes));
    }
    /** Redraws the header. Useful if a column name changes, or something else that changes how the column header is displayed. */
    refreshHeader() {
      this.frameworkOverrides.wrapIncoming(() => this.ctrlsService.getHeaderRowContainerCtrls().forEach((c) => c.refresh()));
    }
    /** Returns `true` if any filter is set. This includes quick filter, column filter, external filter or advanced filter. */
    isAnyFilterPresent() {
      return this.filterManager.isAnyFilterPresent();
    }
    /** Returns `true` if any column filter is set, otherwise `false`. */
    isColumnFilterPresent() {
      return this.filterManager.isColumnFilterPresent() || this.filterManager.isAggregateFilterPresent();
    }
    /** Returns `true` if the Quick Filter is set, otherwise `false`. */
    isQuickFilterPresent() {
      return this.filterManager.isQuickFilterPresent();
    }
    /**
     * Returns the row model inside the table.
     * From here you can see the original rows, rows after filter has been applied,
     * rows after aggregation has been applied, and the final set of 'to be displayed' rows.
     *
     * @deprecated As of v31.1, getModel() is deprecated and will not be available in future versions.
     * Please use the appropriate grid API methods instead
     */
    getModel() {
      warnOnce("Since v31.1 getModel() is deprecated. Please use the appropriate grid API methods instead.");
      return this.rowModel;
    }
    /** 
     * Expand or collapse a specific row node, optionally expanding/collapsing all of its parent nodes.
     * By default rows are expanded asynchronously for best performance. Set forceSync: `true` if you need to interact with the expanded row immediately after this function.
     */
    setRowNodeExpanded(rowNode, expanded, expandParents, forceSync) {
      this.expansionService.setRowNodeExpanded(rowNode, expanded, expandParents, forceSync);
    }
    /**
     * Informs the grid that row group expanded state has changed and it needs to rerender the group nodes.
     * Typically called after updating the row node expanded state explicitly, i.e `rowNode.expanded = false`,
     * across multiple groups and you want to update the grid view in a single rerender instead of on every group change.
     */
    onGroupExpandedOrCollapsed() {
      if (missing(this.clientSideRowModel)) {
        this.logMissingRowModel("onGroupExpandedOrCollapsed", "clientSide");
        return;
      }
      this.expansionService.onGroupExpandedOrCollapsed();
    }
    /**
     * Refresh the Client-Side Row Model, executing the grouping, filtering and sorting again.
     * Optionally provide the step you wish the refresh to apply from. Defaults to `everything`.
     */
    refreshClientSideRowModel(step) {
      if (missing(this.clientSideRowModel)) {
        this.logMissingRowModel("refreshClientSideRowModel", "clientSide");
        return;
      }
      this.clientSideRowModel.refreshModel(step);
    }
    /** Returns `true` when there are no more animation frames left to process. */
    isAnimationFrameQueueEmpty() {
      return this.animationFrameService.isQueueEmpty();
    }
    flushAllAnimationFrames() {
      this.animationFrameService.flushAllFrames();
    }
    /**
     * Returns the row node with the given ID.
     * The row node ID is the one you provide from the callback `getRowId(params)`,
     * otherwise the ID is a number (cast as string) auto-generated by the grid when
     * the row data is set.
     */
    getRowNode(id) {
      return this.rowModel.getRowNode(id);
    }
    /**
     * Gets the sizes that various UI elements will be rendered at with the current theme.
     * If you override the row or header height using `gridOptions`, the override value you provided will be returned.
     */
    getSizesForCurrentTheme() {
      return {
        rowHeight: this.gos.getRowHeightAsNumber(),
        headerHeight: this.columnModel.getHeaderHeight()
      };
    }
    /** Expand all groups. */
    expandAll() {
      if (this.clientSideRowModel || this.serverSideRowModel) {
        this.expansionService.expandAll(true);
      } else {
        this.logMissingRowModel("expandAll", "clientSide", "serverSide");
      }
    }
    /** Collapse all groups. */
    collapseAll() {
      if (this.clientSideRowModel || this.serverSideRowModel) {
        this.expansionService.expandAll(false);
      } else {
        this.logMissingRowModel("collapseAll", "clientSide", "serverSide");
      }
    }
    /**
     * Registers a callback to a virtual row.
     * A virtual row is a row that is visually rendered on the screen (rows that are not visible because of the scroll position are not rendered).
     * Unlike normal events, you do not need to unregister rendered row listeners.
     * When the rendered row is removed from the grid, all associated rendered row listeners will also be removed.
     * listen for this event if your `cellRenderer` needs to do cleanup when the row no longer exists.
     */
    addRenderedRowListener(eventName, rowIndex, callback) {
      this.rowRenderer.addRenderedRowListener(eventName, rowIndex, callback);
    }
    /** Get the current Quick Filter text from the grid, or `undefined` if none is set. */
    getQuickFilter() {
      return this.gos.get("quickFilterText");
    }
    /** Get the state of the Advanced Filter. Used for saving Advanced Filter state */
    getAdvancedFilterModel() {
      if (ModuleRegistry.__assertRegistered("@ag-grid-enterprise/advanced-filter", "api.getAdvancedFilterModel", this.context.getGridId())) {
        return this.filterManager.getAdvancedFilterModel();
      }
      return null;
    }
    /** Set the state of the Advanced Filter. Used for restoring Advanced Filter state */
    setAdvancedFilterModel(advancedFilterModel) {
      this.filterManager.setAdvancedFilterModel(advancedFilterModel);
    }
    /** Open the Advanced Filter Builder dialog (if enabled). */
    showAdvancedFilterBuilder() {
      if (ModuleRegistry.__assertRegistered("@ag-grid-enterprise/advanced-filter", "api.setAdvancedFilterModel", this.context.getGridId())) {
        this.filterManager.showAdvancedFilterBuilder("api");
      }
    }
    /**
     * Set all of the provided nodes selection state to the provided value.
     */
    setNodesSelected(params) {
      const allNodesValid = params.nodes.every((node) => {
        if (node.rowPinned) {
          console.warn("AG Grid: cannot select pinned rows");
          return false;
        }
        if (node.id === void 0) {
          console.warn("AG Grid: cannot select node until id for node is known");
          return false;
        }
        return true;
      });
      if (!allNodesValid) {
        return;
      }
      const { nodes, source, newValue } = params;
      const nodesAsRowNode = nodes;
      this.selectionService.setNodesSelected({ nodes: nodesAsRowNode, source: source != null ? source : "api", newValue });
    }
    /**
     * Select all rows, regardless of filtering and rows that are not visible due to grouping being enabled and their groups not expanded.
     * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAll'`
     */
    selectAll(source = "apiSelectAll") {
      this.selectionService.selectAllRowNodes({ source });
    }
    /**
     * Clear all row selections, regardless of filtering.
     * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAll'`
     */
    deselectAll(source = "apiSelectAll") {
      this.selectionService.deselectAllRowNodes({ source });
    }
    /**
     * Select all filtered rows.
     * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAllFiltered'`
     */
    selectAllFiltered(source = "apiSelectAllFiltered") {
      this.selectionService.selectAllRowNodes({ source, justFiltered: true });
    }
    /**
     * Clear all filtered selections.
     * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAllFiltered'`
     */
    deselectAllFiltered(source = "apiSelectAllFiltered") {
      this.selectionService.deselectAllRowNodes({ source, justFiltered: true });
    }
    /**
     * Returns an object containing rules matching the selected rows in the SSRM.
     * 
     * If `groupSelectsChildren=false` the returned object will be flat, and will conform to IServerSideSelectionState.
     * If `groupSelectsChildren=true` the returned object will be hierarchical, and will conform to IServerSideGroupSelectionState.
     */
    getServerSideSelectionState() {
      if (missing(this.serverSideRowModel)) {
        this.logMissingRowModel("getServerSideSelectionState", "serverSide");
        return null;
      }
      return this.selectionService.getSelectionState();
    }
    /**
     * Set the rules matching the selected rows in the SSRM.
     * 
     * If `groupSelectsChildren=false` the param will be flat, and should conform to IServerSideSelectionState.
     * If `groupSelectsChildren=true` the param will be hierarchical, and should conform to IServerSideGroupSelectionState.
     */
    setServerSideSelectionState(state) {
      if (missing(this.serverSideRowModel)) {
        this.logMissingRowModel("setServerSideSelectionState", "serverSide");
        return;
      }
      this.selectionService.setSelectionState(state, "api");
    }
    /**
     * Select all rows on the current page.
     * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAllCurrentPage'`
     */
    selectAllOnCurrentPage(source = "apiSelectAllCurrentPage") {
      this.selectionService.selectAllRowNodes({ source, justCurrentPage: true });
    }
    /**
     * Clear all filtered on the current page.
     * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAllCurrentPage'`
     */
    deselectAllOnCurrentPage(source = "apiSelectAllCurrentPage") {
      this.selectionService.deselectAllRowNodes({ source, justCurrentPage: true });
    }
    /** Show the 'loading' overlay. */
    showLoadingOverlay() {
      this.overlayService.showLoadingOverlay();
    }
    /** Show the 'no rows' overlay. */
    showNoRowsOverlay() {
      this.overlayService.showNoRowsOverlay();
    }
    /** Hides the overlay if showing. */
    hideOverlay() {
      this.overlayService.hideOverlay();
    }
    /**
     * Returns an unsorted list of selected nodes.
     * Getting the underlying node (rather than the data) is useful when working with tree / aggregated data,
     * as the node can be traversed.
     */
    getSelectedNodes() {
      return this.selectionService.getSelectedNodes();
    }
    /** Returns an unsorted list of selected rows (i.e. row data that you provided). */
    getSelectedRows() {
      return this.selectionService.getSelectedRows();
    }
    /**
     * Returns a list of all selected nodes at 'best cost', a feature to be used with groups / trees.
     * If a group has all its children selected, then the group appears in the result, but not the children.
     * Designed for use with `'children'` as the group selection type, where groups don't actually appear in the selection normally.
     */
    getBestCostNodeSelection() {
      if (missing(this.clientSideRowModel)) {
        this.logMissingRowModel("getBestCostNodeSelection", "clientSide");
        return;
      }
      return this.selectionService.getBestCostNodeSelection();
    }
    /** Retrieve rendered nodes. Due to virtualisation this will contain only the current visible rows and those in the buffer. */
    getRenderedNodes() {
      return this.rowRenderer.getRenderedNodes();
    }
    /**
     *  Ensures the column is visible by scrolling the table if needed.
     *
     * This will have no effect before the firstDataRendered event has fired.
     *
     * @param key - The column to ensure visible
     * @param position - Where the column will be positioned.
     * - `auto` - Scrolls the minimum amount to make sure the column is visible.
     * - `start` - Scrolls the column to the start of the viewport.
     * - `middle` - Scrolls the column to the middle of the viewport.
     * - `end` - Scrolls the column to the end of the viewport.
    */
    ensureColumnVisible(key, position = "auto") {
      this.frameworkOverrides.wrapIncoming(() => this.gridBodyCtrl.getScrollFeature().ensureColumnVisible(key, position), "ensureVisible");
    }
    /**
     * Vertically scrolls the grid until the provided row index is inside the visible viewport.
     * If a position is provided, the grid will attempt to scroll until the row is at the given position within the viewport.
     * This will have no effect before the firstDataRendered event has fired.
     */
    ensureIndexVisible(index, position) {
      this.frameworkOverrides.wrapIncoming(() => this.gridBodyCtrl.getScrollFeature().ensureIndexVisible(index, position), "ensureVisible");
    }
    /**
     * Vertically scrolls the grid until the provided row (or a row matching the provided comparator) is inside the visible viewport.
     * If a position is provided, the grid will attempt to scroll until the row is at the given position within the viewport.
     * This will have no effect before the firstDataRendered event has fired.
     */
    ensureNodeVisible(nodeSelector, position = null) {
      this.frameworkOverrides.wrapIncoming(() => this.gridBodyCtrl.getScrollFeature().ensureNodeVisible(nodeSelector, position), "ensureVisible");
    }
    /**
     * Similar to `forEachNode`, except lists all the leaf nodes.
     * This effectively goes through all the data that you provided to the grid before the grid performed any grouping.
     * If using tree data, goes through all the nodes for the data you provided, including nodes that have children,
     * but excluding groups the grid created where gaps were missing in the hierarchy.
     */
    forEachLeafNode(callback) {
      if (missing(this.clientSideRowModel)) {
        this.logMissingRowModel("forEachLeafNode", "clientSide");
        return;
      }
      this.clientSideRowModel.forEachLeafNode(callback);
    }
    /**
     * Iterates through each node (row) in the grid and calls the callback for each node.
     * This works similar to the `forEach` method on a JavaScript array.
     * This is called for every node, ignoring any filtering or sorting applied within the grid.
     * If using the Infinite Row Model, then this gets called for each page loaded in the page cache.
     */
    forEachNode(callback, includeFooterNodes) {
      this.rowModel.forEachNode(callback, includeFooterNodes);
    }
    /** Similar to `forEachNode`, except skips any filtered out data. */
    forEachNodeAfterFilter(callback) {
      if (missing(this.clientSideRowModel)) {
        this.logMissingRowModel("forEachNodeAfterFilter", "clientSide");
        return;
      }
      this.clientSideRowModel.forEachNodeAfterFilter(callback);
    }
    /** Similar to `forEachNodeAfterFilter`, except the callbacks are called in the order the rows are displayed in the grid. */
    forEachNodeAfterFilterAndSort(callback) {
      if (missing(this.clientSideRowModel)) {
        this.logMissingRowModel("forEachNodeAfterFilterAndSort", "clientSide");
        return;
      }
      this.clientSideRowModel.forEachNodeAfterFilterAndSort(callback);
    }
    /**
     * @deprecated v31.1 To get/set individual filter models, use `getColumnFilterModel` or `setColumnFilterModel` instead.
     * To get hold of the filter instance, use `getColumnFilterInstance` which returns the instance asynchronously.
     */
    getFilterInstance(key, callback) {
      warnOnce(`'getFilterInstance' is deprecated. To get/set individual filter models, use 'getColumnFilterModel' or 'setColumnFilterModel' instead. To get hold of the filter instance, use 'getColumnFilterInstance' which returns the instance asynchronously.`);
      return this.filterManager.getFilterInstance(key, callback);
    }
    /**
     * Returns the filter component instance for a column.
     * For getting/setting models for individual column filters, use `getColumnFilterModel` and `setColumnFilterModel` instead of this.
     * `key` can be a column ID or a `Column` object.
     */
    getColumnFilterInstance(key) {
      return this.filterManager.getColumnFilterInstance(key);
    }
    /** Destroys a filter. Useful to force a particular filter to be created from scratch again. */
    destroyFilter(key) {
      const column = this.columnModel.getPrimaryColumn(key);
      if (column) {
        return this.filterManager.destroyFilter(column, "api");
      }
    }
    /** Gets the status panel instance corresponding to the supplied `id`. */
    getStatusPanel(key) {
      if (!ModuleRegistry.__assertRegistered("@ag-grid-enterprise/status-bar", "api.getStatusPanel", this.context.getGridId())) {
        return;
      }
      const comp = this.statusBarService.getStatusPanel(key);
      return unwrapUserComp(comp);
    }
    getColumnDef(key) {
      const column = this.columnModel.getPrimaryColumn(key);
      if (column) {
        return column.getColDef();
      }
      return null;
    }
    /**
     * Returns the current column definitions.
    */
    getColumnDefs() {
      return this.columnModel.getColumnDefs();
    }
    /**
     * Informs the grid that a filter has changed. This is typically called after a filter change through one of the filter APIs.
     * @param source The source of the filter change event. If not specified defaults to `'api'`.
     */
    onFilterChanged(source = "api") {
      this.filterManager.onFilterChanged({ source });
    }
    /**
     * Gets the grid to act as if the sort was changed.
     * Useful if you update some values and want to get the grid to reorder them according to the new values.
     */
    onSortChanged() {
      this.sortController.onSortChanged("api");
    }
    /**
     * Sets the state of all the column filters. Provide it with what you get from `getFilterModel()` to restore filter state.
     * If inferring cell data types, and row data is provided asynchronously and is yet to be set,
     * the filter model will be applied asynchronously after row data is added.
     * To always perform this synchronously, set `cellDataType = false` on the default column definition,
     * or provide cell data types for every column.
     */
    setFilterModel(model) {
      this.frameworkOverrides.wrapIncoming(() => this.filterManager.setFilterModel(model));
    }
    /** Gets the current state of all the column filters. Used for saving filter state. */
    getFilterModel() {
      return this.filterManager.getFilterModel();
    }
    /**
     * Gets the current filter model for the specified column.
     * Will return `null` if no active filter.
     */
    getColumnFilterModel(column) {
      return this.filterManager.getColumnFilterModel(column);
    }
    /**
     * Sets the filter model for the specified column.
     * Setting a `model` of `null` will reset the filter (make inactive).
     * Must wait on the response before calling `api.onFilterChanged()`.
     */
    setColumnFilterModel(column, model) {
      return this.filterManager.setColumnFilterModel(column, model);
    }
    /** Returns the focused cell (or the last focused cell if the grid lost focus). */
    getFocusedCell() {
      return this.focusService.getFocusedCell();
    }
    /** Clears the focused cell. */
    clearFocusedCell() {
      return this.focusService.clearFocusedCell();
    }
    /** Sets the focus to the specified cell. `rowPinned` can be either 'top', 'bottom' or null (for not pinned). */
    setFocusedCell(rowIndex, colKey, rowPinned) {
      this.focusService.setFocusedCell({ rowIndex, column: colKey, rowPinned, forceBrowserFocus: true });
    }
    /** Adds a drop zone outside of the grid where rows can be dropped. */
    addRowDropZone(params) {
      this.gridBodyCtrl.getRowDragFeature().addRowDropZone(params);
    }
    /** Removes an external drop zone added by `addRowDropZone`. */
    removeRowDropZone(params) {
      const activeDropTarget = this.dragAndDropService.findExternalZone(params);
      if (activeDropTarget) {
        this.dragAndDropService.removeDropTarget(activeDropTarget);
      }
    }
    /** Returns the `RowDropZoneParams` to be used by another grid's `addRowDropZone` method. */
    getRowDropZoneParams(events) {
      return this.gridBodyCtrl.getRowDragFeature().getRowDropZone(events);
    }
    assertSideBarLoaded(apiMethod) {
      return ModuleRegistry.__assertRegistered("@ag-grid-enterprise/side-bar", "api." + apiMethod, this.context.getGridId());
    }
    /** Returns `true` if the side bar is visible. */
    isSideBarVisible() {
      return this.assertSideBarLoaded("isSideBarVisible") && this.sideBarService.getSideBarComp().isDisplayed();
    }
    /** Show/hide the entire side bar, including any visible panel and the tab buttons. */
    setSideBarVisible(show) {
      if (this.assertSideBarLoaded("setSideBarVisible")) {
        this.sideBarService.getSideBarComp().setDisplayed(show);
      }
    }
    /** Sets the side bar position relative to the grid. Possible values are `'left'` or `'right'`. */
    setSideBarPosition(position) {
      if (this.assertSideBarLoaded("setSideBarPosition")) {
        this.sideBarService.getSideBarComp().setSideBarPosition(position);
      }
    }
    /** Opens a particular tool panel. Provide the ID of the tool panel to open. */
    openToolPanel(key) {
      if (this.assertSideBarLoaded("openToolPanel")) {
        this.sideBarService.getSideBarComp().openToolPanel(key, "api");
      }
    }
    /** Closes the currently open tool panel (if any). */
    closeToolPanel() {
      if (this.assertSideBarLoaded("closeToolPanel")) {
        this.sideBarService.getSideBarComp().close("api");
      }
    }
    /** Returns the ID of the currently shown tool panel if any, otherwise `null`. */
    getOpenedToolPanel() {
      if (this.assertSideBarLoaded("getOpenedToolPanel")) {
        return this.sideBarService.getSideBarComp().openedItem();
      }
      return null;
    }
    /** Force refresh all tool panels by calling their `refresh` method. */
    refreshToolPanel() {
      if (this.assertSideBarLoaded("refreshToolPanel")) {
        this.sideBarService.getSideBarComp().refresh();
      }
    }
    /** Returns `true` if the tool panel is showing, otherwise `false`. */
    isToolPanelShowing() {
      return this.assertSideBarLoaded("isToolPanelShowing") && this.sideBarService.getSideBarComp().isToolPanelShowing();
    }
    /** Gets the tool panel instance corresponding to the supplied `id`. */
    getToolPanelInstance(id) {
      if (this.assertSideBarLoaded("getToolPanelInstance")) {
        const comp = this.sideBarService.getSideBarComp().getToolPanelInstance(id);
        return unwrapUserComp(comp);
      }
    }
    /** Returns the current side bar configuration. If a shortcut was used, returns the detailed long form. */
    getSideBar() {
      if (this.assertSideBarLoaded("getSideBar")) {
        return this.sideBarService.getSideBarComp().getDef();
      }
      return void 0;
    }
    /** Tells the grid to recalculate the row heights. */
    resetRowHeights() {
      if (exists(this.clientSideRowModel)) {
        if (this.columnModel.isAutoRowHeightActive()) {
          console.warn("AG Grid: calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.");
          return;
        }
        this.clientSideRowModel.resetRowHeights();
      }
    }
    /**
     * Sets the `rowCount` and `maxRowFound` properties.
     * The second parameter, `maxRowFound`, is optional and if left out, only `rowCount` is set.
     * Set `rowCount` to adjust the height of the vertical scroll.
     * Set `maxRowFound` to enable / disable searching for more rows.
     * Use this method if you add or remove rows into the dataset and need to reset the number of rows or instruct the grid that the entire row count is no longer known.
     */
    setRowCount(rowCount, maxRowFound) {
      if (this.serverSideRowModel) {
        if (this.columnModel.isRowGroupEmpty()) {
          this.serverSideRowModel.setRowCount(rowCount, maxRowFound);
          return;
        }
        console.error("AG Grid: setRowCount cannot be used while using row grouping.");
        return;
      }
      if (this.infiniteRowModel) {
        this.infiniteRowModel.setRowCount(rowCount, maxRowFound);
        return;
      }
      this.logMissingRowModel("setRowCount", "infinite", "serverSide");
    }
    /** Tells the grid a row height has changed. To be used after calling `rowNode.setRowHeight(newHeight)`. */
    onRowHeightChanged() {
      if (this.clientSideRowModel) {
        this.clientSideRowModel.onRowHeightChanged();
      } else if (this.serverSideRowModel) {
        this.serverSideRowModel.onRowHeightChanged();
      }
    }
    /**
     * @deprecated v31.3 Use `getCellValue` instead.
     */
    getValue(colKey, rowNode) {
      this.logDeprecation("31.3", "getValue", "getCellValue");
      return this.getCellValue({ colKey, rowNode });
    }
    getCellValue(params) {
      var _a;
      const { colKey, rowNode, useFormatter } = params;
      let column = (_a = this.columnModel.getPrimaryColumn(colKey)) != null ? _a : this.columnModel.getGridColumn(colKey);
      if (missing(column)) {
        return null;
      }
      const value = this.valueService.getValue(column, rowNode);
      if (useFormatter) {
        const formattedValue = this.valueService.formatValue(column, rowNode, value);
        return formattedValue != null ? formattedValue : escapeString(value, true);
      }
      return value;
    }
    /**
     * Add an event listener for the specified `eventType`.
     * Works similar to `addEventListener` for a browser DOM element.
     * Listeners will be automatically removed when the grid is destroyed.
     */
    addEventListener(eventType, listener) {
      this.apiEventService.addEventListener(eventType, listener);
    }
    /**
     * Add an event listener for all event types coming from the grid.
     * Listeners will be automatically removed when the grid is destroyed.
     */
    addGlobalListener(listener) {
      this.apiEventService.addGlobalListener(listener);
    }
    /** Remove an event listener. */
    removeEventListener(eventType, listener) {
      this.apiEventService.removeEventListener(eventType, listener);
    }
    /** Remove a global event listener. */
    removeGlobalListener(listener) {
      this.apiEventService.removeGlobalListener(listener);
    }
    dispatchEvent(event) {
      this.eventService.dispatchEvent(event);
    }
    /** Will destroy the grid and release resources. If you are using a framework you do not need to call this, as the grid links in with the framework lifecycle. However if you are using Web Components or native JavaScript, you do need to call this, to avoid a memory leak in your application. */
    destroy() {
      var _a;
      const preDestroyLink = `See ${this.frameworkOverrides.getDocLink("grid-lifecycle/#grid-pre-destroyed")}`;
      if (this.destroyCalled) {
        return;
      }
      const event = {
        type: Events.EVENT_GRID_PRE_DESTROYED,
        state: this.getState()
      };
      this.dispatchEvent(event);
      this.destroyCalled = true;
      (_a = this.ctrlsService.get("gridCtrl")) == null ? void 0 : _a.destroyGridUi();
      this.context.destroy();
      this.detailGridInfoMap = {};
      removeAllReferences(this, ["isDestroyed"], preDestroyLink);
    }
    /** Returns `true` if the grid has been destroyed. */
    isDestroyed() {
      return this.destroyCalled;
    }
    /** Reset the Quick Filter cache text on every rowNode. */
    resetQuickFilter() {
      this.filterManager.resetQuickFilterCache();
    }
    /** Returns the list of selected cell ranges. */
    getCellRanges() {
      if (this.rangeService) {
        return this.rangeService.getCellRanges();
      }
      ModuleRegistry.__assertRegistered("@ag-grid-enterprise/range-selection", "api.getCellRanges", this.context.getGridId());
      return null;
    }
    /** Adds the provided cell range to the selected ranges. */
    addCellRange(params) {
      if (this.rangeService) {
        this.rangeService.addCellRange(params);
        return;
      }
      ModuleRegistry.__assertRegistered("@ag-grid-enterprise/range-selection", "api.addCellRange", this.context.getGridId());
    }
    /** Clears the selected ranges. */
    clearRangeSelection() {
      if (this.rangeService) {
        this.rangeService.removeAllCellRanges();
      }
      ModuleRegistry.__assertRegistered("@ag-grid-enterprise/range-selection", "gridApi.clearRangeSelection", this.context.getGridId());
    }
    /** Reverts the last cell edit. */
    undoCellEditing() {
      this.undoRedoService.undo("api");
    }
    /** Re-applies the most recently undone cell edit. */
    redoCellEditing() {
      this.undoRedoService.redo("api");
    }
    /** Returns current number of available cell edit undo operations. */
    getCurrentUndoSize() {
      return this.undoRedoService.getCurrentUndoStackSize();
    }
    /** Returns current number of available cell edit redo operations. */
    getCurrentRedoSize() {
      return this.undoRedoService.getCurrentRedoStackSize();
    }
    assertChart(methodName, func) {
      if (ModuleRegistry.__assertRegistered("@ag-grid-enterprise/charts", "api." + methodName, this.context.getGridId())) {
        return this.frameworkOverrides.wrapIncoming(() => func());
      }
    }
    /** Returns a list of models with information about the charts that are currently rendered from the grid. */
    getChartModels() {
      return this.assertChart("getChartModels", () => this.chartService.getChartModels());
    }
    /** Returns the `ChartRef` using the supplied `chartId`. */
    getChartRef(chartId) {
      return this.assertChart("getChartRef", () => this.chartService.getChartRef(chartId));
    }
    /** Returns a base64-encoded image data URL for the referenced chartId. */
    getChartImageDataURL(params) {
      return this.assertChart("getChartImageDataURL", () => this.chartService.getChartImageDataURL(params));
    }
    /** Starts a browser-based image download for the referenced chartId. */
    downloadChart(params) {
      return this.assertChart("downloadChart", () => this.chartService.downloadChart(params));
    }
    /** Open the Chart Tool Panel. */
    openChartToolPanel(params) {
      return this.assertChart("openChartToolPanel", () => this.chartService.openChartToolPanel(params));
    }
    /** Close the Chart Tool Panel. */
    closeChartToolPanel(params) {
      return this.assertChart("closeChartToolPanel", () => this.chartService.closeChartToolPanel(params.chartId));
    }
    /** Used to programmatically create charts from a range. */
    createRangeChart(params) {
      return this.assertChart("createRangeChart", () => this.chartService.createRangeChart(params));
    }
    /** Used to programmatically create pivot charts from a grid. */
    createPivotChart(params) {
      return this.assertChart("createPivotChart", () => this.chartService.createPivotChart(params));
    }
    /** Used to programmatically create cross filter charts from a range. */
    createCrossFilterChart(params) {
      return this.assertChart("createCrossFilterChart", () => this.chartService.createCrossFilterChart(params));
    }
    /** Used to programmatically update a chart. */
    updateChart(params) {
      return this.assertChart("updateChart", () => this.chartService.updateChart(params));
    }
    /** Restores a chart using the `ChartModel` that was previously obtained from `getChartModels()`. */
    restoreChart(chartModel, chartContainer) {
      return this.assertChart("restoreChart", () => this.chartService.restoreChart(chartModel, chartContainer));
    }
    assertClipboard(methodName, func) {
      if (ModuleRegistry.__assertRegistered("@ag-grid-enterprise/clipboard", "api" + methodName, this.context.getGridId())) {
        func();
      }
    }
    /** Copies data to clipboard by following the same rules as pressing Ctrl+C. */
    copyToClipboard(params) {
      this.assertClipboard("copyToClipboard", () => this.clipboardService.copyToClipboard(params));
    }
    /** Cuts data to clipboard by following the same rules as pressing Ctrl+X. */
    cutToClipboard(params) {
      this.assertClipboard("cutToClipboard", () => this.clipboardService.cutToClipboard(params));
    }
    /** Copies the selected rows to the clipboard. */
    copySelectedRowsToClipboard(params) {
      this.assertClipboard("copySelectedRowsToClipboard", () => this.clipboardService.copySelectedRowsToClipboard(params));
    }
    /** Copies the selected ranges to the clipboard. */
    copySelectedRangeToClipboard(params) {
      this.assertClipboard("copySelectedRangeToClipboard", () => this.clipboardService.copySelectedRangeToClipboard(params));
    }
    /** Copies the selected range down, similar to `Ctrl + D` in Excel. */
    copySelectedRangeDown() {
      this.assertClipboard("copySelectedRangeDown", () => this.clipboardService.copyRangeDown());
    }
    /** Pastes the data from the Clipboard into the focused cell of the grid. If no grid cell is focused, calling this method has no effect. */
    pasteFromClipboard() {
      this.assertClipboard("pasteFromClipboard", () => this.clipboardService.pasteFromClipboard());
    }
    /** @deprecated v31.1 Use `IHeaderParams.showColumnMenu` within a header component, or `api.showColumnMenu` elsewhere. */
    showColumnMenuAfterButtonClick(colKey, buttonElement) {
      warnOnce(`'showColumnMenuAfterButtonClick' is deprecated. Use 'IHeaderParams.showColumnMenu' within a header component, or 'api.showColumnMenu' elsewhere.`);
      const column = this.columnModel.getGridColumn(colKey);
      this.menuService.showColumnMenu({
        column,
        buttonElement,
        positionBy: "button"
      });
    }
    /** @deprecated v31.1 Use `IHeaderParams.showColumnMenuAfterMouseClick` within a header component, or `api.showColumnMenu` elsewhere. */
    showColumnMenuAfterMouseClick(colKey, mouseEvent) {
      warnOnce(`'showColumnMenuAfterMouseClick' is deprecated. Use 'IHeaderParams.showColumnMenuAfterMouseClick' within a header component, or 'api.showColumnMenu' elsewhere.`);
      let column = this.columnModel.getGridColumn(colKey);
      if (!column) {
        column = this.columnModel.getPrimaryColumn(colKey);
      }
      if (!column) {
        console.error(`AG Grid: column '${colKey}' not found`);
        return;
      }
      this.menuService.showColumnMenu({
        column,
        mouseEvent,
        positionBy: "mouse"
      });
    }
    /**
     * Displays the AG Grid context menu
     */
    showContextMenu(params) {
      const { rowNode, column, value, x, y } = params || {};
      let { x: clientX, y: clientY } = this.menuService.getContextMenuPosition(rowNode, column);
      if (x != null) {
        clientX = x;
      }
      if (y != null) {
        clientY = y;
      }
      this.menuService.showContextMenu({
        mouseEvent: new MouseEvent("mousedown", { clientX, clientY }),
        rowNode,
        column,
        value
      });
    }
    /** Show the column chooser. */
    showColumnChooser(params) {
      this.menuService.showColumnChooser({ chooserParams: params });
    }
    /** Show the filter for the provided column. */
    showColumnFilter(colKey) {
      const column = this.columnModel.getGridColumn(colKey);
      if (!column) {
        console.error(`AG Grid: column '${colKey}' not found`);
        return;
      }
      this.menuService.showFilterMenu({
        column,
        containerType: "columnFilter",
        positionBy: "auto"
      });
    }
    /** Show the column menu for the provided column. */
    showColumnMenu(colKey) {
      const column = this.columnModel.getGridColumn(colKey);
      if (!column) {
        console.error(`AG Grid: column '${colKey}' not found`);
        return;
      }
      this.menuService.showColumnMenu({
        column,
        positionBy: "auto"
      });
    }
    /** Hides any visible context menu or column menu. */
    hidePopupMenu() {
      this.menuService.hidePopupMenu();
    }
    /** Hide the column chooser if visible. */
    hideColumnChooser() {
      this.menuService.hideColumnChooser();
    }
    /** Navigates the grid focus to the next cell, as if tabbing. */
    tabToNextCell(event) {
      return this.navigationService.tabToNextCell(false, event);
    }
    /** Navigates the grid focus to the previous cell, as if shift-tabbing. */
    tabToPreviousCell(event) {
      return this.navigationService.tabToNextCell(true, event);
    }
    /** Returns the list of active cell renderer instances. */
    getCellRendererInstances(params = {}) {
      const res = this.rowRenderer.getCellRendererInstances(params);
      const unwrapped = res.map(unwrapUserComp);
      return unwrapped;
    }
    /** Returns the list of active cell editor instances. Optionally provide parameters to restrict to certain columns / row nodes. */
    getCellEditorInstances(params = {}) {
      const res = this.rowRenderer.getCellEditorInstances(params);
      const unwrapped = res.map(unwrapUserComp);
      return unwrapped;
    }
    /** If the grid is editing, returns back details of the editing cell(s). */
    getEditingCells() {
      return this.rowRenderer.getEditingCells();
    }
    /** If a cell is editing, it stops the editing. Pass `true` if you want to cancel the editing (i.e. don't accept changes). */
    stopEditing(cancel = false) {
      this.rowRenderer.stopEditing(cancel);
    }
    /** Start editing the provided cell. If another cell is editing, the editing will be stopped in that other cell. */
    startEditingCell(params) {
      const column = this.columnModel.getGridColumn(params.colKey);
      if (!column) {
        console.warn(`AG Grid: no column found for ${params.colKey}`);
        return;
      }
      const cellPosition = {
        rowIndex: params.rowIndex,
        rowPinned: params.rowPinned || null,
        column
      };
      const notPinned = params.rowPinned == null;
      if (notPinned) {
        this.ensureIndexVisible(params.rowIndex);
      }
      this.ensureColumnVisible(params.colKey);
      const cell = this.navigationService.getCellByPosition(cellPosition);
      if (!cell) {
        return;
      }
      if (!this.focusService.isCellFocused(cellPosition)) {
        this.focusService.setFocusedCell(cellPosition);
      }
      cell.startRowOrCellEdit(params.key);
    }
    /** @deprecated v31.1 addAggFunc(key, func) is  deprecated, please use addAggFuncs({ key: func }) instead. */
    addAggFunc(key, aggFunc) {
      this.logDeprecation("v31.1", "addAggFunc(key, func)", "addAggFuncs({ key: func })");
      if (this.aggFuncService) {
        this.aggFuncService.addAggFuncs({ key: aggFunc });
      }
    }
    /** Add aggregations function with the specified keys. */
    addAggFuncs(aggFuncs) {
      if (this.aggFuncService) {
        this.aggFuncService.addAggFuncs(aggFuncs);
      }
    }
    /** Clears all aggregation functions (including those provided by the grid). */
    clearAggFuncs() {
      if (this.aggFuncService) {
        this.aggFuncService.clear();
      }
    }
    /** Apply transactions to the server side row model. */
    applyServerSideTransaction(transaction) {
      if (!this.serverSideTransactionManager) {
        this.logMissingRowModel("applyServerSideTransaction", "serverSide");
        return;
      }
      return this.serverSideTransactionManager.applyTransaction(transaction);
    }
    /** Batch apply transactions to the server side row model. */
    applyServerSideTransactionAsync(transaction, callback) {
      if (!this.serverSideTransactionManager) {
        this.logMissingRowModel("applyServerSideTransactionAsync", "serverSide");
        return;
      }
      return this.serverSideTransactionManager.applyTransactionAsync(transaction, callback);
    }
    /**
     * Applies row data to a server side store.
     * New rows will overwrite rows at the same index in the same way as if provided by a datasource success callback.
    */
    applyServerSideRowData(params) {
      var _a, _b;
      const startRow = (_a = params.startRow) != null ? _a : 0;
      const route = (_b = params.route) != null ? _b : [];
      if (startRow < 0) {
        console.warn(`AG Grid: invalid value ${params.startRow} for startRow, the value should be >= 0`);
        return;
      }
      if (this.serverSideRowModel) {
        this.serverSideRowModel.applyRowData(params.successParams, startRow, route);
      } else {
        this.logMissingRowModel("setServerSideDatasource", "serverSide");
      }
    }
    /** Gets all failed server side loads to retry. */
    retryServerSideLoads() {
      if (!this.serverSideRowModel) {
        this.logMissingRowModel("retryServerSideLoads", "serverSide");
        return;
      }
      this.serverSideRowModel.retryLoads();
    }
    flushServerSideAsyncTransactions() {
      if (!this.serverSideTransactionManager) {
        this.logMissingRowModel("flushServerSideAsyncTransactions", "serverSide");
        return;
      }
      return this.serverSideTransactionManager.flushAsyncTransactions();
    }
    /** Update row data. Pass a transaction object with lists for `add`, `remove` and `update`. */
    applyTransaction(rowDataTransaction) {
      if (!this.clientSideRowModel) {
        this.logMissingRowModel("applyTransaction", "clientSide");
        return;
      }
      return this.frameworkOverrides.wrapIncoming(() => this.clientSideRowModel.updateRowData(rowDataTransaction));
    }
    /** Same as `applyTransaction` except executes asynchronously for efficiency. */
    applyTransactionAsync(rowDataTransaction, callback) {
      if (!this.clientSideRowModel) {
        this.logMissingRowModel("applyTransactionAsync", "clientSide");
        return;
      }
      this.frameworkOverrides.wrapIncoming(() => this.clientSideRowModel.batchUpdateRowData(rowDataTransaction, callback));
    }
    /** Executes any remaining asynchronous grid transactions, if any are waiting to be executed. */
    flushAsyncTransactions() {
      if (!this.clientSideRowModel) {
        this.logMissingRowModel("flushAsyncTransactions", "clientSide");
        return;
      }
      this.frameworkOverrides.wrapIncoming(() => this.clientSideRowModel.flushAsyncTransactions());
    }
    /**
     * Marks all the currently loaded blocks in the cache for reload.
     * If you have 10 blocks in the cache, all 10 will be marked for reload.
     * The old data will continue to be displayed until the new data is loaded.
     */
    refreshInfiniteCache() {
      if (this.infiniteRowModel) {
        this.infiniteRowModel.refreshCache();
      } else {
        this.logMissingRowModel("refreshInfiniteCache", "infinite");
      }
    }
    /**
     * Purges the cache.
     * The grid is then told to refresh. Only the blocks required to display the current data on screen are fetched (typically no more than 2).
     * The grid will display nothing while the new blocks are loaded.
     * Use this to immediately remove the old data from the user.
     */
    purgeInfiniteCache() {
      if (this.infiniteRowModel) {
        this.infiniteRowModel.purgeCache();
      } else {
        this.logMissingRowModel("purgeInfiniteCache", "infinite");
      }
    }
    /**
     * Refresh a server-side store level.
     * If you pass no parameters, then the top level store is refreshed.
     * To refresh a child level, pass in the string of keys to get to the desired level.
     * Once the store refresh is complete, the storeRefreshed event is fired.
     */
    refreshServerSide(params) {
      if (!this.serverSideRowModel) {
        this.logMissingRowModel("refreshServerSide", "serverSide");
        return;
      }
      this.serverSideRowModel.refreshStore(params);
    }
    /** Returns info on all server side group levels. */
    getServerSideGroupLevelState() {
      if (!this.serverSideRowModel) {
        this.logMissingRowModel("getServerSideGroupLevelState", "serverSide");
        return [];
      }
      return this.serverSideRowModel.getStoreState();
    }
    /** The row count defines how many rows the grid allows scrolling to. */
    getInfiniteRowCount() {
      if (this.infiniteRowModel) {
        return this.infiniteRowModel.getRowCount();
      } else {
        this.logMissingRowModel("getInfiniteRowCount", "infinite");
      }
    }
    /** Returns `true` if grid allows for scrolling past the last row to load more rows, thus providing infinite scroll. */
    isLastRowIndexKnown() {
      if (this.infiniteRowModel) {
        return this.infiniteRowModel.isLastRowIndexKnown();
      } else {
        this.logMissingRowModel("isLastRowIndexKnown", "infinite");
      }
    }
    /**
     * Returns an object representing the state of the cache. This is useful for debugging and understanding how the cache is working.
     */
    getCacheBlockState() {
      return this.rowNodeBlockLoader.getBlockState();
    }
    /** @deprecated v31.1 `getFirstDisplayedRow` is deprecated. Please use `getFirstDisplayedRowIndex` instead. */
    getFirstDisplayedRow() {
      this.logDeprecation("v31.1", "getFirstDisplayedRow", "getFirstDisplayedRowIndex");
      return this.getFirstDisplayedRowIndex();
    }
    /** Get the index of the first displayed row due to scrolling (includes invisible rendered rows in the buffer). */
    getFirstDisplayedRowIndex() {
      return this.rowRenderer.getFirstVirtualRenderedRow();
    }
    /** @deprecated v31.1 `getLastDisplayedRow` is deprecated. Please use `getLastDisplayedRowIndex` instead. */
    getLastDisplayedRow() {
      this.logDeprecation("v31.1", "getLastDisplayedRow", "getLastDisplayedRowIndex");
      return this.getLastDisplayedRowIndex();
    }
    /** Get the index of the last displayed row due to scrolling (includes invisible rendered rows in the buffer). */
    getLastDisplayedRowIndex() {
      return this.rowRenderer.getLastVirtualRenderedRow();
    }
    /** Returns the displayed `RowNode` at the given `index`. */
    getDisplayedRowAtIndex(index) {
      return this.rowModel.getRow(index);
    }
    /** Returns the total number of displayed rows. */
    getDisplayedRowCount() {
      return this.rowModel.getRowCount();
    }
    /**
     * Returns `true` when the last page is known.
     * This will always be `true` if you are using the Client-Side Row Model for pagination.
     * Returns `false` when the last page is not known; this only happens when using Infinite Row Model.
     */
    paginationIsLastPageFound() {
      return this.paginationProxy.isLastPageFound();
    }
    /** Returns how many rows are being shown per page. */
    paginationGetPageSize() {
      return this.paginationProxy.getPageSize();
    }
    /** Returns the 0-based index of the page which is showing. */
    paginationGetCurrentPage() {
      return this.paginationProxy.getCurrentPage();
    }
    /** Returns the total number of pages. Returns `null` if `paginationIsLastPageFound() === false`. */
    paginationGetTotalPages() {
      return this.paginationProxy.getTotalPages();
    }
    /** The total number of rows. Returns `null` if `paginationIsLastPageFound() === false`. */
    paginationGetRowCount() {
      return this.paginationProxy.getMasterRowCount();
    }
    /** Navigates to the next page. */
    paginationGoToNextPage() {
      this.paginationProxy.goToNextPage();
    }
    /** Navigates to the previous page. */
    paginationGoToPreviousPage() {
      this.paginationProxy.goToPreviousPage();
    }
    /** Navigates to the first page. */
    paginationGoToFirstPage() {
      this.paginationProxy.goToFirstPage();
    }
    /** Navigates to the last page. */
    paginationGoToLastPage() {
      this.paginationProxy.goToLastPage();
    }
    /** Goes to the specified page. If the page requested doesn't exist, it will go to the last page. */
    paginationGoToPage(page) {
      this.paginationProxy.goToPage(page);
    }
    // Methods migrated from old ColumnApi
    /**
     * Adjusts the size of columns to fit the available horizontal space.
     *
     * Note: it is not recommended to call this method rapidly e.g. in response
     * to window resize events or as the container size is animated. This can
     * cause the scrollbar to flicker. Use column flex for smoother results.
     * 
     * If inferring cell data types with custom column types
     * and row data is provided asynchronously, the column sizing will happen asynchronously when row data is added.
     * To always perform this synchronously, set `cellDataType = false` on the default column definition.
     **/
    sizeColumnsToFit(paramsOrGridWidth) {
      if (typeof paramsOrGridWidth === "number") {
        this.columnModel.sizeColumnsToFit(paramsOrGridWidth, "api");
      } else {
        this.gridBodyCtrl.sizeColumnsToFit(paramsOrGridWidth);
      }
    }
    /** Call this if you want to open or close a column group. */
    setColumnGroupOpened(group, newValue) {
      this.columnModel.setColumnGroupOpened(group, newValue, "api");
    }
    /** Returns the column group with the given name. */
    getColumnGroup(name, instanceId) {
      return this.columnModel.getColumnGroup(name, instanceId);
    }
    /** Returns the provided column group with the given name. */
    getProvidedColumnGroup(name) {
      return this.columnModel.getProvidedColumnGroup(name);
    }
    /** Returns the display name for a column. Useful if you are doing your own header rendering and want the grid to work out if `headerValueGetter` is used, or if you are doing your own column management GUI, to know what to show as the column name. */
    getDisplayNameForColumn(column, location2) {
      return this.columnModel.getDisplayNameForColumn(column, location2) || "";
    }
    /** Returns the display name for a column group (when grouping columns). */
    getDisplayNameForColumnGroup(columnGroup, location2) {
      return this.columnModel.getDisplayNameForColumnGroup(columnGroup, location2) || "";
    }
    /** Returns the column with the given `colKey`, which can either be the `colId` (a string) or the `colDef` (an object). */
    getColumn(key) {
      return this.columnModel.getPrimaryColumn(key);
    }
    /** Returns all the columns, regardless of visible or not. */
    getColumns() {
      return this.columnModel.getAllPrimaryColumns();
    }
    /** Applies the state of the columns from a previous state. Returns `false` if one or more columns could not be found. */
    applyColumnState(params) {
      return this.columnModel.applyColumnState(params, "api");
    }
    /** Gets the state of the columns. Typically used when saving column state. */
    getColumnState() {
      return this.columnModel.getColumnState();
    }
    /** Sets the state back to match the originally provided column definitions. */
    resetColumnState() {
      this.columnModel.resetColumnState("api");
    }
    /** Gets the state of the column groups. Typically used when saving column group state. */
    getColumnGroupState() {
      return this.columnModel.getColumnGroupState();
    }
    /** Sets the state of the column group state from a previous state. */
    setColumnGroupState(stateItems) {
      this.columnModel.setColumnGroupState(stateItems, "api");
    }
    /** Sets the state back to match the originally provided column definitions. */
    resetColumnGroupState() {
      this.columnModel.resetColumnGroupState("api");
    }
    /** Returns `true` if pinning left or right, otherwise `false`. */
    isPinning() {
      return this.columnModel.isPinningLeft() || this.columnModel.isPinningRight();
    }
    /** Returns `true` if pinning left, otherwise `false`. */
    isPinningLeft() {
      return this.columnModel.isPinningLeft();
    }
    /** Returns `true` if pinning right, otherwise `false`. */
    isPinningRight() {
      return this.columnModel.isPinningRight();
    }
    /** Returns the column to the right of the provided column, taking into consideration open / closed column groups and visible columns. This is useful if you need to know what column is beside yours e.g. if implementing your own cell navigation. */
    getDisplayedColAfter(col) {
      return this.columnModel.getDisplayedColAfter(col);
    }
    /** Same as `getVisibleColAfter` except gives column to the left. */
    getDisplayedColBefore(col) {
      return this.columnModel.getDisplayedColBefore(col);
    }
    /** @deprecated v31.1 setColumnVisible(key, visible) deprecated, please use setColumnsVisible([key], visible) instead. */
    setColumnVisible(key, visible) {
      this.logDeprecation("v31.1", "setColumnVisible(key,visible)", "setColumnsVisible([key],visible)");
      this.columnModel.setColumnsVisible([key], visible, "api");
    }
    /** Sets the visibility of columns. Key can be the column ID or `Column` object. */
    setColumnsVisible(keys2, visible) {
      this.columnModel.setColumnsVisible(keys2, visible, "api");
    }
    /** @deprecated v31.1 setColumnPinned(key, pinned) deprecated, please use setColumnsPinned([key], pinned) instead. */
    setColumnPinned(key, pinned) {
      this.logDeprecation("v31.1", "setColumnPinned(key,pinned)", "setColumnsPinned([key],pinned)");
      this.columnModel.setColumnsPinned([key], pinned, "api");
    }
    /** Set a column's pinned / unpinned state. Key can be the column ID, field, `ColDef` object or `Column` object. */
    setColumnsPinned(keys2, pinned) {
      this.columnModel.setColumnsPinned(keys2, pinned, "api");
    }
    /**
     * Returns all the grid columns, same as `getColumns()`, except
     *
     *  a) it has the order of the columns that are presented in the grid
     *
     *  b) it's after the 'pivot' step, so if pivoting, has the value columns for the pivot.
     */
    getAllGridColumns() {
      return this.columnModel.getAllGridColumns();
    }
    /** Same as `getAllDisplayedColumns` but just for the pinned left portion of the grid. */
    getDisplayedLeftColumns() {
      return this.columnModel.getDisplayedLeftColumns();
    }
    /** Same as `getAllDisplayedColumns` but just for the center portion of the grid. */
    getDisplayedCenterColumns() {
      return this.columnModel.getDisplayedCenterColumns();
    }
    /** Same as `getAllDisplayedColumns` but just for the pinned right portion of the grid. */
    getDisplayedRightColumns() {
      return this.columnModel.getDisplayedRightColumns();
    }
    /** Returns all columns currently displayed (e.g. are visible and if in a group, the group is showing the columns) for the pinned left, centre and pinned right portions of the grid. */
    getAllDisplayedColumns() {
      return this.columnModel.getAllDisplayedColumns();
    }
    /** Same as `getAllGridColumns()`, except only returns rendered columns, i.e. columns that are not within the viewport and therefore not rendered, due to column virtualisation, are not displayed. */
    getAllDisplayedVirtualColumns() {
      return this.columnModel.getViewportColumns();
    }
    /** @deprecated v31.1 moveColumn(key, toIndex) deprecated, please use moveColumns([key], toIndex) instead. */
    moveColumn(key, toIndex) {
      this.logDeprecation("v31.1", "moveColumn(key, toIndex)", "moveColumns([key], toIndex)");
      this.columnModel.moveColumns([key], toIndex, "api");
    }
    /** Moves the column at `fromIdex` to `toIndex`. The column is first removed, then added at the `toIndex` location, thus index locations will change to the right of the column after the removal. */
    moveColumnByIndex(fromIndex, toIndex) {
      this.columnModel.moveColumnByIndex(fromIndex, toIndex, "api");
    }
    /** Moves columns to `toIndex`. The columns are first removed, then added at the `toIndex` location, thus index locations will change to the right of the column after the removal. */
    moveColumns(columnsToMoveKeys, toIndex) {
      this.columnModel.moveColumns(columnsToMoveKeys, toIndex, "api");
    }
    /** Move the column to a new position in the row grouping order. */
    moveRowGroupColumn(fromIndex, toIndex) {
      this.columnModel.moveRowGroupColumn(fromIndex, toIndex, "api");
    }
    /** Sets the agg function for a column. `aggFunc` can be one of the built-in aggregations or a custom aggregation by name or direct function. */
    setColumnAggFunc(key, aggFunc) {
      this.columnModel.setColumnAggFunc(key, aggFunc, "api");
    }
    /** @deprecated v31.1 setColumnWidths(key, newWidth) deprecated, please use setColumnWidths( [{key: newWidth}] ) instead. */
    setColumnWidth(key, newWidth, finished = true, source = "api") {
      this.logDeprecation("v31.1", "setColumnWidth(col, width)", "setColumnWidths([{key: col, newWidth: width}])");
      this.columnModel.setColumnWidths([{ key, newWidth }], false, finished, source);
    }
    /** Sets the column widths of the columns provided. The finished flag gets included in the resulting event and not used internally by the grid. The finished flag is intended for dragging, where a dragging action will produce many `columnWidth` events, so the consumer of events knows when it receives the last event in a stream. The finished parameter is optional, and defaults to `true`. */
    setColumnWidths(columnWidths, finished = true, source = "api") {
      this.columnModel.setColumnWidths(columnWidths, false, finished, source);
    }
    /** Get the pivot mode. */
    isPivotMode() {
      return this.columnModel.isPivotMode();
    }
    /** Returns the pivot result column for the given `pivotKeys` and `valueColId`. Useful to then call operations on the pivot column. */
    getPivotResultColumn(pivotKeys, valueColKey) {
      return this.columnModel.getSecondaryPivotColumn(pivotKeys, valueColKey);
    }
    /** Set the value columns to the provided list of columns. */
    setValueColumns(colKeys) {
      this.columnModel.setValueColumns(colKeys, "api");
    }
    /** Get a list of the existing value columns. */
    getValueColumns() {
      return this.columnModel.getValueColumns();
    }
    /** @deprecated v31.1 removeValueColumn(colKey) deprecated, please use removeValueColumns([colKey]) instead. */
    removeValueColumn(colKey) {
      this.logDeprecation("v31.1", "removeValueColumn(colKey)", "removeValueColumns([colKey])");
      this.columnModel.removeValueColumns([colKey], "api");
    }
    /** Remove the given list of columns from the existing set of value columns. */
    removeValueColumns(colKeys) {
      this.columnModel.removeValueColumns(colKeys, "api");
    }
    /** @deprecated v31.1 addValueColumn(colKey) deprecated, please use addValueColumns([colKey]) instead. */
    addValueColumn(colKey) {
      this.logDeprecation("v31.1", "addValueColumn(colKey)", "addValueColumns([colKey])");
      this.columnModel.addValueColumns([colKey], "api");
    }
    /** Add the given list of columns to the existing set of value columns. */
    addValueColumns(colKeys) {
      this.columnModel.addValueColumns(colKeys, "api");
    }
    /** Set the row group columns. */
    setRowGroupColumns(colKeys) {
      this.columnModel.setRowGroupColumns(colKeys, "api");
    }
    /** @deprecated v31.1 removeRowGroupColumn(colKey) deprecated, please use removeRowGroupColumns([colKey]) instead. */
    removeRowGroupColumn(colKey) {
      this.logDeprecation("v31.1", "removeRowGroupColumn(colKey)", "removeRowGroupColumns([colKey])");
      this.columnModel.removeRowGroupColumns([colKey], "api");
    }
    /** Remove columns from the row groups. */
    removeRowGroupColumns(colKeys) {
      this.columnModel.removeRowGroupColumns(colKeys, "api");
    }
    /** @deprecated v31.1 addRowGroupColumn(colKey) deprecated, please use addRowGroupColumns([colKey]) instead. */
    addRowGroupColumn(colKey) {
      this.logDeprecation("v31.1", "addRowGroupColumn(colKey)", "addRowGroupColumns([colKey])");
      this.columnModel.addRowGroupColumns([colKey], "api");
    }
    /** Add columns to the row groups. */
    addRowGroupColumns(colKeys) {
      this.columnModel.addRowGroupColumns(colKeys, "api");
    }
    /** Get row group columns. */
    getRowGroupColumns() {
      return this.columnModel.getRowGroupColumns();
    }
    /** Set the pivot columns. */
    setPivotColumns(colKeys) {
      this.columnModel.setPivotColumns(colKeys, "api");
    }
    /** @deprecated v31.1 removePivotColumn(colKey) deprecated, please use removePivotColumns([colKey]) instead. */
    removePivotColumn(colKey) {
      this.logDeprecation("v31.1", "removePivotColumn(colKey)", "removePivotColumns([colKey])");
      this.columnModel.removePivotColumns([colKey], "api");
    }
    /** Remove pivot columns. */
    removePivotColumns(colKeys) {
      this.columnModel.removePivotColumns(colKeys, "api");
    }
    /** @deprecated v31.1 addPivotColumn(colKey) deprecated, please use addPivotColumns([colKey]) instead. */
    addPivotColumn(colKey) {
      this.logDeprecation("v31.1", "addPivotColumn(colKey)", "addPivotColumns([colKey])");
      this.columnModel.addPivotColumns([colKey], "api");
    }
    /** Add pivot columns. */
    addPivotColumns(colKeys) {
      this.columnModel.addPivotColumns(colKeys, "api");
    }
    /** Get the pivot columns. */
    getPivotColumns() {
      return this.columnModel.getPivotColumns();
    }
    /** Same as `getAllDisplayedColumnGroups` but just for the pinned left portion of the grid. */
    getLeftDisplayedColumnGroups() {
      return this.columnModel.getDisplayedTreeLeft();
    }
    /** Same as `getAllDisplayedColumnGroups` but just for the center portion of the grid. */
    getCenterDisplayedColumnGroups() {
      return this.columnModel.getDisplayedTreeCentre();
    }
    /** Same as `getAllDisplayedColumnGroups` but just for the pinned right portion of the grid. */
    getRightDisplayedColumnGroups() {
      return this.columnModel.getDisplayedTreeRight();
    }
    /** Returns all 'root' column headers. If you are not grouping columns, these return the columns. If you are grouping, these return the top level groups - you can navigate down through each one to get the other lower level headers and finally the columns at the bottom. */
    getAllDisplayedColumnGroups() {
      return this.columnModel.getAllDisplayedTrees();
    }
    /** @deprecated v31.1 autoSizeColumn(key) deprecated, please use autoSizeColumns([colKey]) instead. */
    autoSizeColumn(key, skipHeader) {
      this.logDeprecation("v31.1", "autoSizeColumn(key, skipHeader)", "autoSizeColumns([key], skipHeader)");
      return this.columnModel.autoSizeColumns({ columns: [key], skipHeader, source: "api" });
    }
    /**
     * Auto-sizes columns based on their contents. If inferring cell data types with custom column types
     * and row data is provided asynchronously, the column sizing will happen asynchronously when row data is added.
     * To always perform this synchronously, set `cellDataType = false` on the default column definition.
     */
    autoSizeColumns(keys2, skipHeader) {
      this.columnModel.autoSizeColumns({ columns: keys2, skipHeader, source: "api" });
    }
    /**
     * Calls `autoSizeColumns` on all displayed columns. If inferring cell data types with custom column types
     * and row data is provided asynchronously, the column sizing will happen asynchronously when row data is added.
     * To always perform this synchronously, set `cellDataType = false` on the default column definition.
     */
    autoSizeAllColumns(skipHeader) {
      this.columnModel.autoSizeAllColumns("api", skipHeader);
    }
    /** Set the pivot result columns. */
    setPivotResultColumns(colDefs) {
      this.columnModel.setSecondaryColumns(colDefs, "api");
    }
    /** Returns the grid's pivot result columns. */
    getPivotResultColumns() {
      return this.columnModel.getSecondaryColumns();
    }
    /** Get the current state of the grid. Can be used in conjunction with the `initialState` grid option to save and restore grid state. */
    getState() {
      return this.stateService.getState();
    }
    /**
     * Returns the grid option value for a provided key.
     */
    getGridOption(key) {
      return this.gos.get(key);
    }
    /**
     * Updates a single gridOption to the new value provided. (Cannot be used on `Initial` properties.)
     * If updating multiple options, it is recommended to instead use `api.updateGridOptions()` which batches update logic.
     */
    setGridOption(key, value) {
      this.updateGridOptions({ [key]: value });
    }
    /**
     * Updates the provided subset of gridOptions with the provided values. (Cannot be used on `Initial` properties.)
     */
    updateGridOptions(options) {
      this.gos.updateGridOptions({ options });
    }
    /** Used internally by grid. Not intended to be used by the client. Interface may change between releases. */
    __internalUpdateGridOptions(options, force) {
      this.gos.updateGridOptions({ options, force, source: "gridOptionsUpdated" });
    }
    deprecatedUpdateGridOption(key, value) {
      warnOnce(`set${key.charAt(0).toUpperCase()}${key.slice(1, key.length)} is deprecated. Please use 'api.setGridOption('${key}', newValue)' or 'api.updateGridOptions({ ${key}: newValue })' instead.`);
      this.setGridOption(key, value);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Set the top pinned rows. Call with no rows / undefined to clear top pinned rows. 
     **/
    setPivotMode(pivotMode) {
      this.deprecatedUpdateGridOption("pivotMode", pivotMode);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Set the top pinned rows. Call with no rows / undefined to clear top pinned rows. 
     **/
    setPinnedTopRowData(rows) {
      this.deprecatedUpdateGridOption("pinnedTopRowData", rows);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Set the bottom pinned rows. Call with no rows / undefined to clear bottom pinned rows.
     * */
    setPinnedBottomRowData(rows) {
      this.deprecatedUpdateGridOption("pinnedBottomRowData", rows);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * DOM element to use as the popup parent for grid popups (context menu, column menu etc).
     * */
    setPopupParent(ePopupParent) {
      this.deprecatedUpdateGridOption("popupParent", ePopupParent);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     */
    setSuppressModelUpdateAfterUpdateTransaction(value) {
      this.deprecatedUpdateGridOption("suppressModelUpdateAfterUpdateTransaction", value);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Resets the data type definitions. This will update the columns in the grid.
     * */
    setDataTypeDefinitions(dataTypeDefinitions) {
      this.deprecatedUpdateGridOption("dataTypeDefinitions", dataTypeDefinitions);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Set whether the grid paginates the data or not.
     *  - `true` to enable pagination
     *  - `false` to disable pagination
     */
    setPagination(value) {
      this.deprecatedUpdateGridOption("pagination", value);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Sets the `paginationPageSize`, then re-paginates the grid so the changes are applied immediately.
     * */
    paginationSetPageSize(size2) {
      this.deprecatedUpdateGridOption("paginationPageSize", size2);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Resets the side bar to the provided configuration. The parameter is the same as the sideBar grid property. The side bar is re-created from scratch with the new config.
     * */
    setSideBar(def2) {
      this.deprecatedUpdateGridOption("sideBar", def2);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     */
    setSuppressClipboardPaste(value) {
      this.deprecatedUpdateGridOption("suppressClipboardPaste", value);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     */
    setGroupRemoveSingleChildren(value) {
      this.deprecatedUpdateGridOption("groupRemoveSingleChildren", value);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     */
    setGroupRemoveLowestSingleChildren(value) {
      this.deprecatedUpdateGridOption("groupRemoveLowestSingleChildren", value);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     */
    setGroupDisplayType(value) {
      this.deprecatedUpdateGridOption("groupDisplayType", value);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Sets the `groupIncludeFooter` property
     */
    setGroupIncludeFooter(value) {
      this.deprecatedUpdateGridOption("groupIncludeFooter", value);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Sets the `groupIncludeTotalFooter` property
     */
    setGroupIncludeTotalFooter(value) {
      this.deprecatedUpdateGridOption("groupIncludeTotalFooter", value);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     */
    setRowClass(className) {
      this.deprecatedUpdateGridOption("rowClass", className);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Sets the `deltaSort` property
     * */
    setDeltaSort(enable) {
      this.deprecatedUpdateGridOption("deltaSort", enable);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Sets the `suppressRowDrag` property.
     * */
    setSuppressRowDrag(value) {
      this.deprecatedUpdateGridOption("suppressRowDrag", value);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Sets the `suppressMoveWhenRowDragging` property.
     * */
    setSuppressMoveWhenRowDragging(value) {
      this.deprecatedUpdateGridOption("suppressMoveWhenRowDragging", value);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Sets the `suppressRowClickSelection` property.
     * */
    setSuppressRowClickSelection(value) {
      this.deprecatedUpdateGridOption("suppressRowClickSelection", value);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Enable/disable the Advanced Filter
     * */
    setEnableAdvancedFilter(enabled) {
      this.deprecatedUpdateGridOption("enableAdvancedFilter", enabled);
    }
    /** 
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Updates the `includeHiddenColumnsInAdvancedFilter` grid option.
     * By default hidden columns are excluded from the Advanced Filter.
     * Set to `true` to include them.
     */
    setIncludeHiddenColumnsInAdvancedFilter(value) {
      this.deprecatedUpdateGridOption("includeHiddenColumnsInAdvancedFilter", value);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * DOM element to use as the parent for the Advanced Filter, to allow it to appear outside of the grid.
     * Set to `null` to appear inside the grid.
     */
    setAdvancedFilterParent(advancedFilterParent) {
      this.deprecatedUpdateGridOption("advancedFilterParent", advancedFilterParent);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Updates the Advanced Filter Builder parameters.
     * */
    setAdvancedFilterBuilderParams(params) {
      this.deprecatedUpdateGridOption("advancedFilterBuilderParams", params);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Pass a Quick Filter text into the grid for filtering.
     * */
    setQuickFilter(newFilter) {
      warnOnce(`setQuickFilter is deprecated. Please use 'api.setGridOption('quickFilterText', newValue)' or 'api.updateGridOptions({ quickFilterText: newValue })' instead.`);
      this.gos.updateGridOptions({ options: { quickFilterText: newFilter } });
    }
    /** 
     * @deprecated As of v30, hidden columns are excluded from the Quick Filter by default. To include hidden columns, use `setIncludeHiddenColumnsInQuickFilter` instead.
     */
    setExcludeHiddenColumnsFromQuickFilter(value) {
      this.deprecatedUpdateGridOption("includeHiddenColumnsInQuickFilter", !value);
    }
    /** 
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Updates the `includeHiddenColumnsInQuickFilter` grid option.
     * By default hidden columns are excluded from the Quick Filter.
     * Set to `true` to include them.
     */
    setIncludeHiddenColumnsInQuickFilter(value) {
      this.deprecatedUpdateGridOption("includeHiddenColumnsInQuickFilter", value);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Updates the `quickFilterParser` grid option,
     * which changes how the Quick Filter splits the Quick Filter text into search terms.
     */
    setQuickFilterParser(quickFilterParser) {
      this.deprecatedUpdateGridOption("quickFilterParser", quickFilterParser);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Updates the `quickFilterMatcher` grid option,
     * which changes the matching logic for whether a row passes the Quick Filter.
     */
    setQuickFilterMatcher(quickFilterMatcher) {
      this.deprecatedUpdateGridOption("quickFilterMatcher", quickFilterMatcher);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * If `true`, the horizontal scrollbar will always be present, even if not required. Otherwise, it will only be displayed when necessary.
     * */
    setAlwaysShowHorizontalScroll(show) {
      this.deprecatedUpdateGridOption("alwaysShowHorizontalScroll", show);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * If `true`, the vertical scrollbar will always be present, even if not required. Otherwise it will only be displayed when necessary.
     * */
    setAlwaysShowVerticalScroll(show) {
      this.deprecatedUpdateGridOption("alwaysShowVerticalScroll", show);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     */
    setFunctionsReadOnly(readOnly) {
      this.deprecatedUpdateGridOption("functionsReadOnly", readOnly);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Call to set new column definitions. The grid will redraw all the column headers, and then redraw all of the rows.
     */
    setColumnDefs(colDefs, source = "api") {
      warnOnce(`setColumnDefs is deprecated. Please use 'api.setGridOption('columnDefs', newValue)' or 'api.updateGridOptions({ columnDefs: newValue })' instead.`);
      this.gos.updateGridOptions({
        options: { columnDefs: colDefs },
        source
      });
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Call to set new auto group column definition. The grid will recreate any auto-group columns if present.
     * */
    setAutoGroupColumnDef(colDef, source = "api") {
      warnOnce(`setAutoGroupColumnDef is deprecated. Please use 'api.setGridOption('autoGroupColumnDef', newValue)' or 'api.updateGridOptions({ autoGroupColumnDef: newValue })' instead.`);
      this.gos.updateGridOptions({
        options: { autoGroupColumnDef: colDef },
        source
      });
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Call to set new Default Column Definition.
     * */
    setDefaultColDef(colDef, source = "api") {
      warnOnce(`setDefaultColDef is deprecated. Please use 'api.setGridOption('defaultColDef', newValue)' or 'api.updateGridOptions({ defaultColDef: newValue })' instead.`);
      this.gos.updateGridOptions({
        options: { defaultColDef: colDef },
        source
      });
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Call to set new Column Types.
     * */
    setColumnTypes(columnTypes, source = "api") {
      warnOnce(`setColumnTypes is deprecated. Please use 'api.setGridOption('columnTypes', newValue)' or 'api.updateGridOptions({ columnTypes: newValue })' instead.`);
      this.gos.updateGridOptions({
        options: { columnTypes },
        source
      });
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Sets the `treeData` property.
     * */
    setTreeData(newTreeData) {
      this.deprecatedUpdateGridOption("treeData", newTreeData);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Set new datasource for Server-Side Row Model.
     * */
    setServerSideDatasource(datasource) {
      this.deprecatedUpdateGridOption("serverSideDatasource", datasource);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * 
     * Note this purges all the cached data and reloads all the rows of the grid.
     * */
    setCacheBlockSize(blockSize) {
      this.deprecatedUpdateGridOption("cacheBlockSize", blockSize);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Set new datasource for Infinite Row Model.
     * */
    setDatasource(datasource) {
      this.deprecatedUpdateGridOption("datasource", datasource);
    }
    /** 
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Set new datasource for Viewport Row Model.
     * */
    setViewportDatasource(viewportDatasource) {
      this.deprecatedUpdateGridOption("viewportDatasource", viewportDatasource);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Set the row data.
     * */
    setRowData(rowData) {
      this.deprecatedUpdateGridOption("rowData", rowData);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Sets the `enableCellTextSelection` property.
     * */
    setEnableCellTextSelection(selectable) {
      this.deprecatedUpdateGridOption("enableCellTextSelection", selectable);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Sets the height in pixels for the row containing the column label header.
     * */
    setHeaderHeight(headerHeight) {
      this.deprecatedUpdateGridOption("headerHeight", headerHeight);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Switch between layout options: `normal`, `autoHeight`, `print`.
     * Defaults to `normal` if no domLayout provided.
     */
    setDomLayout(domLayout) {
      this.deprecatedUpdateGridOption("domLayout", domLayout);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Sets the preferred direction for the selection fill handle.
     * */
    setFillHandleDirection(direction) {
      this.deprecatedUpdateGridOption("fillHandleDirection", direction);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Sets the height in pixels for the rows containing header column groups.
     * */
    setGroupHeaderHeight(headerHeight) {
      this.deprecatedUpdateGridOption("groupHeaderHeight", headerHeight);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Sets the height in pixels for the row containing the floating filters.
     * */
    setFloatingFiltersHeight(headerHeight) {
      this.deprecatedUpdateGridOption("floatingFiltersHeight", headerHeight);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Sets the height in pixels for the row containing the columns when in pivot mode.
     * */
    setPivotHeaderHeight(headerHeight) {
      this.deprecatedUpdateGridOption("pivotHeaderHeight", headerHeight);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     * Sets the height in pixels for the row containing header column groups when in pivot mode.
     * */
    setPivotGroupHeaderHeight(headerHeight) {
      this.deprecatedUpdateGridOption("pivotGroupHeaderHeight", headerHeight);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setAnimateRows(animateRows) {
      this.deprecatedUpdateGridOption("animateRows", animateRows);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setIsExternalFilterPresent(isExternalFilterPresentFunc) {
      this.deprecatedUpdateGridOption("isExternalFilterPresent", isExternalFilterPresentFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setDoesExternalFilterPass(doesExternalFilterPassFunc) {
      this.deprecatedUpdateGridOption("doesExternalFilterPass", doesExternalFilterPassFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setNavigateToNextCell(navigateToNextCellFunc) {
      this.deprecatedUpdateGridOption("navigateToNextCell", navigateToNextCellFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setTabToNextCell(tabToNextCellFunc) {
      this.deprecatedUpdateGridOption("tabToNextCell", tabToNextCellFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setTabToNextHeader(tabToNextHeaderFunc) {
      this.deprecatedUpdateGridOption("tabToNextHeader", tabToNextHeaderFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setNavigateToNextHeader(navigateToNextHeaderFunc) {
      this.deprecatedUpdateGridOption("navigateToNextHeader", navigateToNextHeaderFunc);
    }
    setRowGroupPanelShow(rowGroupPanelShow) {
      this.deprecatedUpdateGridOption("rowGroupPanelShow", rowGroupPanelShow);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setGetGroupRowAgg(getGroupRowAggFunc) {
      this.deprecatedUpdateGridOption("getGroupRowAgg", getGroupRowAggFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setGetBusinessKeyForNode(getBusinessKeyForNodeFunc) {
      this.deprecatedUpdateGridOption("getBusinessKeyForNode", getBusinessKeyForNodeFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setGetChildCount(getChildCountFunc) {
      this.deprecatedUpdateGridOption("getChildCount", getChildCountFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setProcessRowPostCreate(processRowPostCreateFunc) {
      this.deprecatedUpdateGridOption("processRowPostCreate", processRowPostCreateFunc);
    }
    /**
     * @deprecated v31 `getRowId` is a static property and cannot be updated.
     *  */
    setGetRowId(getRowIdFunc) {
      warnOnce(`getRowId is a static property and can no longer be updated.`);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setGetRowClass(rowClassFunc) {
      this.deprecatedUpdateGridOption("getRowClass", rowClassFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setIsFullWidthRow(isFullWidthRowFunc) {
      this.deprecatedUpdateGridOption("isFullWidthRow", isFullWidthRowFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setIsRowSelectable(isRowSelectableFunc) {
      this.deprecatedUpdateGridOption("isRowSelectable", isRowSelectableFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setIsRowMaster(isRowMasterFunc) {
      this.deprecatedUpdateGridOption("isRowMaster", isRowMasterFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setPostSortRows(postSortRowsFunc) {
      this.deprecatedUpdateGridOption("postSortRows", postSortRowsFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setGetDocument(getDocumentFunc) {
      this.deprecatedUpdateGridOption("getDocument", getDocumentFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setGetContextMenuItems(getContextMenuItemsFunc) {
      this.deprecatedUpdateGridOption("getContextMenuItems", getContextMenuItemsFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setGetMainMenuItems(getMainMenuItemsFunc) {
      this.deprecatedUpdateGridOption("getMainMenuItems", getMainMenuItemsFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setProcessCellForClipboard(processCellForClipboardFunc) {
      this.deprecatedUpdateGridOption("processCellForClipboard", processCellForClipboardFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setSendToClipboard(sendToClipboardFunc) {
      this.deprecatedUpdateGridOption("sendToClipboard", sendToClipboardFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setProcessCellFromClipboard(processCellFromClipboardFunc) {
      this.deprecatedUpdateGridOption("processCellFromClipboard", processCellFromClipboardFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setProcessPivotResultColDef(processPivotResultColDefFunc) {
      this.deprecatedUpdateGridOption("processPivotResultColDef", processPivotResultColDefFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setProcessPivotResultColGroupDef(processPivotResultColGroupDefFunc) {
      this.deprecatedUpdateGridOption("processPivotResultColGroupDef", processPivotResultColGroupDefFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setPostProcessPopup(postProcessPopupFunc) {
      this.deprecatedUpdateGridOption("postProcessPopup", postProcessPopupFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setInitialGroupOrderComparator(initialGroupOrderComparatorFunc) {
      this.deprecatedUpdateGridOption("initialGroupOrderComparator", initialGroupOrderComparatorFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setGetChartToolbarItems(getChartToolbarItemsFunc) {
      this.deprecatedUpdateGridOption("getChartToolbarItems", getChartToolbarItemsFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setPaginationNumberFormatter(paginationNumberFormatterFunc) {
      this.deprecatedUpdateGridOption("paginationNumberFormatter", paginationNumberFormatterFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setGetServerSideGroupLevelParams(getServerSideGroupLevelParamsFunc) {
      this.deprecatedUpdateGridOption("getServerSideGroupLevelParams", getServerSideGroupLevelParamsFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setIsServerSideGroupOpenByDefault(isServerSideGroupOpenByDefaultFunc) {
      this.deprecatedUpdateGridOption("isServerSideGroupOpenByDefault", isServerSideGroupOpenByDefaultFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setIsApplyServerSideTransaction(isApplyServerSideTransactionFunc) {
      this.deprecatedUpdateGridOption("isApplyServerSideTransaction", isApplyServerSideTransactionFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setIsServerSideGroup(isServerSideGroupFunc) {
      this.deprecatedUpdateGridOption("isServerSideGroup", isServerSideGroupFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setGetServerSideGroupKey(getServerSideGroupKeyFunc) {
      this.deprecatedUpdateGridOption("getServerSideGroupKey", getServerSideGroupKeyFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setGetRowStyle(rowStyleFunc) {
      this.deprecatedUpdateGridOption("getRowStyle", rowStyleFunc);
    }
    /**
     * @deprecated v31 Use `api.setGridOption` or `api.updateGridOptions` instead.
     *  */
    setGetRowHeight(rowHeightFunc) {
      this.deprecatedUpdateGridOption("getRowHeight", rowHeightFunc);
    }
  };
  __decorateClass([
    Autowired("rowRenderer")
  ], GridApi.prototype, "rowRenderer", 2);
  __decorateClass([
    Autowired("navigationService")
  ], GridApi.prototype, "navigationService", 2);
  __decorateClass([
    Autowired("filterManager")
  ], GridApi.prototype, "filterManager", 2);
  __decorateClass([
    Autowired("columnModel")
  ], GridApi.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("selectionService")
  ], GridApi.prototype, "selectionService", 2);
  __decorateClass([
    Autowired("gridOptionsService")
  ], GridApi.prototype, "gos", 2);
  __decorateClass([
    Autowired("valueService")
  ], GridApi.prototype, "valueService", 2);
  __decorateClass([
    Autowired("alignedGridsService")
  ], GridApi.prototype, "alignedGridsService", 2);
  __decorateClass([
    Autowired("eventService")
  ], GridApi.prototype, "eventService", 2);
  __decorateClass([
    Autowired("pinnedRowModel")
  ], GridApi.prototype, "pinnedRowModel", 2);
  __decorateClass([
    Autowired("context")
  ], GridApi.prototype, "context", 2);
  __decorateClass([
    Autowired("rowModel")
  ], GridApi.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("sortController")
  ], GridApi.prototype, "sortController", 2);
  __decorateClass([
    Autowired("paginationProxy")
  ], GridApi.prototype, "paginationProxy", 2);
  __decorateClass([
    Autowired("focusService")
  ], GridApi.prototype, "focusService", 2);
  __decorateClass([
    Autowired("dragAndDropService")
  ], GridApi.prototype, "dragAndDropService", 2);
  __decorateClass([
    Autowired("menuService")
  ], GridApi.prototype, "menuService", 2);
  __decorateClass([
    Autowired("valueCache")
  ], GridApi.prototype, "valueCache", 2);
  __decorateClass([
    Autowired("animationFrameService")
  ], GridApi.prototype, "animationFrameService", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], GridApi.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("overlayService")
  ], GridApi.prototype, "overlayService", 2);
  __decorateClass([
    Autowired("stateService")
  ], GridApi.prototype, "stateService", 2);
  __decorateClass([
    Autowired("expansionService")
  ], GridApi.prototype, "expansionService", 2);
  __decorateClass([
    Autowired("apiEventService")
  ], GridApi.prototype, "apiEventService", 2);
  __decorateClass([
    Autowired("frameworkOverrides")
  ], GridApi.prototype, "frameworkOverrides", 2);
  __decorateClass([
    Autowired("undoRedoService")
  ], GridApi.prototype, "undoRedoService", 2);
  __decorateClass([
    Autowired("rowNodeBlockLoader")
  ], GridApi.prototype, "rowNodeBlockLoader", 2);
  __decorateClass([
    Optional("csvCreator")
  ], GridApi.prototype, "csvCreator", 2);
  __decorateClass([
    Optional("excelCreator")
  ], GridApi.prototype, "excelCreator", 2);
  __decorateClass([
    Optional("rangeService")
  ], GridApi.prototype, "rangeService", 2);
  __decorateClass([
    Optional("clipboardService")
  ], GridApi.prototype, "clipboardService", 2);
  __decorateClass([
    Optional("aggFuncService")
  ], GridApi.prototype, "aggFuncService", 2);
  __decorateClass([
    Optional("statusBarService")
  ], GridApi.prototype, "statusBarService", 2);
  __decorateClass([
    Optional("chartService")
  ], GridApi.prototype, "chartService", 2);
  __decorateClass([
    Optional("ssrmTransactionManager")
  ], GridApi.prototype, "serverSideTransactionManager", 2);
  __decorateClass([
    Optional("sideBarService")
  ], GridApi.prototype, "sideBarService", 2);
  __decorateClass([
    PostConstruct
  ], GridApi.prototype, "init", 1);
  GridApi = __decorateClass([
    Bean("gridApi")
  ], GridApi);
  var QuickFilterService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.quickFilter = null;
      this.quickFilterParts = null;
    }
    postConstruct() {
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, () => this.resetQuickFilterCache());
      this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, () => this.resetQuickFilterCache());
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.resetQuickFilterCache());
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, () => {
        if (!this.gos.get("includeHiddenColumnsInQuickFilter")) {
          this.resetQuickFilterCache();
        }
      });
      this.addManagedPropertyListener("quickFilterText", (e) => this.setQuickFilter(e.currentValue));
      this.addManagedPropertyListeners([
        "includeHiddenColumnsInQuickFilter",
        "applyQuickFilterBeforePivotOrAgg"
      ], () => this.onQuickFilterColumnConfigChanged());
      this.quickFilter = this.parseQuickFilter(this.gos.get("quickFilterText"));
      this.parser = this.gos.get("quickFilterParser");
      this.matcher = this.gos.get("quickFilterMatcher");
      this.setQuickFilterParts();
      this.addManagedPropertyListeners(["quickFilterMatcher", "quickFilterParser"], () => this.setQuickFilterParserAndMatcher());
    }
    isQuickFilterPresent() {
      return this.quickFilter !== null;
    }
    doesRowPassQuickFilter(node) {
      const usingCache = this.gos.get("cacheQuickFilter");
      if (this.matcher) {
        return this.doesRowPassQuickFilterMatcher(usingCache, node);
      }
      return this.quickFilterParts.every(
        (part) => usingCache ? this.doesRowPassQuickFilterCache(node, part) : this.doesRowPassQuickFilterNoCache(node, part)
      );
    }
    resetQuickFilterCache() {
      this.rowModel.forEachNode((node) => node.quickFilterAggregateText = null);
    }
    setQuickFilterParts() {
      const { quickFilter, parser } = this;
      if (quickFilter) {
        this.quickFilterParts = parser ? parser(quickFilter) : quickFilter.split(" ");
      } else {
        this.quickFilterParts = null;
      }
    }
    parseQuickFilter(newFilter) {
      if (!exists(newFilter)) {
        return null;
      }
      if (!this.gos.isRowModelType("clientSide")) {
        console.warn("AG Grid - Quick filtering only works with the Client-Side Row Model");
        return null;
      }
      return newFilter.toUpperCase();
    }
    setQuickFilter(newFilter) {
      if (newFilter != null && typeof newFilter !== "string") {
        console.warn(`AG Grid - Grid option quickFilterText only supports string inputs, received: ${typeof newFilter}`);
        return;
      }
      const parsedFilter = this.parseQuickFilter(newFilter);
      if (this.quickFilter !== parsedFilter) {
        this.quickFilter = parsedFilter;
        this.setQuickFilterParts();
        this.dispatchEvent({ type: QuickFilterService.EVENT_QUICK_FILTER_CHANGED });
      }
    }
    setQuickFilterParserAndMatcher() {
      const parser = this.gos.get("quickFilterParser");
      const matcher = this.gos.get("quickFilterMatcher");
      const hasChanged2 = parser !== this.parser || matcher !== this.matcher;
      this.parser = parser;
      this.matcher = matcher;
      if (hasChanged2) {
        this.setQuickFilterParts();
        this.dispatchEvent({ type: QuickFilterService.EVENT_QUICK_FILTER_CHANGED });
      }
    }
    onQuickFilterColumnConfigChanged() {
      this.columnModel.refreshQuickFilterColumns();
      this.resetQuickFilterCache();
      if (this.isQuickFilterPresent()) {
        this.dispatchEvent({ type: QuickFilterService.EVENT_QUICK_FILTER_CHANGED });
      }
    }
    doesRowPassQuickFilterNoCache(node, filterPart) {
      const columns = this.columnModel.getAllColumnsForQuickFilter();
      return columns.some((column) => {
        const part = this.getQuickFilterTextForColumn(column, node);
        return exists(part) && part.indexOf(filterPart) >= 0;
      });
    }
    doesRowPassQuickFilterCache(node, filterPart) {
      this.checkGenerateQuickFilterAggregateText(node);
      return node.quickFilterAggregateText.indexOf(filterPart) >= 0;
    }
    doesRowPassQuickFilterMatcher(usingCache, node) {
      let quickFilterAggregateText;
      if (usingCache) {
        this.checkGenerateQuickFilterAggregateText(node);
        quickFilterAggregateText = node.quickFilterAggregateText;
      } else {
        quickFilterAggregateText = this.getQuickFilterAggregateText(node);
      }
      const { quickFilterParts, matcher } = this;
      return matcher(quickFilterParts, quickFilterAggregateText);
    }
    checkGenerateQuickFilterAggregateText(node) {
      if (!node.quickFilterAggregateText) {
        node.quickFilterAggregateText = this.getQuickFilterAggregateText(node);
      }
    }
    getQuickFilterTextForColumn(column, node) {
      let value = this.valueService.getValue(column, node, true);
      const colDef = column.getColDef();
      if (colDef.getQuickFilterText) {
        const params = this.gos.addGridCommonParams({
          value,
          node,
          data: node.data,
          column,
          colDef
        });
        value = colDef.getQuickFilterText(params);
      }
      return exists(value) ? value.toString().toUpperCase() : null;
    }
    getQuickFilterAggregateText(node) {
      const stringParts = [];
      const columns = this.columnModel.getAllColumnsForQuickFilter();
      columns.forEach((column) => {
        const part = this.getQuickFilterTextForColumn(column, node);
        if (exists(part)) {
          stringParts.push(part);
        }
      });
      return stringParts.join(QuickFilterService.QUICK_FILTER_SEPARATOR);
    }
  };
  QuickFilterService.EVENT_QUICK_FILTER_CHANGED = "quickFilterChanged";
  QuickFilterService.QUICK_FILTER_SEPARATOR = "\n";
  __decorateClass([
    Autowired("valueService")
  ], QuickFilterService.prototype, "valueService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], QuickFilterService.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("rowModel")
  ], QuickFilterService.prototype, "rowModel", 2);
  __decorateClass([
    PostConstruct
  ], QuickFilterService.prototype, "postConstruct", 1);
  QuickFilterService = __decorateClass([
    Bean("quickFilterService")
  ], QuickFilterService);
  var FilterManager = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.allColumnFilters = /* @__PURE__ */ new Map();
      this.allColumnListeners = /* @__PURE__ */ new Map();
      this.activeAggregateFilters = [];
      this.activeColumnFilters = [];
      this.processingFilterChange = false;
      this.filterModelUpdateQueue = [];
      this.columnFilterModelUpdateQueue = [];
      this.advancedFilterModelUpdateQueue = [];
    }
    init() {
      var _a, _b, _c;
      this.addManagedListener(this.eventService, Events.EVENT_GRID_COLUMNS_CHANGED, () => this.onColumnsChanged());
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, () => this.refreshFiltersForAggregations());
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, () => this.refreshFiltersForAggregations());
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, () => this.refreshFiltersForAggregations());
      this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, () => this.updateAdvancedFilterColumns());
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, () => this.updateAdvancedFilterColumns());
      this.addManagedListener(this.eventService, Events.EVENT_ROW_DATA_UPDATED, () => this.onNewRowsLoaded("rowDataUpdated"));
      this.externalFilterPresent = this.isExternalFilterPresentCallback();
      this.addManagedPropertyListeners(["isExternalFilterPresent", "doesExternalFilterPass"], () => {
        this.onFilterChanged({ source: "api" });
      });
      this.updateAggFiltering();
      this.addManagedPropertyListener("groupAggFiltering", () => {
        this.updateAggFiltering();
        this.onFilterChanged();
      });
      this.addManagedPropertyListener("advancedFilterModel", (event) => this.setAdvancedFilterModel(event.currentValue));
      this.addManagedListener(
        this.eventService,
        Events.EVENT_ADVANCED_FILTER_ENABLED_CHANGED,
        ({ enabled }) => this.onAdvancedFilterEnabledChanged(enabled)
      );
      this.addManagedListener(this.eventService, Events.EVENT_DATA_TYPES_INFERRED, () => this.processFilterModelUpdateQueue());
      this.addManagedListener(this.quickFilterService, QuickFilterService.EVENT_QUICK_FILTER_CHANGED, () => this.onFilterChanged({ source: "quickFilter" }));
      this.initialFilterModel = __spreadValues({}, (_c = (_b = (_a = this.gos.get("initialState")) == null ? void 0 : _a.filter) == null ? void 0 : _b.filterModel) != null ? _c : {});
    }
    isExternalFilterPresentCallback() {
      const isFilterPresent = this.gos.getCallback("isExternalFilterPresent");
      if (typeof isFilterPresent === "function") {
        return isFilterPresent({});
      }
      return false;
    }
    doesExternalFilterPass(node) {
      const doesFilterPass = this.gos.get("doesExternalFilterPass");
      if (typeof doesFilterPass === "function") {
        return doesFilterPass(node);
      }
      return false;
    }
    setFilterModel(model, source = "api") {
      if (this.isAdvancedFilterEnabled()) {
        this.warnAdvancedFilters();
        return;
      }
      if (this.dataTypeService.isPendingInference()) {
        this.filterModelUpdateQueue.push({ model, source });
        return;
      }
      const allPromises = [];
      const previousModel = this.getFilterModel();
      if (model) {
        const modelKeys = convertToSet(Object.keys(model));
        this.allColumnFilters.forEach((filterWrapper, colId) => {
          const newModel = model[colId];
          allPromises.push(this.setModelOnFilterWrapper(filterWrapper.filterPromise, newModel));
          modelKeys.delete(colId);
        });
        modelKeys.forEach((colId) => {
          const column = this.columnModel.getPrimaryColumn(colId) || this.columnModel.getGridColumn(colId);
          if (!column) {
            console.warn("AG Grid: setFilterModel() - no column found for colId: " + colId);
            return;
          }
          if (!column.isFilterAllowed()) {
            console.warn("AG Grid: setFilterModel() - unable to fully apply model, filtering disabled for colId: " + colId);
            return;
          }
          const filterWrapper = this.getOrCreateFilterWrapper(column, "NO_UI");
          if (!filterWrapper) {
            console.warn("AG-Grid: setFilterModel() - unable to fully apply model, unable to create filter for colId: " + colId);
            return;
          }
          allPromises.push(this.setModelOnFilterWrapper(filterWrapper.filterPromise, model[colId]));
        });
      } else {
        this.allColumnFilters.forEach((filterWrapper) => {
          allPromises.push(this.setModelOnFilterWrapper(filterWrapper.filterPromise, null));
        });
      }
      AgPromise.all(allPromises).then(() => {
        const currentModel = this.getFilterModel();
        const columns = [];
        this.allColumnFilters.forEach((filterWrapper, colId) => {
          const before = previousModel ? previousModel[colId] : null;
          const after = currentModel ? currentModel[colId] : null;
          if (!_.jsonEquals(before, after)) {
            columns.push(filterWrapper.column);
          }
        });
        if (columns.length > 0) {
          this.onFilterChanged({ columns, source });
        }
      });
    }
    setModelOnFilterWrapper(filterPromise, newModel) {
      return new AgPromise((resolve2) => {
        filterPromise.then((filter) => {
          if (typeof filter.setModel !== "function") {
            console.warn("AG Grid: filter missing setModel method, which is needed for setFilterModel");
            resolve2();
          }
          (filter.setModel(newModel) || AgPromise.resolve()).then(() => resolve2());
        });
      });
    }
    getFilterModel() {
      const result = {};
      this.allColumnFilters.forEach((filterWrapper, key) => {
        const model = this.getModelFromFilterWrapper(filterWrapper);
        if (exists(model)) {
          result[key] = model;
        }
      });
      return result;
    }
    getModelFromFilterWrapper(filterWrapper) {
      var _a;
      const filterPromise = filterWrapper.filterPromise;
      const filter = filterPromise.resolveNow(null, (promiseFilter) => promiseFilter);
      if (filter == null) {
        return (_a = this.initialFilterModel[filterWrapper.column.getColId()]) != null ? _a : null;
      }
      if (typeof filter.getModel !== "function") {
        console.warn("AG Grid: filter API missing getModel method, which is needed for getFilterModel");
        return null;
      }
      return filter.getModel();
    }
    isColumnFilterPresent() {
      return this.activeColumnFilters.length > 0;
    }
    isAggregateFilterPresent() {
      return !!this.activeAggregateFilters.length;
    }
    isExternalFilterPresent() {
      return this.externalFilterPresent;
    }
    isChildFilterPresent() {
      return this.isColumnFilterPresent() || this.isQuickFilterPresent() || this.isExternalFilterPresent() || this.isAdvancedFilterPresent();
    }
    isAdvancedFilterPresent() {
      return this.isAdvancedFilterEnabled() && this.advancedFilterService.isFilterPresent();
    }
    onAdvancedFilterEnabledChanged(enabled) {
      var _a;
      if (enabled) {
        if (this.allColumnFilters.size) {
          this.allColumnFilters.forEach((filterWrapper) => this.disposeFilterWrapper(filterWrapper, "advancedFilterEnabled"));
          this.onFilterChanged({ source: "advancedFilter" });
        }
      } else {
        if ((_a = this.advancedFilterService) == null ? void 0 : _a.isFilterPresent()) {
          this.advancedFilterService.setModel(null);
          this.onFilterChanged({ source: "advancedFilter" });
        }
      }
    }
    isAdvancedFilterEnabled() {
      var _a;
      return !!((_a = this.advancedFilterService) == null ? void 0 : _a.isEnabled());
    }
    isAdvancedFilterHeaderActive() {
      return this.isAdvancedFilterEnabled() && this.advancedFilterService.isHeaderActive();
    }
    doAggregateFiltersPass(node, filterToSkip) {
      return this.doColumnFiltersPass(node, filterToSkip, true);
    }
    // called by:
    // 1) onFilterChanged()
    // 2) onNewRowsLoaded()
    updateActiveFilters() {
      this.activeColumnFilters.length = 0;
      this.activeAggregateFilters.length = 0;
      const isFilterActive = (filter) => {
        if (!filter) {
          return false;
        }
        if (!filter.isFilterActive) {
          console.warn("AG Grid: Filter is missing isFilterActive() method");
          return false;
        }
        return filter.isFilterActive();
      };
      const groupFilterEnabled = !!this.gos.getGroupAggFiltering();
      const isAggFilter = (column) => {
        const isSecondary = !column.isPrimary();
        if (isSecondary) {
          return true;
        }
        const isShowingPrimaryColumns = !this.columnModel.isPivotActive();
        const isValueActive = column.isValueActive();
        if (!isValueActive || !isShowingPrimaryColumns) {
          return false;
        }
        if (this.columnModel.isPivotMode()) {
          return true;
        }
        return groupFilterEnabled;
      };
      this.allColumnFilters.forEach((filterWrapper) => {
        if (filterWrapper.filterPromise.resolveNow(false, isFilterActive)) {
          const filterComp = filterWrapper.filterPromise.resolveNow(null, (filter) => filter);
          if (isAggFilter(filterWrapper.column)) {
            this.activeAggregateFilters.push(filterComp);
          } else {
            this.activeColumnFilters.push(filterComp);
          }
        }
      });
    }
    updateFilterFlagInColumns(source, additionalEventAttributes) {
      this.allColumnFilters.forEach((filterWrapper) => {
        const isFilterActive = filterWrapper.filterPromise.resolveNow(false, (filter) => filter.isFilterActive());
        filterWrapper.column.setFilterActive(isFilterActive, source, additionalEventAttributes);
      });
    }
    isAnyFilterPresent() {
      return this.isQuickFilterPresent() || this.isColumnFilterPresent() || this.isAggregateFilterPresent() || this.isExternalFilterPresent() || this.isAdvancedFilterPresent();
    }
    doColumnFiltersPass(node, filterToSkip, targetAggregates) {
      const { data, aggData } = node;
      const targetedFilters = targetAggregates ? this.activeAggregateFilters : this.activeColumnFilters;
      const targetedData = targetAggregates ? aggData : data;
      for (let i = 0; i < targetedFilters.length; i++) {
        const filter = targetedFilters[i];
        if (filter == null || filter === filterToSkip) {
          continue;
        }
        if (typeof filter.doesFilterPass !== "function") {
          throw new Error("Filter is missing method doesFilterPass");
        }
        if (!filter.doesFilterPass({ node, data: targetedData })) {
          return false;
        }
      }
      return true;
    }
    resetQuickFilterCache() {
      this.quickFilterService.resetQuickFilterCache();
    }
    refreshFiltersForAggregations() {
      const isAggFiltering = this.gos.getGroupAggFiltering();
      if (isAggFiltering) {
        this.onFilterChanged();
      }
    }
    // sometimes (especially in React) the filter can call onFilterChanged when we are in the middle
    // of a render cycle. this would be bad, so we wait for render cycle to complete when this happens.
    // this happens in react when we change React State in the grid (eg setting RowCtrl's in RowContainer)
    // which results in React State getting applied in the main application, triggering a useEffect() to
    // be kicked off adn then the application calling the grid's API. in AG-6554, the custom filter was
    // getting it's useEffect() triggered in this way.
    callOnFilterChangedOutsideRenderCycle(params) {
      const action = () => this.onFilterChanged(params);
      if (this.rowRenderer.isRefreshInProgress()) {
        setTimeout(action, 0);
      } else {
        action();
      }
    }
    onFilterChanged(params = {}) {
      const { source, filterInstance, additionalEventAttributes, columns } = params;
      this.updateDependantFilters();
      this.updateActiveFilters();
      this.updateFilterFlagInColumns("filterChanged", additionalEventAttributes);
      this.externalFilterPresent = this.isExternalFilterPresentCallback();
      this.allColumnFilters.forEach((filterWrapper) => {
        if (!filterWrapper.filterPromise) {
          return;
        }
        filterWrapper.filterPromise.then((filter) => {
          if (filter && filter !== filterInstance && filter.onAnyFilterChanged) {
            filter.onAnyFilterChanged();
          }
        });
      });
      const filterChangedEvent = {
        source,
        type: Events.EVENT_FILTER_CHANGED,
        columns: columns || []
      };
      if (additionalEventAttributes) {
        mergeDeep(filterChangedEvent, additionalEventAttributes);
      }
      this.processingFilterChange = true;
      this.eventService.dispatchEvent(filterChangedEvent);
      this.processingFilterChange = false;
    }
    isSuppressFlashingCellsBecauseFiltering() {
      var _a;
      const allowShowChangeAfterFilter = (_a = this.gos.get("allowShowChangeAfterFilter")) != null ? _a : false;
      return !allowShowChangeAfterFilter && this.processingFilterChange;
    }
    isQuickFilterPresent() {
      return this.quickFilterService.isQuickFilterPresent();
    }
    updateAggFiltering() {
      this.aggFiltering = !!this.gos.getGroupAggFiltering();
    }
    isAggregateQuickFilterPresent() {
      return this.isQuickFilterPresent() && this.shouldApplyQuickFilterAfterAgg();
    }
    isNonAggregateQuickFilterPresent() {
      return this.isQuickFilterPresent() && !this.shouldApplyQuickFilterAfterAgg();
    }
    shouldApplyQuickFilterAfterAgg() {
      return (this.aggFiltering || this.columnModel.isPivotMode()) && !this.gos.get("applyQuickFilterBeforePivotOrAgg");
    }
    doesRowPassOtherFilters(filterToSkip, node) {
      return this.doesRowPassFilter({ rowNode: node, filterInstanceToSkip: filterToSkip });
    }
    doesRowPassAggregateFilters(params) {
      if (this.isAggregateQuickFilterPresent() && !this.quickFilterService.doesRowPassQuickFilter(params.rowNode)) {
        return false;
      }
      if (this.isAggregateFilterPresent() && !this.doAggregateFiltersPass(params.rowNode, params.filterInstanceToSkip)) {
        return false;
      }
      return true;
    }
    doesRowPassFilter(params) {
      if (this.isNonAggregateQuickFilterPresent() && !this.quickFilterService.doesRowPassQuickFilter(params.rowNode)) {
        return false;
      }
      if (this.isExternalFilterPresent() && !this.doesExternalFilterPass(params.rowNode)) {
        return false;
      }
      if (this.isColumnFilterPresent() && !this.doColumnFiltersPass(params.rowNode, params.filterInstanceToSkip)) {
        return false;
      }
      if (this.isAdvancedFilterPresent() && !this.advancedFilterService.doesFilterPass(params.rowNode)) {
        return false;
      }
      return true;
    }
    onNewRowsLoaded(source) {
      this.allColumnFilters.forEach((filterWrapper) => {
        filterWrapper.filterPromise.then((filter) => {
          if (filter.onNewRowsLoaded) {
            filter.onNewRowsLoaded();
          }
        });
      });
      this.updateFilterFlagInColumns(source, { afterDataChange: true });
      this.updateActiveFilters();
    }
    createValueGetter(column) {
      return ({ node }) => this.valueService.getValue(column, node, true);
    }
    createGetValue(filterColumn) {
      return (rowNode, column) => {
        const columnToUse = column ? this.columnModel.getGridColumn(column) : filterColumn;
        return columnToUse ? this.valueService.getValue(columnToUse, rowNode, true) : void 0;
      };
    }
    getFilterComponent(column, source, createIfDoesNotExist = true) {
      var _a;
      if (createIfDoesNotExist) {
        return ((_a = this.getOrCreateFilterWrapper(column, source)) == null ? void 0 : _a.filterPromise) || null;
      }
      const filterWrapper = this.cachedFilter(column);
      return filterWrapper ? filterWrapper.filterPromise : null;
    }
    isFilterActive(column) {
      const filterWrapper = this.cachedFilter(column);
      return !!filterWrapper && filterWrapper.filterPromise.resolveNow(false, (filter) => filter.isFilterActive());
    }
    getOrCreateFilterWrapper(column, source) {
      if (!column.isFilterAllowed()) {
        return null;
      }
      let filterWrapper = this.cachedFilter(column);
      if (!filterWrapper) {
        filterWrapper = this.createFilterWrapper(column, source);
        this.setColumnFilterWrapper(column, filterWrapper);
      }
      return filterWrapper;
    }
    cachedFilter(column) {
      return this.allColumnFilters.get(column.getColId());
    }
    getDefaultFilter(column) {
      let defaultFilter;
      if (ModuleRegistry.__isRegistered("@ag-grid-enterprise/set-filter", this.context.getGridId())) {
        defaultFilter = "agSetColumnFilter";
      } else {
        const cellDataType = this.dataTypeService.getBaseDataType(column);
        if (cellDataType === "number") {
          defaultFilter = "agNumberColumnFilter";
        } else if (cellDataType === "date" || cellDataType === "dateString") {
          defaultFilter = "agDateColumnFilter";
        } else {
          defaultFilter = "agTextColumnFilter";
        }
      }
      return defaultFilter;
    }
    getDefaultFloatingFilter(column) {
      let defaultFloatingFilterType;
      if (ModuleRegistry.__isRegistered("@ag-grid-enterprise/set-filter", this.context.getGridId())) {
        defaultFloatingFilterType = "agSetColumnFloatingFilter";
      } else {
        const cellDataType = this.dataTypeService.getBaseDataType(column);
        if (cellDataType === "number") {
          defaultFloatingFilterType = "agNumberColumnFloatingFilter";
        } else if (cellDataType === "date" || cellDataType === "dateString") {
          defaultFloatingFilterType = "agDateColumnFloatingFilter";
        } else {
          defaultFloatingFilterType = "agTextColumnFloatingFilter";
        }
      }
      return defaultFloatingFilterType;
    }
    createFilterInstance(column) {
      const defaultFilter = this.getDefaultFilter(column);
      const colDef = column.getColDef();
      let filterInstance;
      const params = __spreadProps(__spreadValues({}, this.createFilterParams(column, colDef)), {
        filterModifiedCallback: () => this.filterModifiedCallbackFactory(filterInstance, column)(),
        filterChangedCallback: (additionalEventAttributes) => this.filterChangedCallbackFactory(filterInstance, column)(additionalEventAttributes),
        doesRowPassOtherFilter: (node) => this.doesRowPassOtherFilters(filterInstance, node)
      });
      const compDetails = this.userComponentFactory.getFilterDetails(colDef, params, defaultFilter);
      if (!compDetails) {
        return { filterPromise: null, compDetails: null };
      }
      return {
        filterPromise: () => {
          const filterPromise = compDetails.newAgStackInstance();
          if (filterPromise) {
            filterPromise.then((r) => filterInstance = r);
          }
          return filterPromise;
        },
        compDetails
      };
    }
    createFilterParams(column, colDef) {
      const params = this.gos.addGridCommonParams({
        column,
        colDef: cloneObject(colDef),
        rowModel: this.rowModel,
        filterChangedCallback: () => {
        },
        filterModifiedCallback: () => {
        },
        valueGetter: this.createValueGetter(column),
        getValue: this.createGetValue(column),
        doesRowPassOtherFilter: () => true
      });
      return params;
    }
    createFilterWrapper(column, source) {
      var _a;
      const filterWrapper = {
        column,
        filterPromise: null,
        compiledElement: null,
        compDetails: null
      };
      const { filterPromise, compDetails } = this.createFilterInstance(column);
      filterWrapper.filterPromise = (_a = filterPromise == null ? void 0 : filterPromise()) != null ? _a : null;
      filterWrapper.compDetails = compDetails;
      return filterWrapper;
    }
    onColumnsChanged() {
      const columns = [];
      this.allColumnFilters.forEach((wrapper, colId) => {
        let currentColumn;
        if (wrapper.column.isPrimary()) {
          currentColumn = this.columnModel.getPrimaryColumn(colId);
        } else {
          currentColumn = this.columnModel.getGridColumn(colId);
        }
        if (currentColumn && currentColumn === wrapper.column) {
          return;
        }
        columns.push(wrapper.column);
        this.disposeFilterWrapper(wrapper, "columnChanged");
        this.disposeColumnListener(colId);
      });
      if (columns.length > 0) {
        this.onFilterChanged({ columns, source: "api" });
      } else {
        this.updateDependantFilters();
      }
    }
    updateDependantFilters() {
      const groupColumns = this.columnModel.getGroupAutoColumns();
      groupColumns == null ? void 0 : groupColumns.forEach((groupColumn) => {
        if (groupColumn.getColDef().filter === "agGroupColumnFilter") {
          this.getOrCreateFilterWrapper(groupColumn, "NO_UI");
        }
      });
    }
    // for group filters, can change dynamically whether they are allowed or not
    isFilterAllowed(column) {
      var _a, _b;
      if (this.isAdvancedFilterEnabled()) {
        return false;
      }
      const isFilterAllowed = column.isFilterAllowed();
      if (!isFilterAllowed) {
        return false;
      }
      const filterWrapper = this.allColumnFilters.get(column.getColId());
      return (_b = (_a = filterWrapper == null ? void 0 : filterWrapper.filterPromise) == null ? void 0 : _a.resolveNow(
        true,
        // defer to filter component isFilterAllowed if it exists
        (filter) => typeof (filter == null ? void 0 : filter.isFilterAllowed) === "function" ? filter == null ? void 0 : filter.isFilterAllowed() : true
      )) != null ? _b : true;
    }
    getFloatingFilterCompDetails(column, showParentFilter) {
      const parentFilterInstance = (callback) => {
        const filterComponent = this.getFilterComponent(column, "NO_UI");
        if (filterComponent == null) {
          return;
        }
        filterComponent.then((instance) => {
          callback(unwrapUserComp(instance));
        });
      };
      const colDef = column.getColDef();
      const filterParams = __spreadProps(__spreadValues({}, this.createFilterParams(column, colDef)), {
        filterChangedCallback: () => parentFilterInstance((filterInstance) => this.filterChangedCallbackFactory(filterInstance, column)())
      });
      const finalFilterParams = this.userComponentFactory.mergeParamsWithApplicationProvidedParams(colDef, FilterComponent, filterParams);
      let defaultFloatingFilterType = this.userComponentFactory.getDefaultFloatingFilterType(colDef, () => this.getDefaultFloatingFilter(column));
      if (defaultFloatingFilterType == null) {
        defaultFloatingFilterType = "agReadOnlyFloatingFilter";
      }
      const params = {
        column,
        filterParams: finalFilterParams,
        currentParentModel: () => this.getCurrentFloatingFilterParentModel(column),
        parentFilterInstance,
        showParentFilter,
        suppressFilterButton: false
        // This one might be overridden from the colDef
      };
      return this.userComponentFactory.getFloatingFilterCompDetails(colDef, params, defaultFloatingFilterType);
    }
    getCurrentFloatingFilterParentModel(column) {
      const filterComponent = this.getFilterComponent(column, "NO_UI", false);
      return filterComponent ? filterComponent.resolveNow(null, (filter) => filter && filter.getModel()) : null;
    }
    // destroys the filter, so it no longer takes part
    destroyFilter(column, source = "api") {
      const colId = column.getColId();
      const filterWrapper = this.allColumnFilters.get(colId);
      this.disposeColumnListener(colId);
      delete this.initialFilterModel[colId];
      if (filterWrapper) {
        this.disposeFilterWrapper(filterWrapper, source);
        this.onFilterChanged({
          columns: [column],
          source: "api"
        });
      }
    }
    disposeColumnListener(colId) {
      const columnListener = this.allColumnListeners.get(colId);
      if (columnListener) {
        this.allColumnListeners.delete(colId);
        columnListener();
      }
    }
    disposeFilterWrapper(filterWrapper, source) {
      filterWrapper.filterPromise.then((filter) => {
        this.getContext().destroyBean(filter);
        filterWrapper.column.setFilterActive(false, "filterDestroyed");
        this.allColumnFilters.delete(filterWrapper.column.getColId());
        const event = {
          type: Events.EVENT_FILTER_DESTROYED,
          source,
          column: filterWrapper.column
        };
        this.eventService.dispatchEvent(event);
      });
    }
    filterModifiedCallbackFactory(filter, column) {
      return () => {
        const event = {
          type: Events.EVENT_FILTER_MODIFIED,
          column,
          filterInstance: filter
        };
        this.eventService.dispatchEvent(event);
      };
    }
    filterChangedCallbackFactory(filter, column) {
      return (additionalEventAttributes) => {
        var _a;
        const source = (_a = additionalEventAttributes == null ? void 0 : additionalEventAttributes.source) != null ? _a : "api";
        const params = {
          filter,
          additionalEventAttributes,
          columns: [column],
          source
        };
        this.callOnFilterChangedOutsideRenderCycle(params);
      };
    }
    checkDestroyFilter(colId) {
      const filterWrapper = this.allColumnFilters.get(colId);
      if (!filterWrapper) {
        return;
      }
      const column = filterWrapper.column;
      const { compDetails } = column.isFilterAllowed() ? this.createFilterInstance(column) : { compDetails: null };
      if (this.areFilterCompsDifferent(filterWrapper.compDetails, compDetails)) {
        this.destroyFilter(column, "paramsUpdated");
        return;
      }
      const newFilterParams = column.getColDef().filterParams;
      if (!filterWrapper.filterPromise) {
        this.destroyFilter(column, "paramsUpdated");
        return;
      }
      filterWrapper.filterPromise.then((filter) => {
        const shouldRefreshFilter = (filter == null ? void 0 : filter.refresh) ? filter.refresh(__spreadValues(__spreadProps(__spreadValues({}, this.createFilterParams(column, column.getColDef())), {
          filterModifiedCallback: this.filterModifiedCallbackFactory(filter, column),
          filterChangedCallback: this.filterChangedCallbackFactory(filter, column),
          doesRowPassOtherFilter: (node) => this.doesRowPassOtherFilters(filter, node)
        }), newFilterParams)) : true;
        if (shouldRefreshFilter === false) {
          this.destroyFilter(column, "paramsUpdated");
        }
      });
    }
    setColumnFilterWrapper(column, filterWrapper) {
      const colId = column.getColId();
      this.allColumnFilters.set(colId, filterWrapper);
      this.allColumnListeners.set(
        colId,
        this.addManagedListener(
          column,
          Column.EVENT_COL_DEF_CHANGED,
          () => this.checkDestroyFilter(colId)
        )
      );
    }
    areFilterCompsDifferent(oldCompDetails, newCompDetails) {
      if (!newCompDetails || !oldCompDetails) {
        return true;
      }
      const { componentClass: oldComponentClass } = oldCompDetails;
      const { componentClass: newComponentClass } = newCompDetails;
      const isSameComponentClass = oldComponentClass === newComponentClass || // react hooks returns new wrappers, so check nested render method
      (oldComponentClass == null ? void 0 : oldComponentClass.render) && (newComponentClass == null ? void 0 : newComponentClass.render) && oldComponentClass.render === newComponentClass.render;
      return !isSameComponentClass;
    }
    getAdvancedFilterModel() {
      return this.isAdvancedFilterEnabled() ? this.advancedFilterService.getModel() : null;
    }
    setAdvancedFilterModel(expression) {
      if (!this.isAdvancedFilterEnabled()) {
        return;
      }
      if (this.dataTypeService.isPendingInference()) {
        this.advancedFilterModelUpdateQueue.push(expression);
        return;
      }
      this.advancedFilterService.setModel(expression != null ? expression : null);
      this.onFilterChanged({ source: "advancedFilter" });
    }
    showAdvancedFilterBuilder(source) {
      if (!this.isAdvancedFilterEnabled()) {
        return;
      }
      this.advancedFilterService.getCtrl().toggleFilterBuilder(source, true);
    }
    updateAdvancedFilterColumns() {
      if (!this.isAdvancedFilterEnabled()) {
        return;
      }
      if (this.advancedFilterService.updateValidity()) {
        this.onFilterChanged({ source: "advancedFilter" });
      }
    }
    hasFloatingFilters() {
      if (this.isAdvancedFilterEnabled()) {
        return false;
      }
      const gridColumns = this.columnModel.getAllGridColumns();
      return gridColumns.some((col) => col.getColDef().floatingFilter);
    }
    getFilterInstance(key, callback) {
      if (this.isAdvancedFilterEnabled()) {
        this.warnAdvancedFilters();
        return void 0;
      }
      const res = this.getFilterInstanceImpl(key, (instance) => {
        if (!callback) {
          return;
        }
        const unwrapped2 = unwrapUserComp(instance);
        callback(unwrapped2);
      });
      const unwrapped = unwrapUserComp(res);
      return unwrapped;
    }
    getColumnFilterInstance(key) {
      return new Promise((resolve2) => {
        this.getFilterInstance(key, (filter) => {
          resolve2(filter);
        });
      });
    }
    getFilterInstanceImpl(key, callback) {
      const column = this.columnModel.getPrimaryColumn(key);
      if (!column) {
        return void 0;
      }
      const filterPromise = this.getFilterComponent(column, "NO_UI");
      const currentValue = filterPromise && filterPromise.resolveNow(null, (filterComp) => filterComp);
      if (currentValue) {
        setTimeout(callback, 0, currentValue);
      } else if (filterPromise) {
        filterPromise.then((comp) => {
          callback(comp);
        });
      }
      return currentValue;
    }
    warnAdvancedFilters() {
      warnOnce("Column Filter API methods have been disabled as Advanced Filters are enabled.");
    }
    setupAdvancedFilterHeaderComp(eCompToInsertBefore) {
      var _a;
      (_a = this.advancedFilterService) == null ? void 0 : _a.getCtrl().setupHeaderComp(eCompToInsertBefore);
    }
    getHeaderRowCount() {
      return this.isAdvancedFilterHeaderActive() ? 1 : 0;
    }
    getHeaderHeight() {
      return this.isAdvancedFilterHeaderActive() ? this.advancedFilterService.getCtrl().getHeaderHeight() : 0;
    }
    processFilterModelUpdateQueue() {
      this.filterModelUpdateQueue.forEach(({ model, source }) => this.setFilterModel(model, source));
      this.filterModelUpdateQueue = [];
      this.columnFilterModelUpdateQueue.forEach(({ key, model, resolve: resolve2 }) => {
        this.setColumnFilterModel(key, model).then(() => resolve2());
      });
      this.columnFilterModelUpdateQueue = [];
      this.advancedFilterModelUpdateQueue.forEach((model) => this.setAdvancedFilterModel(model));
      this.advancedFilterModelUpdateQueue = [];
    }
    getColumnFilterModel(key) {
      const filterWrapper = this.getFilterWrapper(key);
      return filterWrapper ? this.getModelFromFilterWrapper(filterWrapper) : null;
    }
    setColumnFilterModel(key, model) {
      if (this.isAdvancedFilterEnabled()) {
        this.warnAdvancedFilters();
        return Promise.resolve();
      }
      if (this.dataTypeService.isPendingInference()) {
        let resolve2 = () => {
        };
        const promise = new Promise((res) => {
          resolve2 = res;
        });
        this.columnFilterModelUpdateQueue.push({ key, model, resolve: resolve2 });
        return promise;
      }
      const column = this.columnModel.getPrimaryColumn(key);
      const filterWrapper = column ? this.getOrCreateFilterWrapper(column, "NO_UI") : null;
      const convertPromise = (promise) => {
        return new Promise((resolve2) => {
          promise.then((result) => resolve2(result));
        });
      };
      return filterWrapper ? convertPromise(this.setModelOnFilterWrapper(filterWrapper.filterPromise, model)) : Promise.resolve();
    }
    getFilterWrapper(key) {
      var _a;
      const column = this.columnModel.getPrimaryColumn(key);
      return column ? (_a = this.cachedFilter(column)) != null ? _a : null : null;
    }
    destroy() {
      super.destroy();
      this.allColumnFilters.forEach((filterWrapper) => this.disposeFilterWrapper(filterWrapper, "gridDestroyed"));
      this.allColumnListeners.clear();
    }
  };
  __decorateClass([
    Autowired("valueService")
  ], FilterManager.prototype, "valueService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], FilterManager.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("rowModel")
  ], FilterManager.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("userComponentFactory")
  ], FilterManager.prototype, "userComponentFactory", 2);
  __decorateClass([
    Autowired("rowRenderer")
  ], FilterManager.prototype, "rowRenderer", 2);
  __decorateClass([
    Autowired("dataTypeService")
  ], FilterManager.prototype, "dataTypeService", 2);
  __decorateClass([
    Autowired("quickFilterService")
  ], FilterManager.prototype, "quickFilterService", 2);
  __decorateClass([
    Optional("advancedFilterService")
  ], FilterManager.prototype, "advancedFilterService", 2);
  __decorateClass([
    PostConstruct
  ], FilterManager.prototype, "init", 1);
  FilterManager = __decorateClass([
    Bean("filterManager")
  ], FilterManager);
  var FilterWrapperComp = class extends Component {
    constructor(column, source) {
      super(
        /* html */
        `<div class="ag-filter"></div>`
      );
      this.column = column;
      this.source = source;
      this.filterWrapper = null;
    }
    postConstruct() {
      this.createFilter(true);
      this.addManagedListener(this.eventService, Events.EVENT_FILTER_DESTROYED, this.onFilterDestroyed.bind(this));
    }
    hasFilter() {
      return !!this.filterWrapper;
    }
    getFilter() {
      var _a, _b;
      return (_b = (_a = this.filterWrapper) == null ? void 0 : _a.filterPromise) != null ? _b : null;
    }
    afterInit() {
      var _a, _b, _c;
      return (_c = (_b = (_a = this.filterWrapper) == null ? void 0 : _a.filterPromise) == null ? void 0 : _b.then(() => {
      })) != null ? _c : AgPromise.resolve();
    }
    afterGuiAttached(params) {
      var _a, _b;
      (_b = (_a = this.filterWrapper) == null ? void 0 : _a.filterPromise) == null ? void 0 : _b.then((filter) => {
        var _a2;
        (_a2 = filter == null ? void 0 : filter.afterGuiAttached) == null ? void 0 : _a2.call(filter, params);
      });
    }
    afterGuiDetached() {
      var _a, _b;
      (_b = (_a = this.filterWrapper) == null ? void 0 : _a.filterPromise) == null ? void 0 : _b.then((filter) => {
        var _a2;
        (_a2 = filter == null ? void 0 : filter.afterGuiDetached) == null ? void 0 : _a2.call(filter);
      });
    }
    createFilter(init) {
      var _a;
      const { column, source } = this;
      this.filterWrapper = this.filterManager.getOrCreateFilterWrapper(column, source);
      if (!((_a = this.filterWrapper) == null ? void 0 : _a.filterPromise)) {
        return;
      }
      this.filterWrapper.filterPromise.then((filter) => {
        let guiFromFilter = filter.getGui();
        if (!exists(guiFromFilter)) {
          console.warn(`AG Grid: getGui method from filter returned ${guiFromFilter}, it should be a DOM element or an HTML template string.`);
        }
        if (typeof guiFromFilter === "string") {
          guiFromFilter = loadTemplate(guiFromFilter);
        }
        this.appendChild(guiFromFilter);
        if (init) {
          const event = {
            type: Events.EVENT_FILTER_OPENED,
            column,
            source,
            eGui: this.getGui()
          };
          this.eventService.dispatchEvent(event);
        }
      });
    }
    onFilterDestroyed(event) {
      if ((event.source === "api" || event.source === "paramsUpdated") && event.column.getId() === this.column.getId() && this.columnModel.getPrimaryColumn(this.column)) {
        clearElement(this.getGui());
        this.createFilter();
      }
    }
    destroy() {
      this.filterWrapper = null;
      super.destroy();
    }
  };
  __decorateClass([
    Autowired("filterManager")
  ], FilterWrapperComp.prototype, "filterManager", 2);
  __decorateClass([
    Autowired("columnModel")
  ], FilterWrapperComp.prototype, "columnModel", 2);
  __decorateClass([
    PostConstruct
  ], FilterWrapperComp.prototype, "postConstruct", 1);
  var AbstractHeaderCellComp = class extends Component {
    constructor(template, ctrl) {
      super(template);
      this.ctrl = ctrl;
    }
    getCtrl() {
      return this.ctrl;
    }
  };
  var _HeaderFilterCellComp = class _HeaderFilterCellComp2 extends AbstractHeaderCellComp {
    constructor(ctrl) {
      super(_HeaderFilterCellComp2.TEMPLATE, ctrl);
    }
    postConstruct() {
      const eGui = this.getGui();
      const compProxy = {
        addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
        addOrRemoveBodyCssClass: (cssClassName, on) => this.eFloatingFilterBody.classList.toggle(cssClassName, on),
        setButtonWrapperDisplayed: (displayed) => setDisplayed(this.eButtonWrapper, displayed),
        setCompDetails: (compDetails) => this.setCompDetails(compDetails),
        getFloatingFilterComp: () => this.compPromise,
        setWidth: (width) => eGui.style.width = width,
        setMenuIcon: (eIcon) => this.eButtonShowMainFilter.appendChild(eIcon)
      };
      this.ctrl.setComp(compProxy, eGui, this.eButtonShowMainFilter, this.eFloatingFilterBody);
    }
    setCompDetails(compDetails) {
      if (!compDetails) {
        this.destroyFloatingFilterComp();
        this.compPromise = null;
        return;
      }
      this.compPromise = compDetails.newAgStackInstance();
      this.compPromise.then((comp) => this.afterCompCreated(comp));
    }
    destroyFloatingFilterComp() {
      if (this.floatingFilterComp) {
        this.eFloatingFilterBody.removeChild(this.floatingFilterComp.getGui());
        this.floatingFilterComp = this.destroyBean(this.floatingFilterComp);
      }
    }
    afterCompCreated(comp) {
      if (!comp) {
        return;
      }
      if (!this.isAlive()) {
        this.destroyBean(comp);
        return;
      }
      this.destroyFloatingFilterComp();
      this.floatingFilterComp = comp;
      this.eFloatingFilterBody.appendChild(comp.getGui());
      if (comp.afterGuiAttached) {
        comp.afterGuiAttached();
      }
    }
  };
  _HeaderFilterCellComp.TEMPLATE = /* html */
  `<div class="ag-header-cell ag-floating-filter" role="gridcell">
            <div ref="eFloatingFilterBody" role="presentation"></div>
            <div class="ag-floating-filter-button ag-hidden" ref="eButtonWrapper" role="presentation">
                <button type="button" class="ag-button ag-floating-filter-button-button" ref="eButtonShowMainFilter" tabindex="-1"></button>
            </div>
        </div>`;
  __decorateClass([
    RefSelector("eFloatingFilterBody")
  ], _HeaderFilterCellComp.prototype, "eFloatingFilterBody", 2);
  __decorateClass([
    RefSelector("eButtonWrapper")
  ], _HeaderFilterCellComp.prototype, "eButtonWrapper", 2);
  __decorateClass([
    RefSelector("eButtonShowMainFilter")
  ], _HeaderFilterCellComp.prototype, "eButtonShowMainFilter", 2);
  __decorateClass([
    PostConstruct
  ], _HeaderFilterCellComp.prototype, "postConstruct", 1);
  __decorateClass([
    PreDestroy
  ], _HeaderFilterCellComp.prototype, "destroyFloatingFilterComp", 1);
  var HeaderFilterCellComp = _HeaderFilterCellComp;
  var LayoutCssClasses = /* @__PURE__ */ ((LayoutCssClasses2) => {
    LayoutCssClasses2["AUTO_HEIGHT"] = "ag-layout-auto-height";
    LayoutCssClasses2["NORMAL"] = "ag-layout-normal";
    LayoutCssClasses2["PRINT"] = "ag-layout-print";
    return LayoutCssClasses2;
  })(LayoutCssClasses || {});
  var LayoutFeature = class extends BeanStub {
    constructor(view) {
      super();
      this.view = view;
    }
    postConstruct() {
      this.addManagedPropertyListener("domLayout", this.updateLayoutClasses.bind(this));
      this.updateLayoutClasses();
    }
    updateLayoutClasses() {
      const domLayout = this.getDomLayout();
      const params = {
        autoHeight: domLayout === "autoHeight",
        normal: domLayout === "normal",
        print: domLayout === "print"
      };
      const cssClass = params.autoHeight ? "ag-layout-auto-height" : params.print ? "ag-layout-print" : "ag-layout-normal";
      this.view.updateLayoutClasses(cssClass, params);
    }
    // returns either 'print', 'autoHeight' or 'normal' (normal is the default)
    getDomLayout() {
      var _a;
      const domLayout = (_a = this.gos.get("domLayout")) != null ? _a : "normal";
      const validLayouts = ["normal", "print", "autoHeight"];
      if (validLayouts.indexOf(domLayout) === -1) {
        warnOnce(`${domLayout} is not valid for DOM Layout, valid values are 'normal', 'autoHeight', 'print'.`);
        return "normal";
      }
      return domLayout;
    }
  };
  __decorateClass([
    PostConstruct
  ], LayoutFeature.prototype, "postConstruct", 1);
  var GridBodyScrollFeature = class extends BeanStub {
    constructor(eBodyViewport) {
      super();
      this.lastScrollSource = [null, null];
      this.scrollLeft = -1;
      this.nextScrollTop = -1;
      this.scrollTop = -1;
      this.lastOffsetHeight = -1;
      this.lastScrollTop = -1;
      this.eBodyViewport = eBodyViewport;
      this.resetLastHScrollDebounced = debounce2(() => this.lastScrollSource[
        1
        /* Horizontal */
      ] = null, 500);
      this.resetLastVScrollDebounced = debounce2(() => this.lastScrollSource[
        0
        /* Vertical */
      ] = null, 500);
    }
    postConstruct() {
      this.enableRtl = this.gos.get("enableRtl");
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this));
      this.ctrlsService.whenReady((p2) => {
        this.centerRowsCtrl = p2.center;
        this.onDisplayedColumnsWidthChanged();
        this.addScrollListener();
      });
    }
    addScrollListener() {
      const { fakeHScrollComp, fakeVScrollComp } = this.ctrlsService.getParams();
      this.addManagedListener(this.centerRowsCtrl.getViewportElement(), "scroll", this.onHScroll.bind(this));
      fakeHScrollComp.onScrollCallback(this.onFakeHScroll.bind(this));
      const isDebounce = this.gos.get("debounceVerticalScrollbar");
      const onVScroll = isDebounce ? debounce2(this.onVScroll.bind(this), 100) : this.onVScroll.bind(this);
      const onFakeVScroll = isDebounce ? debounce2(this.onFakeVScroll.bind(this), 100) : this.onFakeVScroll.bind(this);
      this.addManagedListener(this.eBodyViewport, "scroll", onVScroll);
      fakeVScrollComp.onScrollCallback(onFakeVScroll);
    }
    onDisplayedColumnsWidthChanged() {
      if (this.enableRtl) {
        this.horizontallyScrollHeaderCenterAndFloatingCenter();
      }
    }
    horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft) {
      const notYetInitialised = this.centerRowsCtrl == null;
      if (notYetInitialised) {
        return;
      }
      if (scrollLeft === void 0) {
        scrollLeft = this.centerRowsCtrl.getCenterViewportScrollLeft();
      }
      const offset = this.enableRtl ? scrollLeft : -scrollLeft;
      const {
        topCenter,
        stickyTopCenter,
        stickyBottomCenter,
        centerHeader,
        bottomCenter,
        fakeHScrollComp
      } = this.ctrlsService.getParams();
      centerHeader.setHorizontalScroll(-offset);
      bottomCenter.setContainerTranslateX(offset);
      topCenter.setContainerTranslateX(offset);
      stickyTopCenter.setContainerTranslateX(offset);
      stickyBottomCenter.setContainerTranslateX(offset);
      const centerViewport = this.centerRowsCtrl.getViewportElement();
      const isCenterViewportLastHorizontal = this.lastScrollSource[
        1
        /* Horizontal */
      ] === 0;
      scrollLeft = Math.abs(scrollLeft);
      if (isCenterViewportLastHorizontal) {
        fakeHScrollComp.setScrollPosition(scrollLeft);
      } else {
        setScrollLeft(centerViewport, scrollLeft, this.enableRtl);
      }
    }
    isControllingScroll(source, direction) {
      if (this.lastScrollSource[direction] == null) {
        this.lastScrollSource[direction] = source;
        return true;
      }
      return this.lastScrollSource[direction] === source;
    }
    onFakeHScroll() {
      if (!this.isControllingScroll(
        1,
        1
        /* Horizontal */
      )) {
        return;
      }
      this.onHScrollCommon(
        1
        /* FakeContainer */
      );
    }
    onHScroll() {
      if (!this.isControllingScroll(
        0,
        1
        /* Horizontal */
      )) {
        return;
      }
      this.onHScrollCommon(
        0
        /* Container */
      );
    }
    onHScrollCommon(source) {
      const centerContainerViewport = this.centerRowsCtrl.getViewportElement();
      const { scrollLeft } = centerContainerViewport;
      if (this.shouldBlockScrollUpdate(1, scrollLeft, true)) {
        return;
      }
      let newScrollLeft;
      if (source === 0) {
        newScrollLeft = getScrollLeft(centerContainerViewport, this.enableRtl);
      } else {
        newScrollLeft = this.ctrlsService.get("fakeHScrollComp").getScrollPosition();
      }
      this.doHorizontalScroll(Math.round(newScrollLeft));
      this.resetLastHScrollDebounced();
    }
    onFakeVScroll() {
      if (!this.isControllingScroll(
        1,
        0
        /* Vertical */
      )) {
        return;
      }
      this.onVScrollCommon(
        1
        /* FakeContainer */
      );
    }
    onVScroll() {
      if (!this.isControllingScroll(
        0,
        0
        /* Vertical */
      )) {
        return;
      }
      this.onVScrollCommon(
        0
        /* Container */
      );
    }
    onVScrollCommon(source) {
      let scrollTop;
      if (source === 0) {
        scrollTop = this.eBodyViewport.scrollTop;
      } else {
        scrollTop = this.ctrlsService.get("fakeVScrollComp").getScrollPosition();
      }
      if (this.shouldBlockScrollUpdate(0, scrollTop, true)) {
        return;
      }
      this.animationFrameService.setScrollTop(scrollTop);
      this.nextScrollTop = scrollTop;
      if (source === 0) {
        this.ctrlsService.get("fakeVScrollComp").setScrollPosition(scrollTop);
      } else {
        this.eBodyViewport.scrollTop = scrollTop;
      }
      if (this.gos.get("suppressAnimationFrame")) {
        this.scrollGridIfNeeded();
      } else {
        this.animationFrameService.schedule();
      }
      this.resetLastVScrollDebounced();
    }
    doHorizontalScroll(scrollLeft) {
      const fakeScrollLeft = this.ctrlsService.get("fakeHScrollComp").getScrollPosition();
      if (this.scrollLeft === scrollLeft && scrollLeft === fakeScrollLeft) {
        return;
      }
      this.scrollLeft = scrollLeft;
      this.fireScrollEvent(
        1
        /* Horizontal */
      );
      this.horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft);
      this.centerRowsCtrl.onHorizontalViewportChanged(true);
    }
    fireScrollEvent(direction) {
      const bodyScrollEvent = {
        type: Events.EVENT_BODY_SCROLL,
        direction: direction === 1 ? "horizontal" : "vertical",
        left: this.scrollLeft,
        top: this.scrollTop
      };
      this.eventService.dispatchEvent(bodyScrollEvent);
      window.clearTimeout(this.scrollTimer);
      this.scrollTimer = void 0;
      this.scrollTimer = window.setTimeout(() => {
        const bodyScrollEndEvent = __spreadProps(__spreadValues({}, bodyScrollEvent), {
          type: Events.EVENT_BODY_SCROLL_END
        });
        this.eventService.dispatchEvent(bodyScrollEndEvent);
      }, 100);
    }
    shouldBlockScrollUpdate(direction, scrollTo, touchOnly = false) {
      if (touchOnly && !isIOSUserAgent()) {
        return false;
      }
      if (direction === 0) {
        return this.shouldBlockVerticalScroll(scrollTo);
      }
      return this.shouldBlockHorizontalScroll(scrollTo);
    }
    shouldBlockVerticalScroll(scrollTo) {
      const clientHeight = getInnerHeight(this.eBodyViewport);
      const { scrollHeight } = this.eBodyViewport;
      if (scrollTo < 0 || scrollTo + clientHeight > scrollHeight) {
        return true;
      }
      return false;
    }
    shouldBlockHorizontalScroll(scrollTo) {
      const clientWidth = this.centerRowsCtrl.getCenterWidth();
      const { scrollWidth } = this.centerRowsCtrl.getViewportElement();
      if (this.enableRtl && isRtlNegativeScroll()) {
        if (scrollTo > 0) {
          return true;
        }
      } else if (scrollTo < 0) {
        return true;
      }
      if (Math.abs(scrollTo) + clientWidth > scrollWidth) {
        return true;
      }
      return false;
    }
    redrawRowsAfterScroll() {
      this.fireScrollEvent(
        0
        /* Vertical */
      );
    }
    // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.
    // (which happens with some implementations of tabbing). this can result in horizontal scroll getting
    // reset back to the left, however no scroll event is fired. so we need to get header to also scroll
    // back to the left to be kept in sync.
    // adding and removing the grid from the DOM both resets the scroll position and
    // triggers a resize event, so notify listeners if the scroll position has changed
    checkScrollLeft() {
      if (this.scrollLeft !== this.centerRowsCtrl.getCenterViewportScrollLeft()) {
        this.onHScrollCommon(
          0
          /* Container */
        );
      }
    }
    scrollGridIfNeeded() {
      const frameNeeded = this.scrollTop != this.nextScrollTop;
      if (frameNeeded) {
        this.scrollTop = this.nextScrollTop;
        this.redrawRowsAfterScroll();
      }
      return frameNeeded;
    }
    // called by scrollHorizontally method and alignedGridsService
    setHorizontalScrollPosition(hScrollPosition, fromAlignedGridsService = false) {
      const minScrollLeft = 0;
      const maxScrollLeft = this.centerRowsCtrl.getViewportElement().scrollWidth - this.centerRowsCtrl.getCenterWidth();
      if (!fromAlignedGridsService && this.shouldBlockScrollUpdate(1, hScrollPosition)) {
        if (this.enableRtl && isRtlNegativeScroll()) {
          hScrollPosition = hScrollPosition > 0 ? 0 : maxScrollLeft;
        } else {
          hScrollPosition = Math.min(Math.max(hScrollPosition, minScrollLeft), maxScrollLeft);
        }
      }
      setScrollLeft(this.centerRowsCtrl.getViewportElement(), Math.abs(hScrollPosition), this.enableRtl);
      this.doHorizontalScroll(hScrollPosition);
    }
    setVerticalScrollPosition(vScrollPosition) {
      this.eBodyViewport.scrollTop = vScrollPosition;
    }
    getVScrollPosition() {
      this.lastScrollTop = this.eBodyViewport.scrollTop;
      this.lastOffsetHeight = this.eBodyViewport.offsetHeight;
      const result = {
        top: this.lastScrollTop,
        bottom: this.lastScrollTop + this.lastOffsetHeight
      };
      return result;
    }
    /** Get an approximate scroll position that returns the last real value read.
     * This is useful for avoiding repeated DOM reads that force the browser to recalculate styles.
     * This can have big performance improvements but may not be 100% accurate so only use if this is acceptable.
     */
    getApproximateVScollPosition() {
      if (this.lastScrollTop >= 0 && this.lastOffsetHeight >= 0) {
        return {
          top: this.scrollTop,
          bottom: this.scrollTop + this.lastOffsetHeight
        };
      }
      return this.getVScrollPosition();
    }
    getHScrollPosition() {
      return this.centerRowsCtrl.getHScrollPosition();
    }
    isHorizontalScrollShowing() {
      return this.centerRowsCtrl.isHorizontalScrollShowing();
    }
    // called by the headerRootComp and moveColumnController
    scrollHorizontally(pixels) {
      const oldScrollPosition = this.centerRowsCtrl.getViewportElement().scrollLeft;
      this.setHorizontalScrollPosition(oldScrollPosition + pixels);
      return this.centerRowsCtrl.getViewportElement().scrollLeft - oldScrollPosition;
    }
    // gets called by rowRenderer when new data loaded, as it will want to scroll to the top
    scrollToTop() {
      this.eBodyViewport.scrollTop = 0;
    }
    // Valid values for position are bottom, middle and top
    ensureNodeVisible(comparator2, position = null) {
      const rowCount = this.rowModel.getRowCount();
      let indexToSelect = -1;
      for (let i = 0; i < rowCount; i++) {
        const node = this.rowModel.getRow(i);
        if (typeof comparator2 === "function") {
          const predicate = comparator2;
          if (node && predicate(node)) {
            indexToSelect = i;
            break;
          }
        } else {
          if (comparator2 === node || comparator2 === node.data) {
            indexToSelect = i;
            break;
          }
        }
      }
      if (indexToSelect >= 0) {
        this.ensureIndexVisible(indexToSelect, position);
      }
    }
    // Valid values for position are bottom, middle and top
    // position should be {'top','middle','bottom', or undefined/null}.
    // if undefined/null, then the grid will to the minimal amount of scrolling,
    // eg if grid needs to scroll up, it scrolls until row is on top,
    //    if grid needs to scroll down, it scrolls until row is on bottom,
    //    if row is already in view, grid does not scroll
    ensureIndexVisible(index, position) {
      if (this.gos.isDomLayout("print")) {
        return;
      }
      const rowCount = this.paginationProxy.getRowCount();
      if (typeof index !== "number" || index < 0 || index >= rowCount) {
        console.warn("AG Grid: Invalid row index for ensureIndexVisible: " + index);
        return;
      }
      const isPaging = this.gos.get("pagination");
      const paginationPanelEnabled = isPaging && !this.gos.get("suppressPaginationPanel");
      this.getFrameworkOverrides().wrapIncoming(() => {
        if (!paginationPanelEnabled) {
          this.paginationProxy.goToPageWithIndex(index);
        }
        const gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();
        const stickyTopHeight = gridBodyCtrl.getStickyTopHeight();
        const stickyBottomHeight = gridBodyCtrl.getStickyBottomHeight();
        const rowNode = this.paginationProxy.getRow(index);
        let rowGotShiftedDuringOperation;
        do {
          const startingRowTop = rowNode.rowTop;
          const startingRowHeight = rowNode.rowHeight;
          const paginationOffset = this.paginationProxy.getPixelOffset();
          const rowTopPixel = rowNode.rowTop - paginationOffset;
          const rowBottomPixel = rowTopPixel + rowNode.rowHeight;
          const scrollPosition = this.getVScrollPosition();
          const heightOffset = this.heightScaler.getDivStretchOffset();
          const vScrollTop = scrollPosition.top + heightOffset;
          const vScrollBottom = scrollPosition.bottom + heightOffset;
          const viewportHeight = vScrollBottom - vScrollTop;
          const pxTop = this.heightScaler.getScrollPositionForPixel(rowTopPixel);
          const pxBottom = this.heightScaler.getScrollPositionForPixel(rowBottomPixel - viewportHeight);
          const pxMiddle = Math.min((pxTop + pxBottom) / 2, rowTopPixel);
          const rowAboveViewport = vScrollTop + stickyTopHeight > rowTopPixel;
          const rowBelowViewport = vScrollBottom - stickyBottomHeight < rowBottomPixel;
          let newScrollPosition = null;
          if (position === "top") {
            newScrollPosition = pxTop;
          } else if (position === "bottom") {
            newScrollPosition = pxBottom;
          } else if (position === "middle") {
            newScrollPosition = pxMiddle;
          } else if (rowAboveViewport) {
            newScrollPosition = pxTop - stickyTopHeight;
          } else if (rowBelowViewport) {
            newScrollPosition = pxBottom + stickyBottomHeight;
          }
          if (newScrollPosition !== null) {
            this.setVerticalScrollPosition(newScrollPosition);
            this.rowRenderer.redraw({ afterScroll: true });
          }
          rowGotShiftedDuringOperation = startingRowTop !== rowNode.rowTop || startingRowHeight !== rowNode.rowHeight;
        } while (rowGotShiftedDuringOperation);
        this.animationFrameService.flushAllFrames();
      });
    }
    ensureColumnVisible(key, position = "auto") {
      const column = this.columnModel.getGridColumn(key);
      if (!column) {
        return;
      }
      if (column.isPinned()) {
        return;
      }
      if (!this.columnModel.isColumnDisplayed(column)) {
        return;
      }
      const newHorizontalScroll = this.getPositionedHorizontalScroll(column, position);
      this.getFrameworkOverrides().wrapIncoming(() => {
        if (newHorizontalScroll !== null) {
          this.centerRowsCtrl.setCenterViewportScrollLeft(newHorizontalScroll);
        }
        this.centerRowsCtrl.onHorizontalViewportChanged();
        this.animationFrameService.flushAllFrames();
      });
    }
    setScrollPosition(top, left) {
      this.getFrameworkOverrides().wrapIncoming(() => {
        this.centerRowsCtrl.setCenterViewportScrollLeft(left);
        this.setVerticalScrollPosition(top);
        this.rowRenderer.redraw({ afterScroll: true });
        this.animationFrameService.flushAllFrames();
      });
    }
    getPositionedHorizontalScroll(column, position) {
      const { columnBeforeStart, columnAfterEnd } = this.isColumnOutsideViewport(column);
      const viewportTooSmallForColumn = this.centerRowsCtrl.getCenterWidth() < column.getActualWidth();
      const viewportWidth = this.centerRowsCtrl.getCenterWidth();
      const isRtl = this.enableRtl;
      let alignColToStart = (isRtl ? columnBeforeStart : columnAfterEnd) || viewportTooSmallForColumn;
      let alignColToEnd = isRtl ? columnAfterEnd : columnBeforeStart;
      if (position !== "auto") {
        alignColToStart = position === "start";
        alignColToEnd = position === "end";
      }
      const isMiddle = position === "middle";
      if (alignColToStart || alignColToEnd || isMiddle) {
        const { colLeft, colMiddle, colRight } = this.getColumnBounds(column);
        if (isMiddle) {
          return colMiddle - viewportWidth / 2;
        }
        if (alignColToStart) {
          return isRtl ? colRight : colLeft;
        }
        return isRtl ? colLeft - viewportWidth : colRight - viewportWidth;
      }
      return null;
    }
    isColumnOutsideViewport(column) {
      const { start: viewportStart, end: viewportEnd } = this.getViewportBounds();
      const { colLeft, colRight } = this.getColumnBounds(column);
      const isRtl = this.enableRtl;
      const columnBeforeStart = isRtl ? viewportStart > colRight : viewportEnd < colRight;
      const columnAfterEnd = isRtl ? viewportEnd < colLeft : viewportStart > colLeft;
      return { columnBeforeStart, columnAfterEnd };
    }
    getColumnBounds(column) {
      const isRtl = this.enableRtl;
      const bodyWidth = this.columnModel.getBodyContainerWidth();
      const colWidth = column.getActualWidth();
      const colLeft = column.getLeft();
      const multiplier = isRtl ? -1 : 1;
      const colLeftPixel = isRtl ? bodyWidth - colLeft : colLeft;
      const colRightPixel = colLeftPixel + colWidth * multiplier;
      const colMidPixel = colLeftPixel + colWidth / 2 * multiplier;
      return { colLeft: colLeftPixel, colMiddle: colMidPixel, colRight: colRightPixel };
    }
    getViewportBounds() {
      const viewportWidth = this.centerRowsCtrl.getCenterWidth();
      const scrollPosition = this.centerRowsCtrl.getCenterViewportScrollLeft();
      const viewportStartPixel = scrollPosition;
      const viewportEndPixel = viewportWidth + scrollPosition;
      return { start: viewportStartPixel, end: viewportEndPixel, width: viewportWidth };
    }
  };
  __decorateClass([
    Autowired("ctrlsService")
  ], GridBodyScrollFeature.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("animationFrameService")
  ], GridBodyScrollFeature.prototype, "animationFrameService", 2);
  __decorateClass([
    Autowired("paginationProxy")
  ], GridBodyScrollFeature.prototype, "paginationProxy", 2);
  __decorateClass([
    Autowired("rowModel")
  ], GridBodyScrollFeature.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("rowContainerHeightService")
  ], GridBodyScrollFeature.prototype, "heightScaler", 2);
  __decorateClass([
    Autowired("rowRenderer")
  ], GridBodyScrollFeature.prototype, "rowRenderer", 2);
  __decorateClass([
    Autowired("columnModel")
  ], GridBodyScrollFeature.prototype, "columnModel", 2);
  __decorateClass([
    PostConstruct
  ], GridBodyScrollFeature.prototype, "postConstruct", 1);
  var RowAnimationCssClasses = /* @__PURE__ */ ((RowAnimationCssClasses2) => {
    RowAnimationCssClasses2["ANIMATION_ON"] = "ag-row-animation";
    RowAnimationCssClasses2["ANIMATION_OFF"] = "ag-row-no-animation";
    return RowAnimationCssClasses2;
  })(RowAnimationCssClasses || {});
  var CSS_CLASS_FORCE_VERTICAL_SCROLL = "ag-force-vertical-scroll";
  var CSS_CLASS_CELL_SELECTABLE = "ag-selectable";
  var CSS_CLASS_COLUMN_MOVING = "ag-column-moving";
  var GridBodyCtrl = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.stickyTopHeight = 0;
      this.stickyBottomHeight = 0;
    }
    getScrollFeature() {
      return this.bodyScrollFeature;
    }
    getBodyViewportElement() {
      return this.eBodyViewport;
    }
    setComp(comp, eGridBody, eBodyViewport, eTop, eBottom, eStickyTop, eStickyBottom) {
      this.comp = comp;
      this.eGridBody = eGridBody;
      this.eBodyViewport = eBodyViewport;
      this.eTop = eTop;
      this.eBottom = eBottom;
      this.eStickyTop = eStickyTop;
      this.eStickyBottom = eStickyBottom;
      this.setCellTextSelection(this.gos.get("enableCellTextSelection"));
      this.addManagedPropertyListener("enableCellTextSelection", (props) => this.setCellTextSelection(props.currentValue));
      this.createManagedBean(new LayoutFeature(this.comp));
      this.bodyScrollFeature = this.createManagedBean(new GridBodyScrollFeature(this.eBodyViewport));
      this.addRowDragListener();
      this.setupRowAnimationCssClass();
      this.addEventListeners();
      this.addFocusListeners([eTop, eBodyViewport, eBottom, eStickyTop, eStickyBottom]);
      this.onGridColumnsChanged();
      this.addBodyViewportListener();
      this.setFloatingHeights();
      this.disableBrowserDragging();
      this.addStopEditingWhenGridLosesFocus();
      this.filterManager.setupAdvancedFilterHeaderComp(eTop);
      this.ctrlsService.register("gridBodyCtrl", this);
    }
    getComp() {
      return this.comp;
    }
    addEventListeners() {
      this.addManagedListener(this.eventService, Events.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_HEADER_HEIGHT_CHANGED, this.onHeaderHeightChanged.bind(this));
    }
    addFocusListeners(elements) {
      elements.forEach((element) => {
        this.addManagedListener(element, "focusin", (e) => {
          const { target } = e;
          const isFocusedElementNested = isElementChildOfClass(target, "ag-root", element);
          element.classList.toggle("ag-has-focus", !isFocusedElementNested);
        });
        this.addManagedListener(element, "focusout", (e) => {
          const { target, relatedTarget } = e;
          const gridContainRelatedTarget = element.contains(relatedTarget);
          const isNestedRelatedTarget = isElementChildOfClass(relatedTarget, "ag-root", element);
          const isNestedTarget = isElementChildOfClass(target, "ag-root", element);
          if (isNestedTarget) {
            return;
          }
          if (!gridContainRelatedTarget || isNestedRelatedTarget) {
            element.classList.remove("ag-has-focus");
          }
        });
      });
    }
    // used by ColumnAnimationService
    setColumnMovingCss(moving) {
      this.comp.setColumnMovingCss(CSS_CLASS_COLUMN_MOVING, moving);
    }
    setCellTextSelection(selectable = false) {
      this.comp.setCellSelectableCss(CSS_CLASS_CELL_SELECTABLE, selectable);
    }
    onScrollVisibilityChanged() {
      const visible = this.scrollVisibleService.isVerticalScrollShowing();
      this.setVerticalScrollPaddingVisible(visible);
      this.setStickyWidth(visible);
      this.setStickyBottomOffsetBottom();
      const scrollbarWidth = visible ? this.gos.getScrollbarWidth() || 0 : 0;
      const pad = isInvisibleScrollbar() ? 16 : 0;
      const width = `calc(100% + ${scrollbarWidth + pad}px)`;
      this.animationFrameService.requestAnimationFrame(() => this.comp.setBodyViewportWidth(width));
    }
    onGridColumnsChanged() {
      const columns = this.columnModel.getAllGridColumns();
      this.comp.setColumnCount(columns.length);
    }
    // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
    // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
    disableBrowserDragging() {
      this.addManagedListener(this.eGridBody, "dragstart", (event) => {
        if (event.target instanceof HTMLImageElement) {
          event.preventDefault();
          return false;
        }
      });
    }
    addStopEditingWhenGridLosesFocus() {
      if (!this.gos.get("stopEditingWhenCellsLoseFocus")) {
        return;
      }
      const focusOutListener = (event) => {
        const elementWithFocus = event.relatedTarget;
        if (getTabIndex(elementWithFocus) === null) {
          this.rowRenderer.stopEditing();
          return;
        }
        let clickInsideGrid = (
          // see if click came from inside the viewports
          viewports.some((viewport) => viewport.contains(elementWithFocus)) && this.mouseEventService.isElementInThisGrid(elementWithFocus)
        );
        if (!clickInsideGrid) {
          const popupService = this.popupService;
          clickInsideGrid = popupService.getActivePopups().some((popup) => popup.contains(elementWithFocus)) || popupService.isElementWithinCustomPopup(elementWithFocus);
        }
        if (!clickInsideGrid) {
          this.rowRenderer.stopEditing();
        }
      };
      const viewports = [this.eBodyViewport, this.eBottom, this.eTop, this.eStickyTop, this.eStickyBottom];
      viewports.forEach((viewport) => this.addManagedListener(viewport, "focusout", focusOutListener));
    }
    updateRowCount() {
      const headerCount = this.headerNavigationService.getHeaderRowCount() + this.filterManager.getHeaderRowCount();
      const rowCount = this.rowModel.isLastRowIndexKnown() ? this.rowModel.getRowCount() : -1;
      const total = rowCount === -1 ? -1 : headerCount + rowCount;
      this.comp.setRowCount(total);
    }
    registerBodyViewportResizeListener(listener) {
      this.comp.registerBodyViewportResizeListener(listener);
    }
    setVerticalScrollPaddingVisible(visible) {
      const overflowY = visible ? "scroll" : "hidden";
      this.comp.setPinnedTopBottomOverflowY(overflowY);
    }
    isVerticalScrollShowing() {
      const show = this.gos.get("alwaysShowVerticalScroll");
      const cssClass = show ? CSS_CLASS_FORCE_VERTICAL_SCROLL : null;
      const allowVerticalScroll = this.gos.isDomLayout("normal");
      this.comp.setAlwaysVerticalScrollClass(cssClass, show);
      return show || allowVerticalScroll && isVerticalScrollShowing(this.eBodyViewport);
    }
    setupRowAnimationCssClass() {
      const listener = () => {
        const animateRows = this.gos.isAnimateRows() && !this.rowContainerHeightService.isStretching();
        const animateRowsCssClass = animateRows ? "ag-row-animation" : "ag-row-no-animation";
        this.comp.setRowAnimationCssOnBodyViewport(animateRowsCssClass, animateRows);
      };
      listener();
      this.addManagedListener(this.eventService, Events.EVENT_HEIGHT_SCALE_CHANGED, listener);
      this.addManagedPropertyListener("animateRows", listener);
    }
    getGridBodyElement() {
      return this.eGridBody;
    }
    addBodyViewportListener() {
      const listener = this.onBodyViewportContextMenu.bind(this);
      this.addManagedListener(this.eBodyViewport, "contextmenu", listener);
      this.mockContextMenuForIPad(listener);
      this.addManagedListener(this.eBodyViewport, "wheel", this.onBodyViewportWheel.bind(this));
      this.addManagedListener(this.eStickyTop, "wheel", this.onStickyWheel.bind(this));
      this.addManagedListener(this.eStickyBottom, "wheel", this.onStickyWheel.bind(this));
      this.addFullWidthContainerWheelListener();
    }
    addFullWidthContainerWheelListener() {
      const fullWidthContainer = this.eBodyViewport.querySelector(".ag-full-width-container");
      const eCenterColsViewport = this.eBodyViewport.querySelector(".ag-center-cols-viewport");
      if (fullWidthContainer && eCenterColsViewport) {
        this.addManagedListener(fullWidthContainer, "wheel", (e) => this.onFullWidthContainerWheel(e, eCenterColsViewport));
      }
    }
    onFullWidthContainerWheel(e, eCenterColsViewport) {
      if (!e.deltaX || Math.abs(e.deltaY) > Math.abs(e.deltaX) || !this.mouseEventService.isEventFromThisGrid(e)) {
        return;
      }
      e.preventDefault();
      eCenterColsViewport.scrollBy({ left: e.deltaX });
    }
    onBodyViewportContextMenu(mouseEvent, touch, touchEvent) {
      if (!mouseEvent && !touchEvent) {
        return;
      }
      if (this.gos.get("preventDefaultOnContextMenu")) {
        const event = mouseEvent || touchEvent;
        event.preventDefault();
      }
      const { target } = mouseEvent || touch;
      if (target === this.eBodyViewport || target === this.ctrlsService.get("center").getViewportElement()) {
        this.menuService.showContextMenu({ mouseEvent, touchEvent, value: null, anchorToElement: this.eGridBody });
      }
    }
    mockContextMenuForIPad(listener) {
      if (!isIOSUserAgent()) {
        return;
      }
      const touchListener = new TouchListener(this.eBodyViewport);
      const longTapListener = (event) => {
        listener(void 0, event.touchStart, event.touchEvent);
      };
      this.addManagedListener(touchListener, TouchListener.EVENT_LONG_TAP, longTapListener);
      this.addDestroyFunc(() => touchListener.destroy());
    }
    onBodyViewportWheel(e) {
      if (!this.gos.get("suppressScrollWhenPopupsAreOpen")) {
        return;
      }
      if (this.popupService.hasAnchoredPopup()) {
        e.preventDefault();
      }
    }
    onStickyWheel(e) {
      e.preventDefault();
      if (e.offsetY) {
        this.scrollVertically(e.deltaY);
      }
    }
    getGui() {
      return this.eGridBody;
    }
    // called by rowDragFeature
    scrollVertically(pixels) {
      const oldScrollPosition = this.eBodyViewport.scrollTop;
      this.bodyScrollFeature.setVerticalScrollPosition(oldScrollPosition + pixels);
      return this.eBodyViewport.scrollTop - oldScrollPosition;
    }
    addRowDragListener() {
      this.rowDragFeature = this.createManagedBean(new RowDragFeature(this.eBodyViewport));
      this.dragAndDropService.addDropTarget(this.rowDragFeature);
    }
    getRowDragFeature() {
      return this.rowDragFeature;
    }
    onPinnedRowDataChanged() {
      this.setFloatingHeights();
    }
    setFloatingHeights() {
      const { pinnedRowModel } = this;
      let floatingTopHeight = pinnedRowModel.getPinnedTopTotalHeight();
      let floatingBottomHeight = pinnedRowModel.getPinnedBottomTotalHeight();
      this.comp.setTopHeight(floatingTopHeight);
      this.comp.setBottomHeight(floatingBottomHeight);
      this.comp.setTopDisplay(floatingTopHeight ? "inherit" : "none");
      this.comp.setBottomDisplay(floatingBottomHeight ? "inherit" : "none");
      this.setStickyTopOffsetTop();
      this.setStickyBottomOffsetBottom();
    }
    setStickyTopHeight(height = 0) {
      this.comp.setStickyTopHeight(`${height}px`);
      this.stickyTopHeight = height;
    }
    getStickyTopHeight() {
      return this.stickyTopHeight;
    }
    setStickyBottomHeight(height = 0) {
      this.comp.setStickyBottomHeight(`${height}px`);
      this.stickyBottomHeight = height;
    }
    getStickyBottomHeight() {
      return this.stickyBottomHeight;
    }
    setStickyWidth(vScrollVisible) {
      if (!vScrollVisible) {
        this.comp.setStickyTopWidth("100%");
        this.comp.setStickyBottomWidth("100%");
      } else {
        const scrollbarWidth = this.gos.getScrollbarWidth();
        this.comp.setStickyTopWidth(`calc(100% - ${scrollbarWidth}px)`);
        this.comp.setStickyBottomWidth(`calc(100% - ${scrollbarWidth}px)`);
      }
    }
    onHeaderHeightChanged() {
      this.setStickyTopOffsetTop();
    }
    setStickyTopOffsetTop() {
      const headerCtrl = this.ctrlsService.get("gridHeaderCtrl");
      const headerHeight = headerCtrl.getHeaderHeight() + this.filterManager.getHeaderHeight();
      const pinnedTopHeight = this.pinnedRowModel.getPinnedTopTotalHeight();
      let height = 0;
      if (headerHeight > 0) {
        height += headerHeight;
      }
      if (pinnedTopHeight > 0) {
        height += pinnedTopHeight;
      }
      if (height > 0) {
        height += 1;
      }
      this.comp.setStickyTopTop(`${height}px`);
    }
    setStickyBottomOffsetBottom() {
      const pinnedBottomHeight = this.pinnedRowModel.getPinnedBottomTotalHeight();
      const hScrollShowing = this.scrollVisibleService.isHorizontalScrollShowing();
      const scrollbarWidth = hScrollShowing ? this.gos.getScrollbarWidth() || 0 : 0;
      const height = pinnedBottomHeight + scrollbarWidth;
      this.comp.setStickyBottomBottom(`${height}px`);
    }
    // method will call itself if no available width. this covers if the grid
    // isn't visible, but is just about to be visible.
    sizeColumnsToFit(params, nextTimeout) {
      const removeScrollWidth = this.isVerticalScrollShowing();
      const scrollWidthToRemove = removeScrollWidth ? this.gos.getScrollbarWidth() : 0;
      const bodyViewportWidth = getInnerWidth(this.eGridBody);
      const availableWidth = bodyViewportWidth - scrollWidthToRemove;
      if (availableWidth > 0) {
        this.columnModel.sizeColumnsToFit(availableWidth, "sizeColumnsToFit", false, params);
        return;
      }
      if (nextTimeout === void 0) {
        window.setTimeout(() => {
          this.sizeColumnsToFit(params, 100);
        }, 0);
      } else if (nextTimeout === 100) {
        window.setTimeout(() => {
          this.sizeColumnsToFit(params, 500);
        }, 100);
      } else if (nextTimeout === 500) {
        window.setTimeout(() => {
          this.sizeColumnsToFit(params, -1);
        }, 500);
      } else {
        console.warn("AG Grid: tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?");
      }
    }
    // + rangeService
    addScrollEventListener(listener) {
      this.eBodyViewport.addEventListener("scroll", listener, { passive: true });
    }
    // + focusService
    removeScrollEventListener(listener) {
      this.eBodyViewport.removeEventListener("scroll", listener);
    }
  };
  __decorateClass([
    Autowired("animationFrameService")
  ], GridBodyCtrl.prototype, "animationFrameService", 2);
  __decorateClass([
    Autowired("rowContainerHeightService")
  ], GridBodyCtrl.prototype, "rowContainerHeightService", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], GridBodyCtrl.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], GridBodyCtrl.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("scrollVisibleService")
  ], GridBodyCtrl.prototype, "scrollVisibleService", 2);
  __decorateClass([
    Autowired("menuService")
  ], GridBodyCtrl.prototype, "menuService", 2);
  __decorateClass([
    Autowired("headerNavigationService")
  ], GridBodyCtrl.prototype, "headerNavigationService", 2);
  __decorateClass([
    Autowired("dragAndDropService")
  ], GridBodyCtrl.prototype, "dragAndDropService", 2);
  __decorateClass([
    Autowired("pinnedRowModel")
  ], GridBodyCtrl.prototype, "pinnedRowModel", 2);
  __decorateClass([
    Autowired("rowRenderer")
  ], GridBodyCtrl.prototype, "rowRenderer", 2);
  __decorateClass([
    Autowired("popupService")
  ], GridBodyCtrl.prototype, "popupService", 2);
  __decorateClass([
    Autowired("mouseEventService")
  ], GridBodyCtrl.prototype, "mouseEventService", 2);
  __decorateClass([
    Autowired("rowModel")
  ], GridBodyCtrl.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("filterManager")
  ], GridBodyCtrl.prototype, "filterManager", 2);
  var SelectionHandleType = /* @__PURE__ */ ((SelectionHandleType2) => {
    SelectionHandleType2[SelectionHandleType2["FILL"] = 0] = "FILL";
    SelectionHandleType2[SelectionHandleType2["RANGE"] = 1] = "RANGE";
    return SelectionHandleType2;
  })(SelectionHandleType || {});
  var CellRangeType = /* @__PURE__ */ ((CellRangeType2) => {
    CellRangeType2[CellRangeType2["VALUE"] = 0] = "VALUE";
    CellRangeType2[CellRangeType2["DIMENSION"] = 1] = "DIMENSION";
    return CellRangeType2;
  })(CellRangeType || {});
  var CSS_CELL_RANGE_SELECTED = "ag-cell-range-selected";
  var CSS_CELL_RANGE_CHART = "ag-cell-range-chart";
  var CSS_CELL_RANGE_SINGLE_CELL = "ag-cell-range-single-cell";
  var CSS_CELL_RANGE_CHART_CATEGORY = "ag-cell-range-chart-category";
  var CSS_CELL_RANGE_HANDLE = "ag-cell-range-handle";
  var CSS_CELL_RANGE_TOP = "ag-cell-range-top";
  var CSS_CELL_RANGE_RIGHT = "ag-cell-range-right";
  var CSS_CELL_RANGE_BOTTOM = "ag-cell-range-bottom";
  var CSS_CELL_RANGE_LEFT = "ag-cell-range-left";
  var CellRangeFeature = class {
    constructor(beans, ctrl) {
      this.beans = beans;
      this.rangeService = beans.rangeService;
      this.selectionHandleFactory = beans.selectionHandleFactory;
      this.cellCtrl = ctrl;
    }
    setComp(cellComp, eGui) {
      this.cellComp = cellComp;
      this.eGui = eGui;
      this.onRangeSelectionChanged();
    }
    onRangeSelectionChanged() {
      if (!this.cellComp) {
        return;
      }
      this.rangeCount = this.rangeService.getCellRangeCount(this.cellCtrl.getCellPosition());
      this.hasChartRange = this.getHasChartRange();
      this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_SELECTED, this.rangeCount !== 0);
      this.cellComp.addOrRemoveCssClass(`${CSS_CELL_RANGE_SELECTED}-1`, this.rangeCount === 1);
      this.cellComp.addOrRemoveCssClass(`${CSS_CELL_RANGE_SELECTED}-2`, this.rangeCount === 2);
      this.cellComp.addOrRemoveCssClass(`${CSS_CELL_RANGE_SELECTED}-3`, this.rangeCount === 3);
      this.cellComp.addOrRemoveCssClass(`${CSS_CELL_RANGE_SELECTED}-4`, this.rangeCount >= 4);
      this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_CHART, this.hasChartRange);
      setAriaSelected(this.eGui, this.rangeCount > 0 ? true : void 0);
      this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_SINGLE_CELL, this.isSingleCell());
      this.updateRangeBorders();
      this.refreshHandle();
    }
    updateRangeBorders() {
      const rangeBorders = this.getRangeBorders();
      const isSingleCell = this.isSingleCell();
      const isTop = !isSingleCell && rangeBorders.top;
      const isRight = !isSingleCell && rangeBorders.right;
      const isBottom = !isSingleCell && rangeBorders.bottom;
      const isLeft = !isSingleCell && rangeBorders.left;
      this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_TOP, isTop);
      this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_RIGHT, isRight);
      this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_BOTTOM, isBottom);
      this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_LEFT, isLeft);
    }
    isSingleCell() {
      const { rangeService } = this.beans;
      return this.rangeCount === 1 && !!rangeService && !rangeService.isMoreThanOneCell();
    }
    getHasChartRange() {
      const { rangeService } = this.beans;
      if (!this.rangeCount || !rangeService) {
        return false;
      }
      const cellRanges = rangeService.getCellRanges();
      return cellRanges.length > 0 && cellRanges.every((range2) => includes([
        1,
        0
        /* VALUE */
      ], range2.type));
    }
    updateRangeBordersIfRangeCount() {
      if (this.rangeCount > 0) {
        this.updateRangeBorders();
        this.refreshHandle();
      }
    }
    getRangeBorders() {
      const isRtl = this.beans.gos.get("enableRtl");
      let top = false;
      let right = false;
      let bottom = false;
      let left = false;
      const thisCol = this.cellCtrl.getCellPosition().column;
      const columnModel = this.beans.columnModel;
      let leftCol;
      let rightCol;
      if (isRtl) {
        leftCol = columnModel.getDisplayedColAfter(thisCol);
        rightCol = columnModel.getDisplayedColBefore(thisCol);
      } else {
        leftCol = columnModel.getDisplayedColBefore(thisCol);
        rightCol = columnModel.getDisplayedColAfter(thisCol);
      }
      const ranges = this.rangeService.getCellRanges().filter(
        (range2) => this.rangeService.isCellInSpecificRange(this.cellCtrl.getCellPosition(), range2)
      );
      if (!leftCol) {
        left = true;
      }
      if (!rightCol) {
        right = true;
      }
      for (let i = 0; i < ranges.length; i++) {
        if (top && right && bottom && left) {
          break;
        }
        const range2 = ranges[i];
        const startRow = this.rangeService.getRangeStartRow(range2);
        const endRow = this.rangeService.getRangeEndRow(range2);
        if (!top && this.beans.rowPositionUtils.sameRow(startRow, this.cellCtrl.getCellPosition())) {
          top = true;
        }
        if (!bottom && this.beans.rowPositionUtils.sameRow(endRow, this.cellCtrl.getCellPosition())) {
          bottom = true;
        }
        if (!left && leftCol && range2.columns.indexOf(leftCol) < 0) {
          left = true;
        }
        if (!right && rightCol && range2.columns.indexOf(rightCol) < 0) {
          right = true;
        }
      }
      return { top, right, bottom, left };
    }
    refreshHandle() {
      if (this.beans.context.isDestroyed()) {
        return;
      }
      const shouldHaveSelectionHandle = this.shouldHaveSelectionHandle();
      if (this.selectionHandle && !shouldHaveSelectionHandle) {
        this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle);
      }
      if (shouldHaveSelectionHandle) {
        this.addSelectionHandle();
      }
      this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_HANDLE, !!this.selectionHandle);
    }
    shouldHaveSelectionHandle() {
      const gos = this.beans.gos;
      const cellRanges = this.rangeService.getCellRanges();
      const rangesLen = cellRanges.length;
      if (this.rangeCount < 1 || rangesLen < 1) {
        return false;
      }
      const cellRange = last(cellRanges);
      const cellPosition = this.cellCtrl.getCellPosition();
      const isFillHandleAvailable = gos.get("enableFillHandle") && !this.cellCtrl.isSuppressFillHandle();
      const isRangeHandleAvailable = gos.get("enableRangeHandle");
      let handleIsAvailable = rangesLen === 1 && !this.cellCtrl.isEditing() && (isFillHandleAvailable || isRangeHandleAvailable);
      if (this.hasChartRange) {
        const hasCategoryRange = cellRanges[0].type === 1;
        const isCategoryCell = hasCategoryRange && this.rangeService.isCellInSpecificRange(cellPosition, cellRanges[0]);
        this.cellComp.addOrRemoveCssClass(CSS_CELL_RANGE_CHART_CATEGORY, isCategoryCell);
        handleIsAvailable = cellRange.type === 0;
      }
      return handleIsAvailable && cellRange.endRow != null && this.rangeService.isContiguousRange(cellRange) && this.rangeService.isBottomRightCell(cellRange, cellPosition);
    }
    addSelectionHandle() {
      const gos = this.beans.gos;
      const cellRangeType = last(this.rangeService.getCellRanges()).type;
      const selectionHandleFill = gos.get("enableFillHandle") && missing(cellRangeType);
      const type = selectionHandleFill ? 0 : 1;
      if (this.selectionHandle && this.selectionHandle.getType() !== type) {
        this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle);
      }
      if (!this.selectionHandle) {
        this.selectionHandle = this.selectionHandleFactory.createSelectionHandle(type);
      }
      this.selectionHandle.refresh(this.cellCtrl);
    }
    destroy() {
      this.beans.context.destroyBean(this.selectionHandle);
    }
  };
  var CellPositionFeature = class extends BeanStub {
    constructor(ctrl, beans) {
      super();
      this.cellCtrl = ctrl;
      this.beans = beans;
      this.column = ctrl.getColumn();
      this.rowNode = ctrl.getRowNode();
    }
    setupRowSpan() {
      this.rowSpan = this.column.getRowSpan(this.rowNode);
      this.addManagedListener(this.beans.eventService, Events.EVENT_NEW_COLUMNS_LOADED, () => this.onNewColumnsLoaded());
    }
    setComp(eGui) {
      this.eGui = eGui;
      this.setupColSpan();
      this.setupRowSpan();
      this.onLeftChanged();
      this.onWidthChanged();
      this.applyRowSpan();
    }
    onNewColumnsLoaded() {
      const rowSpan = this.column.getRowSpan(this.rowNode);
      if (this.rowSpan === rowSpan) {
        return;
      }
      this.rowSpan = rowSpan;
      this.applyRowSpan(true);
    }
    onDisplayColumnsChanged() {
      const colsSpanning = this.getColSpanningList();
      if (!areEqual(this.colsSpanning, colsSpanning)) {
        this.colsSpanning = colsSpanning;
        this.onWidthChanged();
        this.onLeftChanged();
      }
    }
    setupColSpan() {
      if (this.column.getColDef().colSpan == null) {
        return;
      }
      this.colsSpanning = this.getColSpanningList();
      this.addManagedListener(this.beans.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayColumnsChanged.bind(this));
      this.addManagedListener(this.beans.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onWidthChanged.bind(this));
    }
    onWidthChanged() {
      if (!this.eGui) {
        return;
      }
      const width = this.getCellWidth();
      this.eGui.style.width = `${width}px`;
    }
    getCellWidth() {
      if (!this.colsSpanning) {
        return this.column.getActualWidth();
      }
      return this.colsSpanning.reduce((width, col) => width + col.getActualWidth(), 0);
    }
    getColSpanningList() {
      const colSpan = this.column.getColSpan(this.rowNode);
      const colsSpanning = [];
      if (colSpan === 1) {
        colsSpanning.push(this.column);
      } else {
        let pointer = this.column;
        const pinned = this.column.getPinned();
        for (let i = 0; pointer && i < colSpan; i++) {
          colsSpanning.push(pointer);
          pointer = this.beans.columnModel.getDisplayedColAfter(pointer);
          if (!pointer || missing(pointer)) {
            break;
          }
          if (pinned !== pointer.getPinned()) {
            break;
          }
        }
      }
      return colsSpanning;
    }
    onLeftChanged() {
      if (!this.eGui) {
        return;
      }
      const left = this.modifyLeftForPrintLayout(this.getCellLeft());
      this.eGui.style.left = left + "px";
    }
    getCellLeft() {
      let mostLeftCol;
      if (this.beans.gos.get("enableRtl") && this.colsSpanning) {
        mostLeftCol = last(this.colsSpanning);
      } else {
        mostLeftCol = this.column;
      }
      return mostLeftCol.getLeft();
    }
    modifyLeftForPrintLayout(leftPosition) {
      if (!this.cellCtrl.isPrintLayout() || this.column.getPinned() === "left") {
        return leftPosition;
      }
      const leftWidth = this.beans.columnModel.getDisplayedColumnsLeftWidth();
      if (this.column.getPinned() === "right") {
        const bodyWidth = this.beans.columnModel.getBodyContainerWidth();
        return leftWidth + bodyWidth + (leftPosition || 0);
      }
      return leftWidth + (leftPosition || 0);
    }
    applyRowSpan(force) {
      if (this.rowSpan === 1 && !force) {
        return;
      }
      const singleRowHeight = this.beans.gos.getRowHeightAsNumber();
      const totalRowHeight = singleRowHeight * this.rowSpan;
      this.eGui.style.height = `${totalRowHeight}px`;
      this.eGui.style.zIndex = "1";
    }
    // overriding to make public, as we don't dispose this bean via context
    destroy() {
      super.destroy();
    }
  };
  var CellCustomStyleFeature = class extends BeanStub {
    constructor(ctrl, beans) {
      super();
      this.staticClasses = [];
      this.cellCtrl = ctrl;
      this.beans = beans;
      this.column = ctrl.getColumn();
      this.rowNode = ctrl.getRowNode();
    }
    setComp(comp) {
      this.cellComp = comp;
      this.applyUserStyles();
      this.applyCellClassRules();
      this.applyClassesFromColDef();
    }
    applyCellClassRules() {
      const colDef = this.column.getColDef();
      const { cellClassRules } = colDef;
      const cellClassParams = this.beans.gos.addGridCommonParams({
        value: this.cellCtrl.getValue(),
        data: this.rowNode.data,
        node: this.rowNode,
        colDef,
        column: this.column,
        rowIndex: this.rowNode.rowIndex
      });
      this.beans.stylingService.processClassRules(
        // if current was previous, skip
        cellClassRules === this.cellClassRules ? void 0 : this.cellClassRules,
        cellClassRules,
        cellClassParams,
        (className) => this.cellComp.addOrRemoveCssClass(className, true),
        (className) => this.cellComp.addOrRemoveCssClass(className, false)
      );
      this.cellClassRules = cellClassRules;
    }
    applyUserStyles() {
      const colDef = this.column.getColDef();
      if (!colDef.cellStyle) {
        return;
      }
      let styles;
      if (typeof colDef.cellStyle === "function") {
        const cellStyleParams = this.beans.gos.addGridCommonParams({
          column: this.column,
          value: this.cellCtrl.getValue(),
          colDef,
          data: this.rowNode.data,
          node: this.rowNode,
          rowIndex: this.rowNode.rowIndex
        });
        const cellStyleFunc = colDef.cellStyle;
        styles = cellStyleFunc(cellStyleParams);
      } else {
        styles = colDef.cellStyle;
      }
      if (styles) {
        this.cellComp.setUserStyles(styles);
      }
    }
    applyClassesFromColDef() {
      const colDef = this.column.getColDef();
      const cellClassParams = this.beans.gos.addGridCommonParams({
        value: this.cellCtrl.getValue(),
        data: this.rowNode.data,
        node: this.rowNode,
        column: this.column,
        colDef,
        rowIndex: this.rowNode.rowIndex
      });
      if (this.staticClasses.length) {
        this.staticClasses.forEach((className) => this.cellComp.addOrRemoveCssClass(className, false));
      }
      this.staticClasses = this.beans.stylingService.getStaticCellClasses(colDef, cellClassParams);
      if (this.staticClasses.length) {
        this.staticClasses.forEach((className) => this.cellComp.addOrRemoveCssClass(className, true));
      }
    }
    // overriding to make public, as we don't dispose this bean via context
    destroy() {
      super.destroy();
    }
  };
  var Beans = class {
    postConstruct() {
      if (this.gos.isRowModelType("clientSide")) {
        this.clientSideRowModel = this.rowModel;
      }
      if (this.gos.isRowModelType("serverSide")) {
        this.serverSideRowModel = this.rowModel;
      }
    }
  };
  __decorateClass([
    Autowired("resizeObserverService")
  ], Beans.prototype, "resizeObserverService", 2);
  __decorateClass([
    Autowired("paginationProxy")
  ], Beans.prototype, "paginationProxy", 2);
  __decorateClass([
    Autowired("context")
  ], Beans.prototype, "context", 2);
  __decorateClass([
    Autowired("gridOptionsService")
  ], Beans.prototype, "gos", 2);
  __decorateClass([
    Autowired("environment")
  ], Beans.prototype, "environment", 2);
  __decorateClass([
    Autowired("rowRenderer")
  ], Beans.prototype, "rowRenderer", 2);
  __decorateClass([
    Autowired("valueService")
  ], Beans.prototype, "valueService", 2);
  __decorateClass([
    Autowired("eventService")
  ], Beans.prototype, "eventService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], Beans.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("headerNavigationService")
  ], Beans.prototype, "headerNavigationService", 2);
  __decorateClass([
    Autowired("navigationService")
  ], Beans.prototype, "navigationService", 2);
  __decorateClass([
    Autowired("columnAnimationService")
  ], Beans.prototype, "columnAnimationService", 2);
  __decorateClass([
    Autowired("focusService")
  ], Beans.prototype, "focusService", 2);
  __decorateClass([
    Autowired("popupService")
  ], Beans.prototype, "popupService", 2);
  __decorateClass([
    Autowired("stylingService")
  ], Beans.prototype, "stylingService", 2);
  __decorateClass([
    Autowired("columnHoverService")
  ], Beans.prototype, "columnHoverService", 2);
  __decorateClass([
    Autowired("userComponentFactory")
  ], Beans.prototype, "userComponentFactory", 2);
  __decorateClass([
    Autowired("userComponentRegistry")
  ], Beans.prototype, "userComponentRegistry", 2);
  __decorateClass([
    Autowired("animationFrameService")
  ], Beans.prototype, "animationFrameService", 2);
  __decorateClass([
    Autowired("dragService")
  ], Beans.prototype, "dragService", 2);
  __decorateClass([
    Autowired("dragAndDropService")
  ], Beans.prototype, "dragAndDropService", 2);
  __decorateClass([
    Autowired("sortController")
  ], Beans.prototype, "sortController", 2);
  __decorateClass([
    Autowired("filterManager")
  ], Beans.prototype, "filterManager", 2);
  __decorateClass([
    Autowired("rowContainerHeightService")
  ], Beans.prototype, "rowContainerHeightService", 2);
  __decorateClass([
    Autowired("frameworkOverrides")
  ], Beans.prototype, "frameworkOverrides", 2);
  __decorateClass([
    Autowired("cellPositionUtils")
  ], Beans.prototype, "cellPositionUtils", 2);
  __decorateClass([
    Autowired("rowPositionUtils")
  ], Beans.prototype, "rowPositionUtils", 2);
  __decorateClass([
    Autowired("selectionService")
  ], Beans.prototype, "selectionService", 2);
  __decorateClass([
    Autowired("rowCssClassCalculator")
  ], Beans.prototype, "rowCssClassCalculator", 2);
  __decorateClass([
    Autowired("rowModel")
  ], Beans.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], Beans.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("ctrlsFactory")
  ], Beans.prototype, "ctrlsFactory", 2);
  __decorateClass([
    Autowired("agStackComponentsRegistry")
  ], Beans.prototype, "agStackComponentsRegistry", 2);
  __decorateClass([
    Autowired("valueCache")
  ], Beans.prototype, "valueCache", 2);
  __decorateClass([
    Autowired("rowNodeEventThrottle")
  ], Beans.prototype, "rowNodeEventThrottle", 2);
  __decorateClass([
    Autowired("localeService")
  ], Beans.prototype, "localeService", 2);
  __decorateClass([
    Autowired("syncService")
  ], Beans.prototype, "syncService", 2);
  __decorateClass([
    Autowired("ariaAnnouncementService")
  ], Beans.prototype, "ariaAnnouncementService", 2);
  __decorateClass([
    Optional("rangeService")
  ], Beans.prototype, "rangeService", 2);
  __decorateClass([
    Optional("selectionHandleFactory")
  ], Beans.prototype, "selectionHandleFactory", 2);
  __decorateClass([
    PostConstruct
  ], Beans.prototype, "postConstruct", 1);
  Beans = __decorateClass([
    Bean("beans")
  ], Beans);
  var CellMouseListenerFeature = class extends Beans {
    constructor(ctrl, beans, column) {
      super();
      this.cellCtrl = ctrl;
      this.beans = beans;
      this.column = column;
    }
    onMouseEvent(eventName, mouseEvent) {
      if (isStopPropagationForAgGrid(mouseEvent)) {
        return;
      }
      switch (eventName) {
        case "click":
          this.onCellClicked(mouseEvent);
          break;
        case "mousedown":
        case "touchstart":
          this.onMouseDown(mouseEvent);
          break;
        case "dblclick":
          this.onCellDoubleClicked(mouseEvent);
          break;
        case "mouseout":
          this.onMouseOut(mouseEvent);
          break;
        case "mouseover":
          this.onMouseOver(mouseEvent);
          break;
      }
    }
    onCellClicked(mouseEvent) {
      if (this.isDoubleClickOnIPad()) {
        this.onCellDoubleClicked(mouseEvent);
        mouseEvent.preventDefault();
        return;
      }
      const { eventService, rangeService, gos } = this.beans;
      const isMultiKey = mouseEvent.ctrlKey || mouseEvent.metaKey;
      if (rangeService && isMultiKey) {
        if (rangeService.getCellRangeCount(this.cellCtrl.getCellPosition()) > 1) {
          rangeService.intersectLastRange(true);
        }
      }
      const cellClickedEvent = this.cellCtrl.createEvent(mouseEvent, Events.EVENT_CELL_CLICKED);
      eventService.dispatchEvent(cellClickedEvent);
      const colDef = this.column.getColDef();
      if (colDef.onCellClicked) {
        window.setTimeout(() => {
          this.beans.frameworkOverrides.wrapOutgoing(() => {
            colDef.onCellClicked(cellClickedEvent);
          });
        }, 0);
      }
      const editOnSingleClick = (gos.get("singleClickEdit") || colDef.singleClickEdit) && !gos.get("suppressClickEdit");
      if (editOnSingleClick && !(mouseEvent.shiftKey && (rangeService == null ? void 0 : rangeService.getCellRanges().length) != 0)) {
        this.cellCtrl.startRowOrCellEdit();
      }
    }
    // returns true if on iPad and this is second 'click' event in 200ms
    isDoubleClickOnIPad() {
      if (!isIOSUserAgent() || isEventSupported("dblclick")) {
        return false;
      }
      const nowMillis = (/* @__PURE__ */ new Date()).getTime();
      const res = nowMillis - this.lastIPadMouseClickEvent < 200;
      this.lastIPadMouseClickEvent = nowMillis;
      return res;
    }
    onCellDoubleClicked(mouseEvent) {
      const colDef = this.column.getColDef();
      const cellDoubleClickedEvent = this.cellCtrl.createEvent(mouseEvent, Events.EVENT_CELL_DOUBLE_CLICKED);
      this.beans.eventService.dispatchEvent(cellDoubleClickedEvent);
      if (typeof colDef.onCellDoubleClicked === "function") {
        window.setTimeout(() => {
          this.beans.frameworkOverrides.wrapOutgoing(() => {
            colDef.onCellDoubleClicked(cellDoubleClickedEvent);
          });
        }, 0);
      }
      const editOnDoubleClick = !this.beans.gos.get("singleClickEdit") && !this.beans.gos.get("suppressClickEdit");
      if (editOnDoubleClick) {
        this.cellCtrl.startRowOrCellEdit(null, mouseEvent);
      }
    }
    onMouseDown(mouseEvent) {
      const { ctrlKey, metaKey, shiftKey } = mouseEvent;
      const target = mouseEvent.target;
      const { cellCtrl, beans } = this;
      const { eventService, rangeService, focusService } = beans;
      if (this.isRightClickInExistingRange(mouseEvent)) {
        return;
      }
      const ranges = rangeService && rangeService.getCellRanges().length != 0;
      if (!shiftKey || !ranges) {
        const forceBrowserFocus = isBrowserSafari() && !cellCtrl.isEditing() && !isFocusableFormField(target);
        cellCtrl.focusCell(forceBrowserFocus);
      }
      if (shiftKey && ranges && !focusService.isCellFocused(cellCtrl.getCellPosition())) {
        mouseEvent.preventDefault();
        const focusedCellPosition = focusService.getFocusedCell();
        if (focusedCellPosition) {
          const { column, rowIndex, rowPinned } = focusedCellPosition;
          const focusedRowCtrl = beans.rowRenderer.getRowByPosition({ rowIndex, rowPinned });
          const focusedCellCtrl = focusedRowCtrl == null ? void 0 : focusedRowCtrl.getCellCtrl(column);
          if (focusedCellCtrl == null ? void 0 : focusedCellCtrl.isEditing()) {
            focusedCellCtrl.stopEditing();
          }
          focusService.setFocusedCell({
            column,
            rowIndex,
            rowPinned,
            forceBrowserFocus: true,
            preventScrollOnBrowserFocus: true
          });
        }
      }
      if (this.containsWidget(target)) {
        return;
      }
      if (rangeService) {
        const thisCell = this.cellCtrl.getCellPosition();
        if (shiftKey) {
          rangeService.extendLatestRangeToCell(thisCell);
        } else {
          const isMultiKey = ctrlKey || metaKey;
          rangeService.setRangeToCell(thisCell, isMultiKey);
        }
      }
      eventService.dispatchEvent(this.cellCtrl.createEvent(mouseEvent, Events.EVENT_CELL_MOUSE_DOWN));
    }
    isRightClickInExistingRange(mouseEvent) {
      const { rangeService } = this.beans;
      if (rangeService) {
        const cellInRange = rangeService.isCellInAnyRange(this.cellCtrl.getCellPosition());
        const isRightClick = mouseEvent.button === 2 || mouseEvent.ctrlKey && this.beans.gos.get("allowContextMenuWithControlKey");
        if (cellInRange && isRightClick) {
          return true;
        }
      }
      return false;
    }
    containsWidget(target) {
      return isElementChildOfClass(target, "ag-selection-checkbox", 3);
    }
    onMouseOut(mouseEvent) {
      if (this.mouseStayingInsideCell(mouseEvent)) {
        return;
      }
      const cellMouseOutEvent = this.cellCtrl.createEvent(mouseEvent, Events.EVENT_CELL_MOUSE_OUT);
      this.beans.eventService.dispatchEvent(cellMouseOutEvent);
      this.beans.columnHoverService.clearMouseOver();
    }
    onMouseOver(mouseEvent) {
      if (this.mouseStayingInsideCell(mouseEvent)) {
        return;
      }
      const cellMouseOverEvent = this.cellCtrl.createEvent(mouseEvent, Events.EVENT_CELL_MOUSE_OVER);
      this.beans.eventService.dispatchEvent(cellMouseOverEvent);
      this.beans.columnHoverService.setMouseOver([this.column]);
    }
    mouseStayingInsideCell(e) {
      if (!e.target || !e.relatedTarget) {
        return false;
      }
      const eGui = this.cellCtrl.getGui();
      const cellContainsTarget = eGui.contains(e.target);
      const cellContainsRelatedTarget = eGui.contains(e.relatedTarget);
      return cellContainsTarget && cellContainsRelatedTarget;
    }
    destroy() {
    }
  };
  var CellKeyboardListenerFeature = class extends BeanStub {
    constructor(ctrl, beans, column, rowNode, rowCtrl) {
      super();
      this.cellCtrl = ctrl;
      this.beans = beans;
      this.rowNode = rowNode;
      this.rowCtrl = rowCtrl;
    }
    setComp(eGui) {
      this.eGui = eGui;
    }
    onKeyDown(event) {
      const key = event.key;
      switch (key) {
        case KeyCode.ENTER:
          this.onEnterKeyDown(event);
          break;
        case KeyCode.F2:
          this.onF2KeyDown(event);
          break;
        case KeyCode.ESCAPE:
          this.onEscapeKeyDown(event);
          break;
        case KeyCode.TAB:
          this.onTabKeyDown(event);
          break;
        case KeyCode.BACKSPACE:
        case KeyCode.DELETE:
          this.onBackspaceOrDeleteKeyDown(key, event);
          break;
        case KeyCode.DOWN:
        case KeyCode.UP:
        case KeyCode.RIGHT:
        case KeyCode.LEFT:
          this.onNavigationKeyDown(event, key);
          break;
      }
    }
    onNavigationKeyDown(event, key) {
      if (this.cellCtrl.isEditing()) {
        return;
      }
      if (event.shiftKey && this.cellCtrl.isRangeSelectionEnabled()) {
        this.onShiftRangeSelect(event);
      } else {
        this.beans.navigationService.navigateToNextCell(event, key, this.cellCtrl.getCellPosition(), true);
      }
      event.preventDefault();
    }
    onShiftRangeSelect(event) {
      if (!this.beans.rangeService) {
        return;
      }
      const endCell = this.beans.rangeService.extendLatestRangeInDirection(event);
      if (endCell) {
        this.beans.navigationService.ensureCellVisible(endCell);
      }
    }
    onTabKeyDown(event) {
      this.beans.navigationService.onTabKeyDown(this.cellCtrl, event);
    }
    onBackspaceOrDeleteKeyDown(key, event) {
      var _a;
      const { cellCtrl, beans, rowNode } = this;
      const { gos, rangeService, eventService } = beans;
      if (cellCtrl.isEditing()) {
        return;
      }
      eventService.dispatchEvent({ type: Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_START });
      if (isDeleteKey(key, gos.get("enableCellEditingOnBackspace"))) {
        if (rangeService && gos.get("enableRangeSelection")) {
          rangeService.clearCellRangeCellValues({ dispatchWrapperEvents: true, wrapperEventSource: "deleteKey" });
        } else if (cellCtrl.isCellEditable()) {
          const column = cellCtrl.getColumn();
          const emptyValue = (_a = this.beans.valueService.parseValue(column, rowNode, "", rowNode.getValueFromValueService(column))) != null ? _a : null;
          rowNode.setDataValue(column, emptyValue, "cellClear");
        }
      } else {
        cellCtrl.startRowOrCellEdit(key, event);
      }
      eventService.dispatchEvent({ type: Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_END });
    }
    onEnterKeyDown(e) {
      if (this.cellCtrl.isEditing() || this.rowCtrl.isEditing()) {
        this.cellCtrl.stopEditingAndFocus(false, e.shiftKey);
      } else {
        if (this.beans.gos.get("enterNavigatesVertically")) {
          const key = e.shiftKey ? KeyCode.UP : KeyCode.DOWN;
          this.beans.navigationService.navigateToNextCell(null, key, this.cellCtrl.getCellPosition(), false);
        } else {
          this.cellCtrl.startRowOrCellEdit(KeyCode.ENTER, e);
          if (this.cellCtrl.isEditing()) {
            e.preventDefault();
          }
        }
      }
    }
    onF2KeyDown(event) {
      if (!this.cellCtrl.isEditing()) {
        this.cellCtrl.startRowOrCellEdit(KeyCode.F2, event);
      }
    }
    onEscapeKeyDown(event) {
      if (this.cellCtrl.isEditing()) {
        this.cellCtrl.stopRowOrCellEdit(true);
        this.cellCtrl.focusCell(true);
      }
    }
    processCharacter(event) {
      const eventTarget = event.target;
      const eventOnChildComponent = eventTarget !== this.eGui;
      if (eventOnChildComponent || this.cellCtrl.isEditing()) {
        return;
      }
      const key = event.key;
      if (key === " ") {
        this.onSpaceKeyDown(event);
      } else {
        this.cellCtrl.startRowOrCellEdit(key, event);
        event.preventDefault();
      }
    }
    onSpaceKeyDown(event) {
      const { gos } = this.beans;
      if (!this.cellCtrl.isEditing() && gos.isRowSelection()) {
        const currentSelection = this.rowNode.isSelected();
        const newSelection = !currentSelection;
        if (newSelection || !gos.get("suppressRowDeselection")) {
          const groupSelectsFiltered = this.beans.gos.get("groupSelectsFiltered");
          const updatedCount = this.rowNode.setSelectedParams({
            newValue: newSelection,
            rangeSelect: event.shiftKey,
            groupSelectsFiltered,
            event,
            source: "spaceKey"
          });
          if (currentSelection === void 0 && updatedCount === 0) {
            this.rowNode.setSelectedParams({
              newValue: false,
              rangeSelect: event.shiftKey,
              groupSelectsFiltered,
              event,
              source: "spaceKey"
            });
          }
        }
      }
      event.preventDefault();
    }
    destroy() {
      super.destroy();
    }
  };
  var DndSourceComp = class extends Component {
    constructor(rowNode, column, eCell) {
      super(
        /* html */
        `<div class="ag-drag-handle ag-row-drag" draggable="true"></div>`
      );
      this.rowNode = rowNode;
      this.column = column;
      this.eCell = eCell;
    }
    postConstruct() {
      const eGui = this.getGui();
      eGui.appendChild(createIconNoSpan("rowDrag", this.gos, null));
      this.addGuiEventListener("mousedown", (e) => {
        e.stopPropagation();
      });
      this.addDragSource();
      this.checkVisibility();
    }
    addDragSource() {
      this.addGuiEventListener("dragstart", this.onDragStart.bind(this));
    }
    onDragStart(dragEvent) {
      const providedOnRowDrag = this.column.getColDef().dndSourceOnRowDrag;
      dragEvent.dataTransfer.setDragImage(this.eCell, 0, 0);
      const defaultOnRowDrag = () => {
        try {
          const jsonData = JSON.stringify(this.rowNode.data);
          dragEvent.dataTransfer.setData("application/json", jsonData);
          dragEvent.dataTransfer.setData("text/plain", jsonData);
        } catch (e) {
        }
      };
      if (providedOnRowDrag) {
        const params = this.gos.addGridCommonParams({
          rowNode: this.rowNode,
          dragEvent
        });
        providedOnRowDrag(params);
      } else {
        defaultOnRowDrag();
      }
    }
    checkVisibility() {
      const visible = this.column.isDndSource(this.rowNode);
      this.setDisplayed(visible);
    }
  };
  __decorateClass([
    PostConstruct
  ], DndSourceComp.prototype, "postConstruct", 1);
  var CSS_FIRST_COLUMN = "ag-column-first";
  var CSS_LAST_COLUMN = "ag-column-last";
  var CssClassApplier = class {
    static getHeaderClassesFromColDef(abstractColDef, gos, column, columnGroup) {
      if (missing(abstractColDef)) {
        return [];
      }
      return this.getColumnClassesFromCollDef(
        abstractColDef.headerClass,
        abstractColDef,
        gos,
        column,
        columnGroup
      );
    }
    static getToolPanelClassesFromColDef(abstractColDef, gos, column, columnGroup) {
      if (missing(abstractColDef)) {
        return [];
      }
      return this.getColumnClassesFromCollDef(
        abstractColDef.toolPanelClass,
        abstractColDef,
        gos,
        column,
        columnGroup
      );
    }
    static refreshFirstAndLastStyles(comp, column, columnModel) {
      comp.addOrRemoveCssClass(CSS_FIRST_COLUMN, columnModel.isColumnAtEdge(column, "first"));
      comp.addOrRemoveCssClass(CSS_LAST_COLUMN, columnModel.isColumnAtEdge(column, "last"));
    }
    static getClassParams(abstractColDef, gos, column, columnGroup) {
      return gos.addGridCommonParams({
        // bad naming, as colDef here can be a group or a column,
        // however most people won't appreciate the difference,
        // so keeping it as colDef to avoid confusion.
        colDef: abstractColDef,
        column,
        columnGroup
      });
    }
    static getColumnClassesFromCollDef(classesOrFunc, abstractColDef, gos, column, columnGroup) {
      if (missing(classesOrFunc)) {
        return [];
      }
      let classToUse;
      if (typeof classesOrFunc === "function") {
        const params = this.getClassParams(abstractColDef, gos, column, columnGroup);
        classToUse = classesOrFunc(params);
      } else {
        classToUse = classesOrFunc;
      }
      if (typeof classToUse === "string") {
        return [classToUse];
      }
      if (Array.isArray(classToUse)) {
        return [...classToUse];
      }
      return [];
    }
  };
  var CSS_CELL = "ag-cell";
  var CSS_AUTO_HEIGHT = "ag-cell-auto-height";
  var CSS_NORMAL_HEIGHT = "ag-cell-normal-height";
  var CSS_CELL_FOCUS = "ag-cell-focus";
  var CSS_CELL_FIRST_RIGHT_PINNED = "ag-cell-first-right-pinned";
  var CSS_CELL_LAST_LEFT_PINNED = "ag-cell-last-left-pinned";
  var CSS_CELL_NOT_INLINE_EDITING = "ag-cell-not-inline-editing";
  var CSS_COLUMN_HOVER = "ag-column-hover";
  var CSS_CELL_WRAP_TEXT = "ag-cell-wrap-text";
  var instanceIdSequence2 = 0;
  var _CellCtrl = class _CellCtrl2 extends BeanStub {
    constructor(column, rowNode, beans, rowCtrl) {
      super();
      this.cellRangeFeature = null;
      this.cellPositionFeature = null;
      this.cellCustomStyleFeature = null;
      this.tooltipFeature = null;
      this.cellMouseListenerFeature = null;
      this.cellKeyboardListenerFeature = null;
      this.suppressRefreshCell = false;
      this.onCellCompAttachedFuncs = [];
      this.column = column;
      this.rowNode = rowNode;
      this.beans = beans;
      this.rowCtrl = rowCtrl;
      this.instanceId = column.getId() + "-" + instanceIdSequence2++;
      this.colIdSanitised = escapeString(this.column.getId());
      if (!beans.gos.get("suppressCellFocus")) {
        this.tabIndex = -1;
      }
      this.createCellPosition();
      this.addFeatures();
      this.updateAndFormatValue(false);
    }
    shouldRestoreFocus() {
      return this.beans.focusService.shouldRestoreFocus(this.cellPosition);
    }
    addFeatures() {
      this.cellPositionFeature = new CellPositionFeature(this, this.beans);
      this.addDestroyFunc(() => {
        var _a;
        (_a = this.cellPositionFeature) == null ? void 0 : _a.destroy();
        this.cellPositionFeature = null;
      });
      this.cellCustomStyleFeature = new CellCustomStyleFeature(this, this.beans);
      this.addDestroyFunc(() => {
        var _a;
        (_a = this.cellCustomStyleFeature) == null ? void 0 : _a.destroy();
        this.cellCustomStyleFeature = null;
      });
      this.cellMouseListenerFeature = new CellMouseListenerFeature(this, this.beans, this.column);
      this.addDestroyFunc(() => {
        var _a;
        (_a = this.cellMouseListenerFeature) == null ? void 0 : _a.destroy();
        this.cellMouseListenerFeature = null;
      });
      this.cellKeyboardListenerFeature = new CellKeyboardListenerFeature(this, this.beans, this.column, this.rowNode, this.rowCtrl);
      this.addDestroyFunc(() => {
        var _a;
        (_a = this.cellKeyboardListenerFeature) == null ? void 0 : _a.destroy();
        this.cellKeyboardListenerFeature = null;
      });
      if (this.column.isTooltipEnabled()) {
        this.enableTooltipFeature();
        this.addDestroyFunc(() => {
          this.disableTooltipFeature();
        });
      }
      const rangeSelectionEnabled = this.beans.rangeService && this.beans.gos.get("enableRangeSelection");
      if (rangeSelectionEnabled) {
        this.cellRangeFeature = new CellRangeFeature(this.beans, this);
        this.addDestroyFunc(() => {
          var _a;
          (_a = this.cellRangeFeature) == null ? void 0 : _a.destroy();
          this.cellRangeFeature = null;
        });
      }
    }
    enableTooltipFeature(value, shouldDisplayTooltip) {
      const getTooltipValue = () => {
        const colDef = this.column.getColDef();
        const data = this.rowNode.data;
        if (colDef.tooltipField && exists(data)) {
          return getValueUsingField(data, colDef.tooltipField, this.column.isTooltipFieldContainsDots());
        }
        const valueGetter = colDef.tooltipValueGetter;
        if (valueGetter) {
          return valueGetter(this.beans.gos.addGridCommonParams({
            location: "cell",
            colDef: this.column.getColDef(),
            column: this.column,
            rowIndex: this.cellPosition.rowIndex,
            node: this.rowNode,
            data: this.rowNode.data,
            value: this.value,
            valueFormatted: this.valueFormatted
          }));
        }
        return null;
      };
      const isTooltipWhenTruncated = this.beans.gos.get("tooltipShowMode") === "whenTruncated";
      if (!shouldDisplayTooltip && isTooltipWhenTruncated && !this.isCellRenderer()) {
        shouldDisplayTooltip = () => {
          const eGui = this.getGui();
          const textEl = eGui.children.length === 0 ? eGui : eGui.querySelector(".ag-cell-value");
          if (!textEl) {
            return true;
          }
          return textEl.scrollWidth > textEl.clientWidth;
        };
      }
      const tooltipCtrl = {
        getColumn: () => this.column,
        getColDef: () => this.column.getColDef(),
        getRowIndex: () => this.cellPosition.rowIndex,
        getRowNode: () => this.rowNode,
        getGui: () => this.getGui(),
        getLocation: () => "cell",
        getTooltipValue: value != null ? () => value : getTooltipValue,
        // this makes no sense, why is the cell formatted value passed to the tooltip???
        getValueFormatted: () => this.valueFormatted,
        shouldDisplayTooltip
      };
      this.tooltipFeature = new TooltipFeature(tooltipCtrl, this.beans);
    }
    disableTooltipFeature() {
      if (!this.tooltipFeature) {
        return;
      }
      this.tooltipFeature.destroy();
      this.tooltipFeature = null;
    }
    setComp(comp, eGui, eCellWrapper, printLayout, startEditing) {
      var _a, _b, _c, _d;
      this.cellComp = comp;
      this.eGui = eGui;
      this.printLayout = printLayout;
      this.addDomData();
      this.onCellFocused(this.focusEventToRestore);
      this.applyStaticCssClasses();
      this.setWrapText();
      this.onFirstRightPinnedChanged();
      this.onLastLeftPinnedChanged();
      this.onColumnHover();
      this.setupControlComps();
      this.setupAutoHeight(eCellWrapper);
      this.refreshFirstAndLastStyles();
      this.refreshAriaColIndex();
      (_a = this.cellPositionFeature) == null ? void 0 : _a.setComp(eGui);
      (_b = this.cellCustomStyleFeature) == null ? void 0 : _b.setComp(comp);
      (_c = this.tooltipFeature) == null ? void 0 : _c.refreshToolTip();
      (_d = this.cellKeyboardListenerFeature) == null ? void 0 : _d.setComp(this.eGui);
      if (this.cellRangeFeature) {
        this.cellRangeFeature.setComp(comp, eGui);
      }
      if (startEditing && this.isCellEditable()) {
        this.startEditing();
      } else {
        this.showValue();
      }
      if (this.onCellCompAttachedFuncs.length) {
        this.onCellCompAttachedFuncs.forEach((func) => func());
        this.onCellCompAttachedFuncs = [];
      }
    }
    setupAutoHeight(eCellWrapper) {
      this.isAutoHeight = this.column.isAutoHeight();
      if (!this.isAutoHeight || !eCellWrapper) {
        return;
      }
      const eParentCell = eCellWrapper.parentElement;
      const minRowHeight = this.beans.gos.getRowHeightForNode(this.rowNode).height;
      const measureHeight = (timesCalled) => {
        if (this.editing) {
          return;
        }
        if (!this.isAlive()) {
          return;
        }
        const { paddingTop, paddingBottom, borderBottomWidth, borderTopWidth } = getElementSize(eParentCell);
        const extraHeight = paddingTop + paddingBottom + borderBottomWidth + borderTopWidth;
        const wrapperHeight = eCellWrapper.offsetHeight;
        const autoHeight = wrapperHeight + extraHeight;
        if (timesCalled < 5) {
          const doc2 = this.beans.gos.getDocument();
          const notYetInDom = !doc2 || !doc2.contains(eCellWrapper);
          const possiblyNoContentYet = autoHeight == 0;
          if (notYetInDom || possiblyNoContentYet) {
            window.setTimeout(() => measureHeight(timesCalled + 1), 0);
            return;
          }
        }
        const newHeight = Math.max(autoHeight, minRowHeight);
        this.rowNode.setRowAutoHeight(newHeight, this.column);
      };
      const listener = () => measureHeight(0);
      listener();
      const destroyResizeObserver = this.beans.resizeObserverService.observeResize(eCellWrapper, listener);
      this.addDestroyFunc(() => {
        destroyResizeObserver();
        this.rowNode.setRowAutoHeight(void 0, this.column);
      });
    }
    getCellAriaRole() {
      var _a;
      return (_a = this.column.getColDef().cellAriaRole) != null ? _a : "gridcell";
    }
    getInstanceId() {
      return this.instanceId;
    }
    getColumnIdSanitised() {
      return this.colIdSanitised;
    }
    getTabIndex() {
      return this.tabIndex;
    }
    isCellRenderer() {
      const colDef = this.column.getColDef();
      return colDef.cellRenderer != null || colDef.cellRendererSelector != null;
    }
    getValueToDisplay() {
      var _a;
      return (_a = this.valueFormatted) != null ? _a : this.value;
    }
    showValue(forceNewCellRendererInstance = false) {
      var _a;
      const valueToDisplay = this.getValueToDisplay();
      let compDetails;
      if (this.rowNode.stub) {
        const params = this.createCellRendererParams();
        compDetails = this.beans.userComponentFactory.getLoadingCellRendererDetails(this.column.getColDef(), params);
      } else if (this.isCellRenderer()) {
        const params = this.createCellRendererParams();
        compDetails = this.beans.userComponentFactory.getCellRendererDetails(this.column.getColDef(), params);
      }
      this.cellComp.setRenderDetails(compDetails, valueToDisplay, forceNewCellRendererInstance);
      (_a = this.cellRangeFeature) == null ? void 0 : _a.refreshHandle();
    }
    setupControlComps() {
      const colDef = this.column.getColDef();
      this.includeSelection = this.isIncludeControl(colDef.checkboxSelection);
      this.includeRowDrag = this.isIncludeControl(colDef.rowDrag);
      this.includeDndSource = this.isIncludeControl(colDef.dndSource);
      this.cellComp.setIncludeSelection(this.includeSelection);
      this.cellComp.setIncludeDndSource(this.includeDndSource);
      this.cellComp.setIncludeRowDrag(this.includeRowDrag);
    }
    isForceWrapper() {
      const forceWrapper = this.beans.gos.get("enableCellTextSelection") || this.column.isAutoHeight();
      return forceWrapper;
    }
    isIncludeControl(value) {
      const rowNodePinned = this.rowNode.rowPinned != null;
      const isFunc = typeof value === "function";
      const res = rowNodePinned ? false : isFunc || value === true;
      return res;
    }
    refreshShouldDestroy() {
      const colDef = this.column.getColDef();
      const selectionChanged = this.includeSelection != this.isIncludeControl(colDef.checkboxSelection);
      const rowDragChanged = this.includeRowDrag != this.isIncludeControl(colDef.rowDrag);
      const dndSourceChanged = this.includeDndSource != this.isIncludeControl(colDef.dndSource);
      const autoHeightChanged = this.isAutoHeight != this.column.isAutoHeight();
      return selectionChanged || rowDragChanged || dndSourceChanged || autoHeightChanged;
    }
    // either called internally if single cell editing, or called by rowRenderer if row editing
    startEditing(key = null, cellStartedEdit = false, event = null) {
      if (!this.isCellEditable() || this.editing) {
        return;
      }
      if (!this.cellComp) {
        this.onCellCompAttachedFuncs.push(() => {
          this.startEditing(key, cellStartedEdit, event);
        });
        return;
      }
      const editorParams = this.createCellEditorParams(key, cellStartedEdit);
      const colDef = this.column.getColDef();
      const compDetails = this.beans.userComponentFactory.getCellEditorDetails(colDef, editorParams);
      this.editCompDetails = compDetails;
      const popup = (compDetails == null ? void 0 : compDetails.popupFromSelector) != null ? compDetails.popupFromSelector : !!colDef.cellEditorPopup;
      const position = (compDetails == null ? void 0 : compDetails.popupPositionFromSelector) != null ? compDetails.popupPositionFromSelector : colDef.cellEditorPopupPosition;
      this.setEditing(true);
      this.cellComp.setEditDetails(compDetails, popup, position, this.beans.gos.get("reactiveCustomComponents"));
      const e = this.createEvent(event, Events.EVENT_CELL_EDITING_STARTED);
      this.beans.eventService.dispatchEvent(e);
    }
    setEditing(editing) {
      var _a;
      if (this.editing === editing) {
        return;
      }
      this.editing = editing;
      (_a = this.cellRangeFeature) == null ? void 0 : _a.refreshHandle();
    }
    // pass in 'true' to cancel the editing.
    stopRowOrCellEdit(cancel = false) {
      if (this.beans.gos.get("editType") === "fullRow") {
        this.rowCtrl.stopEditing(cancel);
      } else {
        this.stopEditing(cancel);
      }
    }
    onPopupEditorClosed() {
      if (!this.isEditing()) {
        return;
      }
      this.stopEditingAndFocus();
    }
    takeValueFromCellEditor(cancel) {
      const noValueResult = { newValueExists: false };
      if (cancel) {
        return noValueResult;
      }
      const cellEditor = this.cellComp.getCellEditor();
      if (!cellEditor) {
        return noValueResult;
      }
      const userWantsToCancel = cellEditor.isCancelAfterEnd && cellEditor.isCancelAfterEnd();
      if (userWantsToCancel) {
        return noValueResult;
      }
      const newValue = cellEditor.getValue();
      return {
        newValue,
        newValueExists: true
      };
    }
    /**
     * @returns `True` if the value changes, otherwise `False`.
     */
    saveNewValue(oldValue, newValue) {
      if (newValue === oldValue) {
        return false;
      }
      this.suppressRefreshCell = true;
      const valueChanged = this.rowNode.setDataValue(this.column, newValue, "edit");
      this.suppressRefreshCell = false;
      return valueChanged;
    }
    /**
     * Ends the Cell Editing
     * @param cancel `True` if the edit process is being canceled.
     * @returns `True` if the value of the `GridCell` has been updated, otherwise `False`.
     */
    stopEditing(cancel = false) {
      if (!this.editing) {
        return false;
      }
      const { newValue, newValueExists } = this.takeValueFromCellEditor(cancel);
      const oldValue = this.rowNode.getValueFromValueService(this.column);
      let valueChanged = false;
      if (newValueExists) {
        valueChanged = this.saveNewValue(oldValue, newValue);
      }
      this.setEditing(false);
      this.cellComp.setEditDetails();
      this.editCompDetails = void 0;
      this.updateAndFormatValue(false);
      this.refreshCell({ forceRefresh: true, suppressFlash: true });
      this.dispatchEditingStoppedEvent(oldValue, newValue, !cancel && !!valueChanged);
      return valueChanged;
    }
    dispatchEditingStoppedEvent(oldValue, newValue, valueChanged) {
      const editingStoppedEvent = __spreadProps(__spreadValues({}, this.createEvent(null, Events.EVENT_CELL_EDITING_STOPPED)), {
        oldValue,
        newValue,
        valueChanged
      });
      this.beans.eventService.dispatchEvent(editingStoppedEvent);
    }
    createCellEditorParams(key, cellStartedEdit) {
      return this.beans.gos.addGridCommonParams({
        value: this.rowNode.getValueFromValueService(this.column),
        eventKey: key,
        column: this.column,
        colDef: this.column.getColDef(),
        rowIndex: this.getCellPosition().rowIndex,
        node: this.rowNode,
        data: this.rowNode.data,
        cellStartedEdit,
        onKeyDown: this.onKeyDown.bind(this),
        stopEditing: this.stopEditingAndFocus.bind(this),
        eGridCell: this.getGui(),
        parseValue: this.parseValue.bind(this),
        formatValue: this.formatValue.bind(this)
      });
    }
    createCellRendererParams() {
      const res = this.beans.gos.addGridCommonParams({
        value: this.value,
        valueFormatted: this.valueFormatted,
        getValue: () => this.rowNode.getValueFromValueService(this.column),
        setValue: (value) => this.beans.valueService.setValue(this.rowNode, this.column, value),
        formatValue: this.formatValue.bind(this),
        data: this.rowNode.data,
        node: this.rowNode,
        pinned: this.column.getPinned(),
        colDef: this.column.getColDef(),
        column: this.column,
        rowIndex: this.getCellPosition().rowIndex,
        refreshCell: this.refreshCell.bind(this),
        eGridCell: this.getGui(),
        eParentOfValue: this.cellComp.getParentOfValue(),
        registerRowDragger: (rowDraggerElement, dragStartPixels, value, suppressVisibilityChange) => this.registerRowDragger(rowDraggerElement, dragStartPixels, suppressVisibilityChange),
        setTooltip: (value, shouldDisplayTooltip) => {
          var _a;
          if (this.tooltipFeature) {
            this.disableTooltipFeature();
          }
          this.enableTooltipFeature(value, shouldDisplayTooltip);
          (_a = this.tooltipFeature) == null ? void 0 : _a.refreshToolTip();
        }
      });
      return res;
    }
    parseValue(newValue) {
      return this.beans.valueService.parseValue(this.column, this.rowNode, newValue, this.getValue());
    }
    setFocusOutOnEditor() {
      if (!this.editing) {
        return;
      }
      const cellEditor = this.cellComp.getCellEditor();
      if (cellEditor && cellEditor.focusOut) {
        cellEditor.focusOut();
      }
    }
    setFocusInOnEditor() {
      if (!this.editing) {
        return;
      }
      const cellEditor = this.cellComp.getCellEditor();
      if (cellEditor && cellEditor.focusIn) {
        cellEditor.focusIn();
      } else {
        this.focusCell(true);
      }
    }
    onCellChanged(event) {
      const eventImpactsThisCell = event.column === this.column;
      if (eventImpactsThisCell) {
        this.refreshCell({});
      }
    }
    refreshOrDestroyCell(params) {
      var _a;
      if (this.refreshShouldDestroy()) {
        (_a = this.rowCtrl) == null ? void 0 : _a.recreateCell(this);
      } else {
        this.refreshCell(params);
      }
    }
    // + stop editing {forceRefresh: true, suppressFlash: true}
    // + event cellChanged {}
    // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything
    // + rowCtrl: event dataChanged {suppressFlash: !update, newData: !update}
    // + rowCtrl: api refreshCells() {animate: true/false}
    // + rowRenderer: api softRefreshView() {}
    refreshCell(params) {
      var _a, _b, _c, _d;
      if (this.suppressRefreshCell || this.editing) {
        return;
      }
      const colDef = this.column.getColDef();
      const newData = params != null && !!params.newData;
      const suppressFlash = params != null && !!params.suppressFlash || !!colDef.suppressCellFlash;
      const noValueProvided = colDef.field == null && colDef.valueGetter == null && colDef.showRowGroup == null;
      const forceRefresh = params && params.forceRefresh || noValueProvided || newData;
      const isCellCompReady = !!this.cellComp;
      const valuesDifferent = this.updateAndFormatValue(isCellCompReady);
      const dataNeedsUpdating = forceRefresh || valuesDifferent;
      if (!isCellCompReady) {
        return;
      }
      if (dataNeedsUpdating) {
        this.showValue(newData);
        const processingFilterChange = this.beans.filterManager.isSuppressFlashingCellsBecauseFiltering();
        const flashCell = !suppressFlash && !processingFilterChange && (this.beans.gos.get("enableCellChangeFlash") || colDef.enableCellChangeFlash);
        if (flashCell) {
          this.flashCell();
        }
        (_a = this.cellCustomStyleFeature) == null ? void 0 : _a.applyUserStyles();
        (_b = this.cellCustomStyleFeature) == null ? void 0 : _b.applyClassesFromColDef();
      }
      (_c = this.tooltipFeature) == null ? void 0 : _c.refreshToolTip();
      (_d = this.cellCustomStyleFeature) == null ? void 0 : _d.applyCellClassRules();
    }
    // cell editors call this, when they want to stop for reasons other
    // than what we pick up on. eg selecting from a dropdown ends editing.
    stopEditingAndFocus(suppressNavigateAfterEdit = false, shiftKey = false) {
      this.stopRowOrCellEdit();
      this.focusCell(true);
      if (!suppressNavigateAfterEdit) {
        this.navigateAfterEdit(shiftKey);
      }
    }
    navigateAfterEdit(shiftKey) {
      const enterNavigatesVerticallyAfterEdit = this.beans.gos.get("enterNavigatesVerticallyAfterEdit");
      if (enterNavigatesVerticallyAfterEdit) {
        const key = shiftKey ? KeyCode.UP : KeyCode.DOWN;
        this.beans.navigationService.navigateToNextCell(null, key, this.getCellPosition(), false);
      }
    }
    // user can also call this via API
    flashCell(delays) {
      var _a, _b;
      const flashDuration = (_a = delays == null ? void 0 : delays.flashDuration) != null ? _a : delays == null ? void 0 : delays.flashDelay;
      const fadeDuration = (_b = delays == null ? void 0 : delays.fadeDuration) != null ? _b : delays == null ? void 0 : delays.fadeDelay;
      this.animateCell("data-changed", flashDuration, fadeDuration);
    }
    animateCell(cssName, flashDuration, fadeDuration) {
      if (!this.cellComp) {
        return;
      }
      const fullName = `ag-cell-${cssName}`;
      const animationFullName = `ag-cell-${cssName}-animation`;
      const { gos } = this.beans;
      if (!flashDuration) {
        flashDuration = gos.get("cellFlashDuration");
      }
      if (!exists(fadeDuration)) {
        fadeDuration = gos.get("cellFadeDuration");
      }
      this.cellComp.addOrRemoveCssClass(fullName, true);
      this.cellComp.addOrRemoveCssClass(animationFullName, false);
      this.beans.frameworkOverrides.wrapIncoming(() => {
        window.setTimeout(() => {
          if (!this.isAlive()) {
            return;
          }
          this.cellComp.addOrRemoveCssClass(fullName, false);
          this.cellComp.addOrRemoveCssClass(animationFullName, true);
          this.eGui.style.transition = `background-color ${fadeDuration}ms`;
          window.setTimeout(() => {
            if (!this.isAlive()) {
              return;
            }
            this.cellComp.addOrRemoveCssClass(animationFullName, false);
            this.eGui.style.transition = "";
          }, fadeDuration);
        }, flashDuration);
      });
    }
    onFlashCells(event) {
      if (!this.cellComp) {
        return;
      }
      const cellId = this.beans.cellPositionUtils.createId(this.getCellPosition());
      const shouldFlash = event.cells[cellId];
      if (shouldFlash) {
        this.animateCell("highlight");
      }
    }
    isCellEditable() {
      return this.column.isCellEditable(this.rowNode);
    }
    isSuppressFillHandle() {
      return this.column.isSuppressFillHandle();
    }
    formatValue(value) {
      var _a;
      return (_a = this.callValueFormatter(value)) != null ? _a : value;
    }
    callValueFormatter(value) {
      return this.beans.valueService.formatValue(this.column, this.rowNode, value);
    }
    updateAndFormatValue(compareValues) {
      const oldValue = this.value;
      const oldValueFormatted = this.valueFormatted;
      this.value = this.rowNode.getValueFromValueService(this.column);
      this.valueFormatted = this.callValueFormatter(this.value);
      if (compareValues) {
        return !this.valuesAreEqual(oldValue, this.value) || this.valueFormatted != oldValueFormatted;
      }
      return true;
    }
    valuesAreEqual(val1, val2) {
      const colDef = this.column.getColDef();
      return colDef.equals ? colDef.equals(val1, val2) : val1 === val2;
    }
    getComp() {
      return this.cellComp;
    }
    getValue() {
      return this.value;
    }
    addDomData() {
      const element = this.getGui();
      this.beans.gos.setDomData(element, _CellCtrl2.DOM_DATA_KEY_CELL_CTRL, this);
      this.addDestroyFunc(() => this.beans.gos.setDomData(element, _CellCtrl2.DOM_DATA_KEY_CELL_CTRL, null));
    }
    createEvent(domEvent, eventType) {
      const event = this.beans.gos.addGridCommonParams({
        type: eventType,
        node: this.rowNode,
        data: this.rowNode.data,
        value: this.value,
        column: this.column,
        colDef: this.column.getColDef(),
        rowPinned: this.rowNode.rowPinned,
        event: domEvent,
        rowIndex: this.rowNode.rowIndex
      });
      return event;
    }
    processCharacter(event) {
      var _a;
      (_a = this.cellKeyboardListenerFeature) == null ? void 0 : _a.processCharacter(event);
    }
    onKeyDown(event) {
      var _a;
      (_a = this.cellKeyboardListenerFeature) == null ? void 0 : _a.onKeyDown(event);
    }
    onMouseEvent(eventName, mouseEvent) {
      var _a;
      (_a = this.cellMouseListenerFeature) == null ? void 0 : _a.onMouseEvent(eventName, mouseEvent);
    }
    getGui() {
      return this.eGui;
    }
    getColSpanningList() {
      return this.cellPositionFeature.getColSpanningList();
    }
    onLeftChanged() {
      var _a;
      if (!this.cellComp) {
        return;
      }
      (_a = this.cellPositionFeature) == null ? void 0 : _a.onLeftChanged();
    }
    onDisplayedColumnsChanged() {
      if (!this.eGui) {
        return;
      }
      this.refreshAriaColIndex();
      this.refreshFirstAndLastStyles();
    }
    refreshFirstAndLastStyles() {
      const { cellComp, column, beans } = this;
      CssClassApplier.refreshFirstAndLastStyles(cellComp, column, beans.columnModel);
    }
    refreshAriaColIndex() {
      const colIdx = this.beans.columnModel.getAriaColumnIndex(this.column);
      setAriaColIndex(this.getGui(), colIdx);
    }
    isSuppressNavigable() {
      return this.column.isSuppressNavigable(this.rowNode);
    }
    onWidthChanged() {
      var _a;
      return (_a = this.cellPositionFeature) == null ? void 0 : _a.onWidthChanged();
    }
    getColumn() {
      return this.column;
    }
    getRowNode() {
      return this.rowNode;
    }
    isPrintLayout() {
      return this.printLayout;
    }
    getCellPosition() {
      return this.cellPosition;
    }
    isEditing() {
      return this.editing;
    }
    // called by rowRenderer when user navigates via tab key
    startRowOrCellEdit(key, event = null) {
      if (!this.cellComp) {
        this.onCellCompAttachedFuncs.push(() => {
          this.startRowOrCellEdit(key, event);
        });
        return;
      }
      if (this.beans.gos.get("editType") === "fullRow") {
        this.rowCtrl.startRowEditing(key, this);
      } else {
        this.startEditing(key, true, event);
      }
    }
    getRowCtrl() {
      return this.rowCtrl;
    }
    getRowPosition() {
      return {
        rowIndex: this.cellPosition.rowIndex,
        rowPinned: this.cellPosition.rowPinned
      };
    }
    updateRangeBordersIfRangeCount() {
      if (!this.cellComp) {
        return;
      }
      if (this.cellRangeFeature) {
        this.cellRangeFeature.updateRangeBordersIfRangeCount();
      }
    }
    onRangeSelectionChanged() {
      if (!this.cellComp) {
        return;
      }
      if (this.cellRangeFeature) {
        this.cellRangeFeature.onRangeSelectionChanged();
      }
    }
    isRangeSelectionEnabled() {
      return this.cellRangeFeature != null;
    }
    focusCell(forceBrowserFocus = false) {
      this.beans.focusService.setFocusedCell({
        rowIndex: this.getCellPosition().rowIndex,
        column: this.column,
        rowPinned: this.rowNode.rowPinned,
        forceBrowserFocus
      });
    }
    onRowIndexChanged() {
      this.createCellPosition();
      this.onCellFocused();
      if (this.cellRangeFeature) {
        this.cellRangeFeature.onRangeSelectionChanged();
      }
    }
    onFirstRightPinnedChanged() {
      if (!this.cellComp) {
        return;
      }
      const firstRightPinned = this.column.isFirstRightPinned();
      this.cellComp.addOrRemoveCssClass(CSS_CELL_FIRST_RIGHT_PINNED, firstRightPinned);
    }
    onLastLeftPinnedChanged() {
      if (!this.cellComp) {
        return;
      }
      const lastLeftPinned = this.column.isLastLeftPinned();
      this.cellComp.addOrRemoveCssClass(CSS_CELL_LAST_LEFT_PINNED, lastLeftPinned);
    }
    onCellFocused(event) {
      if (this.beans.gos.get("suppressCellFocus")) {
        return;
      }
      const cellFocused = this.beans.focusService.isCellFocused(this.cellPosition);
      if (!this.cellComp) {
        if (cellFocused && (event == null ? void 0 : event.forceBrowserFocus)) {
          this.focusEventToRestore = event;
        }
        return;
      }
      this.focusEventToRestore = void 0;
      this.cellComp.addOrRemoveCssClass(CSS_CELL_FOCUS, cellFocused);
      if (cellFocused && event && event.forceBrowserFocus) {
        const focusEl = this.cellComp.getFocusableElement();
        focusEl.focus({ preventScroll: !!event.preventScrollOnBrowserFocus });
      }
      const fullRowEdit = this.beans.gos.get("editType") === "fullRow";
      if (!cellFocused && !fullRowEdit && this.editing) {
        this.stopRowOrCellEdit();
      }
      if (cellFocused) {
        this.rowCtrl.announceDescription();
      }
    }
    createCellPosition() {
      this.cellPosition = {
        rowIndex: this.rowNode.rowIndex,
        rowPinned: makeNull(this.rowNode.rowPinned),
        column: this.column
      };
    }
    // CSS Classes that only get applied once, they never change
    applyStaticCssClasses() {
      this.cellComp.addOrRemoveCssClass(CSS_CELL, true);
      this.cellComp.addOrRemoveCssClass(CSS_CELL_NOT_INLINE_EDITING, true);
      const autoHeight = this.column.isAutoHeight() == true;
      this.cellComp.addOrRemoveCssClass(CSS_AUTO_HEIGHT, autoHeight);
      this.cellComp.addOrRemoveCssClass(CSS_NORMAL_HEIGHT, !autoHeight);
    }
    onColumnHover() {
      if (!this.cellComp) {
        return;
      }
      if (!this.beans.gos.get("columnHoverHighlight")) {
        return;
      }
      const isHovered = this.beans.columnHoverService.isHovered(this.column);
      this.cellComp.addOrRemoveCssClass(CSS_COLUMN_HOVER, isHovered);
    }
    onColDefChanged() {
      if (!this.cellComp) {
        return;
      }
      const isTooltipEnabled = this.column.isTooltipEnabled();
      if (isTooltipEnabled) {
        this.disableTooltipFeature();
        this.enableTooltipFeature();
      } else {
        this.disableTooltipFeature();
      }
      this.setWrapText();
      if (!this.editing) {
        this.refreshOrDestroyCell({ forceRefresh: true, suppressFlash: true });
      } else {
        const cellEditor = this.getCellEditor();
        if (cellEditor == null ? void 0 : cellEditor.refresh) {
          const { eventKey, cellStartedEdit } = this.editCompDetails.params;
          const editorParams = this.createCellEditorParams(eventKey, cellStartedEdit);
          const colDef = this.column.getColDef();
          const compDetails = this.beans.userComponentFactory.getCellEditorDetails(colDef, editorParams);
          cellEditor.refresh(compDetails.params);
        }
      }
    }
    setWrapText() {
      const value = this.column.getColDef().wrapText == true;
      this.cellComp.addOrRemoveCssClass(CSS_CELL_WRAP_TEXT, value);
    }
    dispatchCellContextMenuEvent(event) {
      const colDef = this.column.getColDef();
      const cellContextMenuEvent = this.createEvent(event, Events.EVENT_CELL_CONTEXT_MENU);
      this.beans.eventService.dispatchEvent(cellContextMenuEvent);
      if (colDef.onCellContextMenu) {
        window.setTimeout(() => {
          this.beans.frameworkOverrides.wrapOutgoing(() => {
            colDef.onCellContextMenu(cellContextMenuEvent);
          });
        }, 0);
      }
    }
    getCellRenderer() {
      return this.cellComp ? this.cellComp.getCellRenderer() : null;
    }
    getCellEditor() {
      return this.cellComp ? this.cellComp.getCellEditor() : null;
    }
    destroy() {
      this.onCellCompAttachedFuncs = [];
      super.destroy();
    }
    createSelectionCheckbox() {
      const cbSelectionComponent = new CheckboxSelectionComponent();
      this.beans.context.createBean(cbSelectionComponent);
      cbSelectionComponent.init({ rowNode: this.rowNode, column: this.column });
      return cbSelectionComponent;
    }
    createDndSource() {
      const dndSourceComp = new DndSourceComp(this.rowNode, this.column, this.eGui);
      this.beans.context.createBean(dndSourceComp);
      return dndSourceComp;
    }
    registerRowDragger(customElement, dragStartPixels, suppressVisibilityChange) {
      if (this.customRowDragComp) {
        this.customRowDragComp.setDragElement(customElement, dragStartPixels);
        return;
      }
      const newComp = this.createRowDragComp(customElement, dragStartPixels, suppressVisibilityChange);
      if (newComp) {
        this.customRowDragComp = newComp;
        this.addDestroyFunc(() => {
          this.beans.context.destroyBean(newComp);
          this.customRowDragComp = null;
        });
      }
    }
    createRowDragComp(customElement, dragStartPixels, suppressVisibilityChange) {
      const pagination = this.beans.gos.get("pagination");
      const rowDragManaged = this.beans.gos.get("rowDragManaged");
      const clientSideRowModelActive = this.beans.gos.isRowModelType("clientSide");
      if (rowDragManaged) {
        if (!clientSideRowModelActive) {
          warnOnce("managed row dragging is only allowed in the Client Side Row Model");
          return;
        }
        if (pagination) {
          warnOnce("managed row dragging is not possible when doing pagination");
          return;
        }
      }
      const rowDragComp = new RowDragComp(() => this.value, this.rowNode, this.column, customElement, dragStartPixels, suppressVisibilityChange);
      this.beans.context.createBean(rowDragComp);
      return rowDragComp;
    }
  };
  _CellCtrl.DOM_DATA_KEY_CELL_CTRL = "cellCtrl";
  var CellCtrl = _CellCtrl;
  var instanceIdSequence3 = 0;
  var _RowCtrl = class _RowCtrl2 extends BeanStub {
    constructor(rowNode, beans, animateIn, useAnimationFrameForCreate, printLayout) {
      super();
      this.allRowGuis = [];
      this.active = true;
      this.centerCellCtrls = { list: [], map: {} };
      this.leftCellCtrls = { list: [], map: {} };
      this.rightCellCtrls = { list: [], map: {} };
      this.slideInAnimation = {
        left: false,
        center: false,
        right: false,
        fullWidth: false
      };
      this.fadeInAnimation = {
        left: false,
        center: false,
        right: false,
        fullWidth: false
      };
      this.rowDragComps = [];
      this.lastMouseDownOnDragger = false;
      this.emptyStyle = {};
      this.updateColumnListsPending = false;
      this.rowId = null;
      this.businessKeySanitised = null;
      this.beans = beans;
      this.gos = beans.gos;
      this.rowNode = rowNode;
      this.paginationPage = beans.paginationProxy.getCurrentPage();
      this.useAnimationFrameForCreate = useAnimationFrameForCreate;
      this.printLayout = printLayout;
      this.suppressRowTransform = this.gos.get("suppressRowTransform");
      this.instanceId = rowNode.id + "-" + instanceIdSequence3++;
      this.rowId = escapeString(rowNode.id);
      this.initRowBusinessKey();
      this.rowFocused = beans.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
      this.rowLevel = beans.rowCssClassCalculator.calculateRowLevel(this.rowNode);
      this.setRowType();
      this.setAnimateFlags(animateIn);
      this.rowStyles = this.processStylesFromGridOptions();
      if (this.isFullWidth() && !this.gos.get("suppressCellFocus")) {
        this.tabIndex = -1;
      }
      this.addListeners();
    }
    initRowBusinessKey() {
      this.businessKeyForNodeFunc = this.gos.get("getBusinessKeyForNode");
      this.updateRowBusinessKey();
    }
    updateRowBusinessKey() {
      if (typeof this.businessKeyForNodeFunc !== "function") {
        return;
      }
      const businessKey = this.businessKeyForNodeFunc(this.rowNode);
      this.businessKeySanitised = escapeString(businessKey);
    }
    getRowId() {
      return this.rowId;
    }
    getRowStyles() {
      return this.rowStyles;
    }
    getTabIndex() {
      return this.tabIndex;
    }
    isSticky() {
      return this.rowNode.sticky;
    }
    getInstanceId() {
      return this.instanceId;
    }
    setComp(rowComp, element, containerType) {
      const gui = { rowComp, element, containerType };
      this.allRowGuis.push(gui);
      if (containerType === "left") {
        this.leftGui = gui;
      } else if (containerType === "right") {
        this.rightGui = gui;
      } else if (containerType === "fullWidth") {
        this.fullWidthGui = gui;
      } else {
        this.centerGui = gui;
      }
      this.initialiseRowComp(gui);
      if (this.rowType !== "FullWidthLoading" && !this.rowNode.rowPinned) {
        this.beans.rowRenderer.dispatchFirstDataRenderedEvent();
      }
    }
    unsetComp(containerType) {
      this.allRowGuis = this.allRowGuis.filter((rowGui) => rowGui.containerType !== containerType);
      switch (containerType) {
        case "left":
          this.leftGui = void 0;
          break;
        case "right":
          this.rightGui = void 0;
          break;
        case "fullWidth":
          this.fullWidthGui = void 0;
          break;
        case "center":
          this.centerGui = void 0;
          break;
        default:
      }
    }
    isCacheable() {
      return this.rowType === "FullWidthDetail" && this.gos.get("keepDetailRows");
    }
    setCached(cached) {
      const displayValue = cached ? "none" : "";
      this.allRowGuis.forEach((rg) => rg.element.style.display = displayValue);
    }
    initialiseRowComp(gui) {
      const gos = this.gos;
      this.listenOnDomOrder(gui);
      if (this.beans.columnModel.wasAutoRowHeightEverActive()) {
        this.rowNode.checkAutoHeights();
      }
      this.onRowHeightChanged(gui);
      this.updateRowIndexes(gui);
      this.setFocusedClasses(gui);
      this.setStylesFromGridOptions(false, gui);
      if (gos.isRowSelection() && this.rowNode.selectable) {
        this.onRowSelected(gui);
      }
      this.updateColumnLists(!this.useAnimationFrameForCreate);
      const comp = gui.rowComp;
      const initialRowClasses = this.getInitialRowClasses(gui.containerType);
      initialRowClasses.forEach((name) => comp.addOrRemoveCssClass(name, true));
      this.executeSlideAndFadeAnimations(gui);
      if (this.rowNode.group) {
        setAriaExpanded(gui.element, this.rowNode.expanded == true);
      }
      this.setRowCompRowId(comp);
      this.setRowCompRowBusinessKey(comp);
      gos.setDomData(gui.element, _RowCtrl2.DOM_DATA_KEY_ROW_CTRL, this);
      this.addDestroyFunc(
        () => gos.setDomData(gui.element, _RowCtrl2.DOM_DATA_KEY_ROW_CTRL, null)
      );
      if (this.useAnimationFrameForCreate) {
        this.beans.animationFrameService.createTask(
          this.addHoverFunctionality.bind(this, gui.element),
          this.rowNode.rowIndex,
          "createTasksP2"
        );
      } else {
        this.addHoverFunctionality(gui.element);
      }
      if (this.isFullWidth()) {
        this.setupFullWidth(gui);
      }
      if (gos.get("rowDragEntireRow")) {
        this.addRowDraggerToRow(gui);
      }
      if (this.useAnimationFrameForCreate) {
        this.beans.animationFrameService.addDestroyTask(() => {
          if (!this.isAlive()) {
            return;
          }
          gui.rowComp.addOrRemoveCssClass("ag-after-created", true);
        });
      }
      this.executeProcessRowPostCreateFunc();
    }
    setRowCompRowBusinessKey(comp) {
      if (this.businessKeySanitised == null) {
        return;
      }
      comp.setRowBusinessKey(this.businessKeySanitised);
    }
    getBusinessKey() {
      return this.businessKeySanitised;
    }
    setRowCompRowId(comp) {
      this.rowId = escapeString(this.rowNode.id);
      if (this.rowId == null) {
        return;
      }
      comp.setRowId(this.rowId);
    }
    executeSlideAndFadeAnimations(gui) {
      const { containerType } = gui;
      const shouldSlide = this.slideInAnimation[containerType];
      if (shouldSlide) {
        executeNextVMTurn(() => {
          this.onTopChanged();
        });
        this.slideInAnimation[containerType] = false;
      }
      const shouldFade = this.fadeInAnimation[containerType];
      if (shouldFade) {
        executeNextVMTurn(() => {
          gui.rowComp.addOrRemoveCssClass("ag-opacity-zero", false);
        });
        this.fadeInAnimation[containerType] = false;
      }
    }
    addRowDraggerToRow(gui) {
      if (this.gos.get("enableRangeSelection")) {
        warnOnce("Setting `rowDragEntireRow: true` in the gridOptions doesn't work with `enableRangeSelection: true`");
        return;
      }
      const translate = this.beans.localeService.getLocaleTextFunc();
      const rowDragComp = new RowDragComp(
        () => `1 ${translate("rowDragRow", "row")}`,
        this.rowNode,
        void 0,
        gui.element,
        void 0,
        true
      );
      const rowDragBean = this.createBean(rowDragComp, this.beans.context);
      this.rowDragComps.push(rowDragBean);
    }
    setupFullWidth(gui) {
      const pinned = this.getPinnedForContainer(gui.containerType);
      if (this.rowType == "FullWidthDetail") {
        if (!ModuleRegistry.__assertRegistered("@ag-grid-enterprise/master-detail", "cell renderer 'agDetailCellRenderer' (for master detail)", this.beans.context.getGridId())) {
          return;
        }
      }
      const compDetails = this.createFullWidthCompDetails(gui.element, pinned);
      gui.rowComp.showFullWidth(compDetails);
    }
    isPrintLayout() {
      return this.printLayout;
    }
    getFullWidthCellRenderers() {
      var _a, _b;
      if (this.gos.get("embedFullWidthRows")) {
        return this.allRowGuis.map((gui) => {
          var _a2;
          return (_a2 = gui == null ? void 0 : gui.rowComp) == null ? void 0 : _a2.getFullWidthCellRenderer();
        });
      }
      return [(_b = (_a = this.fullWidthGui) == null ? void 0 : _a.rowComp) == null ? void 0 : _b.getFullWidthCellRenderer()];
    }
    // use by autoWidthCalculator, as it clones the elements
    getCellElement(column) {
      const cellCtrl = this.getCellCtrl(column);
      return cellCtrl ? cellCtrl.getGui() : null;
    }
    executeProcessRowPostCreateFunc() {
      const func = this.gos.getCallback("processRowPostCreate");
      if (!func || !this.areAllContainersReady()) {
        return;
      }
      const params = {
        // areAllContainersReady asserts that centerGui is not null
        eRow: this.centerGui.element,
        ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
        ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
        node: this.rowNode,
        rowIndex: this.rowNode.rowIndex,
        addRenderedRowListener: this.addEventListener.bind(this)
      };
      func(params);
    }
    areAllContainersReady() {
      const isLeftReady = !!this.leftGui || !this.beans.columnModel.isPinningLeft();
      const isCenterReady = !!this.centerGui;
      const isRightReady = !!this.rightGui || !this.beans.columnModel.isPinningRight();
      return isLeftReady && isCenterReady && isRightReady;
    }
    setRowType() {
      const isStub = this.rowNode.stub && !this.gos.get("suppressServerSideFullWidthLoadingRow");
      const isFullWidthCell = this.rowNode.isFullWidthCell();
      const isDetailCell = this.gos.get("masterDetail") && this.rowNode.detail;
      const pivotMode = this.beans.columnModel.isPivotMode();
      const isGroupRow = !!this.rowNode.group && !this.rowNode.footer;
      const isFullWidthGroup = isGroupRow && this.gos.isGroupUseEntireRow(pivotMode);
      if (isStub) {
        this.rowType = "FullWidthLoading";
      } else if (isDetailCell) {
        this.rowType = "FullWidthDetail";
      } else if (isFullWidthCell) {
        this.rowType = "FullWidth";
      } else if (isFullWidthGroup) {
        this.rowType = "FullWidthGroup";
      } else {
        this.rowType = "Normal";
      }
    }
    updateColumnLists(suppressAnimationFrame = false, useFlushSync = false) {
      if (this.isFullWidth()) {
        return;
      }
      const noAnimation = suppressAnimationFrame || this.gos.get("suppressAnimationFrame") || this.printLayout;
      if (noAnimation) {
        this.updateColumnListsImpl(useFlushSync);
        return;
      }
      if (this.updateColumnListsPending) {
        return;
      }
      this.beans.animationFrameService.createTask(
        () => {
          if (!this.active) {
            return;
          }
          this.updateColumnListsImpl(true);
        },
        this.rowNode.rowIndex,
        "createTasksP1"
      );
      this.updateColumnListsPending = true;
    }
    createCellCtrls(prev, cols, pinned = null) {
      const res = {
        list: [],
        map: {}
      };
      const addCell = (colInstanceId, cellCtrl) => {
        res.list.push(cellCtrl);
        res.map[colInstanceId] = cellCtrl;
      };
      cols.forEach((col) => {
        const colInstanceId = col.getInstanceId();
        let cellCtrl = prev.map[colInstanceId];
        if (!cellCtrl) {
          cellCtrl = new CellCtrl(col, this.rowNode, this.beans, this);
        }
        addCell(colInstanceId, cellCtrl);
      });
      prev.list.forEach((prevCellCtrl) => {
        const cellInResult = res.map[prevCellCtrl.getColumn().getInstanceId()] != null;
        if (cellInResult) {
          return;
        }
        const keepCell = !this.isCellEligibleToBeRemoved(prevCellCtrl, pinned);
        if (keepCell) {
          addCell(prevCellCtrl.getColumn().getInstanceId(), prevCellCtrl);
          return;
        }
        prevCellCtrl.destroy();
      });
      return res;
    }
    updateColumnListsImpl(useFlushSync) {
      this.updateColumnListsPending = false;
      this.createAllCellCtrls();
      this.setCellCtrls(useFlushSync);
    }
    setCellCtrls(useFlushSync) {
      this.allRowGuis.forEach((item) => {
        const cellControls = this.getCellCtrlsForContainer(item.containerType);
        item.rowComp.setCellCtrls(cellControls, useFlushSync);
      });
    }
    getCellCtrlsForContainer(containerType) {
      switch (containerType) {
        case "left":
          return this.leftCellCtrls.list;
        case "right":
          return this.rightCellCtrls.list;
        case "fullWidth":
          return [];
        case "center":
          return this.centerCellCtrls.list;
        default:
          const exhaustiveCheck = containerType;
          throw new Error(`Unhandled case: ${exhaustiveCheck}`);
      }
    }
    createAllCellCtrls() {
      const columnModel = this.beans.columnModel;
      if (this.printLayout) {
        this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, columnModel.getAllDisplayedColumns());
        this.leftCellCtrls = { list: [], map: {} };
        this.rightCellCtrls = { list: [], map: {} };
      } else {
        const centerCols = columnModel.getViewportCenterColumnsForRow(this.rowNode);
        this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, centerCols);
        const leftCols = columnModel.getDisplayedLeftColumnsForRow(this.rowNode);
        this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, leftCols, "left");
        const rightCols = columnModel.getDisplayedRightColumnsForRow(this.rowNode);
        this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, rightCols, "right");
      }
    }
    isCellEligibleToBeRemoved(cellCtrl, nextContainerPinned) {
      const REMOVE_CELL = true;
      const KEEP_CELL = false;
      const column = cellCtrl.getColumn();
      if (column.getPinned() != nextContainerPinned) {
        return REMOVE_CELL;
      }
      const editing = cellCtrl.isEditing();
      const focused = this.beans.focusService.isCellFocused(cellCtrl.getCellPosition());
      const mightWantToKeepCell = editing || focused;
      if (mightWantToKeepCell) {
        const column2 = cellCtrl.getColumn();
        const displayedColumns = this.beans.columnModel.getAllDisplayedColumns();
        const cellStillDisplayed = displayedColumns.indexOf(column2) >= 0;
        return cellStillDisplayed ? KEEP_CELL : REMOVE_CELL;
      }
      return REMOVE_CELL;
    }
    getDomOrder() {
      const isEnsureDomOrder = this.gos.get("ensureDomOrder");
      return isEnsureDomOrder || this.gos.isDomLayout("print");
    }
    listenOnDomOrder(gui) {
      const listener = () => {
        gui.rowComp.setDomOrder(this.getDomOrder());
      };
      this.addManagedPropertyListener("domLayout", listener);
      this.addManagedPropertyListener("ensureDomOrder", listener);
    }
    setAnimateFlags(animateIn) {
      if (this.isSticky() || !animateIn) {
        return;
      }
      const oldRowTopExists = exists(this.rowNode.oldRowTop);
      const pinningLeft = this.beans.columnModel.isPinningLeft();
      const pinningRight = this.beans.columnModel.isPinningRight();
      if (oldRowTopExists) {
        if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
          this.slideInAnimation.fullWidth = true;
          return;
        }
        this.slideInAnimation.center = true;
        this.slideInAnimation.left = pinningLeft;
        this.slideInAnimation.right = pinningRight;
      } else {
        if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
          this.fadeInAnimation.fullWidth = true;
          return;
        }
        this.fadeInAnimation.center = true;
        this.fadeInAnimation.left = pinningLeft;
        this.fadeInAnimation.right = pinningRight;
      }
    }
    isEditing() {
      return this.editingRow;
    }
    isFullWidth() {
      return this.rowType !== "Normal";
    }
    refreshFullWidth() {
      const tryRefresh = (gui, pinned) => {
        if (!gui) {
          return true;
        }
        return gui.rowComp.refreshFullWidth(() => {
          const compDetails = this.createFullWidthCompDetails(gui.element, pinned);
          return compDetails.params;
        });
      };
      const fullWidthSuccess = tryRefresh(this.fullWidthGui, null);
      const centerSuccess = tryRefresh(this.centerGui, null);
      const leftSuccess = tryRefresh(this.leftGui, "left");
      const rightSuccess = tryRefresh(this.rightGui, "right");
      const allFullWidthRowsRefreshed = fullWidthSuccess && centerSuccess && leftSuccess && rightSuccess;
      return allFullWidthRowsRefreshed;
    }
    addListeners() {
      this.addManagedListener(this.rowNode, RowNode.EVENT_HEIGHT_CHANGED, () => this.onRowHeightChanged());
      this.addManagedListener(this.rowNode, RowNode.EVENT_ROW_SELECTED, () => this.onRowSelected());
      this.addManagedListener(this.rowNode, RowNode.EVENT_ROW_INDEX_CHANGED, this.onRowIndexChanged.bind(this));
      this.addManagedListener(this.rowNode, RowNode.EVENT_TOP_CHANGED, this.onTopChanged.bind(this));
      this.addManagedListener(this.rowNode, RowNode.EVENT_EXPANDED_CHANGED, this.updateExpandedCss.bind(this));
      this.addManagedListener(this.rowNode, RowNode.EVENT_HAS_CHILDREN_CHANGED, this.updateExpandedCss.bind(this));
      if (this.rowNode.detail) {
        this.addManagedListener(this.rowNode.parent, RowNode.EVENT_DATA_CHANGED, this.onRowNodeDataChanged.bind(this));
      }
      this.addManagedListener(this.rowNode, RowNode.EVENT_DATA_CHANGED, this.onRowNodeDataChanged.bind(this));
      this.addManagedListener(this.rowNode, RowNode.EVENT_CELL_CHANGED, this.postProcessCss.bind(this));
      this.addManagedListener(this.rowNode, RowNode.EVENT_HIGHLIGHT_CHANGED, this.onRowNodeHighlightChanged.bind(this));
      this.addManagedListener(this.rowNode, RowNode.EVENT_DRAGGING_CHANGED, this.postProcessRowDragging.bind(this));
      this.addManagedListener(this.rowNode, RowNode.EVENT_UI_LEVEL_CHANGED, this.onUiLevelChanged.bind(this));
      const eventService = this.beans.eventService;
      this.addManagedListener(eventService, Events.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED, this.onPaginationPixelOffsetChanged.bind(this));
      this.addManagedListener(eventService, Events.EVENT_HEIGHT_SCALE_CHANGED, this.onTopChanged.bind(this));
      this.addManagedListener(eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
      this.addManagedListener(eventService, Events.EVENT_VIRTUAL_COLUMNS_CHANGED, this.onVirtualColumnsChanged.bind(this));
      this.addManagedListener(eventService, Events.EVENT_CELL_FOCUSED, this.onCellFocusChanged.bind(this));
      this.addManagedListener(eventService, Events.EVENT_CELL_FOCUS_CLEARED, this.onCellFocusChanged.bind(this));
      this.addManagedListener(eventService, Events.EVENT_PAGINATION_CHANGED, this.onPaginationChanged.bind(this));
      this.addManagedListener(eventService, Events.EVENT_MODEL_UPDATED, this.refreshFirstAndLastRowStyles.bind(this));
      this.addManagedListener(eventService, Events.EVENT_COLUMN_MOVED, this.updateColumnLists.bind(this));
      this.addDestroyFunc(() => {
        this.destroyBeans(this.rowDragComps, this.beans.context);
        if (this.tooltipFeature) {
          this.tooltipFeature = this.destroyBean(this.tooltipFeature, this.beans.context);
        }
      });
      this.addManagedPropertyListeners(["rowDragEntireRow"], () => {
        const useRowDragEntireRow = this.gos.get("rowDragEntireRow");
        if (useRowDragEntireRow) {
          this.allRowGuis.forEach((gui) => {
            this.addRowDraggerToRow(gui);
          });
          return;
        }
        this.destroyBeans(this.rowDragComps, this.beans.context);
        this.rowDragComps = [];
      });
      this.addListenersForCellComps();
    }
    addListenersForCellComps() {
      this.addManagedListener(this.rowNode, RowNode.EVENT_ROW_INDEX_CHANGED, () => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onRowIndexChanged());
      });
      this.addManagedListener(this.rowNode, RowNode.EVENT_CELL_CHANGED, (event) => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onCellChanged(event));
      });
    }
    onRowNodeDataChanged(event) {
      const fullWidthChanged = this.isFullWidth() !== !!this.rowNode.isFullWidthCell();
      if (fullWidthChanged) {
        this.beans.rowRenderer.redrawRow(this.rowNode);
        return;
      }
      if (this.isFullWidth()) {
        const refresh = this.refreshFullWidth();
        if (!refresh) {
          this.beans.rowRenderer.redrawRow(this.rowNode);
        }
        return;
      }
      this.getAllCellCtrls().forEach(
        (cellCtrl) => cellCtrl.refreshCell({
          suppressFlash: !event.update,
          newData: !event.update
        })
      );
      this.allRowGuis.forEach((gui) => {
        this.setRowCompRowId(gui.rowComp);
        this.updateRowBusinessKey();
        this.setRowCompRowBusinessKey(gui.rowComp);
      });
      this.onRowSelected();
      this.postProcessCss();
    }
    postProcessCss() {
      this.setStylesFromGridOptions(true);
      this.postProcessClassesFromGridOptions();
      this.postProcessRowClassRules();
      this.postProcessRowDragging();
    }
    onRowNodeHighlightChanged() {
      const highlighted = this.rowNode.highlighted;
      this.allRowGuis.forEach((gui) => {
        const aboveOn = highlighted === 0;
        const belowOn = highlighted === 1;
        gui.rowComp.addOrRemoveCssClass("ag-row-highlight-above", aboveOn);
        gui.rowComp.addOrRemoveCssClass("ag-row-highlight-below", belowOn);
      });
    }
    postProcessRowDragging() {
      const dragging = this.rowNode.dragging;
      this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass("ag-row-dragging", dragging));
    }
    updateExpandedCss() {
      const expandable = this.rowNode.isExpandable();
      const expanded = this.rowNode.expanded == true;
      this.allRowGuis.forEach((gui) => {
        gui.rowComp.addOrRemoveCssClass("ag-row-group", expandable);
        gui.rowComp.addOrRemoveCssClass("ag-row-group-expanded", expandable && expanded);
        gui.rowComp.addOrRemoveCssClass("ag-row-group-contracted", expandable && !expanded);
        setAriaExpanded(gui.element, expandable && expanded);
      });
    }
    onDisplayedColumnsChanged() {
      this.updateColumnLists(true);
      if (this.beans.columnModel.wasAutoRowHeightEverActive()) {
        this.rowNode.checkAutoHeights();
      }
    }
    onVirtualColumnsChanged() {
      this.updateColumnLists(false, true);
    }
    getRowPosition() {
      return {
        rowPinned: makeNull(this.rowNode.rowPinned),
        rowIndex: this.rowNode.rowIndex
      };
    }
    onKeyboardNavigate(keyboardEvent) {
      const currentFullWidthComp = this.allRowGuis.find((c) => c.element.contains(keyboardEvent.target));
      const currentFullWidthContainer = currentFullWidthComp ? currentFullWidthComp.element : null;
      const isFullWidthContainerFocused = currentFullWidthContainer === keyboardEvent.target;
      if (!isFullWidthContainerFocused) {
        return;
      }
      const node = this.rowNode;
      const lastFocusedCell = this.beans.focusService.getFocusedCell();
      const cellPosition = {
        rowIndex: node.rowIndex,
        rowPinned: node.rowPinned,
        column: lastFocusedCell && lastFocusedCell.column
      };
      this.beans.navigationService.navigateToNextCell(keyboardEvent, keyboardEvent.key, cellPosition, true);
      keyboardEvent.preventDefault();
    }
    onTabKeyDown(keyboardEvent) {
      if (keyboardEvent.defaultPrevented || isStopPropagationForAgGrid(keyboardEvent)) {
        return;
      }
      const currentFullWidthComp = this.allRowGuis.find((c) => c.element.contains(keyboardEvent.target));
      const currentFullWidthContainer = currentFullWidthComp ? currentFullWidthComp.element : null;
      const isFullWidthContainerFocused = currentFullWidthContainer === keyboardEvent.target;
      let nextEl = null;
      if (!isFullWidthContainerFocused) {
        nextEl = this.beans.focusService.findNextFocusableElement(currentFullWidthContainer, false, keyboardEvent.shiftKey);
      }
      if (this.isFullWidth() && isFullWidthContainerFocused || !nextEl) {
        this.beans.navigationService.onTabKeyDown(this, keyboardEvent);
      }
    }
    getFullWidthElement() {
      if (this.fullWidthGui) {
        return this.fullWidthGui.element;
      }
      return null;
    }
    getRowYPosition() {
      var _a;
      const displayedEl = (_a = this.allRowGuis.find((el) => isVisible(el.element))) == null ? void 0 : _a.element;
      if (displayedEl) {
        return displayedEl.getBoundingClientRect().top;
      }
      return 0;
    }
    onFullWidthRowFocused(event) {
      var _a;
      const node = this.rowNode;
      const isFocused = !event ? false : this.isFullWidth() && event.rowIndex === node.rowIndex && event.rowPinned == node.rowPinned;
      const element = this.fullWidthGui ? this.fullWidthGui.element : (_a = this.centerGui) == null ? void 0 : _a.element;
      if (!element) {
        return;
      }
      element.classList.toggle("ag-full-width-focus", isFocused);
      if (isFocused) {
        element.focus({ preventScroll: true });
      }
    }
    recreateCell(cellCtrl) {
      this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, cellCtrl);
      this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, cellCtrl);
      this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, cellCtrl);
      cellCtrl.destroy();
      this.updateColumnLists();
    }
    removeCellCtrl(prev, cellCtrlToRemove) {
      const res = {
        list: [],
        map: {}
      };
      prev.list.forEach((cellCtrl) => {
        if (cellCtrl === cellCtrlToRemove) {
          return;
        }
        res.list.push(cellCtrl);
        res.map[cellCtrl.getColumn().getInstanceId()] = cellCtrl;
      });
      return res;
    }
    onMouseEvent(eventName, mouseEvent) {
      switch (eventName) {
        case "dblclick":
          this.onRowDblClick(mouseEvent);
          break;
        case "click":
          this.onRowClick(mouseEvent);
          break;
        case "touchstart":
        case "mousedown":
          this.onRowMouseDown(mouseEvent);
          break;
      }
    }
    createRowEvent(type, domEvent) {
      return this.gos.addGridCommonParams({
        type,
        node: this.rowNode,
        data: this.rowNode.data,
        rowIndex: this.rowNode.rowIndex,
        rowPinned: this.rowNode.rowPinned,
        event: domEvent
      });
    }
    createRowEventWithSource(type, domEvent) {
      const event = this.createRowEvent(type, domEvent);
      event.source = this;
      return event;
    }
    onRowDblClick(mouseEvent) {
      if (isStopPropagationForAgGrid(mouseEvent)) {
        return;
      }
      const agEvent = this.createRowEventWithSource(Events.EVENT_ROW_DOUBLE_CLICKED, mouseEvent);
      this.beans.eventService.dispatchEvent(agEvent);
    }
    onRowMouseDown(mouseEvent) {
      this.lastMouseDownOnDragger = isElementChildOfClass(mouseEvent.target, "ag-row-drag", 3);
      if (!this.isFullWidth()) {
        return;
      }
      const node = this.rowNode;
      const columnModel = this.beans.columnModel;
      if (this.beans.rangeService) {
        this.beans.rangeService.removeAllCellRanges();
      }
      this.beans.focusService.setFocusedCell({
        rowIndex: node.rowIndex,
        column: columnModel.getAllDisplayedColumns()[0],
        rowPinned: node.rowPinned,
        forceBrowserFocus: true
      });
    }
    onRowClick(mouseEvent) {
      const stop2 = isStopPropagationForAgGrid(mouseEvent) || this.lastMouseDownOnDragger;
      if (stop2) {
        return;
      }
      const agEvent = this.createRowEventWithSource(Events.EVENT_ROW_CLICKED, mouseEvent);
      this.beans.eventService.dispatchEvent(agEvent);
      const isMultiKey = mouseEvent.ctrlKey || mouseEvent.metaKey;
      const isShiftKey = mouseEvent.shiftKey;
      const groupSelectsChildren = this.gos.get("groupSelectsChildren");
      if (
        // we do not allow selecting groups by clicking (as the click here expands the group), or if it's a detail row,
        // so return if it's a group row
        groupSelectsChildren && this.rowNode.group || this.isRowSelectionBlocked() || // if click selection suppressed, do nothing
        this.gos.get("suppressRowClickSelection")
      ) {
        return;
      }
      const multiSelectOnClick = this.gos.get("rowMultiSelectWithClick");
      const rowDeselectionWithCtrl = !this.gos.get("suppressRowDeselection");
      const source = "rowClicked";
      if (this.rowNode.isSelected()) {
        if (multiSelectOnClick) {
          this.rowNode.setSelectedParams({ newValue: false, event: mouseEvent, source });
        } else if (isMultiKey) {
          if (rowDeselectionWithCtrl) {
            this.rowNode.setSelectedParams({ newValue: false, event: mouseEvent, source });
          }
        } else {
          this.rowNode.setSelectedParams({ newValue: true, clearSelection: !isShiftKey, rangeSelect: isShiftKey, event: mouseEvent, source });
        }
      } else {
        const clearSelection = multiSelectOnClick ? false : !isMultiKey;
        this.rowNode.setSelectedParams({ newValue: true, clearSelection, rangeSelect: isShiftKey, event: mouseEvent, source });
      }
    }
    isRowSelectionBlocked() {
      return !this.rowNode.selectable || !!this.rowNode.rowPinned || !this.gos.isRowSelection();
    }
    setupDetailRowAutoHeight(eDetailGui) {
      if (this.rowType !== "FullWidthDetail") {
        return;
      }
      if (!this.gos.get("detailRowAutoHeight")) {
        return;
      }
      const checkRowSizeFunc = () => {
        const clientHeight = eDetailGui.clientHeight;
        if (clientHeight != null && clientHeight > 0) {
          const updateRowHeightFunc = () => {
            this.rowNode.setRowHeight(clientHeight);
            if (this.beans.clientSideRowModel) {
              this.beans.clientSideRowModel.onRowHeightChanged();
            } else if (this.beans.serverSideRowModel) {
              this.beans.serverSideRowModel.onRowHeightChanged();
            }
          };
          window.setTimeout(updateRowHeightFunc, 0);
        }
      };
      const resizeObserverDestroyFunc = this.beans.resizeObserverService.observeResize(eDetailGui, checkRowSizeFunc);
      this.addDestroyFunc(resizeObserverDestroyFunc);
      checkRowSizeFunc();
    }
    createFullWidthCompDetails(eRow, pinned) {
      const params = this.gos.addGridCommonParams({
        fullWidth: true,
        data: this.rowNode.data,
        node: this.rowNode,
        value: this.rowNode.key,
        valueFormatted: this.rowNode.key,
        rowIndex: this.rowNode.rowIndex,
        // these need to be taken out, as part of 'afterAttached' now
        eGridCell: eRow,
        eParentOfValue: eRow,
        pinned,
        addRenderedRowListener: this.addEventListener.bind(this),
        registerRowDragger: (rowDraggerElement, dragStartPixels, value, suppressVisibilityChange) => this.addFullWidthRowDragging(rowDraggerElement, dragStartPixels, value, suppressVisibilityChange),
        setTooltip: (value, shouldDisplayTooltip) => this.refreshRowTooltip(value, shouldDisplayTooltip)
      });
      switch (this.rowType) {
        case "FullWidthDetail":
          return this.beans.userComponentFactory.getFullWidthDetailCellRendererDetails(params);
        case "FullWidthGroup":
          return this.beans.userComponentFactory.getFullWidthGroupCellRendererDetails(params);
        case "FullWidthLoading":
          return this.beans.userComponentFactory.getFullWidthLoadingCellRendererDetails(params);
        default:
          return this.beans.userComponentFactory.getFullWidthCellRendererDetails(params);
      }
    }
    refreshRowTooltip(value, shouldDisplayTooltip) {
      if (!this.fullWidthGui) {
        return;
      }
      const tooltipParams = {
        getGui: () => this.fullWidthGui.element,
        getTooltipValue: () => value,
        getLocation: () => "fullWidthRow",
        shouldDisplayTooltip
      };
      if (this.tooltipFeature) {
        this.destroyBean(this.tooltipFeature, this.beans.context);
      }
      this.tooltipFeature = this.createBean(new TooltipFeature(tooltipParams, this.beans));
    }
    addFullWidthRowDragging(rowDraggerElement, dragStartPixels, value = "", suppressVisibilityChange) {
      if (!this.isFullWidth()) {
        return;
      }
      const rowDragComp = new RowDragComp(() => value, this.rowNode, void 0, rowDraggerElement, dragStartPixels, suppressVisibilityChange);
      this.createBean(rowDragComp, this.beans.context);
      this.addDestroyFunc(() => {
        this.destroyBean(rowDragComp, this.beans.context);
      });
    }
    onUiLevelChanged() {
      const newLevel = this.beans.rowCssClassCalculator.calculateRowLevel(this.rowNode);
      if (this.rowLevel != newLevel) {
        const classToAdd = "ag-row-level-" + newLevel;
        const classToRemove = "ag-row-level-" + this.rowLevel;
        this.allRowGuis.forEach((gui) => {
          gui.rowComp.addOrRemoveCssClass(classToAdd, true);
          gui.rowComp.addOrRemoveCssClass(classToRemove, false);
        });
      }
      this.rowLevel = newLevel;
    }
    isFirstRowOnPage() {
      return this.rowNode.rowIndex === this.beans.paginationProxy.getPageFirstRow();
    }
    isLastRowOnPage() {
      return this.rowNode.rowIndex === this.beans.paginationProxy.getPageLastRow();
    }
    refreshFirstAndLastRowStyles() {
      const newFirst = this.isFirstRowOnPage();
      const newLast = this.isLastRowOnPage();
      if (this.firstRowOnPage !== newFirst) {
        this.firstRowOnPage = newFirst;
        this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass("ag-row-first", newFirst));
      }
      if (this.lastRowOnPage !== newLast) {
        this.lastRowOnPage = newLast;
        this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass("ag-row-last", newLast));
      }
    }
    stopEditing(cancel = false) {
      if (this.stoppingRowEdit) {
        return;
      }
      const cellControls = this.getAllCellCtrls();
      const isRowEdit = this.editingRow;
      this.stoppingRowEdit = true;
      let fireRowEditEvent = false;
      for (const ctrl of cellControls) {
        const valueChanged = ctrl.stopEditing(cancel);
        if (isRowEdit && !cancel && !fireRowEditEvent && valueChanged) {
          fireRowEditEvent = true;
        }
      }
      if (fireRowEditEvent) {
        const event = this.createRowEvent(Events.EVENT_ROW_VALUE_CHANGED);
        this.beans.eventService.dispatchEvent(event);
      }
      if (isRowEdit) {
        this.setEditingRow(false);
      }
      this.stoppingRowEdit = false;
    }
    setInlineEditingCss(editing) {
      this.allRowGuis.forEach((gui) => {
        gui.rowComp.addOrRemoveCssClass("ag-row-inline-editing", editing);
        gui.rowComp.addOrRemoveCssClass("ag-row-not-inline-editing", !editing);
      });
    }
    setEditingRow(value) {
      this.editingRow = value;
      this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass("ag-row-editing", value));
      const event = value ? this.createRowEvent(Events.EVENT_ROW_EDITING_STARTED) : this.createRowEvent(Events.EVENT_ROW_EDITING_STOPPED);
      this.beans.eventService.dispatchEvent(event);
    }
    startRowEditing(key = null, sourceRenderedCell = null, event = null) {
      if (this.editingRow) {
        return;
      }
      const atLeastOneEditing = this.getAllCellCtrls().reduce((prev, cellCtrl) => {
        const cellStartedEdit = cellCtrl === sourceRenderedCell;
        if (cellStartedEdit) {
          cellCtrl.startEditing(key, cellStartedEdit, event);
        } else {
          cellCtrl.startEditing(null, cellStartedEdit, event);
        }
        if (prev) {
          return true;
        }
        return cellCtrl.isEditing();
      }, false);
      if (atLeastOneEditing) {
        this.setEditingRow(true);
      }
    }
    getAllCellCtrls() {
      if (this.leftCellCtrls.list.length === 0 && this.rightCellCtrls.list.length === 0) {
        return this.centerCellCtrls.list;
      }
      const res = [...this.centerCellCtrls.list, ...this.leftCellCtrls.list, ...this.rightCellCtrls.list];
      return res;
    }
    postProcessClassesFromGridOptions() {
      const cssClasses = this.beans.rowCssClassCalculator.processClassesFromGridOptions(this.rowNode);
      if (!cssClasses || !cssClasses.length) {
        return;
      }
      cssClasses.forEach((classStr) => {
        this.allRowGuis.forEach((c) => c.rowComp.addOrRemoveCssClass(classStr, true));
      });
    }
    postProcessRowClassRules() {
      this.beans.rowCssClassCalculator.processRowClassRules(
        this.rowNode,
        (className) => {
          this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass(className, true));
        },
        (className) => {
          this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass(className, false));
        }
      );
    }
    setStylesFromGridOptions(updateStyles, gui) {
      if (updateStyles) {
        this.rowStyles = this.processStylesFromGridOptions();
      }
      this.forEachGui(gui, (gui2) => gui2.rowComp.setUserStyles(this.rowStyles));
    }
    getPinnedForContainer(rowContainerType) {
      const pinned = rowContainerType === "left" ? "left" : rowContainerType === "right" ? "right" : null;
      return pinned;
    }
    getInitialRowClasses(rowContainerType) {
      const pinned = this.getPinnedForContainer(rowContainerType);
      const params = {
        rowNode: this.rowNode,
        rowFocused: this.rowFocused,
        fadeRowIn: this.fadeInAnimation[rowContainerType],
        rowIsEven: this.rowNode.rowIndex % 2 === 0,
        rowLevel: this.rowLevel,
        fullWidthRow: this.isFullWidth(),
        firstRowOnPage: this.isFirstRowOnPage(),
        lastRowOnPage: this.isLastRowOnPage(),
        printLayout: this.printLayout,
        expandable: this.rowNode.isExpandable(),
        pinned
      };
      return this.beans.rowCssClassCalculator.getInitialRowClasses(params);
    }
    processStylesFromGridOptions() {
      const rowStyle = this.gos.get("rowStyle");
      if (rowStyle && typeof rowStyle === "function") {
        console.warn("AG Grid: rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead");
        return;
      }
      const rowStyleFunc = this.gos.getCallback("getRowStyle");
      let rowStyleFuncResult;
      if (rowStyleFunc) {
        const params = {
          data: this.rowNode.data,
          node: this.rowNode,
          rowIndex: this.rowNode.rowIndex
        };
        rowStyleFuncResult = rowStyleFunc(params);
      }
      if (rowStyleFuncResult || rowStyle) {
        return Object.assign({}, rowStyle, rowStyleFuncResult);
      }
      return this.emptyStyle;
    }
    onRowSelected(gui) {
      const selected = !!this.rowNode.isSelected();
      this.forEachGui(gui, (gui2) => {
        gui2.rowComp.addOrRemoveCssClass("ag-row-selected", selected);
        setAriaSelected(gui2.element, selected);
        const hasFocus = gui2.element.contains(this.beans.gos.getActiveDomElement());
        if (hasFocus && (gui2 === this.centerGui || gui2 === this.fullWidthGui)) {
          this.announceDescription();
        }
      });
    }
    announceDescription() {
      if (this.isRowSelectionBlocked()) {
        return;
      }
      const selected = this.rowNode.isSelected();
      if (selected && this.beans.gos.get("suppressRowDeselection")) {
        return;
      }
      const translate = this.beans.localeService.getLocaleTextFunc();
      const label = translate(
        selected ? "ariaRowDeselect" : "ariaRowSelect",
        `Press SPACE to ${selected ? "deselect" : "select"} this row.`
      );
      this.beans.ariaAnnouncementService.announceValue(label);
    }
    addHoverFunctionality(eRow) {
      if (!this.active) {
        return;
      }
      this.addManagedListener(eRow, "mouseenter", () => this.rowNode.onMouseEnter());
      this.addManagedListener(eRow, "mouseleave", () => this.rowNode.onMouseLeave());
      this.addManagedListener(this.rowNode, RowNode.EVENT_MOUSE_ENTER, () => {
        if (!this.beans.dragService.isDragging() && !this.gos.get("suppressRowHoverHighlight")) {
          eRow.classList.add("ag-row-hover");
          this.rowNode.setHovered(true);
        }
      });
      this.addManagedListener(this.rowNode, RowNode.EVENT_MOUSE_LEAVE, () => {
        eRow.classList.remove("ag-row-hover");
        this.rowNode.setHovered(false);
      });
    }
    // for animation, we don't want to animate entry or exit to a very far away pixel,
    // otherwise the row would move so fast, it would appear to disappear. so this method
    // moves the row closer to the viewport if it is far away, so the row slide in / out
    // at a speed the user can see.
    roundRowTopToBounds(rowTop) {
      const range2 = this.beans.ctrlsService.getGridBodyCtrl().getScrollFeature().getApproximateVScollPosition();
      const minPixel = this.applyPaginationOffset(range2.top, true) - 100;
      const maxPixel = this.applyPaginationOffset(range2.bottom, true) + 100;
      return Math.min(Math.max(minPixel, rowTop), maxPixel);
    }
    getFrameworkOverrides() {
      return this.beans.frameworkOverrides;
    }
    forEachGui(gui, callback) {
      if (gui) {
        callback(gui);
      } else {
        this.allRowGuis.forEach(callback);
      }
    }
    onRowHeightChanged(gui) {
      if (this.rowNode.rowHeight == null) {
        return;
      }
      const rowHeight = this.rowNode.rowHeight;
      const defaultRowHeight = this.beans.environment.getDefaultRowHeight();
      const isHeightFromFunc = this.gos.isGetRowHeightFunction();
      const heightFromFunc = isHeightFromFunc ? this.gos.getRowHeightForNode(this.rowNode).height : void 0;
      const lineHeight = heightFromFunc ? `${Math.min(defaultRowHeight, heightFromFunc) - 2}px` : void 0;
      this.forEachGui(gui, (gui2) => {
        gui2.element.style.height = `${rowHeight}px`;
        if (lineHeight) {
          gui2.element.style.setProperty("--ag-line-height", lineHeight);
        }
      });
    }
    addEventListener(eventType, listener) {
      super.addEventListener(eventType, listener);
    }
    removeEventListener(eventType, listener) {
      super.removeEventListener(eventType, listener);
    }
    // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
    destroyFirstPass(suppressAnimation = false) {
      this.active = false;
      if (!suppressAnimation && this.gos.isAnimateRows() && !this.isSticky()) {
        const rowStillVisibleJustNotInViewport = this.rowNode.rowTop != null;
        if (rowStillVisibleJustNotInViewport) {
          const rowTop = this.roundRowTopToBounds(this.rowNode.rowTop);
          this.setRowTop(rowTop);
        } else {
          this.allRowGuis.forEach((gui) => gui.rowComp.addOrRemoveCssClass("ag-opacity-zero", true));
        }
      }
      this.rowNode.setHovered(false);
      const event = this.createRowEvent(Events.EVENT_VIRTUAL_ROW_REMOVED);
      this.dispatchEvent(event);
      this.beans.eventService.dispatchEvent(event);
      super.destroy();
    }
    destroySecondPass() {
      this.allRowGuis.length = 0;
      this.stopEditing();
      const destroyCellCtrls = (ctrls) => {
        ctrls.list.forEach((c) => c.destroy());
        return { list: [], map: {} };
      };
      this.centerCellCtrls = destroyCellCtrls(this.centerCellCtrls);
      this.leftCellCtrls = destroyCellCtrls(this.leftCellCtrls);
      this.rightCellCtrls = destroyCellCtrls(this.rightCellCtrls);
    }
    setFocusedClasses(gui) {
      this.forEachGui(gui, (gui2) => {
        gui2.rowComp.addOrRemoveCssClass("ag-row-focus", this.rowFocused);
        gui2.rowComp.addOrRemoveCssClass("ag-row-no-focus", !this.rowFocused);
      });
    }
    onCellFocusChanged() {
      const rowFocused = this.beans.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
      if (rowFocused !== this.rowFocused) {
        this.rowFocused = rowFocused;
        this.setFocusedClasses();
      }
      if (!rowFocused && this.editingRow) {
        this.stopEditing(false);
      }
    }
    onPaginationChanged() {
      const currentPage = this.beans.paginationProxy.getCurrentPage();
      if (this.paginationPage !== currentPage) {
        this.paginationPage = currentPage;
        this.onTopChanged();
      }
      this.refreshFirstAndLastRowStyles();
    }
    onTopChanged() {
      this.setRowTop(this.rowNode.rowTop);
    }
    onPaginationPixelOffsetChanged() {
      this.onTopChanged();
    }
    // applies pagination offset, eg if on second page, and page height is 500px, then removes
    // 500px from the top position, so a row with rowTop 600px is displayed at location 100px.
    // reverse will take the offset away rather than add.
    applyPaginationOffset(topPx, reverse = false) {
      if (this.rowNode.isRowPinned() || this.rowNode.sticky) {
        return topPx;
      }
      const pixelOffset = this.beans.paginationProxy.getPixelOffset();
      const multiplier = reverse ? 1 : -1;
      return topPx + pixelOffset * multiplier;
    }
    setRowTop(pixels) {
      if (this.printLayout) {
        return;
      }
      if (exists(pixels)) {
        const afterPaginationPixels = this.applyPaginationOffset(pixels);
        const skipScaling = this.rowNode.isRowPinned() || this.rowNode.sticky;
        const afterScalingPixels = skipScaling ? afterPaginationPixels : this.beans.rowContainerHeightService.getRealPixelPosition(afterPaginationPixels);
        const topPx = `${afterScalingPixels}px`;
        this.setRowTopStyle(topPx);
      }
    }
    // the top needs to be set into the DOM element when the element is created, not updated afterwards.
    // otherwise the transition would not work, as it would be transitioning from zero (the unset value).
    // for example, suppose a row that is outside the viewport, then user does a filter to remove other rows
    // and this row now appears in the viewport, and the row moves up (ie it was under the viewport and not rendered,
    // but now is in the viewport) then a new RowComp is created, however it should have it's position initialised
    // to below the viewport, so the row will appear to animate up. if we didn't set the initial position at creation
    // time, the row would animate down (ie from position zero).
    getInitialRowTop(rowContainerType) {
      return this.suppressRowTransform ? this.getInitialRowTopShared(rowContainerType) : void 0;
    }
    getInitialTransform(rowContainerType) {
      return this.suppressRowTransform ? void 0 : `translateY(${this.getInitialRowTopShared(rowContainerType)})`;
    }
    getInitialRowTopShared(rowContainerType) {
      if (this.printLayout) {
        return "";
      }
      let rowTop;
      if (this.isSticky()) {
        rowTop = this.rowNode.stickyRowTop;
      } else {
        const pixels = this.slideInAnimation[rowContainerType] ? this.roundRowTopToBounds(this.rowNode.oldRowTop) : this.rowNode.rowTop;
        const afterPaginationPixels = this.applyPaginationOffset(pixels);
        rowTop = this.rowNode.isRowPinned() ? afterPaginationPixels : this.beans.rowContainerHeightService.getRealPixelPosition(afterPaginationPixels);
      }
      return rowTop + "px";
    }
    setRowTopStyle(topPx) {
      this.allRowGuis.forEach(
        (gui) => this.suppressRowTransform ? gui.rowComp.setTop(topPx) : gui.rowComp.setTransform(`translateY(${topPx})`)
      );
    }
    getRowNode() {
      return this.rowNode;
    }
    getCellCtrl(column) {
      let res = null;
      this.getAllCellCtrls().forEach((cellCtrl) => {
        if (cellCtrl.getColumn() == column) {
          res = cellCtrl;
        }
      });
      if (res != null) {
        return res;
      }
      this.getAllCellCtrls().forEach((cellCtrl) => {
        if (cellCtrl.getColSpanningList().indexOf(column) >= 0) {
          res = cellCtrl;
        }
      });
      return res;
    }
    onRowIndexChanged() {
      if (this.rowNode.rowIndex != null) {
        this.onCellFocusChanged();
        this.updateRowIndexes();
        this.postProcessCss();
      }
    }
    getRowIndex() {
      return this.rowNode.getRowIndexString();
    }
    updateRowIndexes(gui) {
      const rowIndexStr = this.rowNode.getRowIndexString();
      const headerRowCount = this.beans.headerNavigationService.getHeaderRowCount() + this.beans.filterManager.getHeaderRowCount();
      const rowIsEven = this.rowNode.rowIndex % 2 === 0;
      const ariaRowIndex = headerRowCount + this.rowNode.rowIndex + 1;
      this.forEachGui(gui, (c) => {
        c.rowComp.setRowIndex(rowIndexStr);
        c.rowComp.addOrRemoveCssClass("ag-row-even", rowIsEven);
        c.rowComp.addOrRemoveCssClass("ag-row-odd", !rowIsEven);
        setAriaRowIndex(c.element, ariaRowIndex);
      });
    }
  };
  _RowCtrl.DOM_DATA_KEY_ROW_CTRL = "renderedRow";
  var RowCtrl = _RowCtrl;
  var RowContainerEventsFeature = class extends BeanStub {
    constructor(element) {
      super();
      this.element = element;
    }
    postConstruct() {
      this.addKeyboardListeners();
      this.addMouseListeners();
      this.mockContextMenuForIPad();
    }
    addKeyboardListeners() {
      const eventName = "keydown";
      const listener = this.processKeyboardEvent.bind(this, eventName);
      this.addManagedListener(this.element, eventName, listener);
    }
    addMouseListeners() {
      const mouseDownEvent = isEventSupported("touchstart") ? "touchstart" : "mousedown";
      const eventNames = ["dblclick", "contextmenu", "mouseover", "mouseout", "click", mouseDownEvent];
      eventNames.forEach((eventName) => {
        const listener = this.processMouseEvent.bind(this, eventName);
        this.addManagedListener(this.element, eventName, listener);
      });
    }
    processMouseEvent(eventName, mouseEvent) {
      if (!this.mouseEventService.isEventFromThisGrid(mouseEvent) || isStopPropagationForAgGrid(mouseEvent)) {
        return;
      }
      const rowComp = this.getRowForEvent(mouseEvent);
      const cellCtrl = this.mouseEventService.getRenderedCellForEvent(mouseEvent);
      if (eventName === "contextmenu") {
        this.handleContextMenuMouseEvent(mouseEvent, void 0, rowComp, cellCtrl);
      } else {
        if (cellCtrl) {
          cellCtrl.onMouseEvent(eventName, mouseEvent);
        }
        if (rowComp) {
          rowComp.onMouseEvent(eventName, mouseEvent);
        }
      }
    }
    mockContextMenuForIPad() {
      if (!isIOSUserAgent()) {
        return;
      }
      const touchListener = new TouchListener(this.element);
      const longTapListener = (event) => {
        const rowComp = this.getRowForEvent(event.touchEvent);
        const cellComp = this.mouseEventService.getRenderedCellForEvent(event.touchEvent);
        this.handleContextMenuMouseEvent(void 0, event.touchEvent, rowComp, cellComp);
      };
      this.addManagedListener(touchListener, TouchListener.EVENT_LONG_TAP, longTapListener);
      this.addDestroyFunc(() => touchListener.destroy());
    }
    getRowForEvent(event) {
      let sourceElement = event.target;
      while (sourceElement) {
        const rowCon = this.gos.getDomData(sourceElement, RowCtrl.DOM_DATA_KEY_ROW_CTRL);
        if (rowCon) {
          return rowCon;
        }
        sourceElement = sourceElement.parentElement;
      }
      return null;
    }
    handleContextMenuMouseEvent(mouseEvent, touchEvent, rowComp, cellCtrl) {
      const rowNode = rowComp ? rowComp.getRowNode() : null;
      const column = cellCtrl ? cellCtrl.getColumn() : null;
      let value = null;
      if (column) {
        const event = mouseEvent ? mouseEvent : touchEvent;
        cellCtrl.dispatchCellContextMenuEvent(event != null ? event : null);
        value = this.valueService.getValue(column, rowNode);
      }
      const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
      const anchorToElement = cellCtrl ? cellCtrl.getGui() : gridBodyCon.getGridBodyElement();
      this.menuService.showContextMenu({ mouseEvent, touchEvent, rowNode, column, value, anchorToElement });
    }
    getControlsForEventTarget(target) {
      return {
        cellCtrl: getCtrlForEventTarget(this.gos, target, CellCtrl.DOM_DATA_KEY_CELL_CTRL),
        rowCtrl: getCtrlForEventTarget(this.gos, target, RowCtrl.DOM_DATA_KEY_ROW_CTRL)
      };
    }
    processKeyboardEvent(eventName, keyboardEvent) {
      const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(keyboardEvent.target);
      if (keyboardEvent.defaultPrevented) {
        return;
      }
      if (cellCtrl) {
        this.processCellKeyboardEvent(cellCtrl, eventName, keyboardEvent);
      } else if (rowCtrl && rowCtrl.isFullWidth()) {
        this.processFullWidthRowKeyboardEvent(rowCtrl, eventName, keyboardEvent);
      }
    }
    processCellKeyboardEvent(cellCtrl, eventName, keyboardEvent) {
      const rowNode = cellCtrl.getRowNode();
      const column = cellCtrl.getColumn();
      const editing = cellCtrl.isEditing();
      const gridProcessingAllowed = !isUserSuppressingKeyboardEvent(this.gos, keyboardEvent, rowNode, column, editing);
      if (gridProcessingAllowed) {
        if (eventName === "keydown") {
          const wasScrollKey = !editing && this.navigationService.handlePageScrollingKey(keyboardEvent);
          if (!wasScrollKey) {
            cellCtrl.onKeyDown(keyboardEvent);
          }
          this.doGridOperations(keyboardEvent, cellCtrl.isEditing());
          if (isEventFromPrintableCharacter(keyboardEvent)) {
            cellCtrl.processCharacter(keyboardEvent);
          }
        }
      }
      if (eventName === "keydown") {
        const cellKeyDownEvent = cellCtrl.createEvent(keyboardEvent, Events.EVENT_CELL_KEY_DOWN);
        this.eventService.dispatchEvent(cellKeyDownEvent);
      }
    }
    processFullWidthRowKeyboardEvent(rowComp, eventName, keyboardEvent) {
      const rowNode = rowComp.getRowNode();
      const focusedCell = this.focusService.getFocusedCell();
      const column = focusedCell && focusedCell.column;
      const gridProcessingAllowed = !isUserSuppressingKeyboardEvent(this.gos, keyboardEvent, rowNode, column, false);
      if (gridProcessingAllowed) {
        const key = keyboardEvent.key;
        if (eventName === "keydown") {
          switch (key) {
            case KeyCode.PAGE_HOME:
            case KeyCode.PAGE_END:
            case KeyCode.PAGE_UP:
            case KeyCode.PAGE_DOWN:
              this.navigationService.handlePageScrollingKey(keyboardEvent, true);
              break;
            case KeyCode.UP:
            case KeyCode.DOWN:
              rowComp.onKeyboardNavigate(keyboardEvent);
              break;
            case KeyCode.TAB:
              rowComp.onTabKeyDown(keyboardEvent);
              break;
            default:
          }
        }
      }
      if (eventName === "keydown") {
        const cellKeyDownEvent = rowComp.createRowEvent(Events.EVENT_CELL_KEY_DOWN, keyboardEvent);
        this.eventService.dispatchEvent(cellKeyDownEvent);
      }
    }
    doGridOperations(keyboardEvent, editing) {
      if (!keyboardEvent.ctrlKey && !keyboardEvent.metaKey) {
        return;
      }
      if (editing) {
        return;
      }
      if (!this.mouseEventService.isEventFromThisGrid(keyboardEvent)) {
        return;
      }
      const keyCode = normaliseQwertyAzerty(keyboardEvent);
      if (keyCode === KeyCode.A) {
        return this.onCtrlAndA(keyboardEvent);
      }
      if (keyCode === KeyCode.C) {
        return this.onCtrlAndC(keyboardEvent);
      }
      if (keyCode === KeyCode.D) {
        return this.onCtrlAndD(keyboardEvent);
      }
      if (keyCode === KeyCode.V) {
        return this.onCtrlAndV(keyboardEvent);
      }
      if (keyCode === KeyCode.X) {
        return this.onCtrlAndX(keyboardEvent);
      }
      if (keyCode === KeyCode.Y) {
        return this.onCtrlAndY();
      }
      if (keyCode === KeyCode.Z) {
        return this.onCtrlAndZ(keyboardEvent);
      }
    }
    onCtrlAndA(event) {
      const { pinnedRowModel, paginationProxy, rangeService } = this;
      if (rangeService && paginationProxy.isRowsToRender()) {
        const [isEmptyPinnedTop, isEmptyPinnedBottom] = [
          pinnedRowModel.isEmpty("top"),
          pinnedRowModel.isEmpty("bottom")
        ];
        const floatingStart = isEmptyPinnedTop ? null : "top";
        let floatingEnd;
        let rowEnd;
        if (isEmptyPinnedBottom) {
          floatingEnd = null;
          rowEnd = this.paginationProxy.getRowCount() - 1;
        } else {
          floatingEnd = "bottom";
          rowEnd = pinnedRowModel.getPinnedBottomRowData().length - 1;
        }
        const allDisplayedColumns = this.columnModel.getAllDisplayedColumns();
        if (missingOrEmpty(allDisplayedColumns)) {
          return;
        }
        rangeService.setCellRange({
          rowStartIndex: 0,
          rowStartPinned: floatingStart,
          rowEndIndex: rowEnd,
          rowEndPinned: floatingEnd,
          columnStart: allDisplayedColumns[0],
          columnEnd: last(allDisplayedColumns)
        });
      }
      event.preventDefault();
    }
    onCtrlAndC(event) {
      if (!this.clipboardService || this.gos.get("enableCellTextSelection")) {
        return;
      }
      const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(event.target);
      if ((cellCtrl == null ? void 0 : cellCtrl.isEditing()) || (rowCtrl == null ? void 0 : rowCtrl.isEditing())) {
        return;
      }
      event.preventDefault();
      this.clipboardService.copyToClipboard();
    }
    onCtrlAndX(event) {
      if (!this.clipboardService || this.gos.get("enableCellTextSelection") || this.gos.get("suppressCutToClipboard")) {
        return;
      }
      const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(event.target);
      if ((cellCtrl == null ? void 0 : cellCtrl.isEditing()) || (rowCtrl == null ? void 0 : rowCtrl.isEditing())) {
        return;
      }
      event.preventDefault();
      this.clipboardService.cutToClipboard(void 0, "ui");
    }
    onCtrlAndV(event) {
      const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(event.target);
      if ((cellCtrl == null ? void 0 : cellCtrl.isEditing()) || (rowCtrl == null ? void 0 : rowCtrl.isEditing())) {
        return;
      }
      if (this.clipboardService && !this.gos.get("suppressClipboardPaste")) {
        this.clipboardService.pasteFromClipboard();
      }
    }
    onCtrlAndD(event) {
      if (this.clipboardService && !this.gos.get("suppressClipboardPaste")) {
        this.clipboardService.copyRangeDown();
      }
      event.preventDefault();
    }
    onCtrlAndZ(event) {
      if (!this.gos.get("undoRedoCellEditing")) {
        return;
      }
      event.preventDefault();
      if (event.shiftKey) {
        this.undoRedoService.redo("ui");
      } else {
        this.undoRedoService.undo("ui");
      }
    }
    onCtrlAndY() {
      this.undoRedoService.redo("ui");
    }
  };
  __decorateClass([
    Autowired("mouseEventService")
  ], RowContainerEventsFeature.prototype, "mouseEventService", 2);
  __decorateClass([
    Autowired("valueService")
  ], RowContainerEventsFeature.prototype, "valueService", 2);
  __decorateClass([
    Autowired("menuService")
  ], RowContainerEventsFeature.prototype, "menuService", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], RowContainerEventsFeature.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("navigationService")
  ], RowContainerEventsFeature.prototype, "navigationService", 2);
  __decorateClass([
    Autowired("focusService")
  ], RowContainerEventsFeature.prototype, "focusService", 2);
  __decorateClass([
    Autowired("undoRedoService")
  ], RowContainerEventsFeature.prototype, "undoRedoService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], RowContainerEventsFeature.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("paginationProxy")
  ], RowContainerEventsFeature.prototype, "paginationProxy", 2);
  __decorateClass([
    Autowired("pinnedRowModel")
  ], RowContainerEventsFeature.prototype, "pinnedRowModel", 2);
  __decorateClass([
    Optional("rangeService")
  ], RowContainerEventsFeature.prototype, "rangeService", 2);
  __decorateClass([
    Optional("clipboardService")
  ], RowContainerEventsFeature.prototype, "clipboardService", 2);
  __decorateClass([
    PostConstruct
  ], RowContainerEventsFeature.prototype, "postConstruct", 1);
  var ViewportSizeFeature = class extends BeanStub {
    constructor(centerContainerCtrl) {
      super();
      this.centerContainerCtrl = centerContainerCtrl;
    }
    postConstruct() {
      this.ctrlsService.whenReady((p2) => {
        this.gridBodyCtrl = p2.gridBodyCtrl;
        this.listenForResize();
      });
      this.addManagedListener(this.eventService, Events.EVENT_SCROLLBAR_WIDTH_CHANGED, this.onScrollbarWidthChanged.bind(this));
      this.addManagedPropertyListeners(["alwaysShowHorizontalScroll", "alwaysShowVerticalScroll"], () => {
        this.checkViewportAndScrolls();
      });
    }
    listenForResize() {
      const listener = () => this.onCenterViewportResized();
      this.centerContainerCtrl.registerViewportResizeListener(listener);
      this.gridBodyCtrl.registerBodyViewportResizeListener(listener);
    }
    onScrollbarWidthChanged() {
      this.checkViewportAndScrolls();
    }
    onCenterViewportResized() {
      if (this.centerContainerCtrl.isViewportInTheDOMTree()) {
        this.keepPinnedColumnsNarrowerThanViewport();
        this.checkViewportAndScrolls();
        const newWidth = this.centerContainerCtrl.getCenterWidth();
        if (newWidth !== this.centerWidth) {
          this.centerWidth = newWidth;
          this.columnModel.refreshFlexedColumns(
            { viewportWidth: this.centerWidth, updateBodyWidths: true, fireResizedEvent: true }
          );
        }
      } else {
        this.bodyHeight = 0;
      }
    }
    keepPinnedColumnsNarrowerThanViewport() {
      const eBodyViewport = this.gridBodyCtrl.getBodyViewportElement();
      const bodyWidth = getInnerWidth(eBodyViewport);
      if (bodyWidth <= 50) {
        return;
      }
      let columnsToRemove = this.getPinnedColumnsOverflowingViewport(bodyWidth - 50);
      const processUnpinnedColumns = this.gos.getCallback("processUnpinnedColumns");
      if (!columnsToRemove.length) {
        return;
      }
      if (processUnpinnedColumns) {
        const params = {
          columns: columnsToRemove,
          viewportWidth: bodyWidth
        };
        columnsToRemove = processUnpinnedColumns(params);
      }
      this.columnModel.setColumnsPinned(columnsToRemove, null, "viewportSizeFeature");
    }
    getPinnedColumnsOverflowingViewport(viewportWidth) {
      const pinnedRightWidth = this.pinnedWidthService.getPinnedRightWidth();
      const pinnedLeftWidth = this.pinnedWidthService.getPinnedLeftWidth();
      const totalPinnedWidth = pinnedRightWidth + pinnedLeftWidth;
      if (totalPinnedWidth < viewportWidth) {
        return [];
      }
      const pinnedLeftColumns = [...this.columnModel.getDisplayedLeftColumns()];
      const pinnedRightColumns = [...this.columnModel.getDisplayedRightColumns()];
      let indexRight = 0;
      let indexLeft = 0;
      let totalWidthRemoved = 0;
      const columnsToRemove = [];
      let spaceNecessary = totalPinnedWidth - totalWidthRemoved - viewportWidth;
      while ((indexLeft < pinnedLeftColumns.length || indexRight < pinnedRightColumns.length) && spaceNecessary > 0) {
        if (indexRight < pinnedRightColumns.length) {
          const currentColumn = pinnedRightColumns[indexRight++];
          spaceNecessary -= currentColumn.getActualWidth();
          columnsToRemove.push(currentColumn);
        }
        if (indexLeft < pinnedLeftColumns.length && spaceNecessary > 0) {
          const currentColumn = pinnedLeftColumns[indexLeft++];
          spaceNecessary -= currentColumn.getActualWidth();
          columnsToRemove.push(currentColumn);
        }
      }
      return columnsToRemove;
    }
    // gets called every time the viewport size changes. we use this to check visibility of scrollbars
    // in the grid panel, and also to check size and position of viewport for row and column virtualisation.
    checkViewportAndScrolls() {
      this.updateScrollVisibleService();
      this.checkBodyHeight();
      this.onHorizontalViewportChanged();
      this.gridBodyCtrl.getScrollFeature().checkScrollLeft();
    }
    getBodyHeight() {
      return this.bodyHeight;
    }
    checkBodyHeight() {
      const eBodyViewport = this.gridBodyCtrl.getBodyViewportElement();
      const bodyHeight = getInnerHeight(eBodyViewport);
      if (this.bodyHeight !== bodyHeight) {
        this.bodyHeight = bodyHeight;
        const event = {
          type: Events.EVENT_BODY_HEIGHT_CHANGED
        };
        this.eventService.dispatchEvent(event);
      }
    }
    updateScrollVisibleService() {
      this.updateScrollVisibleServiceImpl();
      setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
    }
    updateScrollVisibleServiceImpl() {
      const params = {
        horizontalScrollShowing: this.isHorizontalScrollShowing(),
        verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing()
      };
      this.scrollVisibleService.setScrollsVisible(params);
    }
    isHorizontalScrollShowing() {
      return this.centerContainerCtrl.isHorizontalScrollShowing();
    }
    // this gets called whenever a change in the viewport, so we can inform column controller it has to work
    // out the virtual columns again. gets called from following locations:
    // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
    onHorizontalViewportChanged() {
      const scrollWidth = this.centerContainerCtrl.getCenterWidth();
      const scrollPosition = this.centerContainerCtrl.getViewportScrollLeft();
      this.columnModel.setViewportPosition(scrollWidth, scrollPosition);
    }
  };
  __decorateClass([
    Autowired("ctrlsService")
  ], ViewportSizeFeature.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("pinnedWidthService")
  ], ViewportSizeFeature.prototype, "pinnedWidthService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], ViewportSizeFeature.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("scrollVisibleService")
  ], ViewportSizeFeature.prototype, "scrollVisibleService", 2);
  __decorateClass([
    PostConstruct
  ], ViewportSizeFeature.prototype, "postConstruct", 1);
  var SetPinnedLeftWidthFeature = class extends BeanStub {
    constructor(element) {
      super();
      this.element = element;
    }
    postConstruct() {
      this.addManagedListener(this.eventService, Events.EVENT_LEFT_PINNED_WIDTH_CHANGED, this.onPinnedLeftWidthChanged.bind(this));
    }
    onPinnedLeftWidthChanged() {
      const leftWidth = this.pinnedWidthService.getPinnedLeftWidth();
      const displayed = leftWidth > 0;
      setDisplayed(this.element, displayed);
      setFixedWidth(this.element, leftWidth);
    }
    getWidth() {
      return this.pinnedWidthService.getPinnedLeftWidth();
    }
  };
  __decorateClass([
    Autowired("pinnedWidthService")
  ], SetPinnedLeftWidthFeature.prototype, "pinnedWidthService", 2);
  __decorateClass([
    PostConstruct
  ], SetPinnedLeftWidthFeature.prototype, "postConstruct", 1);
  var SetPinnedRightWidthFeature = class extends BeanStub {
    constructor(element) {
      super();
      this.element = element;
    }
    postConstruct() {
      this.addManagedListener(this.eventService, Events.EVENT_RIGHT_PINNED_WIDTH_CHANGED, this.onPinnedRightWidthChanged.bind(this));
    }
    onPinnedRightWidthChanged() {
      const rightWidth = this.pinnedWidthService.getPinnedRightWidth();
      const displayed = rightWidth > 0;
      setDisplayed(this.element, displayed);
      setFixedWidth(this.element, rightWidth);
    }
    getWidth() {
      return this.pinnedWidthService.getPinnedRightWidth();
    }
  };
  __decorateClass([
    Autowired("pinnedWidthService")
  ], SetPinnedRightWidthFeature.prototype, "pinnedWidthService", 2);
  __decorateClass([
    PostConstruct
  ], SetPinnedRightWidthFeature.prototype, "postConstruct", 1);
  var SetHeightFeature = class extends BeanStub {
    constructor(eContainer, eViewport) {
      super();
      this.eContainer = eContainer;
      this.eViewport = eViewport;
    }
    postConstruct() {
      this.addManagedListener(this.eventService, Events.EVENT_ROW_CONTAINER_HEIGHT_CHANGED, this.onHeightChanged.bind(this));
    }
    onHeightChanged() {
      const height = this.maxDivHeightScaler.getUiContainerHeight();
      const heightString = height != null ? `${height}px` : ``;
      this.eContainer.style.height = heightString;
      if (this.eViewport) {
        this.eViewport.style.height = heightString;
      }
    }
  };
  __decorateClass([
    Autowired("rowContainerHeightService")
  ], SetHeightFeature.prototype, "maxDivHeightScaler", 2);
  __decorateClass([
    PostConstruct
  ], SetHeightFeature.prototype, "postConstruct", 1);
  var DragListenerFeature = class extends BeanStub {
    constructor(eContainer) {
      super();
      this.eContainer = eContainer;
    }
    postConstruct() {
      if (!this.rangeService) {
        return;
      }
      this.params = {
        eElement: this.eContainer,
        onDragStart: this.rangeService.onDragStart.bind(this.rangeService),
        onDragStop: this.rangeService.onDragStop.bind(this.rangeService),
        onDragging: this.rangeService.onDragging.bind(this.rangeService)
      };
      this.addManagedPropertyListener("enableRangeSelection", (props) => {
        const isEnabled = props.currentValue;
        if (isEnabled) {
          this.enableFeature();
          return;
        }
        this.disableFeature();
      });
      this.addDestroyFunc(() => this.disableFeature());
      const isRangeSelection = this.gos.get("enableRangeSelection");
      if (isRangeSelection) {
        this.enableFeature();
      }
    }
    enableFeature() {
      this.dragService.addDragSource(this.params);
    }
    disableFeature() {
      this.dragService.removeDragSource(this.params);
    }
  };
  __decorateClass([
    Autowired("dragService")
  ], DragListenerFeature.prototype, "dragService", 2);
  __decorateClass([
    Optional("rangeService")
  ], DragListenerFeature.prototype, "rangeService", 2);
  __decorateClass([
    PostConstruct
  ], DragListenerFeature.prototype, "postConstruct", 1);
  var CenterWidthFeature = class extends BeanStub {
    constructor(callback, addSpacer = false) {
      super();
      this.callback = callback;
      this.addSpacer = addSpacer;
    }
    postConstruct() {
      const listener = this.setWidth.bind(this);
      this.addManagedPropertyListener("domLayout", listener);
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_CONTAINER_WIDTH_CHANGED, listener);
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, listener);
      this.addManagedListener(this.eventService, Events.EVENT_LEFT_PINNED_WIDTH_CHANGED, listener);
      if (this.addSpacer) {
        this.addManagedListener(this.eventService, Events.EVENT_RIGHT_PINNED_WIDTH_CHANGED, listener);
        this.addManagedListener(this.eventService, Events.EVENT_SCROLL_VISIBILITY_CHANGED, listener);
        this.addManagedListener(this.eventService, Events.EVENT_SCROLLBAR_WIDTH_CHANGED, listener);
      }
      this.setWidth();
    }
    setWidth() {
      const { columnModel } = this;
      const printLayout = this.gos.isDomLayout("print");
      const centerWidth = columnModel.getBodyContainerWidth();
      const leftWidth = columnModel.getDisplayedColumnsLeftWidth();
      const rightWidth = columnModel.getDisplayedColumnsRightWidth();
      let totalWidth;
      if (printLayout) {
        totalWidth = centerWidth + leftWidth + rightWidth;
      } else {
        totalWidth = centerWidth;
        if (this.addSpacer) {
          const relevantWidth = this.gos.get("enableRtl") ? leftWidth : rightWidth;
          if (relevantWidth === 0 && this.scrollVisibleService.isVerticalScrollShowing()) {
            totalWidth += this.gos.getScrollbarWidth();
          }
        }
      }
      this.callback(totalWidth);
    }
  };
  __decorateClass([
    Autowired("columnModel")
  ], CenterWidthFeature.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("scrollVisibleService")
  ], CenterWidthFeature.prototype, "scrollVisibleService", 2);
  __decorateClass([
    PostConstruct
  ], CenterWidthFeature.prototype, "postConstruct", 1);
  var RowContainerName = /* @__PURE__ */ ((RowContainerName2) => {
    RowContainerName2["LEFT"] = "left";
    RowContainerName2["RIGHT"] = "right";
    RowContainerName2["CENTER"] = "center";
    RowContainerName2["FULL_WIDTH"] = "fullWidth";
    RowContainerName2["TOP_LEFT"] = "topLeft";
    RowContainerName2["TOP_RIGHT"] = "topRight";
    RowContainerName2["TOP_CENTER"] = "topCenter";
    RowContainerName2["TOP_FULL_WIDTH"] = "topFullWidth";
    RowContainerName2["STICKY_TOP_LEFT"] = "stickyTopLeft";
    RowContainerName2["STICKY_TOP_RIGHT"] = "stickyTopRight";
    RowContainerName2["STICKY_TOP_CENTER"] = "stickyTopCenter";
    RowContainerName2["STICKY_TOP_FULL_WIDTH"] = "stickyTopFullWidth";
    RowContainerName2["STICKY_BOTTOM_LEFT"] = "stickyBottomLeft";
    RowContainerName2["STICKY_BOTTOM_RIGHT"] = "stickyBottomRight";
    RowContainerName2["STICKY_BOTTOM_CENTER"] = "stickyBottomCenter";
    RowContainerName2["STICKY_BOTTOM_FULL_WIDTH"] = "stickyBottomFullWidth";
    RowContainerName2["BOTTOM_LEFT"] = "bottomLeft";
    RowContainerName2["BOTTOM_RIGHT"] = "bottomRight";
    RowContainerName2["BOTTOM_CENTER"] = "bottomCenter";
    RowContainerName2["BOTTOM_FULL_WIDTH"] = "bottomFullWidth";
    return RowContainerName2;
  })(RowContainerName || {});
  var RowContainerType = /* @__PURE__ */ ((RowContainerType3) => {
    RowContainerType3["LEFT"] = "left";
    RowContainerType3["RIGHT"] = "right";
    RowContainerType3["CENTER"] = "center";
    RowContainerType3["FULL_WIDTH"] = "fullWidth";
    return RowContainerType3;
  })(RowContainerType || {});
  function getRowContainerTypeForName(name) {
    switch (name) {
      case "center":
      case "topCenter":
      case "stickyTopCenter":
      case "bottomCenter":
      case "stickyBottomCenter":
        return "center";
      case "left":
      case "topLeft":
      case "stickyTopLeft":
      case "bottomLeft":
      case "stickyBottomLeft":
        return "left";
      case "right":
      case "topRight":
      case "stickyTopRight":
      case "bottomRight":
      case "stickyBottomRight":
        return "right";
      case "fullWidth":
      case "topFullWidth":
      case "stickyTopFullWidth":
      case "bottomFullWidth":
      case "stickyBottomFullWidth":
        return "fullWidth";
      default:
        throw Error("Invalid Row Container Type");
    }
  }
  var ContainerCssClasses = convertToMap([
    ["center", "ag-center-cols-container"],
    ["left", "ag-pinned-left-cols-container"],
    ["right", "ag-pinned-right-cols-container"],
    ["fullWidth", "ag-full-width-container"],
    ["topCenter", "ag-floating-top-container"],
    ["topLeft", "ag-pinned-left-floating-top"],
    ["topRight", "ag-pinned-right-floating-top"],
    ["topFullWidth", "ag-floating-top-full-width-container"],
    ["stickyTopCenter", "ag-sticky-top-container"],
    ["stickyTopLeft", "ag-pinned-left-sticky-top"],
    ["stickyTopRight", "ag-pinned-right-sticky-top"],
    ["stickyTopFullWidth", "ag-sticky-top-full-width-container"],
    ["stickyBottomCenter", "ag-sticky-bottom-container"],
    ["stickyBottomLeft", "ag-pinned-left-sticky-bottom"],
    ["stickyBottomRight", "ag-pinned-right-sticky-bottom"],
    ["stickyBottomFullWidth", "ag-sticky-bottom-full-width-container"],
    ["bottomCenter", "ag-floating-bottom-container"],
    ["bottomLeft", "ag-pinned-left-floating-bottom"],
    ["bottomRight", "ag-pinned-right-floating-bottom"],
    ["bottomFullWidth", "ag-floating-bottom-full-width-container"]
  ]);
  var ViewportCssClasses = convertToMap([
    ["center", "ag-center-cols-viewport"],
    ["topCenter", "ag-floating-top-viewport"],
    ["stickyTopCenter", "ag-sticky-top-viewport"],
    ["bottomCenter", "ag-floating-bottom-viewport"],
    ["stickyBottomCenter", "ag-sticky-bottom-viewport"]
  ]);
  var _RowContainerCtrl = class _RowContainerCtrl2 extends BeanStub {
    constructor(name) {
      super();
      this.visible = true;
      this.EMPTY_CTRLS = [];
      this.name = name;
      this.isFullWithContainer = this.name === "topFullWidth" || this.name === "stickyTopFullWidth" || this.name === "stickyBottomFullWidth" || this.name === "bottomFullWidth" || this.name === "fullWidth";
    }
    static getRowContainerCssClasses(name) {
      const containerClass = ContainerCssClasses.get(name);
      const viewportClass = ViewportCssClasses.get(name);
      return { container: containerClass, viewport: viewportClass };
    }
    static getPinned(name) {
      switch (name) {
        case "bottomLeft":
        case "topLeft":
        case "stickyTopLeft":
        case "stickyBottomLeft":
        case "left":
          return "left";
        case "bottomRight":
        case "topRight":
        case "stickyTopRight":
        case "stickyBottomRight":
        case "right":
          return "right";
        default:
          return null;
      }
    }
    postConstruct() {
      this.enableRtl = this.gos.get("enableRtl");
      this.forContainers(
        [
          "center"
          /* CENTER */
        ],
        () => this.viewportSizeFeature = this.createManagedBean(new ViewportSizeFeature(this))
      );
    }
    registerWithCtrlsService() {
      switch (this.name) {
        case "fullWidth":
        case "topFullWidth":
        case "stickyTopFullWidth":
        case "bottomFullWidth":
        case "stickyBottomFullWidth":
          return;
        default: {
          this.ctrlsService.register(this.name, this);
        }
      }
    }
    forContainers(names, callback) {
      if (names.indexOf(this.name) >= 0) {
        callback();
      }
    }
    getContainerElement() {
      return this.eContainer;
    }
    getViewportSizeFeature() {
      return this.viewportSizeFeature;
    }
    setComp(view, eContainer, eViewport) {
      this.comp = view;
      this.eContainer = eContainer;
      this.eViewport = eViewport;
      this.createManagedBean(new RowContainerEventsFeature(this.eContainer));
      this.addPreventScrollWhileDragging();
      this.listenOnDomOrder();
      this.stopHScrollOnPinnedRows();
      const allTopNoFW = [
        "topCenter",
        "topLeft",
        "topRight"
        /* TOP_RIGHT */
      ];
      const allStickyTopNoFW = [
        "stickyTopCenter",
        "stickyTopLeft",
        "stickyTopRight"
        /* STICKY_TOP_RIGHT */
      ];
      const allStickyBottomNoFW = [
        "stickyBottomCenter",
        "stickyBottomLeft",
        "stickyBottomRight"
        /* STICKY_BOTTOM_RIGHT */
      ];
      const allBottomNoFW = [
        "bottomCenter",
        "bottomLeft",
        "bottomRight"
        /* BOTTOM_RIGHT */
      ];
      const allMiddleNoFW = [
        "center",
        "left",
        "right"
        /* RIGHT */
      ];
      const allNoFW = [...allTopNoFW, ...allBottomNoFW, ...allMiddleNoFW, ...allStickyTopNoFW, ...allStickyBottomNoFW];
      const allMiddle = [
        "center",
        "left",
        "right",
        "fullWidth"
        /* FULL_WIDTH */
      ];
      const allCenter = [
        "center",
        "topCenter",
        "stickyTopCenter",
        "bottomCenter",
        "stickyBottomCenter"
        /* STICKY_BOTTOM_CENTER */
      ];
      const allLeft = [
        "left",
        "bottomLeft",
        "topLeft",
        "stickyTopLeft",
        "stickyBottomLeft"
        /* STICKY_BOTTOM_LEFT */
      ];
      const allRight = [
        "right",
        "bottomRight",
        "topRight",
        "stickyTopRight",
        "stickyBottomRight"
        /* STICKY_BOTTOM_RIGHT */
      ];
      this.forContainers(allLeft, () => {
        this.pinnedWidthFeature = this.createManagedBean(new SetPinnedLeftWidthFeature(this.eContainer));
        this.addManagedListener(this.eventService, Events.EVENT_LEFT_PINNED_WIDTH_CHANGED, () => this.onPinnedWidthChanged());
      });
      this.forContainers(allRight, () => {
        this.pinnedWidthFeature = this.createManagedBean(new SetPinnedRightWidthFeature(this.eContainer));
        this.addManagedListener(this.eventService, Events.EVENT_RIGHT_PINNED_WIDTH_CHANGED, () => this.onPinnedWidthChanged());
      });
      this.forContainers(allMiddle, () => this.createManagedBean(new SetHeightFeature(this.eContainer, this.name === "center" ? eViewport : void 0)));
      this.forContainers(allNoFW, () => this.createManagedBean(new DragListenerFeature(this.eContainer)));
      this.forContainers(allCenter, () => this.createManagedBean(
        new CenterWidthFeature((width) => this.comp.setContainerWidth(`${width}px`))
      ));
      this.addListeners();
      this.registerWithCtrlsService();
    }
    addListeners() {
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, () => this.onDisplayedColumnsChanged());
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, () => this.onDisplayedColumnsWidthChanged());
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_ROWS_CHANGED, (params) => this.onDisplayedRowsChanged(params.afterScroll));
      this.onDisplayedColumnsChanged();
      this.onDisplayedColumnsWidthChanged();
      this.onDisplayedRowsChanged();
    }
    listenOnDomOrder() {
      const allStickyContainers = [
        "stickyTopCenter",
        "stickyTopLeft",
        "stickyTopRight",
        "stickyTopFullWidth",
        "stickyBottomCenter",
        "stickyBottomLeft",
        "stickyBottomRight",
        "stickyBottomFullWidth"
        /* STICKY_BOTTOM_FULL_WIDTH */
      ];
      const isStickContainer = allStickyContainers.indexOf(this.name) >= 0;
      if (isStickContainer) {
        this.comp.setDomOrder(true);
        return;
      }
      const listener = () => {
        const isEnsureDomOrder = this.gos.get("ensureDomOrder");
        const isPrintLayout = this.gos.isDomLayout("print");
        this.comp.setDomOrder(isEnsureDomOrder || isPrintLayout);
      };
      this.addManagedPropertyListener("domLayout", listener);
      listener();
    }
    // when editing a pinned row, if the cell is half outside the scrollable area, the browser can
    // scroll the column into view. we do not want this, the pinned sections should never scroll.
    // so we listen to scrolls on these containers and reset the scroll if we find one.
    stopHScrollOnPinnedRows() {
      this.forContainers([
        "topCenter",
        "stickyTopCenter",
        "bottomCenter",
        "stickyBottomCenter"
        /* STICKY_BOTTOM_CENTER */
      ], () => {
        const resetScrollLeft = () => this.eViewport.scrollLeft = 0;
        this.addManagedListener(this.eViewport, "scroll", resetScrollLeft);
      });
    }
    onDisplayedColumnsChanged() {
      this.forContainers([
        "center"
        /* CENTER */
      ], () => this.onHorizontalViewportChanged());
    }
    onDisplayedColumnsWidthChanged() {
      this.forContainers([
        "center"
        /* CENTER */
      ], () => this.onHorizontalViewportChanged());
    }
    // this methods prevents the grid views from being scrolled while the dragService is being used
    // eg. the view should not scroll up and down while dragging rows using the rowDragComp.
    addPreventScrollWhileDragging() {
      const preventScroll = (e) => {
        if (this.dragService.isDragging()) {
          if (e.cancelable) {
            e.preventDefault();
          }
        }
      };
      this.eContainer.addEventListener("touchmove", preventScroll, { passive: false });
      this.addDestroyFunc(() => this.eContainer.removeEventListener("touchmove", preventScroll));
    }
    // this gets called whenever a change in the viewport, so we can inform column controller it has to work
    // out the virtual columns again. gets called from following locations:
    // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
    onHorizontalViewportChanged(afterScroll = false) {
      const scrollWidth = this.getCenterWidth();
      const scrollPosition = this.getCenterViewportScrollLeft();
      this.columnModel.setViewportPosition(scrollWidth, scrollPosition, afterScroll);
    }
    getCenterWidth() {
      return getInnerWidth(this.eViewport);
    }
    getCenterViewportScrollLeft() {
      return getScrollLeft(this.eViewport, this.enableRtl);
    }
    registerViewportResizeListener(listener) {
      const unsubscribeFromResize = this.resizeObserverService.observeResize(this.eViewport, listener);
      this.addDestroyFunc(() => unsubscribeFromResize());
    }
    isViewportInTheDOMTree() {
      return isInDOM(this.eViewport);
    }
    getViewportScrollLeft() {
      return getScrollLeft(this.eViewport, this.enableRtl);
    }
    isHorizontalScrollShowing() {
      const isAlwaysShowHorizontalScroll = this.gos.get("alwaysShowHorizontalScroll");
      return isAlwaysShowHorizontalScroll || isHorizontalScrollShowing(this.eViewport);
    }
    getViewportElement() {
      return this.eViewport;
    }
    setContainerTranslateX(amount) {
      this.eContainer.style.transform = `translateX(${amount}px)`;
    }
    getHScrollPosition() {
      const res = {
        left: this.eViewport.scrollLeft,
        right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
      };
      return res;
    }
    setCenterViewportScrollLeft(value) {
      setScrollLeft(this.eViewport, value, this.enableRtl);
    }
    isContainerVisible() {
      const pinned = _RowContainerCtrl2.getPinned(this.name);
      return !pinned || !!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0;
    }
    onPinnedWidthChanged() {
      const visible = this.isContainerVisible();
      if (this.visible != visible) {
        this.visible = visible;
        this.onDisplayedRowsChanged();
      }
    }
    onDisplayedRowsChanged(afterScroll = false) {
      const rows = this.getRowCtrls();
      if (!this.visible || rows.length === 0) {
        this.comp.setRowCtrls({ rowCtrls: this.EMPTY_CTRLS });
        return;
      }
      const printLayout = this.gos.isDomLayout("print");
      const embedFullWidthRows = this.gos.get("embedFullWidthRows");
      const embedFW = embedFullWidthRows || printLayout;
      const rowsThisContainer = rows.filter((rowCtrl) => {
        const fullWidthRow = rowCtrl.isFullWidth();
        const match = this.isFullWithContainer ? !embedFW && fullWidthRow : embedFW || !fullWidthRow;
        return match;
      });
      this.comp.setRowCtrls({ rowCtrls: rowsThisContainer, useFlushSync: afterScroll });
    }
    getRowCtrls() {
      switch (this.name) {
        case "topCenter":
        case "topLeft":
        case "topRight":
        case "topFullWidth":
          return this.rowRenderer.getTopRowCtrls();
        case "stickyTopCenter":
        case "stickyTopLeft":
        case "stickyTopRight":
        case "stickyTopFullWidth":
          return this.rowRenderer.getStickyTopRowCtrls();
        case "stickyBottomCenter":
        case "stickyBottomLeft":
        case "stickyBottomRight":
        case "stickyBottomFullWidth":
          return this.rowRenderer.getStickyBottomRowCtrls();
        case "bottomCenter":
        case "bottomLeft":
        case "bottomRight":
        case "bottomFullWidth":
          return this.rowRenderer.getBottomRowCtrls();
        default:
          return this.rowRenderer.getCentreRowCtrls();
      }
    }
  };
  __decorateClass([
    Autowired("dragService")
  ], _RowContainerCtrl.prototype, "dragService", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], _RowContainerCtrl.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], _RowContainerCtrl.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("resizeObserverService")
  ], _RowContainerCtrl.prototype, "resizeObserverService", 2);
  __decorateClass([
    Autowired("rowRenderer")
  ], _RowContainerCtrl.prototype, "rowRenderer", 2);
  __decorateClass([
    PostConstruct
  ], _RowContainerCtrl.prototype, "postConstruct", 1);
  var RowContainerCtrl = _RowContainerCtrl;
  var GRID_BODY_TEMPLATE = (
    /* html */
    `<div class="ag-root ag-unselectable" role="treegrid">
        <ag-header-root ref="gridHeader"></ag-header-root>
        <div class="ag-floating-top" ref="eTop" role="presentation">
            <ag-row-container ref="topLeftContainer" name="${"topLeft"}"></ag-row-container>
            <ag-row-container ref="topCenterContainer" name="${"topCenter"}"></ag-row-container>
            <ag-row-container ref="topRightContainer" name="${"topRight"}"></ag-row-container>
            <ag-row-container ref="topFullWidthContainer" name="${"topFullWidth"}"></ag-row-container>
        </div>
        <div class="ag-body" ref="eBody" role="presentation">
            <div class="ag-body-viewport" ref="eBodyViewport" role="presentation">
                <ag-row-container ref="leftContainer" name="${"left"}"></ag-row-container>
                <ag-row-container ref="centerContainer" name="${"center"}"></ag-row-container>
                <ag-row-container ref="rightContainer" name="${"right"}"></ag-row-container>
                <ag-row-container ref="fullWidthContainer" name="${"fullWidth"}"></ag-row-container>
            </div>
            <ag-fake-vertical-scroll></ag-fake-vertical-scroll>
        </div>
        <div class="ag-sticky-top" ref="eStickyTop" role="presentation">
            <ag-row-container ref="stickyTopLeftContainer" name="${"stickyTopLeft"}"></ag-row-container>
            <ag-row-container ref="stickyTopCenterContainer" name="${"stickyTopCenter"}"></ag-row-container>
            <ag-row-container ref="stickyTopRightContainer" name="${"stickyTopRight"}"></ag-row-container>
            <ag-row-container ref="stickyTopFullWidthContainer" name="${"stickyTopFullWidth"}"></ag-row-container>
        </div>
        <div class="ag-sticky-bottom" ref="eStickyBottom" role="presentation">
            <ag-row-container ref="stickyBottomLeftContainer" name="${"stickyBottomLeft"}"></ag-row-container>
            <ag-row-container ref="stickyBottomCenterContainer" name="${"stickyBottomCenter"}"></ag-row-container>
            <ag-row-container ref="stickyBottomRightContainer" name="${"stickyBottomRight"}"></ag-row-container>
            <ag-row-container ref="stickyBottomFullWidthContainer" name="${"stickyBottomFullWidth"}"></ag-row-container>
        </div>
        <div class="ag-floating-bottom" ref="eBottom" role="presentation">
            <ag-row-container ref="bottomLeftContainer" name="${"bottomLeft"}"></ag-row-container>
            <ag-row-container ref="bottomCenterContainer" name="${"bottomCenter"}"></ag-row-container>
            <ag-row-container ref="bottomRightContainer" name="${"bottomRight"}"></ag-row-container>
            <ag-row-container ref="bottomFullWidthContainer" name="${"bottomFullWidth"}"></ag-row-container>
        </div>
        <ag-fake-horizontal-scroll></ag-fake-horizontal-scroll>
        <ag-overlay-wrapper></ag-overlay-wrapper>
    </div>`
  );
  var GridBodyComp = class extends Component {
    constructor() {
      super(GRID_BODY_TEMPLATE);
    }
    init() {
      const setHeight = (height, element) => {
        const heightString = `${height}px`;
        element.style.minHeight = heightString;
        element.style.height = heightString;
      };
      const compProxy = {
        setRowAnimationCssOnBodyViewport: (cssClass, animate) => this.setRowAnimationCssOnBodyViewport(cssClass, animate),
        setColumnCount: (count) => setAriaColCount(this.getGui(), count),
        setRowCount: (count) => setAriaRowCount(this.getGui(), count),
        setTopHeight: (height) => setHeight(height, this.eTop),
        setBottomHeight: (height) => setHeight(height, this.eBottom),
        setTopDisplay: (display) => this.eTop.style.display = display,
        setBottomDisplay: (display) => this.eBottom.style.display = display,
        setStickyTopHeight: (height) => this.eStickyTop.style.height = height,
        setStickyTopTop: (top) => this.eStickyTop.style.top = top,
        setStickyTopWidth: (width) => this.eStickyTop.style.width = width,
        setStickyBottomHeight: (height) => this.eStickyBottom.style.height = height,
        setStickyBottomBottom: (bottom) => this.eStickyBottom.style.bottom = bottom,
        setStickyBottomWidth: (width) => this.eStickyBottom.style.width = width,
        setColumnMovingCss: (cssClass, flag) => this.addOrRemoveCssClass(cssClass, flag),
        updateLayoutClasses: (cssClass, params) => {
          const classLists = [
            this.eBodyViewport.classList,
            this.eBody.classList
          ];
          classLists.forEach((classList) => {
            classList.toggle("ag-layout-auto-height", params.autoHeight);
            classList.toggle("ag-layout-normal", params.normal);
            classList.toggle("ag-layout-print", params.print);
          });
          this.addOrRemoveCssClass("ag-layout-auto-height", params.autoHeight);
          this.addOrRemoveCssClass("ag-layout-normal", params.normal);
          this.addOrRemoveCssClass("ag-layout-print", params.print);
        },
        setAlwaysVerticalScrollClass: (cssClass, on) => this.eBodyViewport.classList.toggle(CSS_CLASS_FORCE_VERTICAL_SCROLL, on),
        registerBodyViewportResizeListener: (listener) => {
          const unsubscribeFromResize = this.resizeObserverService.observeResize(this.eBodyViewport, listener);
          this.addDestroyFunc(() => unsubscribeFromResize());
        },
        setPinnedTopBottomOverflowY: (overflow) => this.eTop.style.overflowY = this.eBottom.style.overflowY = overflow,
        setCellSelectableCss: (cssClass, selectable) => {
          [this.eTop, this.eBodyViewport, this.eBottom].forEach((ct) => ct.classList.toggle(cssClass, selectable));
        },
        setBodyViewportWidth: (width) => this.eBodyViewport.style.width = width
      };
      this.ctrl = this.createManagedBean(new GridBodyCtrl());
      this.ctrl.setComp(
        compProxy,
        this.getGui(),
        this.eBodyViewport,
        this.eTop,
        this.eBottom,
        this.eStickyTop,
        this.eStickyBottom
      );
      if (this.rangeService && this.gos.get("enableRangeSelection") || this.gos.get("rowSelection") === "multiple") {
        setAriaMultiSelectable(this.getGui(), true);
      }
    }
    setRowAnimationCssOnBodyViewport(cssClass, animateRows) {
      const bodyViewportClassList = this.eBodyViewport.classList;
      bodyViewportClassList.toggle("ag-row-animation", animateRows);
      bodyViewportClassList.toggle("ag-row-no-animation", !animateRows);
    }
    getFloatingTopBottom() {
      return [this.eTop, this.eBottom];
    }
  };
  __decorateClass([
    Autowired("resizeObserverService")
  ], GridBodyComp.prototype, "resizeObserverService", 2);
  __decorateClass([
    Optional("rangeService")
  ], GridBodyComp.prototype, "rangeService", 2);
  __decorateClass([
    RefSelector("eBodyViewport")
  ], GridBodyComp.prototype, "eBodyViewport", 2);
  __decorateClass([
    RefSelector("eStickyTop")
  ], GridBodyComp.prototype, "eStickyTop", 2);
  __decorateClass([
    RefSelector("eStickyBottom")
  ], GridBodyComp.prototype, "eStickyBottom", 2);
  __decorateClass([
    RefSelector("eTop")
  ], GridBodyComp.prototype, "eTop", 2);
  __decorateClass([
    RefSelector("eBottom")
  ], GridBodyComp.prototype, "eBottom", 2);
  __decorateClass([
    RefSelector("gridHeader")
  ], GridBodyComp.prototype, "headerRootComp", 2);
  __decorateClass([
    RefSelector("eBody")
  ], GridBodyComp.prototype, "eBody", 2);
  __decorateClass([
    PostConstruct
  ], GridBodyComp.prototype, "init", 1);
  var ScrollVisibleService = class extends BeanStub {
    postConstruct() {
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this));
    }
    onDisplayedColumnsChanged() {
      this.update();
    }
    onDisplayedColumnsWidthChanged() {
      this.update();
    }
    update() {
      if (this.columnAnimationService.isActive()) {
        this.columnAnimationService.executeLaterVMTurn(() => {
          this.columnAnimationService.executeLaterVMTurn(() => this.updateImpl());
        });
      } else {
        this.updateImpl();
      }
    }
    updateImpl() {
      const centerRowCtrl = this.ctrlsService.get("center");
      if (!centerRowCtrl || this.columnAnimationService.isActive()) {
        return;
      }
      const params = {
        horizontalScrollShowing: centerRowCtrl.isHorizontalScrollShowing(),
        verticalScrollShowing: this.isVerticalScrollShowing()
      };
      this.setScrollsVisible(params);
    }
    setScrollsVisible(params) {
      const atLeastOneDifferent = this.horizontalScrollShowing !== params.horizontalScrollShowing || this.verticalScrollShowing !== params.verticalScrollShowing;
      if (atLeastOneDifferent) {
        this.horizontalScrollShowing = params.horizontalScrollShowing;
        this.verticalScrollShowing = params.verticalScrollShowing;
        const event = {
          type: Events.EVENT_SCROLL_VISIBILITY_CHANGED
        };
        this.eventService.dispatchEvent(event);
      }
    }
    // used by pagination service - to know page height
    isHorizontalScrollShowing() {
      return this.horizontalScrollShowing;
    }
    // used by header container
    isVerticalScrollShowing() {
      return this.verticalScrollShowing;
    }
  };
  __decorateClass([
    Autowired("ctrlsService")
  ], ScrollVisibleService.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("columnAnimationService")
  ], ScrollVisibleService.prototype, "columnAnimationService", 2);
  __decorateClass([
    PostConstruct
  ], ScrollVisibleService.prototype, "postConstruct", 1);
  ScrollVisibleService = __decorateClass([
    Bean("scrollVisibleService")
  ], ScrollVisibleService);
  var MouseEventService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.gridInstanceId = MouseEventService.gridInstanceSequence.next();
    }
    // we put the instance id onto the main DOM element. this is used for events, when grids are inside grids,
    // so the grid can work out if the even came from this grid or a grid inside this one. see the ctrl+v logic
    // for where this is used.
    stampTopLevelGridCompWithGridInstance(eGridDiv) {
      eGridDiv[MouseEventService.GRID_DOM_KEY] = this.gridInstanceId;
    }
    getRenderedCellForEvent(event) {
      return getCtrlForEventTarget(this.gos, event.target, CellCtrl.DOM_DATA_KEY_CELL_CTRL);
    }
    // walks the path of the event, and returns true if this grid is the first one that it finds. if doing
    // master / detail grids, and a child grid is found, then it returns false. this stops things like copy/paste
    // getting executed on many grids at the same time.
    isEventFromThisGrid(event) {
      const res = this.isElementInThisGrid(event.target);
      return res;
    }
    isElementInThisGrid(element) {
      let pointer = element;
      while (pointer) {
        const instanceId = pointer[MouseEventService.GRID_DOM_KEY];
        if (exists(instanceId)) {
          const eventFromThisGrid = instanceId === this.gridInstanceId;
          return eventFromThisGrid;
        }
        pointer = pointer.parentElement;
      }
      return false;
    }
    getCellPositionForEvent(event) {
      const cellComp = this.getRenderedCellForEvent(event);
      return cellComp ? cellComp.getCellPosition() : null;
    }
    getNormalisedPosition(event) {
      const gridPanelHasScrolls = this.gos.isDomLayout("normal");
      const e = event;
      let x;
      let y;
      if (e.clientX != null || e.clientY != null) {
        x = e.clientX;
        y = e.clientY;
      } else {
        x = e.x;
        y = e.y;
      }
      if (gridPanelHasScrolls) {
        const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
        const vRange = gridBodyCon.getScrollFeature().getVScrollPosition();
        const hRange = gridBodyCon.getScrollFeature().getHScrollPosition();
        x += hRange.left;
        y += vRange.top;
      }
      return { x, y };
    }
  };
  MouseEventService.gridInstanceSequence = new NumberSequence();
  MouseEventService.GRID_DOM_KEY = "__ag_grid_instance";
  __decorateClass([
    Autowired("ctrlsService")
  ], MouseEventService.prototype, "ctrlsService", 2);
  MouseEventService = __decorateClass([
    Bean("mouseEventService")
  ], MouseEventService);
  var NavigationService = class extends BeanStub {
    constructor() {
      super();
      this.onPageDown = throttle(this.onPageDown, 100);
      this.onPageUp = throttle(this.onPageUp, 100);
    }
    postConstruct() {
      this.ctrlsService.whenReady((p2) => {
        this.gridBodyCon = p2.gridBodyCtrl;
      });
    }
    handlePageScrollingKey(event, fromFullWidth = false) {
      const key = event.key;
      const alt = event.altKey;
      const ctrl = event.ctrlKey || event.metaKey;
      const rangeServiceShouldHandleShift = !!this.rangeService && event.shiftKey;
      const currentCell = this.mouseEventService.getCellPositionForEvent(event);
      let processed = false;
      switch (key) {
        case KeyCode.PAGE_HOME:
        case KeyCode.PAGE_END:
          if (!ctrl && !alt) {
            this.onHomeOrEndKey(key);
            processed = true;
          }
          break;
        case KeyCode.LEFT:
        case KeyCode.RIGHT:
        case KeyCode.UP:
        case KeyCode.DOWN:
          if (!currentCell) {
            return false;
          }
          if (ctrl && !alt && !rangeServiceShouldHandleShift) {
            this.onCtrlUpDownLeftRight(key, currentCell);
            processed = true;
          }
          break;
        case KeyCode.PAGE_DOWN:
        case KeyCode.PAGE_UP:
          if (!ctrl && !alt) {
            processed = this.handlePageUpDown(key, currentCell, fromFullWidth);
          }
          break;
      }
      if (processed) {
        event.preventDefault();
      }
      return processed;
    }
    handlePageUpDown(key, currentCell, fromFullWidth) {
      if (fromFullWidth) {
        currentCell = this.focusService.getFocusedCell();
      }
      if (!currentCell) {
        return false;
      }
      if (key === KeyCode.PAGE_UP) {
        this.onPageUp(currentCell);
      } else {
        this.onPageDown(currentCell);
      }
      return true;
    }
    navigateTo(navigateParams) {
      var _a;
      const { scrollIndex, scrollType, scrollColumn, focusIndex, focusColumn } = navigateParams;
      if (exists(scrollColumn) && !scrollColumn.isPinned()) {
        this.gridBodyCon.getScrollFeature().ensureColumnVisible(scrollColumn);
      }
      if (exists(scrollIndex)) {
        this.gridBodyCon.getScrollFeature().ensureIndexVisible(scrollIndex, scrollType);
      }
      if (!navigateParams.isAsync) {
        this.gridBodyCon.getScrollFeature().ensureIndexVisible(focusIndex);
      }
      this.focusService.setFocusedCell({ rowIndex: focusIndex, column: focusColumn, rowPinned: null, forceBrowserFocus: true });
      (_a = this.rangeService) == null ? void 0 : _a.setRangeToCell({ rowIndex: focusIndex, rowPinned: null, column: focusColumn });
    }
    // this method is throttled, see the `constructor`
    onPageDown(gridCell) {
      const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
      const scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();
      const pixelsInOnePage = this.getViewportHeight();
      const pagingPixelOffset = this.paginationProxy.getPixelOffset();
      const currentPageBottomPixel = scrollPosition.top + pixelsInOnePage;
      const currentPageBottomRow = this.paginationProxy.getRowIndexAtPixel(currentPageBottomPixel + pagingPixelOffset);
      if (this.columnModel.isAutoRowHeightActive()) {
        this.navigateToNextPageWithAutoHeight(gridCell, currentPageBottomRow);
      } else {
        this.navigateToNextPage(gridCell, currentPageBottomRow);
      }
    }
    // this method is throttled, see the `constructor`
    onPageUp(gridCell) {
      const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
      const scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();
      const pagingPixelOffset = this.paginationProxy.getPixelOffset();
      const currentPageTopPixel = scrollPosition.top;
      const currentPageTopRow = this.paginationProxy.getRowIndexAtPixel(currentPageTopPixel + pagingPixelOffset);
      if (this.columnModel.isAutoRowHeightActive()) {
        this.navigateToNextPageWithAutoHeight(gridCell, currentPageTopRow, true);
      } else {
        this.navigateToNextPage(gridCell, currentPageTopRow, true);
      }
    }
    navigateToNextPage(gridCell, scrollIndex, up = false) {
      const pixelsInOnePage = this.getViewportHeight();
      const firstRow = this.paginationProxy.getPageFirstRow();
      const lastRow = this.paginationProxy.getPageLastRow();
      const pagingPixelOffset = this.paginationProxy.getPixelOffset();
      const currentRowNode = this.paginationProxy.getRow(gridCell.rowIndex);
      const rowPixelDiff = up ? (currentRowNode == null ? void 0 : currentRowNode.rowHeight) - pixelsInOnePage - pagingPixelOffset : pixelsInOnePage - pagingPixelOffset;
      const nextCellPixel = (currentRowNode == null ? void 0 : currentRowNode.rowTop) + rowPixelDiff;
      let focusIndex = this.paginationProxy.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);
      if (focusIndex === gridCell.rowIndex) {
        const diff = up ? -1 : 1;
        scrollIndex = focusIndex = gridCell.rowIndex + diff;
      }
      let scrollType;
      if (up) {
        scrollType = "bottom";
        if (focusIndex < firstRow) {
          focusIndex = firstRow;
        }
        if (scrollIndex < firstRow) {
          scrollIndex = firstRow;
        }
      } else {
        scrollType = "top";
        if (focusIndex > lastRow) {
          focusIndex = lastRow;
        }
        if (scrollIndex > lastRow) {
          scrollIndex = lastRow;
        }
      }
      if (this.isRowTallerThanView(focusIndex)) {
        scrollIndex = focusIndex;
        scrollType = "top";
      }
      this.navigateTo({
        scrollIndex,
        scrollType,
        scrollColumn: null,
        focusIndex,
        focusColumn: gridCell.column
      });
    }
    navigateToNextPageWithAutoHeight(gridCell, scrollIndex, up = false) {
      this.navigateTo({
        scrollIndex,
        scrollType: up ? "bottom" : "top",
        scrollColumn: null,
        focusIndex: scrollIndex,
        focusColumn: gridCell.column
      });
      setTimeout(() => {
        const focusIndex = this.getNextFocusIndexForAutoHeight(gridCell, up);
        this.navigateTo({
          scrollIndex,
          scrollType: up ? "bottom" : "top",
          scrollColumn: null,
          focusIndex,
          focusColumn: gridCell.column,
          isAsync: true
        });
      }, 50);
    }
    getNextFocusIndexForAutoHeight(gridCell, up = false) {
      var _a;
      const step = up ? -1 : 1;
      const pixelsInOnePage = this.getViewportHeight();
      const lastRowIndex = this.paginationProxy.getPageLastRow();
      let pixelSum = 0;
      let currentIndex = gridCell.rowIndex;
      while (currentIndex >= 0 && currentIndex <= lastRowIndex) {
        const currentCell = this.paginationProxy.getRow(currentIndex);
        if (currentCell) {
          const currentCellHeight = (_a = currentCell.rowHeight) != null ? _a : 0;
          if (pixelSum + currentCellHeight > pixelsInOnePage) {
            break;
          }
          pixelSum += currentCellHeight;
        }
        currentIndex += step;
      }
      return Math.max(0, Math.min(currentIndex, lastRowIndex));
    }
    getViewportHeight() {
      const { gridBodyCtrl, center } = this.ctrlsService.getParams();
      const scrollPosition = gridBodyCtrl.getScrollFeature().getVScrollPosition();
      const scrollbarWidth = this.gos.getScrollbarWidth();
      let pixelsInOnePage = scrollPosition.bottom - scrollPosition.top;
      if (center.isHorizontalScrollShowing()) {
        pixelsInOnePage -= scrollbarWidth;
      }
      return pixelsInOnePage;
    }
    isRowTallerThanView(rowIndex) {
      const rowNode = this.paginationProxy.getRow(rowIndex);
      if (!rowNode) {
        return false;
      }
      const rowHeight = rowNode.rowHeight;
      if (typeof rowHeight !== "number") {
        return false;
      }
      return rowHeight > this.getViewportHeight();
    }
    onCtrlUpDownLeftRight(key, gridCell) {
      const cellToFocus = this.cellNavigationService.getNextCellToFocus(key, gridCell, true);
      const { rowIndex, column } = cellToFocus;
      this.navigateTo({
        scrollIndex: rowIndex,
        scrollType: null,
        scrollColumn: column,
        focusIndex: rowIndex,
        focusColumn: column
      });
    }
    // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring
    // same cell into view (which means either scroll all the way up, or all the way down).
    onHomeOrEndKey(key) {
      const homeKey = key === KeyCode.PAGE_HOME;
      const allColumns = this.columnModel.getAllDisplayedColumns();
      const columnToSelect = homeKey ? allColumns[0] : last(allColumns);
      const scrollIndex = homeKey ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();
      this.navigateTo({
        scrollIndex,
        scrollType: null,
        scrollColumn: columnToSelect,
        focusIndex: scrollIndex,
        focusColumn: columnToSelect
      });
    }
    // result of keyboard event
    onTabKeyDown(previous, keyboardEvent) {
      const backwards = keyboardEvent.shiftKey;
      const movedToNextCell = this.tabToNextCellCommon(previous, backwards, keyboardEvent);
      if (movedToNextCell !== false) {
        if (movedToNextCell) {
          keyboardEvent.preventDefault();
        }
        return;
      }
      if (backwards) {
        const { rowIndex, rowPinned } = previous.getRowPosition();
        const firstRow = rowPinned ? rowIndex === 0 : rowIndex === this.paginationProxy.getPageFirstRow();
        if (firstRow) {
          if (this.gos.get("headerHeight") === 0 || this.gos.get("suppressHeaderFocus")) {
            this.focusService.focusNextGridCoreContainer(true, true);
          } else {
            keyboardEvent.preventDefault();
            this.focusService.focusPreviousFromFirstCell(keyboardEvent);
          }
        }
      } else {
        if (previous instanceof CellCtrl) {
          previous.focusCell(true);
        }
        if (this.focusService.focusNextGridCoreContainer(backwards)) {
          keyboardEvent.preventDefault();
        }
      }
    }
    // comes from API
    tabToNextCell(backwards, event) {
      const focusedCell = this.focusService.getFocusedCell();
      if (!focusedCell) {
        return false;
      }
      let cellOrRow = this.getCellByPosition(focusedCell);
      if (!cellOrRow) {
        cellOrRow = this.rowRenderer.getRowByPosition(focusedCell);
        if (!cellOrRow || !cellOrRow.isFullWidth()) {
          return false;
        }
      }
      return !!this.tabToNextCellCommon(cellOrRow, backwards, event);
    }
    tabToNextCellCommon(previous, backwards, event) {
      let editing = previous.isEditing();
      if (!editing && previous instanceof CellCtrl) {
        const cell = previous;
        const row = cell.getRowCtrl();
        if (row) {
          editing = row.isEditing();
        }
      }
      let res;
      if (editing) {
        if (this.gos.get("editType") === "fullRow") {
          res = this.moveToNextEditingRow(previous, backwards, event);
        } else {
          res = this.moveToNextEditingCell(previous, backwards, event);
        }
      } else {
        res = this.moveToNextCellNotEditing(previous, backwards);
      }
      if (res === null) {
        return res;
      }
      return res || !!this.focusService.getFocusedHeader();
    }
    // returns null if no navigation should be performed
    moveToNextEditingCell(previousCell, backwards, event = null) {
      const previousPos = previousCell.getCellPosition();
      previousCell.getGui().focus();
      previousCell.stopEditing();
      const nextCell = this.findNextCellToFocusOn(previousPos, backwards, true);
      if (nextCell === false) {
        return null;
      }
      if (nextCell == null) {
        return false;
      }
      nextCell.startEditing(null, true, event);
      nextCell.focusCell(false);
      return true;
    }
    // returns null if no navigation should be performed
    moveToNextEditingRow(previousCell, backwards, event = null) {
      const previousPos = previousCell.getCellPosition();
      const nextCell = this.findNextCellToFocusOn(previousPos, backwards, true);
      if (nextCell === false) {
        return null;
      }
      if (nextCell == null) {
        return false;
      }
      const nextPos = nextCell.getCellPosition();
      const previousEditable = this.isCellEditable(previousPos);
      const nextEditable = this.isCellEditable(nextPos);
      const rowsMatch = nextPos && previousPos.rowIndex === nextPos.rowIndex && previousPos.rowPinned === nextPos.rowPinned;
      if (previousEditable) {
        previousCell.setFocusOutOnEditor();
      }
      if (!rowsMatch) {
        const pRow = previousCell.getRowCtrl();
        pRow.stopEditing();
        const nRow = nextCell.getRowCtrl();
        nRow.startRowEditing(void 0, void 0, event);
      }
      if (nextEditable) {
        nextCell.setFocusInOnEditor();
        nextCell.focusCell();
      } else {
        nextCell.focusCell(true);
      }
      return true;
    }
    // returns null if no navigation should be performed
    moveToNextCellNotEditing(previousCell, backwards) {
      const displayedColumns = this.columnModel.getAllDisplayedColumns();
      let cellPos;
      if (previousCell instanceof RowCtrl) {
        cellPos = __spreadProps(__spreadValues({}, previousCell.getRowPosition()), {
          column: backwards ? displayedColumns[0] : last(displayedColumns)
        });
      } else {
        cellPos = previousCell.getCellPosition();
      }
      const nextCell = this.findNextCellToFocusOn(cellPos, backwards, false);
      if (nextCell === false) {
        return null;
      }
      if (nextCell instanceof CellCtrl) {
        nextCell.focusCell(true);
      } else if (nextCell) {
        return this.tryToFocusFullWidthRow(nextCell.getRowPosition(), backwards);
      }
      return exists(nextCell);
    }
    /**
     * called by the cell, when tab is pressed while editing.
     * @return: RenderedCell when navigation successful, false if navigation should not be performed, otherwise null
     */
    findNextCellToFocusOn(previousPosition, backwards, startEditing) {
      var _a;
      let nextPosition = previousPosition;
      while (true) {
        if (previousPosition !== nextPosition) {
          previousPosition = nextPosition;
        }
        if (!backwards) {
          nextPosition = this.getLastCellOfColSpan(nextPosition);
        }
        nextPosition = this.cellNavigationService.getNextTabbedCell(nextPosition, backwards);
        const userFunc = this.gos.getCallback("tabToNextCell");
        if (exists(userFunc)) {
          const params = {
            backwards,
            editing: startEditing,
            previousCellPosition: previousPosition,
            nextCellPosition: nextPosition ? nextPosition : null
          };
          const userResult = userFunc(params);
          if (userResult === true || userResult === null) {
            if (userResult === null) {
              warnOnce("Returning `null` from tabToNextCell is deprecated. Return `true` to stay on the current cell, or `false` to let the browser handle the tab behaviour.");
            }
            nextPosition = previousPosition;
          } else if (userResult === false) {
            return false;
          } else {
            if (userResult.floating) {
              warnOnce(`tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?`);
              userResult.rowPinned = userResult.floating;
            }
            nextPosition = {
              rowIndex: userResult.rowIndex,
              column: userResult.column,
              rowPinned: userResult.rowPinned
            };
          }
        }
        if (!nextPosition) {
          return null;
        }
        if (nextPosition.rowIndex < 0) {
          const headerLen = this.headerNavigationService.getHeaderRowCount();
          this.focusService.focusHeaderPosition({
            headerPosition: {
              headerRowIndex: headerLen + nextPosition.rowIndex,
              column: nextPosition.column
            },
            fromCell: true
          });
          return null;
        }
        const fullRowEdit = this.gos.get("editType") === "fullRow";
        if (startEditing && !fullRowEdit) {
          const cellIsEditable = this.isCellEditable(nextPosition);
          if (!cellIsEditable) {
            continue;
          }
        }
        this.ensureCellVisible(nextPosition);
        const nextCell = this.getCellByPosition(nextPosition);
        if (!nextCell) {
          const row = this.rowRenderer.getRowByPosition(nextPosition);
          if (!row || !row.isFullWidth() || startEditing) {
            continue;
          }
          return row;
        }
        if (nextCell.isSuppressNavigable()) {
          continue;
        }
        (_a = this.rangeService) == null ? void 0 : _a.setRangeToCell(nextPosition);
        return nextCell;
      }
    }
    isCellEditable(cell) {
      const rowNode = this.lookupRowNodeForCell(cell);
      if (rowNode) {
        return cell.column.isCellEditable(rowNode);
      }
      return false;
    }
    getCellByPosition(cellPosition) {
      const rowCtrl = this.rowRenderer.getRowByPosition(cellPosition);
      if (!rowCtrl) {
        return null;
      }
      return rowCtrl.getCellCtrl(cellPosition.column);
    }
    lookupRowNodeForCell(cell) {
      if (cell.rowPinned === "top") {
        return this.pinnedRowModel.getPinnedTopRow(cell.rowIndex);
      }
      if (cell.rowPinned === "bottom") {
        return this.pinnedRowModel.getPinnedBottomRow(cell.rowIndex);
      }
      return this.paginationProxy.getRow(cell.rowIndex);
    }
    // we use index for rows, but column object for columns, as the next column (by index) might not
    // be visible (header grouping) so it's not reliable, so using the column object instead.
    navigateToNextCell(event, key, currentCell, allowUserOverride) {
      let nextCell = currentCell;
      let hitEdgeOfGrid = false;
      while (nextCell && (nextCell === currentCell || !this.isValidNavigateCell(nextCell))) {
        if (this.gos.get("enableRtl")) {
          if (key === KeyCode.LEFT) {
            nextCell = this.getLastCellOfColSpan(nextCell);
          }
        } else if (key === KeyCode.RIGHT) {
          nextCell = this.getLastCellOfColSpan(nextCell);
        }
        nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell);
        hitEdgeOfGrid = missing(nextCell);
      }
      if (hitEdgeOfGrid && event && event.key === KeyCode.UP) {
        nextCell = {
          rowIndex: -1,
          rowPinned: null,
          column: currentCell.column
        };
      }
      if (allowUserOverride) {
        const userFunc = this.gos.getCallback("navigateToNextCell");
        if (exists(userFunc)) {
          const params = {
            key,
            previousCellPosition: currentCell,
            nextCellPosition: nextCell ? nextCell : null,
            event
          };
          const userCell = userFunc(params);
          if (exists(userCell)) {
            if (userCell.floating) {
              warnOnce(`tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?`);
              userCell.rowPinned = userCell.floating;
            }
            nextCell = {
              rowPinned: userCell.rowPinned,
              rowIndex: userCell.rowIndex,
              column: userCell.column
            };
          } else {
            nextCell = null;
          }
        }
      }
      if (!nextCell) {
        return;
      }
      if (nextCell.rowIndex < 0) {
        const headerLen = this.headerNavigationService.getHeaderRowCount();
        this.focusService.focusHeaderPosition({
          headerPosition: { headerRowIndex: headerLen + nextCell.rowIndex, column: currentCell.column },
          event: event || void 0,
          fromCell: true
        });
        return;
      }
      const normalisedPosition = this.getNormalisedPosition(nextCell);
      if (normalisedPosition) {
        this.focusPosition(normalisedPosition);
      } else {
        this.tryToFocusFullWidthRow(nextCell);
      }
    }
    getNormalisedPosition(cellPosition) {
      this.ensureCellVisible(cellPosition);
      const cellCtrl = this.getCellByPosition(cellPosition);
      if (!cellCtrl) {
        return null;
      }
      cellPosition = cellCtrl.getCellPosition();
      this.ensureCellVisible(cellPosition);
      return cellPosition;
    }
    tryToFocusFullWidthRow(position, backwards = false) {
      const displayedColumns = this.columnModel.getAllDisplayedColumns();
      const rowComp = this.rowRenderer.getRowByPosition(position);
      if (!rowComp || !rowComp.isFullWidth()) {
        return false;
      }
      const currentCellFocused = this.focusService.getFocusedCell();
      const cellPosition = {
        rowIndex: position.rowIndex,
        rowPinned: position.rowPinned,
        column: position.column || (backwards ? last(displayedColumns) : displayedColumns[0])
      };
      this.focusPosition(cellPosition);
      const fromBelow = currentCellFocused != null ? this.rowPositionUtils.before(cellPosition, currentCellFocused) : false;
      const focusEvent = {
        type: Events.EVENT_FULL_WIDTH_ROW_FOCUSED,
        rowIndex: cellPosition.rowIndex,
        rowPinned: cellPosition.rowPinned,
        column: cellPosition.column,
        isFullWidthCell: true,
        floating: cellPosition.rowPinned,
        fromBelow
      };
      this.eventService.dispatchEvent(focusEvent);
      return true;
    }
    focusPosition(cellPosition) {
      var _a;
      this.focusService.setFocusedCell({
        rowIndex: cellPosition.rowIndex,
        column: cellPosition.column,
        rowPinned: cellPosition.rowPinned,
        forceBrowserFocus: true
      });
      (_a = this.rangeService) == null ? void 0 : _a.setRangeToCell(cellPosition);
    }
    isValidNavigateCell(cell) {
      const rowNode = this.rowPositionUtils.getRowNode(cell);
      return !!rowNode;
    }
    getLastCellOfColSpan(cell) {
      const cellCtrl = this.getCellByPosition(cell);
      if (!cellCtrl) {
        return cell;
      }
      const colSpanningList = cellCtrl.getColSpanningList();
      if (colSpanningList.length === 1) {
        return cell;
      }
      return {
        rowIndex: cell.rowIndex,
        column: last(colSpanningList),
        rowPinned: cell.rowPinned
      };
    }
    ensureCellVisible(gridCell) {
      const isGroupStickyEnabled = this.gos.isGroupRowsSticky();
      const rowNode = this.rowModel.getRow(gridCell.rowIndex);
      const skipScrollToRow = isGroupStickyEnabled && (rowNode == null ? void 0 : rowNode.sticky);
      if (!skipScrollToRow && missing(gridCell.rowPinned)) {
        this.gridBodyCon.getScrollFeature().ensureIndexVisible(gridCell.rowIndex);
      }
      if (!gridCell.column.isPinned()) {
        this.gridBodyCon.getScrollFeature().ensureColumnVisible(gridCell.column);
      }
    }
  };
  __decorateClass([
    Autowired("mouseEventService")
  ], NavigationService.prototype, "mouseEventService", 2);
  __decorateClass([
    Autowired("paginationProxy")
  ], NavigationService.prototype, "paginationProxy", 2);
  __decorateClass([
    Autowired("focusService")
  ], NavigationService.prototype, "focusService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], NavigationService.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("rowModel")
  ], NavigationService.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], NavigationService.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("rowRenderer")
  ], NavigationService.prototype, "rowRenderer", 2);
  __decorateClass([
    Autowired("headerNavigationService")
  ], NavigationService.prototype, "headerNavigationService", 2);
  __decorateClass([
    Autowired("rowPositionUtils")
  ], NavigationService.prototype, "rowPositionUtils", 2);
  __decorateClass([
    Autowired("cellNavigationService")
  ], NavigationService.prototype, "cellNavigationService", 2);
  __decorateClass([
    Autowired("pinnedRowModel")
  ], NavigationService.prototype, "pinnedRowModel", 2);
  __decorateClass([
    Optional("rangeService")
  ], NavigationService.prototype, "rangeService", 2);
  __decorateClass([
    PostConstruct
  ], NavigationService.prototype, "postConstruct", 1);
  NavigationService = __decorateClass([
    Bean("navigationService")
  ], NavigationService);
  var _PopupEditorWrapper = class _PopupEditorWrapper2 extends PopupComponent {
    constructor(params) {
      super(
        /* html */
        `<div class="ag-popup-editor" tabindex="-1"/>`
      );
      this.params = params;
    }
    postConstruct() {
      this.gos.setDomData(this.getGui(), _PopupEditorWrapper2.DOM_KEY_POPUP_EDITOR_WRAPPER, true);
      this.addKeyDownListener();
    }
    addKeyDownListener() {
      const eGui = this.getGui();
      const params = this.params;
      const listener = (event) => {
        if (!isUserSuppressingKeyboardEvent(this.gos, event, params.node, params.column, true)) {
          params.onKeyDown(event);
        }
      };
      this.addManagedListener(eGui, "keydown", listener);
    }
  };
  _PopupEditorWrapper.DOM_KEY_POPUP_EDITOR_WRAPPER = "popupEditorWrapper";
  __decorateClass([
    PostConstruct
  ], _PopupEditorWrapper.prototype, "postConstruct", 1);
  var PopupEditorWrapper = _PopupEditorWrapper;
  var CellComp = class extends Component {
    constructor(beans, cellCtrl, printLayout, eRow, editingRow) {
      super();
      this.rendererVersion = 0;
      this.editorVersion = 0;
      this.beans = beans;
      this.column = cellCtrl.getColumn();
      this.rowNode = cellCtrl.getRowNode();
      this.rowCtrl = cellCtrl.getRowCtrl();
      this.eRow = eRow;
      this.cellCtrl = cellCtrl;
      const cellDiv = document.createElement("div");
      cellDiv.setAttribute("comp-id", `${this.getCompId()}`);
      this.setTemplateFromElement(cellDiv);
      const eGui = this.getGui();
      this.forceWrapper = cellCtrl.isForceWrapper();
      this.refreshWrapper(false);
      const setAttribute = (name, value) => {
        if (value != null && value != "") {
          eGui.setAttribute(name, value);
        } else {
          eGui.removeAttribute(name);
        }
      };
      setAriaRole(eGui, cellCtrl.getCellAriaRole());
      setAttribute("col-id", cellCtrl.getColumnIdSanitised());
      const tabIndex = cellCtrl.getTabIndex();
      if (tabIndex !== void 0) {
        setAttribute("tabindex", tabIndex.toString());
      }
      const compProxy = {
        addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
        setUserStyles: (styles) => addStylesToElement(eGui, styles),
        getFocusableElement: () => this.getFocusableElement(),
        setIncludeSelection: (include) => this.includeSelection = include,
        setIncludeRowDrag: (include) => this.includeRowDrag = include,
        setIncludeDndSource: (include) => this.includeDndSource = include,
        setRenderDetails: (compDetails, valueToDisplay, force) => this.setRenderDetails(compDetails, valueToDisplay, force),
        setEditDetails: (compDetails, popup, position) => this.setEditDetails(compDetails, popup, position),
        getCellEditor: () => this.cellEditor || null,
        getCellRenderer: () => this.cellRenderer || null,
        getParentOfValue: () => this.getParentOfValue()
      };
      cellCtrl.setComp(compProxy, this.getGui(), this.eCellWrapper, printLayout, editingRow);
    }
    getParentOfValue() {
      if (this.eCellValue) {
        return this.eCellValue;
      }
      if (this.eCellWrapper) {
        return this.eCellWrapper;
      }
      return this.getGui();
    }
    setRenderDetails(compDetails, valueToDisplay, forceNewCellRendererInstance) {
      const isInlineEditing = this.cellEditor && !this.cellEditorPopupWrapper;
      if (isInlineEditing) {
        return;
      }
      this.firstRender = this.firstRender == null;
      const controlWrapperChanged = this.refreshWrapper(false);
      this.refreshEditStyles(false);
      if (compDetails) {
        const neverRefresh = forceNewCellRendererInstance || controlWrapperChanged;
        const cellRendererRefreshSuccessful = neverRefresh ? false : this.refreshCellRenderer(compDetails);
        if (!cellRendererRefreshSuccessful) {
          this.destroyRenderer();
          this.createCellRendererInstance(compDetails);
        }
      } else {
        this.destroyRenderer();
        this.insertValueWithoutCellRenderer(valueToDisplay);
      }
    }
    setEditDetails(compDetails, popup, position) {
      if (compDetails) {
        this.createCellEditorInstance(compDetails, popup, position);
      } else {
        this.destroyEditor();
      }
    }
    removeControls() {
      this.checkboxSelectionComp = this.beans.context.destroyBean(this.checkboxSelectionComp);
      this.dndSourceComp = this.beans.context.destroyBean(this.dndSourceComp);
      this.rowDraggingComp = this.beans.context.destroyBean(this.rowDraggingComp);
    }
    // returns true if wrapper was changed
    refreshWrapper(editing) {
      const providingControls = this.includeRowDrag || this.includeDndSource || this.includeSelection;
      const usingWrapper = providingControls || this.forceWrapper;
      const putWrapperIn = usingWrapper && this.eCellWrapper == null;
      if (putWrapperIn) {
        const wrapperDiv = document.createElement("div");
        wrapperDiv.setAttribute("role", "presentation");
        wrapperDiv.setAttribute("class", "ag-cell-wrapper");
        this.eCellWrapper = wrapperDiv;
        this.getGui().appendChild(this.eCellWrapper);
      }
      const takeWrapperOut = !usingWrapper && this.eCellWrapper != null;
      if (takeWrapperOut) {
        removeFromParent(this.eCellWrapper);
        this.eCellWrapper = void 0;
      }
      this.addOrRemoveCssClass("ag-cell-value", !usingWrapper);
      const usingCellValue = !editing && usingWrapper;
      const putCellValueIn = usingCellValue && this.eCellValue == null;
      if (putCellValueIn) {
        const cellSpan = document.createElement("span");
        cellSpan.setAttribute("role", "presentation");
        cellSpan.setAttribute("class", "ag-cell-value");
        this.eCellValue = cellSpan;
        this.eCellWrapper.appendChild(this.eCellValue);
      }
      const takeCellValueOut = !usingCellValue && this.eCellValue != null;
      if (takeCellValueOut) {
        removeFromParent(this.eCellValue);
        this.eCellValue = void 0;
      }
      const templateChanged = putWrapperIn || takeWrapperOut || putCellValueIn || takeCellValueOut;
      if (templateChanged) {
        this.removeControls();
      }
      if (!editing) {
        if (providingControls) {
          this.addControls();
        }
      }
      return templateChanged;
    }
    addControls() {
      if (this.includeRowDrag) {
        if (this.rowDraggingComp == null) {
          this.rowDraggingComp = this.cellCtrl.createRowDragComp();
          if (this.rowDraggingComp) {
            this.eCellWrapper.insertBefore(this.rowDraggingComp.getGui(), this.eCellValue);
          }
        }
      }
      if (this.includeDndSource) {
        if (this.dndSourceComp == null) {
          this.dndSourceComp = this.cellCtrl.createDndSource();
          this.eCellWrapper.insertBefore(this.dndSourceComp.getGui(), this.eCellValue);
        }
      }
      if (this.includeSelection) {
        if (this.checkboxSelectionComp == null) {
          this.checkboxSelectionComp = this.cellCtrl.createSelectionCheckbox();
          this.eCellWrapper.insertBefore(this.checkboxSelectionComp.getGui(), this.eCellValue);
        }
      }
    }
    createCellEditorInstance(compDetails, popup, position) {
      const versionCopy = this.editorVersion;
      const cellEditorPromise = compDetails.newAgStackInstance();
      if (!cellEditorPromise) {
        return;
      }
      const { params } = compDetails;
      cellEditorPromise.then((c) => this.afterCellEditorCreated(versionCopy, c, params, popup, position));
      const cellEditorAsync = missing(this.cellEditor);
      if (cellEditorAsync && params.cellStartedEdit) {
        this.cellCtrl.focusCell(true);
      }
    }
    insertValueWithoutCellRenderer(valueToDisplay) {
      const eParent = this.getParentOfValue();
      clearElement(eParent);
      const escapedValue = valueToDisplay != null ? escapeString(valueToDisplay, true) : null;
      if (escapedValue != null) {
        eParent.textContent = escapedValue;
      }
    }
    destroyEditorAndRenderer() {
      this.destroyRenderer();
      this.destroyEditor();
    }
    destroyRenderer() {
      const { context } = this.beans;
      this.cellRenderer = context.destroyBean(this.cellRenderer);
      removeFromParent(this.cellRendererGui);
      this.cellRendererGui = null;
      this.rendererVersion++;
    }
    destroyEditor() {
      const { context } = this.beans;
      if (this.hideEditorPopup) {
        this.hideEditorPopup();
      }
      this.hideEditorPopup = void 0;
      this.cellEditor = context.destroyBean(this.cellEditor);
      this.cellEditorPopupWrapper = context.destroyBean(this.cellEditorPopupWrapper);
      removeFromParent(this.cellEditorGui);
      this.cellEditorGui = null;
      this.editorVersion++;
    }
    refreshCellRenderer(compClassAndParams) {
      if (this.cellRenderer == null || this.cellRenderer.refresh == null) {
        return false;
      }
      if (this.cellRendererClass !== compClassAndParams.componentClass) {
        return false;
      }
      const result = this.cellRenderer.refresh(compClassAndParams.params);
      return result === true || result === void 0;
    }
    createCellRendererInstance(compDetails) {
      const suppressAnimationFrame = this.beans.gos.get("suppressAnimationFrame");
      const useTaskService = !suppressAnimationFrame;
      const displayComponentVersionCopy = this.rendererVersion;
      const { componentClass } = compDetails;
      const createCellRendererFunc = () => {
        const staleTask = this.rendererVersion !== displayComponentVersionCopy || !this.isAlive();
        if (staleTask) {
          return;
        }
        const componentPromise = compDetails.newAgStackInstance();
        const callback = this.afterCellRendererCreated.bind(this, displayComponentVersionCopy, componentClass);
        if (componentPromise) {
          componentPromise.then(callback);
        }
      };
      if (useTaskService && this.firstRender) {
        this.beans.animationFrameService.createTask(createCellRendererFunc, this.rowNode.rowIndex, "createTasksP2");
      } else {
        createCellRendererFunc();
      }
    }
    getCtrl() {
      return this.cellCtrl;
    }
    getRowCtrl() {
      return this.rowCtrl;
    }
    getCellRenderer() {
      return this.cellRenderer;
    }
    getCellEditor() {
      return this.cellEditor;
    }
    afterCellRendererCreated(cellRendererVersion, cellRendererClass, cellRenderer) {
      const staleTask = !this.isAlive() || cellRendererVersion !== this.rendererVersion;
      if (staleTask) {
        this.beans.context.destroyBean(cellRenderer);
        return;
      }
      this.cellRenderer = cellRenderer;
      this.cellRendererClass = cellRendererClass;
      this.cellRendererGui = this.cellRenderer.getGui();
      if (this.cellRendererGui != null) {
        const eParent = this.getParentOfValue();
        clearElement(eParent);
        eParent.appendChild(this.cellRendererGui);
      }
    }
    afterCellEditorCreated(requestVersion, cellEditor, params, popup, position) {
      const staleComp = requestVersion !== this.editorVersion;
      if (staleComp) {
        this.beans.context.destroyBean(cellEditor);
        return;
      }
      const editingCancelledByUserComp = cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart();
      if (editingCancelledByUserComp) {
        this.beans.context.destroyBean(cellEditor);
        this.cellCtrl.stopEditing(true);
        return;
      }
      if (!cellEditor.getGui) {
        console.warn(`AG Grid: cellEditor for column ${this.column.getId()} is missing getGui() method`);
        this.beans.context.destroyBean(cellEditor);
        return;
      }
      this.cellEditor = cellEditor;
      this.cellEditorGui = cellEditor.getGui();
      const cellEditorInPopup = popup || cellEditor.isPopup !== void 0 && cellEditor.isPopup();
      if (cellEditorInPopup) {
        this.addPopupCellEditor(params, position);
      } else {
        this.addInCellEditor();
      }
      this.refreshEditStyles(true, cellEditorInPopup);
      if (cellEditor.afterGuiAttached) {
        cellEditor.afterGuiAttached();
      }
    }
    refreshEditStyles(editing, isPopup) {
      var _a;
      this.addOrRemoveCssClass("ag-cell-inline-editing", editing && !isPopup);
      this.addOrRemoveCssClass("ag-cell-popup-editing", editing && !!isPopup);
      this.addOrRemoveCssClass("ag-cell-not-inline-editing", !editing || !!isPopup);
      (_a = this.rowCtrl) == null ? void 0 : _a.setInlineEditingCss(editing);
    }
    addInCellEditor() {
      const eGui = this.getGui();
      if (eGui.contains(this.beans.gos.getActiveDomElement())) {
        eGui.focus();
      }
      this.destroyRenderer();
      this.refreshWrapper(true);
      this.clearParentOfValue();
      if (this.cellEditorGui) {
        const eParent = this.getParentOfValue();
        eParent.appendChild(this.cellEditorGui);
      }
    }
    addPopupCellEditor(params, position) {
      if (this.beans.gos.get("editType") === "fullRow") {
        console.warn("AG Grid: popup cellEditor does not work with fullRowEdit - you cannot use them both - either turn off fullRowEdit, or stop using popup editors.");
      }
      const cellEditor = this.cellEditor;
      this.cellEditorPopupWrapper = this.beans.context.createBean(new PopupEditorWrapper(params));
      const ePopupGui = this.cellEditorPopupWrapper.getGui();
      if (this.cellEditorGui) {
        ePopupGui.appendChild(this.cellEditorGui);
      }
      const popupService = this.beans.popupService;
      const useModelPopup = this.beans.gos.get("stopEditingWhenCellsLoseFocus");
      const positionToUse = position != null ? position : cellEditor.getPopupPosition ? cellEditor.getPopupPosition() : "over";
      const isRtl = this.beans.gos.get("enableRtl");
      const positionParams = {
        ePopup: ePopupGui,
        column: this.column,
        rowNode: this.rowNode,
        type: "popupCellEditor",
        eventSource: this.getGui(),
        position: positionToUse,
        alignSide: isRtl ? "right" : "left",
        keepWithinBounds: true
      };
      const positionCallback = popupService.positionPopupByComponent.bind(popupService, positionParams);
      const translate = this.beans.localeService.getLocaleTextFunc();
      const addPopupRes = popupService.addPopup({
        modal: useModelPopup,
        eChild: ePopupGui,
        closeOnEsc: true,
        closedCallback: () => {
          this.cellCtrl.onPopupEditorClosed();
        },
        anchorToElement: this.getGui(),
        positionCallback,
        ariaLabel: translate("ariaLabelCellEditor", "Cell Editor")
      });
      if (addPopupRes) {
        this.hideEditorPopup = addPopupRes.hideFunc;
      }
    }
    detach() {
      this.eRow.removeChild(this.getGui());
    }
    // if the row is also getting destroyed, then we don't need to remove from dom,
    // as the row will also get removed, so no need to take out the cells from the row
    // if the row is going (removing is an expensive operation, so only need to remove
    // the top part)
    //
    // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
    destroy() {
      this.cellCtrl.stopEditing();
      this.destroyEditorAndRenderer();
      this.removeControls();
      super.destroy();
    }
    clearParentOfValue() {
      const eGui = this.getGui();
      if (eGui.contains(this.beans.gos.getActiveDomElement()) && browserSupportsPreventScroll()) {
        eGui.focus({ preventScroll: true });
      }
      clearElement(this.getParentOfValue());
    }
  };
  var RowComp = class extends Component {
    constructor(ctrl, beans, containerType) {
      super();
      this.cellComps = {};
      this.beans = beans;
      this.rowCtrl = ctrl;
      const rowDiv = document.createElement("div");
      rowDiv.setAttribute("comp-id", `${this.getCompId()}`);
      rowDiv.setAttribute("style", this.getInitialStyle(containerType));
      this.setTemplateFromElement(rowDiv);
      const eGui = this.getGui();
      const style = eGui.style;
      this.domOrder = this.rowCtrl.getDomOrder();
      setAriaRole(eGui, "row");
      const tabIndex = this.rowCtrl.getTabIndex();
      if (tabIndex != null) {
        eGui.setAttribute("tabindex", tabIndex.toString());
      }
      const compProxy = {
        setDomOrder: (domOrder) => this.domOrder = domOrder,
        setCellCtrls: (cellCtrls) => this.setCellCtrls(cellCtrls),
        showFullWidth: (compDetails) => this.showFullWidth(compDetails),
        getFullWidthCellRenderer: () => this.getFullWidthCellRenderer(),
        addOrRemoveCssClass: (name, on) => this.addOrRemoveCssClass(name, on),
        setUserStyles: (styles) => addStylesToElement(eGui, styles),
        setTop: (top) => style.top = top,
        setTransform: (transform2) => style.transform = transform2,
        setRowIndex: (rowIndex) => eGui.setAttribute("row-index", rowIndex),
        setRowId: (rowId) => eGui.setAttribute("row-id", rowId),
        setRowBusinessKey: (businessKey) => eGui.setAttribute("row-business-key", businessKey),
        refreshFullWidth: (getUpdatedParams) => this.refreshFullWidth(getUpdatedParams)
      };
      ctrl.setComp(compProxy, this.getGui(), containerType);
      this.addDestroyFunc(() => {
        ctrl.unsetComp(containerType);
      });
    }
    getInitialStyle(containerType) {
      const transform2 = this.rowCtrl.getInitialTransform(containerType);
      return transform2 ? `transform: ${transform2}` : `top: ${this.rowCtrl.getInitialRowTop(containerType)}`;
    }
    showFullWidth(compDetails) {
      const callback = (cellRenderer) => {
        if (this.isAlive()) {
          const eGui = cellRenderer.getGui();
          this.getGui().appendChild(eGui);
          this.rowCtrl.setupDetailRowAutoHeight(eGui);
          this.setFullWidthRowComp(cellRenderer);
        } else {
          this.beans.context.destroyBean(cellRenderer);
        }
      };
      const res = compDetails.newAgStackInstance();
      if (!res) {
        return;
      }
      res.then(callback);
    }
    setCellCtrls(cellCtrls) {
      const cellsToRemove = Object.assign({}, this.cellComps);
      cellCtrls.forEach((cellCtrl) => {
        const key = cellCtrl.getInstanceId();
        const existingCellComp = this.cellComps[key];
        if (existingCellComp == null) {
          this.newCellComp(cellCtrl);
        } else {
          cellsToRemove[key] = null;
        }
      });
      const cellCompsToRemove = getAllValuesInObject(cellsToRemove).filter((cellComp) => cellComp != null);
      this.destroyCells(cellCompsToRemove);
      this.ensureDomOrder(cellCtrls);
    }
    ensureDomOrder(cellCtrls) {
      if (!this.domOrder) {
        return;
      }
      const elementsInOrder = [];
      cellCtrls.forEach((cellCtrl) => {
        const cellComp = this.cellComps[cellCtrl.getInstanceId()];
        if (cellComp) {
          elementsInOrder.push(cellComp.getGui());
        }
      });
      setDomChildOrder(this.getGui(), elementsInOrder);
    }
    newCellComp(cellCtrl) {
      const cellComp = new CellComp(
        this.beans,
        cellCtrl,
        this.rowCtrl.isPrintLayout(),
        this.getGui(),
        this.rowCtrl.isEditing()
      );
      this.cellComps[cellCtrl.getInstanceId()] = cellComp;
      this.getGui().appendChild(cellComp.getGui());
    }
    destroy() {
      super.destroy();
      this.destroyAllCells();
    }
    destroyAllCells() {
      const cellsToDestroy = getAllValuesInObject(this.cellComps).filter((cp) => cp != null);
      this.destroyCells(cellsToDestroy);
    }
    setFullWidthRowComp(fullWidthRowComponent) {
      if (this.fullWidthCellRenderer) {
        console.error("AG Grid - should not be setting fullWidthRowComponent twice");
      }
      this.fullWidthCellRenderer = fullWidthRowComponent;
      this.addDestroyFunc(() => {
        this.fullWidthCellRenderer = this.beans.context.destroyBean(this.fullWidthCellRenderer);
      });
    }
    getFullWidthCellRenderer() {
      return this.fullWidthCellRenderer;
    }
    destroyCells(cellComps) {
      cellComps.forEach((cellComp) => {
        if (!cellComp) {
          return;
        }
        const instanceId = cellComp.getCtrl().getInstanceId();
        if (this.cellComps[instanceId] !== cellComp) {
          return;
        }
        cellComp.detach();
        cellComp.destroy();
        this.cellComps[instanceId] = null;
      });
    }
    refreshFullWidth(getUpdatedParams) {
      const { fullWidthCellRenderer } = this;
      if (!fullWidthCellRenderer || !fullWidthCellRenderer.refresh) {
        return false;
      }
      const params = getUpdatedParams();
      return fullWidthCellRenderer.refresh(params);
    }
  };
  function templateFactory() {
    const name = Component.elementGettingCreated.getAttribute("name");
    const cssClasses = RowContainerCtrl.getRowContainerCssClasses(name);
    let res;
    const centerTemplate = name === "center" || name === "topCenter" || name === "stickyTopCenter" || name === "bottomCenter" || name === "stickyBottomCenter";
    if (centerTemplate) {
      res = /* html */
      `<div class="${cssClasses.viewport}" ref="eViewport" role="presentation">
                <div class="${cssClasses.container}" ref="eContainer"></div>
            </div>`;
    } else {
      res = /* html */
      `<div class="${cssClasses.container}" ref="eContainer"></div>`;
    }
    return res;
  }
  var RowContainerComp = class extends Component {
    constructor() {
      super(templateFactory());
      this.rowComps = {};
      this.name = Component.elementGettingCreated.getAttribute("name");
      this.type = getRowContainerTypeForName(this.name);
    }
    postConstruct() {
      const compProxy = {
        setViewportHeight: (height) => this.eViewport.style.height = height,
        setRowCtrls: ({ rowCtrls }) => this.setRowCtrls(rowCtrls),
        setDomOrder: (domOrder) => {
          this.domOrder = domOrder;
        },
        setContainerWidth: (width) => this.eContainer.style.width = width
      };
      const ctrl = this.createManagedBean(new RowContainerCtrl(this.name));
      ctrl.setComp(compProxy, this.eContainer, this.eViewport);
    }
    preDestroy() {
      this.setRowCtrls([]);
    }
    setRowCtrls(rowCtrls) {
      const oldRows = __spreadValues({}, this.rowComps);
      this.rowComps = {};
      this.lastPlacedElement = null;
      const processRow = (rowCon) => {
        const instanceId = rowCon.getInstanceId();
        const existingRowComp = oldRows[instanceId];
        if (existingRowComp) {
          this.rowComps[instanceId] = existingRowComp;
          delete oldRows[instanceId];
          this.ensureDomOrder(existingRowComp.getGui());
        } else {
          if (!rowCon.getRowNode().displayed) {
            return;
          }
          const rowComp = new RowComp(rowCon, this.beans, this.type);
          this.rowComps[instanceId] = rowComp;
          this.appendRow(rowComp.getGui());
        }
      };
      rowCtrls.forEach(processRow);
      getAllValuesInObject(oldRows).forEach((oldRowComp) => {
        this.eContainer.removeChild(oldRowComp.getGui());
        oldRowComp.destroy();
      });
      setAriaRole(this.eContainer, "rowgroup");
    }
    appendRow(element) {
      if (this.domOrder) {
        insertWithDomOrder(this.eContainer, element, this.lastPlacedElement);
      } else {
        this.eContainer.appendChild(element);
      }
      this.lastPlacedElement = element;
    }
    ensureDomOrder(eRow) {
      if (this.domOrder) {
        ensureDomOrder(this.eContainer, eRow, this.lastPlacedElement);
        this.lastPlacedElement = eRow;
      }
    }
  };
  __decorateClass([
    Autowired("beans")
  ], RowContainerComp.prototype, "beans", 2);
  __decorateClass([
    RefSelector("eViewport")
  ], RowContainerComp.prototype, "eViewport", 2);
  __decorateClass([
    RefSelector("eContainer")
  ], RowContainerComp.prototype, "eContainer", 2);
  __decorateClass([
    PostConstruct
  ], RowContainerComp.prototype, "postConstruct", 1);
  __decorateClass([
    PreDestroy
  ], RowContainerComp.prototype, "preDestroy", 1);
  var BodyDropPivotTarget = class {
    constructor(pinned) {
      this.columnsToAggregate = [];
      this.columnsToGroup = [];
      this.columnsToPivot = [];
      this.pinned = pinned;
    }
    /** Callback for when drag enters */
    onDragEnter(draggingEvent) {
      this.clearColumnsList();
      if (this.gos.get("functionsReadOnly")) {
        return;
      }
      const dragColumns = draggingEvent.dragItem.columns;
      if (!dragColumns) {
        return;
      }
      dragColumns.forEach((column) => {
        if (!column.isPrimary()) {
          return;
        }
        if (column.isAnyFunctionActive()) {
          return;
        }
        if (column.isAllowValue()) {
          this.columnsToAggregate.push(column);
        } else if (column.isAllowRowGroup()) {
          this.columnsToGroup.push(column);
        } else if (column.isAllowPivot()) {
          this.columnsToPivot.push(column);
        }
      });
    }
    getIconName() {
      const totalColumns = this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length;
      if (totalColumns > 0) {
        return this.pinned ? DragAndDropService.ICON_PINNED : DragAndDropService.ICON_MOVE;
      }
      return null;
    }
    /** Callback for when drag leaves */
    onDragLeave(draggingEvent) {
      this.clearColumnsList();
    }
    clearColumnsList() {
      this.columnsToAggregate.length = 0;
      this.columnsToGroup.length = 0;
      this.columnsToPivot.length = 0;
    }
    /** Callback for when dragging */
    onDragging(draggingEvent) {
    }
    /** Callback for when drag stops */
    onDragStop(draggingEvent) {
      if (this.columnsToAggregate.length > 0) {
        this.columnModel.addValueColumns(this.columnsToAggregate, "toolPanelDragAndDrop");
      }
      if (this.columnsToGroup.length > 0) {
        this.columnModel.addRowGroupColumns(this.columnsToGroup, "toolPanelDragAndDrop");
      }
      if (this.columnsToPivot.length > 0) {
        this.columnModel.addPivotColumns(this.columnsToPivot, "toolPanelDragAndDrop");
      }
    }
  };
  __decorateClass([
    Autowired("columnModel")
  ], BodyDropPivotTarget.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("gridOptionsService")
  ], BodyDropPivotTarget.prototype, "gos", 2);
  var ColumnMoveHelper = class {
    static attemptMoveColumns(params) {
      const { isFromHeader, hDirection, xPosition, fromEnter, fakeEvent, pinned, gos, columnModel } = params;
      const draggingLeft = hDirection === 0;
      const draggingRight = hDirection === 1;
      let { allMovingColumns } = params;
      if (isFromHeader) {
        let newCols = [];
        allMovingColumns.forEach((col) => {
          var _a;
          let movingGroup = null;
          let parent = col.getParent();
          while (parent != null && parent.getDisplayedLeafColumns().length === 1) {
            movingGroup = parent;
            parent = parent.getParent();
          }
          if (movingGroup != null) {
            const isMarryChildren = !!((_a = movingGroup.getColGroupDef()) == null ? void 0 : _a.marryChildren);
            const columnsToMove = isMarryChildren ? movingGroup.getProvidedColumnGroup().getLeafColumns() : movingGroup.getLeafColumns();
            columnsToMove.forEach((newCol) => {
              if (!newCols.includes(newCol)) {
                newCols.push(newCol);
              }
            });
          } else if (!newCols.includes(col)) {
            newCols.push(col);
          }
        });
        allMovingColumns = newCols;
      }
      const allMovingColumnsOrdered = allMovingColumns.slice();
      columnModel.sortColumnsLikeGridColumns(allMovingColumnsOrdered);
      const validMoves = this.calculateValidMoves({
        movingCols: allMovingColumnsOrdered,
        draggingRight,
        xPosition,
        pinned,
        gos,
        columnModel
      });
      const oldIndex = this.calculateOldIndex(allMovingColumnsOrdered, columnModel);
      if (validMoves.length === 0) {
        return;
      }
      const firstValidMove = validMoves[0];
      let constrainDirection = oldIndex !== null && !fromEnter;
      if (isFromHeader) {
        constrainDirection = oldIndex !== null;
      }
      if (constrainDirection && !fakeEvent) {
        if (draggingLeft && firstValidMove >= oldIndex) {
          return;
        }
        if (draggingRight && firstValidMove <= oldIndex) {
          return;
        }
      }
      const displayedCols = columnModel.getAllDisplayedColumns();
      let potentialMoves = [];
      let targetOrder = null;
      for (let i = 0; i < validMoves.length; i++) {
        const move = validMoves[i];
        const order = columnModel.getProposedColumnOrder(allMovingColumnsOrdered, move);
        if (!columnModel.doesOrderPassRules(order)) {
          continue;
        }
        const displayedOrder = order.filter((col) => displayedCols.includes(col));
        if (targetOrder === null) {
          targetOrder = displayedOrder;
        } else if (!areEqual(displayedOrder, targetOrder)) {
          break;
        }
        const fragCount = this.groupFragCount(order);
        potentialMoves.push({ move, fragCount });
      }
      if (potentialMoves.length === 0) {
        return;
      }
      potentialMoves.sort((a, b) => a.fragCount - b.fragCount);
      return this.moveColumns(allMovingColumns, potentialMoves[0].move, "uiColumnMoved", false, columnModel);
    }
    static moveColumns(columns, toIndex, source, finished, columnModel) {
      columnModel.moveColumns(columns, toIndex, source, finished);
      return finished ? null : { columns, toIndex };
    }
    // returns the index of the first column in the list ONLY if the cols are all beside
    // each other. if the cols are not beside each other, then returns null
    static calculateOldIndex(movingCols, columnModel) {
      const gridCols = columnModel.getAllGridColumns();
      const indexes = sortNumerically(movingCols.map((col) => gridCols.indexOf(col)));
      const firstIndex = indexes[0];
      const lastIndex = last(indexes);
      const spread = lastIndex - firstIndex;
      const gapsExist = spread !== indexes.length - 1;
      return gapsExist ? null : firstIndex;
    }
    // A measure of how fragmented in terms of groups an order of columns is
    static groupFragCount(columns) {
      function parents(col) {
        let result = [];
        let parent = col.getOriginalParent();
        while (parent != null) {
          result.push(parent);
          parent = parent.getOriginalParent();
        }
        return result;
      }
      let count = 0;
      for (let i = 0; i < columns.length - 1; i++) {
        let a = parents(columns[i]);
        let b = parents(columns[i + 1]);
        [a, b] = a.length > b.length ? [a, b] : [b, a];
        a.forEach((parent) => {
          if (b.indexOf(parent) === -1) {
            count++;
          }
        });
      }
      return count;
    }
    static getDisplayedColumns(columnModel, type) {
      switch (type) {
        case "left":
          return columnModel.getDisplayedLeftColumns();
        case "right":
          return columnModel.getDisplayedRightColumns();
        default:
          return columnModel.getDisplayedCenterColumns();
      }
    }
    static calculateValidMoves(params) {
      const { movingCols, draggingRight, xPosition, pinned, gos, columnModel } = params;
      const isMoveBlocked = gos.get("suppressMovableColumns") || movingCols.some((col) => col.getColDef().suppressMovable);
      if (isMoveBlocked) {
        return [];
      }
      const allDisplayedCols = this.getDisplayedColumns(columnModel, pinned);
      const allGridCols = columnModel.getAllGridColumns();
      const movingDisplayedCols = allDisplayedCols.filter((col) => includes(movingCols, col));
      const otherDisplayedCols = allDisplayedCols.filter((col) => !includes(movingCols, col));
      const otherGridCols = allGridCols.filter((col) => !includes(movingCols, col));
      let displayIndex = 0;
      let availableWidth = xPosition;
      if (draggingRight) {
        let widthOfMovingDisplayedCols = 0;
        movingDisplayedCols.forEach((col) => widthOfMovingDisplayedCols += col.getActualWidth());
        availableWidth -= widthOfMovingDisplayedCols;
      }
      if (availableWidth > 0) {
        for (let i = 0; i < otherDisplayedCols.length; i++) {
          const col = otherDisplayedCols[i];
          availableWidth -= col.getActualWidth();
          if (availableWidth < 0) {
            break;
          }
          displayIndex++;
        }
        if (draggingRight) {
          displayIndex++;
        }
      }
      let firstValidMove;
      if (displayIndex > 0) {
        const leftColumn = otherDisplayedCols[displayIndex - 1];
        firstValidMove = otherGridCols.indexOf(leftColumn) + 1;
      } else {
        firstValidMove = otherGridCols.indexOf(otherDisplayedCols[0]);
        if (firstValidMove === -1) {
          firstValidMove = 0;
        }
      }
      const validMoves = [firstValidMove];
      const numberComparator = (a, b) => a - b;
      if (draggingRight) {
        let pointer = firstValidMove + 1;
        const lastIndex = allGridCols.length - 1;
        while (pointer <= lastIndex) {
          validMoves.push(pointer);
          pointer++;
        }
        validMoves.sort(numberComparator);
      } else {
        let pointer = firstValidMove;
        const lastIndex = allGridCols.length - 1;
        let displacedCol = allGridCols[pointer];
        while (pointer <= lastIndex && allDisplayedCols.indexOf(displacedCol) < 0) {
          pointer++;
          validMoves.push(pointer);
          displacedCol = allGridCols[pointer];
        }
        pointer = firstValidMove - 1;
        const firstDisplayIndex = 0;
        while (pointer >= firstDisplayIndex) {
          validMoves.push(pointer);
          pointer--;
        }
        validMoves.sort(numberComparator).reverse();
      }
      return validMoves;
    }
    static normaliseX(x, pinned, fromKeyboard, gos, ctrlsService) {
      const eViewport = ctrlsService.getHeaderRowContainerCtrl(pinned).getViewport();
      if (fromKeyboard) {
        x -= eViewport.getBoundingClientRect().left;
      }
      if (gos.get("enableRtl")) {
        const clientWidth = eViewport.clientWidth;
        x = clientWidth - x;
      }
      if (pinned == null) {
        x += ctrlsService.get("center").getCenterViewportScrollLeft();
      }
      return x;
    }
  };
  var MoveColumnFeature = class {
    constructor(pinned) {
      this.needToMoveLeft = false;
      this.needToMoveRight = false;
      this.lastMovedInfo = null;
      this.pinned = pinned;
      this.isCenterContainer = !exists(pinned);
    }
    init() {
      this.ctrlsService.whenReady((p2) => {
        this.gridBodyCon = p2.gridBodyCtrl;
      });
    }
    getIconName() {
      return this.pinned ? DragAndDropService.ICON_PINNED : DragAndDropService.ICON_MOVE;
    }
    onDragEnter(draggingEvent) {
      const columns = draggingEvent.dragItem.columns;
      const dragCameFromToolPanel = draggingEvent.dragSource.type === 0;
      if (dragCameFromToolPanel) {
        this.setColumnsVisible(columns, true, "uiColumnDragged");
      } else {
        const visibleState = draggingEvent.dragItem.visibleState;
        const visibleColumns = (columns || []).filter((column) => visibleState[column.getId()]);
        this.setColumnsVisible(visibleColumns, true, "uiColumnDragged");
      }
      this.setColumnsPinned(columns, this.pinned, "uiColumnDragged");
      this.onDragging(draggingEvent, true, true);
    }
    onDragLeave() {
      this.ensureIntervalCleared();
      this.lastMovedInfo = null;
    }
    setColumnsVisible(columns, visible, source) {
      if (columns) {
        const allowedCols = columns.filter((c) => !c.getColDef().lockVisible);
        this.columnModel.setColumnsVisible(allowedCols, visible, source);
      }
    }
    setColumnsPinned(columns, pinned, source) {
      if (columns) {
        const allowedCols = columns.filter((c) => !c.getColDef().lockPinned);
        this.columnModel.setColumnsPinned(allowedCols, pinned, source);
      }
    }
    onDragStop() {
      this.onDragging(this.lastDraggingEvent, false, true, true);
      this.ensureIntervalCleared();
      this.lastMovedInfo = null;
    }
    checkCenterForScrolling(xAdjustedForScroll) {
      if (this.isCenterContainer) {
        const centerCtrl = this.ctrlsService.get("center");
        const firstVisiblePixel = centerCtrl.getCenterViewportScrollLeft();
        const lastVisiblePixel = firstVisiblePixel + centerCtrl.getCenterWidth();
        if (this.gos.get("enableRtl")) {
          this.needToMoveRight = xAdjustedForScroll < firstVisiblePixel + 50;
          this.needToMoveLeft = xAdjustedForScroll > lastVisiblePixel - 50;
        } else {
          this.needToMoveLeft = xAdjustedForScroll < firstVisiblePixel + 50;
          this.needToMoveRight = xAdjustedForScroll > lastVisiblePixel - 50;
        }
        if (this.needToMoveLeft || this.needToMoveRight) {
          this.ensureIntervalStarted();
        } else {
          this.ensureIntervalCleared();
        }
      }
    }
    onDragging(draggingEvent = this.lastDraggingEvent, fromEnter = false, fakeEvent = false, finished = false) {
      var _a;
      if (finished) {
        if (this.lastMovedInfo) {
          const { columns, toIndex } = this.lastMovedInfo;
          ColumnMoveHelper.moveColumns(columns, toIndex, "uiColumnMoved", true, this.columnModel);
        }
        return;
      }
      this.lastDraggingEvent = draggingEvent;
      if (missing(draggingEvent.hDirection)) {
        return;
      }
      const mouseX = ColumnMoveHelper.normaliseX(
        draggingEvent.x,
        this.pinned,
        false,
        this.gos,
        this.ctrlsService
      );
      if (!fromEnter) {
        this.checkCenterForScrolling(mouseX);
      }
      const hDirection = this.normaliseDirection(draggingEvent.hDirection);
      const dragSourceType = draggingEvent.dragSource.type;
      const allMovingColumns = ((_a = draggingEvent.dragSource.getDragItem().columns) == null ? void 0 : _a.filter((col) => {
        if (col.getColDef().lockPinned) {
          return col.getPinned() == this.pinned;
        }
        return true;
      })) || [];
      const lastMovedInfo = ColumnMoveHelper.attemptMoveColumns({
        allMovingColumns,
        isFromHeader: dragSourceType === 1,
        hDirection,
        xPosition: mouseX,
        pinned: this.pinned,
        fromEnter,
        fakeEvent,
        gos: this.gos,
        columnModel: this.columnModel
      });
      if (lastMovedInfo) {
        this.lastMovedInfo = lastMovedInfo;
      }
    }
    normaliseDirection(hDirection) {
      if (this.gos.get("enableRtl")) {
        switch (hDirection) {
          case 0:
            return 1;
          case 1:
            return 0;
          default:
            console.error(`AG Grid: Unknown direction ${hDirection}`);
        }
      } else {
        return hDirection;
      }
    }
    ensureIntervalStarted() {
      if (!this.movingIntervalId) {
        this.intervalCount = 0;
        this.failedMoveAttempts = 0;
        this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100);
        if (this.needToMoveLeft) {
          this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_LEFT, true);
        } else {
          this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_RIGHT, true);
        }
      }
    }
    ensureIntervalCleared() {
      if (this.movingIntervalId) {
        window.clearInterval(this.movingIntervalId);
        this.movingIntervalId = null;
        this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_MOVE);
      }
    }
    moveInterval() {
      let pixelsToMove;
      this.intervalCount++;
      pixelsToMove = 10 + this.intervalCount * 5;
      if (pixelsToMove > 100) {
        pixelsToMove = 100;
      }
      let pixelsMoved = null;
      const scrollFeature = this.gridBodyCon.getScrollFeature();
      if (this.needToMoveLeft) {
        pixelsMoved = scrollFeature.scrollHorizontally(-pixelsToMove);
      } else if (this.needToMoveRight) {
        pixelsMoved = scrollFeature.scrollHorizontally(pixelsToMove);
      }
      if (pixelsMoved !== 0) {
        this.onDragging(this.lastDraggingEvent);
        this.failedMoveAttempts = 0;
      } else {
        this.failedMoveAttempts++;
        const columns = this.lastDraggingEvent.dragItem.columns;
        const columnsThatCanPin = columns.filter((c) => !c.getColDef().lockPinned);
        if (columnsThatCanPin.length > 0) {
          this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_PINNED);
          if (this.failedMoveAttempts > 7) {
            const pinType = this.needToMoveLeft ? "left" : "right";
            this.setColumnsPinned(columnsThatCanPin, pinType, "uiColumnDragged");
            this.dragAndDropService.nudge();
          }
        }
      }
    }
  };
  __decorateClass([
    Autowired("columnModel")
  ], MoveColumnFeature.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("dragAndDropService")
  ], MoveColumnFeature.prototype, "dragAndDropService", 2);
  __decorateClass([
    Autowired("gridOptionsService")
  ], MoveColumnFeature.prototype, "gos", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], MoveColumnFeature.prototype, "ctrlsService", 2);
  __decorateClass([
    PostConstruct
  ], MoveColumnFeature.prototype, "init", 1);
  var BodyDropTarget = class extends BeanStub {
    constructor(pinned, eContainer) {
      super();
      this.pinned = pinned;
      this.eContainer = eContainer;
    }
    postConstruct() {
      this.ctrlsService.whenReady((p2) => {
        switch (this.pinned) {
          case "left":
            this.eSecondaryContainers = [
              [p2.gridBodyCtrl.getBodyViewportElement(), p2.left.getContainerElement()],
              [p2.bottomLeft.getContainerElement()],
              [p2.topLeft.getContainerElement()]
            ];
            break;
          case "right":
            this.eSecondaryContainers = [
              [p2.gridBodyCtrl.getBodyViewportElement(), p2.right.getContainerElement()],
              [p2.bottomRight.getContainerElement()],
              [p2.topRight.getContainerElement()]
            ];
            break;
          default:
            this.eSecondaryContainers = [
              [p2.gridBodyCtrl.getBodyViewportElement(), p2.center.getViewportElement()],
              [p2.bottomCenter.getViewportElement()],
              [p2.topCenter.getViewportElement()]
            ];
            break;
        }
      });
    }
    isInterestedIn(type) {
      return type === 1 || type === 0 && this.gos.get("allowDragFromColumnsToolPanel");
    }
    getSecondaryContainers() {
      return this.eSecondaryContainers;
    }
    getContainer() {
      return this.eContainer;
    }
    init() {
      this.moveColumnFeature = this.createManagedBean(new MoveColumnFeature(this.pinned));
      this.bodyDropPivotTarget = this.createManagedBean(new BodyDropPivotTarget(this.pinned));
      this.dragAndDropService.addDropTarget(this);
    }
    getIconName() {
      return this.currentDropListener.getIconName();
    }
    // we want to use the bodyPivotTarget if the user is dragging columns in from the toolPanel
    // and we are in pivot mode, as it has to logic to set pivot/value/group on the columns when
    // dropped into the grid's body.
    isDropColumnInPivotMode(draggingEvent) {
      return this.columnModel.isPivotMode() && draggingEvent.dragSource.type === 0;
    }
    onDragEnter(draggingEvent) {
      this.currentDropListener = this.isDropColumnInPivotMode(draggingEvent) ? this.bodyDropPivotTarget : this.moveColumnFeature;
      this.currentDropListener.onDragEnter(draggingEvent);
    }
    onDragLeave(params) {
      this.currentDropListener.onDragLeave(params);
    }
    onDragging(params) {
      this.currentDropListener.onDragging(params);
    }
    onDragStop(params) {
      this.currentDropListener.onDragStop(params);
    }
  };
  __decorateClass([
    Autowired("dragAndDropService")
  ], BodyDropTarget.prototype, "dragAndDropService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], BodyDropTarget.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], BodyDropTarget.prototype, "ctrlsService", 2);
  __decorateClass([
    PostConstruct
  ], BodyDropTarget.prototype, "postConstruct", 1);
  __decorateClass([
    PostConstruct
  ], BodyDropTarget.prototype, "init", 1);
  var _HeaderCellComp = class _HeaderCellComp2 extends AbstractHeaderCellComp {
    constructor(ctrl) {
      super(_HeaderCellComp2.TEMPLATE, ctrl);
      this.headerCompVersion = 0;
      this.column = ctrl.getColumnGroupChild();
      this.pinned = ctrl.getPinned();
    }
    postConstruct() {
      const eGui = this.getGui();
      const setAttribute = (name, value) => {
        if (value != null && value != "") {
          eGui.setAttribute(name, value);
        } else {
          eGui.removeAttribute(name);
        }
      };
      setAttribute("col-id", this.column.getColId());
      const compProxy = {
        setWidth: (width) => eGui.style.width = width,
        addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
        setAriaSort: (sort) => sort ? setAriaSort(eGui, sort) : removeAriaSort(eGui),
        setUserCompDetails: (compDetails) => this.setUserCompDetails(compDetails),
        getUserCompInstance: () => this.headerComp
      };
      this.ctrl.setComp(compProxy, this.getGui(), this.eResize, this.eHeaderCompWrapper);
      const selectAllGui = this.ctrl.getSelectAllGui();
      this.eResize.insertAdjacentElement("afterend", selectAllGui);
    }
    destroyHeaderComp() {
      if (this.headerComp) {
        this.eHeaderCompWrapper.removeChild(this.headerCompGui);
        this.headerComp = this.destroyBean(this.headerComp);
        this.headerCompGui = void 0;
      }
    }
    setUserCompDetails(compDetails) {
      this.headerCompVersion++;
      const versionCopy = this.headerCompVersion;
      compDetails.newAgStackInstance().then((comp) => this.afterCompCreated(versionCopy, comp));
    }
    afterCompCreated(version2, headerComp) {
      if (version2 != this.headerCompVersion || !this.isAlive()) {
        this.destroyBean(headerComp);
        return;
      }
      this.destroyHeaderComp();
      this.headerComp = headerComp;
      this.headerCompGui = headerComp.getGui();
      this.eHeaderCompWrapper.appendChild(this.headerCompGui);
      this.ctrl.setDragSource(this.getGui());
    }
  };
  _HeaderCellComp.TEMPLATE = /* html */
  `<div class="ag-header-cell" role="columnheader">
            <div ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
            <div ref="eHeaderCompWrapper" class="ag-header-cell-comp-wrapper" role="presentation"></div>
        </div>`;
  __decorateClass([
    RefSelector("eResize")
  ], _HeaderCellComp.prototype, "eResize", 2);
  __decorateClass([
    RefSelector("eHeaderCompWrapper")
  ], _HeaderCellComp.prototype, "eHeaderCompWrapper", 2);
  __decorateClass([
    PostConstruct
  ], _HeaderCellComp.prototype, "postConstruct", 1);
  __decorateClass([
    PreDestroy
  ], _HeaderCellComp.prototype, "destroyHeaderComp", 1);
  var HeaderCellComp = _HeaderCellComp;
  var _HeaderGroupCellComp = class _HeaderGroupCellComp2 extends AbstractHeaderCellComp {
    constructor(ctrl) {
      super(_HeaderGroupCellComp2.TEMPLATE, ctrl);
    }
    postConstruct() {
      const eGui = this.getGui();
      const setAttribute = (key, value) => value != void 0 ? eGui.setAttribute(key, value) : eGui.removeAttribute(key);
      eGui.setAttribute("col-id", this.ctrl.getColId());
      const compProxy = {
        addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
        setResizableDisplayed: (displayed) => setDisplayed(this.eResize, displayed),
        setWidth: (width) => eGui.style.width = width,
        setAriaExpanded: (expanded) => setAttribute("aria-expanded", expanded),
        setUserCompDetails: (details) => this.setUserCompDetails(details),
        getUserCompInstance: () => this.headerGroupComp
      };
      this.ctrl.setComp(compProxy, eGui, this.eResize);
    }
    setUserCompDetails(details) {
      details.newAgStackInstance().then((comp) => this.afterHeaderCompCreated(comp));
    }
    afterHeaderCompCreated(headerGroupComp) {
      const destroyFunc = () => this.destroyBean(headerGroupComp);
      if (!this.isAlive()) {
        destroyFunc();
        return;
      }
      const eGui = this.getGui();
      const eHeaderGroupGui = headerGroupComp.getGui();
      eGui.appendChild(eHeaderGroupGui);
      this.addDestroyFunc(destroyFunc);
      this.headerGroupComp = headerGroupComp;
      this.ctrl.setDragSource(eGui);
    }
  };
  _HeaderGroupCellComp.TEMPLATE = /* html */
  `<div class="ag-header-group-cell" role="columnheader">
            <div ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
        </div>`;
  __decorateClass([
    RefSelector("eResize")
  ], _HeaderGroupCellComp.prototype, "eResize", 2);
  __decorateClass([
    PostConstruct
  ], _HeaderGroupCellComp.prototype, "postConstruct", 1);
  var HeaderGroupCellComp = _HeaderGroupCellComp;
  var HeaderRowType = /* @__PURE__ */ ((HeaderRowType2) => {
    HeaderRowType2["COLUMN_GROUP"] = "group";
    HeaderRowType2["COLUMN"] = "column";
    HeaderRowType2["FLOATING_FILTER"] = "filter";
    return HeaderRowType2;
  })(HeaderRowType || {});
  var HeaderRowComp = class extends Component {
    constructor(ctrl) {
      super();
      this.headerComps = {};
      this.ctrl = ctrl;
      this.setTemplate(
        /* html */
        `<div class="${this.ctrl.getHeaderRowClass()}" role="row"></div>`
      );
    }
    init() {
      setAriaRowIndex(this.getGui(), this.ctrl.getAriaRowIndex());
      const compProxy = {
        setHeight: (height) => this.getGui().style.height = height,
        setTop: (top) => this.getGui().style.top = top,
        setHeaderCtrls: (ctrls, forceOrder) => this.setHeaderCtrls(ctrls, forceOrder),
        setWidth: (width) => this.getGui().style.width = width
      };
      this.ctrl.setComp(compProxy);
    }
    destroyHeaderCtrls() {
      this.setHeaderCtrls([], false);
    }
    setHeaderCtrls(ctrls, forceOrder) {
      if (!this.isAlive()) {
        return;
      }
      const oldComps = this.headerComps;
      this.headerComps = {};
      ctrls.forEach((ctrl) => {
        const id = ctrl.getInstanceId();
        let comp = oldComps[id];
        delete oldComps[id];
        if (comp == null) {
          comp = this.createHeaderComp(ctrl);
          this.getGui().appendChild(comp.getGui());
        }
        this.headerComps[id] = comp;
      });
      iterateObject(oldComps, (id, comp) => {
        this.getGui().removeChild(comp.getGui());
        this.destroyBean(comp);
      });
      if (forceOrder) {
        const comps = getAllValuesInObject(this.headerComps);
        comps.sort((a, b) => {
          const leftA = a.getCtrl().getColumnGroupChild().getLeft();
          const leftB = b.getCtrl().getColumnGroupChild().getLeft();
          return leftA - leftB;
        });
        const elementsInOrder = comps.map((c) => c.getGui());
        setDomChildOrder(this.getGui(), elementsInOrder);
      }
    }
    createHeaderComp(headerCtrl) {
      let result;
      switch (this.ctrl.getType()) {
        case "group":
          result = new HeaderGroupCellComp(headerCtrl);
          break;
        case "filter":
          result = new HeaderFilterCellComp(headerCtrl);
          break;
        default:
          result = new HeaderCellComp(headerCtrl);
          break;
      }
      this.createBean(result);
      result.setParentComponent(this);
      return result;
    }
  };
  __decorateClass([
    PostConstruct
  ], HeaderRowComp.prototype, "init", 1);
  __decorateClass([
    PreDestroy
  ], HeaderRowComp.prototype, "destroyHeaderCtrls", 1);
  var instanceIdSequence4 = 0;
  var _AbstractHeaderCellCtrl = class _AbstractHeaderCellCtrl2 extends BeanStub {
    constructor(columnGroupChild, beans, parentRowCtrl) {
      super();
      this.resizeToggleTimeout = 0;
      this.resizeMultiplier = 1;
      this.resizeFeature = null;
      this.lastFocusEvent = null;
      this.dragSource = null;
      this.columnGroupChild = columnGroupChild;
      this.parentRowCtrl = parentRowCtrl;
      this.beans = beans;
      this.instanceId = columnGroupChild.getUniqueId() + "-" + instanceIdSequence4++;
    }
    postConstruct() {
      this.addManagedPropertyListeners(["suppressHeaderFocus"], () => this.refreshTabIndex());
    }
    shouldStopEventPropagation(e) {
      const { headerRowIndex, column } = this.focusService.getFocusedHeader();
      return isUserSuppressingHeaderKeyboardEvent(
        this.gos,
        e,
        headerRowIndex,
        column
      );
    }
    getWrapperHasFocus() {
      const activeEl = this.gos.getActiveDomElement();
      return activeEl === this.eGui;
    }
    setGui(eGui) {
      this.eGui = eGui;
      this.addDomData();
      this.addManagedListener(this.beans.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
      this.onDisplayedColumnsChanged();
      this.refreshTabIndex();
    }
    onDisplayedColumnsChanged() {
      if (!this.comp || !this.column) {
        return;
      }
      this.refreshFirstAndLastStyles();
      this.refreshAriaColIndex();
    }
    refreshFirstAndLastStyles() {
      const { comp, column, beans } = this;
      CssClassApplier.refreshFirstAndLastStyles(comp, column, beans.columnModel);
    }
    refreshAriaColIndex() {
      const { beans, column } = this;
      const colIdx = beans.columnModel.getAriaColumnIndex(column);
      setAriaColIndex(this.eGui, colIdx);
    }
    addResizeAndMoveKeyboardListeners() {
      if (!this.resizeFeature) {
        return;
      }
      this.addManagedListener(this.eGui, "keydown", this.onGuiKeyDown.bind(this));
      this.addManagedListener(this.eGui, "keyup", this.onGuiKeyUp.bind(this));
    }
    refreshTabIndex() {
      const suppressHeaderFocus = this.gos.get("suppressHeaderFocus");
      if (suppressHeaderFocus) {
        this.eGui.removeAttribute("tabindex");
      } else {
        this.eGui.setAttribute("tabindex", "-1");
      }
    }
    onGuiKeyDown(e) {
      var _a;
      const activeEl = this.gos.getActiveDomElement();
      const isLeftOrRight = e.key === KeyCode.LEFT || e.key === KeyCode.RIGHT;
      if (this.isResizing) {
        e.preventDefault();
        e.stopImmediatePropagation();
      }
      if (
        // if elements within the header are focused, we don't process the event
        activeEl !== this.eGui || // if shiftKey and altKey are not pressed, it's cell navigation so we don't process the event
        !e.shiftKey && !e.altKey
      ) {
        return;
      }
      if (this.isResizing || isLeftOrRight) {
        e.preventDefault();
        e.stopImmediatePropagation();
      }
      if (!isLeftOrRight) {
        return;
      }
      const isLeft = e.key === KeyCode.LEFT !== this.gos.get("enableRtl");
      const direction = HorizontalDirection[isLeft ? "Left" : "Right"];
      if (e.altKey) {
        this.isResizing = true;
        this.resizeMultiplier += 1;
        const diff = this.getViewportAdjustedResizeDiff(e);
        this.resizeHeader(diff, e.shiftKey);
        (_a = this.resizeFeature) == null ? void 0 : _a.toggleColumnResizing(true);
      } else {
        this.moveHeader(direction);
      }
    }
    getViewportAdjustedResizeDiff(e) {
      let diff = this.getResizeDiff(e);
      const pinned = this.column.getPinned();
      if (pinned) {
        const leftWidth = this.pinnedWidthService.getPinnedLeftWidth();
        const rightWidth = this.pinnedWidthService.getPinnedRightWidth();
        const bodyWidth = getInnerWidth(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) - 50;
        if (leftWidth + rightWidth + diff > bodyWidth) {
          if (bodyWidth > leftWidth + rightWidth) {
            diff = bodyWidth - leftWidth - rightWidth;
          } else {
            return 0;
          }
        }
      }
      return diff;
    }
    getResizeDiff(e) {
      let isLeft = e.key === KeyCode.LEFT !== this.gos.get("enableRtl");
      const pinned = this.column.getPinned();
      const isRtl = this.gos.get("enableRtl");
      if (pinned) {
        if (isRtl !== (pinned === "right")) {
          isLeft = !isLeft;
        }
      }
      return (isLeft ? -1 : 1) * this.resizeMultiplier;
    }
    onGuiKeyUp() {
      if (!this.isResizing) {
        return;
      }
      if (this.resizeToggleTimeout) {
        window.clearTimeout(this.resizeToggleTimeout);
        this.resizeToggleTimeout = 0;
      }
      this.isResizing = false;
      this.resizeMultiplier = 1;
      this.resizeToggleTimeout = setTimeout(() => {
        var _a;
        (_a = this.resizeFeature) == null ? void 0 : _a.toggleColumnResizing(false);
      }, 150);
    }
    handleKeyDown(e) {
      const wrapperHasFocus = this.getWrapperHasFocus();
      switch (e.key) {
        case KeyCode.PAGE_DOWN:
        case KeyCode.PAGE_UP:
        case KeyCode.PAGE_HOME:
        case KeyCode.PAGE_END:
          if (wrapperHasFocus) {
            e.preventDefault();
          }
      }
    }
    addDomData() {
      const key = _AbstractHeaderCellCtrl2.DOM_DATA_KEY_HEADER_CTRL;
      this.gos.setDomData(this.eGui, key, this);
      this.addDestroyFunc(() => this.gos.setDomData(this.eGui, key, null));
    }
    getGui() {
      return this.eGui;
    }
    focus(event) {
      if (!this.eGui) {
        return false;
      }
      this.lastFocusEvent = event || null;
      this.eGui.focus();
      return true;
    }
    getRowIndex() {
      return this.parentRowCtrl.getRowIndex();
    }
    getParentRowCtrl() {
      return this.parentRowCtrl;
    }
    getPinned() {
      return this.parentRowCtrl.getPinned();
    }
    getInstanceId() {
      return this.instanceId;
    }
    getColumnGroupChild() {
      return this.columnGroupChild;
    }
    removeDragSource() {
      if (this.dragSource) {
        this.dragAndDropService.removeDragSource(this.dragSource);
        this.dragSource = null;
      }
    }
    handleContextMenuMouseEvent(mouseEvent, touchEvent, column) {
      const event = mouseEvent != null ? mouseEvent : touchEvent;
      if (this.gos.get("preventDefaultOnContextMenu")) {
        event.preventDefault();
      }
      const columnToUse = column instanceof Column ? column : void 0;
      if (this.menuService.isHeaderContextMenuEnabled(columnToUse)) {
        this.menuService.showHeaderContextMenu(columnToUse, mouseEvent, touchEvent);
      }
      this.dispatchColumnMouseEvent(Events.EVENT_COLUMN_HEADER_CONTEXT_MENU, column);
    }
    dispatchColumnMouseEvent(eventType, column) {
      const event = {
        type: eventType,
        column
      };
      this.eventService.dispatchEvent(event);
    }
    destroy() {
      super.destroy();
      this.removeDragSource();
      this.comp = null;
      this.column = null;
      this.resizeFeature = null;
      this.lastFocusEvent = null;
      this.columnGroupChild = null;
      this.parentRowCtrl = null;
      this.eGui = null;
    }
  };
  _AbstractHeaderCellCtrl.DOM_DATA_KEY_HEADER_CTRL = "headerCtrl";
  __decorateClass([
    Autowired("pinnedWidthService")
  ], _AbstractHeaderCellCtrl.prototype, "pinnedWidthService", 2);
  __decorateClass([
    Autowired("focusService")
  ], _AbstractHeaderCellCtrl.prototype, "focusService", 2);
  __decorateClass([
    Autowired("userComponentFactory")
  ], _AbstractHeaderCellCtrl.prototype, "userComponentFactory", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], _AbstractHeaderCellCtrl.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("dragAndDropService")
  ], _AbstractHeaderCellCtrl.prototype, "dragAndDropService", 2);
  __decorateClass([
    Autowired("menuService")
  ], _AbstractHeaderCellCtrl.prototype, "menuService", 2);
  __decorateClass([
    PostConstruct
  ], _AbstractHeaderCellCtrl.prototype, "postConstruct", 1);
  var AbstractHeaderCellCtrl = _AbstractHeaderCellCtrl;
  var SetLeftFeature = class extends BeanStub {
    constructor(columnOrGroup, eCell, beans, colsSpanning) {
      super();
      this.columnOrGroup = columnOrGroup;
      this.eCell = eCell;
      this.ariaEl = this.eCell.querySelector("[role=columnheader]") || this.eCell;
      this.colsSpanning = colsSpanning;
      this.beans = beans;
    }
    setColsSpanning(colsSpanning) {
      this.colsSpanning = colsSpanning;
      this.onLeftChanged();
    }
    getColumnOrGroup() {
      if (this.beans.gos.get("enableRtl") && this.colsSpanning) {
        return last(this.colsSpanning);
      }
      return this.columnOrGroup;
    }
    postConstruct() {
      this.addManagedListener(this.columnOrGroup, Column.EVENT_LEFT_CHANGED, this.onLeftChanged.bind(this));
      this.setLeftFirstTime();
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onLeftChanged.bind(this));
      this.addManagedPropertyListener("domLayout", this.onLeftChanged.bind(this));
    }
    setLeftFirstTime() {
      const suppressMoveAnimation = this.beans.gos.get("suppressColumnMoveAnimation");
      const oldLeftExists = exists(this.columnOrGroup.getOldLeft());
      const animateColumnMove = this.beans.columnAnimationService.isActive() && oldLeftExists && !suppressMoveAnimation;
      if (animateColumnMove) {
        this.animateInLeft();
      } else {
        this.onLeftChanged();
      }
    }
    animateInLeft() {
      const colOrGroup = this.getColumnOrGroup();
      const left = colOrGroup.getLeft();
      const oldLeft = colOrGroup.getOldLeft();
      const oldActualLeft = this.modifyLeftForPrintLayout(colOrGroup, oldLeft);
      const actualLeft = this.modifyLeftForPrintLayout(colOrGroup, left);
      this.setLeft(oldActualLeft);
      this.actualLeft = actualLeft;
      this.beans.columnAnimationService.executeNextVMTurn(() => {
        if (this.actualLeft === actualLeft) {
          this.setLeft(actualLeft);
        }
      });
    }
    onLeftChanged() {
      const colOrGroup = this.getColumnOrGroup();
      const left = colOrGroup.getLeft();
      this.actualLeft = this.modifyLeftForPrintLayout(colOrGroup, left);
      this.setLeft(this.actualLeft);
    }
    modifyLeftForPrintLayout(colOrGroup, leftPosition) {
      const printLayout = this.beans.gos.isDomLayout("print");
      if (!printLayout) {
        return leftPosition;
      }
      if (colOrGroup.getPinned() === "left") {
        return leftPosition;
      }
      const leftWidth = this.beans.columnModel.getDisplayedColumnsLeftWidth();
      if (colOrGroup.getPinned() === "right") {
        const bodyWidth = this.beans.columnModel.getBodyContainerWidth();
        return leftWidth + bodyWidth + leftPosition;
      }
      return leftWidth + leftPosition;
    }
    setLeft(value) {
      if (exists(value)) {
        this.eCell.style.left = `${value}px`;
      }
      let indexColumn;
      if (this.columnOrGroup instanceof Column) {
        indexColumn = this.columnOrGroup;
      } else {
        const columnGroup = this.columnOrGroup;
        const children = columnGroup.getLeafColumns();
        if (!children.length) {
          return;
        }
        if (children.length > 1) {
          setAriaColSpan(this.ariaEl, children.length);
        }
        indexColumn = children[0];
      }
    }
  };
  __decorateClass([
    PostConstruct
  ], SetLeftFeature.prototype, "postConstruct", 1);
  var HoverFeature = class extends BeanStub {
    constructor(columns, element) {
      super();
      this.columns = columns;
      this.element = element;
    }
    postConstruct() {
      if (this.gos.get("columnHoverHighlight")) {
        this.addMouseHoverListeners();
      }
    }
    addMouseHoverListeners() {
      this.addManagedListener(this.element, "mouseout", this.onMouseOut.bind(this));
      this.addManagedListener(this.element, "mouseover", this.onMouseOver.bind(this));
    }
    onMouseOut() {
      this.columnHoverService.clearMouseOver();
    }
    onMouseOver() {
      this.columnHoverService.setMouseOver(this.columns);
    }
  };
  __decorateClass([
    Autowired("columnHoverService")
  ], HoverFeature.prototype, "columnHoverService", 2);
  __decorateClass([
    PostConstruct
  ], HoverFeature.prototype, "postConstruct", 1);
  var HeaderFilterCellCtrl = class extends AbstractHeaderCellCtrl {
    constructor(column, beans, parentRowCtrl) {
      super(column, beans, parentRowCtrl);
      this.iconCreated = false;
      this.column = column;
    }
    setComp(comp, eGui, eButtonShowMainFilter, eFloatingFilterBody) {
      this.comp = comp;
      this.eButtonShowMainFilter = eButtonShowMainFilter;
      this.eFloatingFilterBody = eFloatingFilterBody;
      this.setGui(eGui);
      this.setupActive();
      this.setupWidth();
      this.setupLeft();
      this.setupHover();
      this.setupFocus();
      this.setupAria();
      this.setupFilterButton();
      this.setupUserComp();
      this.setupSyncWithFilter();
      this.setupUi();
      this.addManagedListener(this.eButtonShowMainFilter, "click", this.showParentFilter.bind(this));
      this.setupFilterChangedListener();
      this.addManagedListener(this.column, Column.EVENT_COL_DEF_CHANGED, this.onColDefChanged.bind(this));
    }
    // empty abstract method
    resizeHeader() {
    }
    // empty abstract method
    moveHeader() {
    }
    setupActive() {
      const colDef = this.column.getColDef();
      const filterExists = !!colDef.filter;
      const floatingFilterExists = !!colDef.floatingFilter;
      this.active = filterExists && floatingFilterExists;
    }
    setupUi() {
      this.comp.setButtonWrapperDisplayed(!this.suppressFilterButton && this.active);
      this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton);
      this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton);
      if (!this.active || this.iconCreated) {
        return;
      }
      const eMenuIcon = createIconNoSpan("filter", this.gos, this.column);
      if (eMenuIcon) {
        this.iconCreated = true;
        this.eButtonShowMainFilter.appendChild(eMenuIcon);
      }
    }
    setupFocus() {
      this.createManagedBean(new ManagedFocusFeature(
        this.eGui,
        {
          shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
          onTabKeyDown: this.onTabKeyDown.bind(this),
          handleKeyDown: this.handleKeyDown.bind(this),
          onFocusIn: this.onFocusIn.bind(this)
        }
      ));
    }
    setupAria() {
      const localeTextFunc = this.localeService.getLocaleTextFunc();
      setAriaLabel(this.eButtonShowMainFilter, localeTextFunc("ariaFilterMenuOpen", "Open Filter Menu"));
    }
    onTabKeyDown(e) {
      const activeEl = this.gos.getActiveDomElement();
      const wrapperHasFocus = activeEl === this.eGui;
      if (wrapperHasFocus) {
        return;
      }
      const nextFocusableEl = this.focusService.findNextFocusableElement(this.eGui, null, e.shiftKey);
      if (nextFocusableEl) {
        this.beans.headerNavigationService.scrollToColumn(this.column);
        e.preventDefault();
        nextFocusableEl.focus();
        return;
      }
      const nextFocusableColumn = this.findNextColumnWithFloatingFilter(e.shiftKey);
      if (!nextFocusableColumn) {
        return;
      }
      if (this.focusService.focusHeaderPosition({
        headerPosition: {
          headerRowIndex: this.getParentRowCtrl().getRowIndex(),
          column: nextFocusableColumn
        },
        event: e
      })) {
        e.preventDefault();
      }
    }
    findNextColumnWithFloatingFilter(backwards) {
      const columnModel = this.beans.columnModel;
      let nextCol = this.column;
      do {
        nextCol = backwards ? columnModel.getDisplayedColBefore(nextCol) : columnModel.getDisplayedColAfter(nextCol);
        if (!nextCol) {
          break;
        }
      } while (!nextCol.getColDef().filter || !nextCol.getColDef().floatingFilter);
      return nextCol;
    }
    handleKeyDown(e) {
      super.handleKeyDown(e);
      const wrapperHasFocus = this.getWrapperHasFocus();
      switch (e.key) {
        case KeyCode.UP:
        case KeyCode.DOWN:
          if (!wrapperHasFocus) {
            e.preventDefault();
          }
        case KeyCode.LEFT:
        case KeyCode.RIGHT:
          if (wrapperHasFocus) {
            return;
          }
          e.stopPropagation();
        case KeyCode.ENTER:
          if (wrapperHasFocus) {
            if (this.focusService.focusInto(this.eGui)) {
              e.preventDefault();
            }
          }
          break;
        case KeyCode.ESCAPE:
          if (!wrapperHasFocus) {
            this.eGui.focus();
          }
      }
    }
    onFocusIn(e) {
      const isRelatedWithin = this.eGui.contains(e.relatedTarget);
      if (isRelatedWithin) {
        return;
      }
      const notFromHeaderWrapper = !!e.relatedTarget && !e.relatedTarget.classList.contains("ag-floating-filter");
      const fromWithinHeader = !!e.relatedTarget && isElementChildOfClass(e.relatedTarget, "ag-floating-filter");
      if (notFromHeaderWrapper && fromWithinHeader && e.target === this.eGui) {
        const lastFocusEvent = this.lastFocusEvent;
        const fromTab = !!(lastFocusEvent && lastFocusEvent.key === KeyCode.TAB);
        if (lastFocusEvent && fromTab) {
          const shouldFocusLast = lastFocusEvent.shiftKey;
          this.focusService.focusInto(this.eGui, shouldFocusLast);
        }
      }
      const rowIndex = this.getRowIndex();
      this.beans.focusService.setFocusedHeader(rowIndex, this.column);
    }
    setupHover() {
      this.createManagedBean(new HoverFeature([this.column], this.eGui));
      const listener = () => {
        if (!this.gos.get("columnHoverHighlight")) {
          return;
        }
        const hovered = this.beans.columnHoverService.isHovered(this.column);
        this.comp.addOrRemoveCssClass("ag-column-hover", hovered);
      };
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_HOVER_CHANGED, listener);
      listener();
    }
    setupLeft() {
      const setLeftFeature = new SetLeftFeature(this.column, this.eGui, this.beans);
      this.createManagedBean(setLeftFeature);
    }
    setupFilterButton() {
      this.suppressFilterButton = !this.menuService.isFloatingFilterButtonEnabled(this.column);
      this.highlightFilterButtonWhenActive = !this.menuService.isLegacyMenuEnabled();
    }
    setupUserComp() {
      if (!this.active) {
        return;
      }
      const compDetails = this.beans.filterManager.getFloatingFilterCompDetails(
        this.column,
        () => this.showParentFilter()
      );
      if (compDetails) {
        this.setCompDetails(compDetails);
      }
    }
    setCompDetails(compDetails) {
      this.userCompDetails = compDetails;
      this.comp.setCompDetails(compDetails);
    }
    showParentFilter() {
      const eventSource = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
      this.menuService.showFilterMenu({
        column: this.column,
        buttonElement: eventSource,
        containerType: "floatingFilter",
        positionBy: "button"
      });
    }
    setupSyncWithFilter() {
      if (!this.active) {
        return;
      }
      const { filterManager } = this.beans;
      const syncWithFilter = (event) => {
        if ((event == null ? void 0 : event.source) === "filterDestroyed" && this.context.isDestroyed()) {
          return;
        }
        const compPromise = this.comp.getFloatingFilterComp();
        if (!compPromise) {
          return;
        }
        compPromise.then((comp) => {
          var _a;
          if (comp) {
            const parentModel = filterManager.getCurrentFloatingFilterParentModel(this.column);
            comp.onParentModelChanged(parentModel, event ? this.gos.addGridCommonParams({
              columns: (_a = event.columns) != null ? _a : [],
              type: Events.EVENT_FILTER_CHANGED,
              source: event.source === "api" ? "api" : "columnFilter"
            }) : null);
          }
        });
      };
      this.destroySyncListener = this.addManagedListener(this.column, Column.EVENT_FILTER_CHANGED, syncWithFilter);
      if (filterManager.isFilterActive(this.column)) {
        syncWithFilter(null);
      }
    }
    setupWidth() {
      const listener = () => {
        const width = `${this.column.getActualWidth()}px`;
        this.comp.setWidth(width);
      };
      this.addManagedListener(this.column, Column.EVENT_WIDTH_CHANGED, listener);
      listener();
    }
    setupFilterChangedListener() {
      if (this.active) {
        this.destroyFilterChangedListener = this.addManagedListener(this.column, Column.EVENT_FILTER_CHANGED, this.updateFilterButton.bind(this));
        this.updateFilterButton();
      }
    }
    updateFilterButton() {
      if (!this.suppressFilterButton && this.comp) {
        const isFilterAllowed = this.beans.filterManager.isFilterAllowed(this.column);
        this.comp.setButtonWrapperDisplayed(isFilterAllowed);
        if (this.highlightFilterButtonWhenActive && isFilterAllowed) {
          this.eButtonShowMainFilter.classList.toggle("ag-filter-active", this.column.isFilterActive());
        }
      }
    }
    onColDefChanged() {
      var _a, _b;
      const wasActive = this.active;
      this.setupActive();
      const becomeActive = !wasActive && this.active;
      if (wasActive && !this.active) {
        (_a = this.destroySyncListener) == null ? void 0 : _a.call(this);
        (_b = this.destroyFilterChangedListener) == null ? void 0 : _b.call(this);
      }
      const newCompDetails = this.active ? this.beans.filterManager.getFloatingFilterCompDetails(
        this.column,
        () => this.showParentFilter()
      ) : null;
      const compPromise = this.comp.getFloatingFilterComp();
      if (!compPromise || !newCompDetails) {
        this.updateCompDetails(newCompDetails, becomeActive);
      } else {
        compPromise.then((compInstance) => {
          var _a2;
          if (!compInstance || this.beans.filterManager.areFilterCompsDifferent((_a2 = this.userCompDetails) != null ? _a2 : null, newCompDetails)) {
            this.updateCompDetails(newCompDetails, becomeActive);
          } else {
            this.updateFloatingFilterParams(newCompDetails);
          }
        });
      }
    }
    updateCompDetails(compDetails, becomeActive) {
      if (!this.isAlive()) {
        return;
      }
      this.setCompDetails(compDetails);
      this.setupFilterButton();
      this.setupUi();
      if (becomeActive) {
        this.setupSyncWithFilter();
        this.setupFilterChangedListener();
      }
    }
    updateFloatingFilterParams(userCompDetails) {
      var _a;
      if (!userCompDetails) {
        return;
      }
      const params = userCompDetails.params;
      (_a = this.comp.getFloatingFilterComp()) == null ? void 0 : _a.then((floatingFilter) => {
        let hasRefreshed = false;
        if ((floatingFilter == null ? void 0 : floatingFilter.refresh) && typeof floatingFilter.refresh === "function") {
          const result = floatingFilter.refresh(params);
          if (result !== null) {
            hasRefreshed = true;
          }
        }
        if (!hasRefreshed && (floatingFilter == null ? void 0 : floatingFilter.onParamsUpdated) && typeof floatingFilter.onParamsUpdated === "function") {
          const result = floatingFilter.onParamsUpdated(params);
          if (result !== null) {
            warnOnce(`Custom floating filter method 'onParamsUpdated' is deprecated. Use 'refresh' instead.`);
          }
        }
      });
    }
    destroy() {
      super.destroy();
      this.eButtonShowMainFilter = null;
      this.eFloatingFilterBody = null;
      this.userCompDetails = null;
      this.destroySyncListener = null;
      this.destroyFilterChangedListener = null;
    }
  };
  var ResizeFeature = class extends BeanStub {
    constructor(pinned, column, eResize, comp, ctrl) {
      super();
      this.pinned = pinned;
      this.column = column;
      this.eResize = eResize;
      this.comp = comp;
      this.ctrl = ctrl;
    }
    postConstruct() {
      const destroyResizeFuncs = [];
      let canResize;
      let canAutosize;
      const addResize = () => {
        setDisplayed(this.eResize, canResize);
        if (!canResize) {
          return;
        }
        const finishedWithResizeFunc = this.horizontalResizeService.addResizeBar({
          eResizeBar: this.eResize,
          onResizeStart: this.onResizeStart.bind(this),
          onResizing: this.onResizing.bind(this, false),
          onResizeEnd: this.onResizing.bind(this, true)
        });
        destroyResizeFuncs.push(finishedWithResizeFunc);
        if (canAutosize) {
          const skipHeaderOnAutoSize = this.gos.get("skipHeaderOnAutoSize");
          const autoSizeColListener = () => {
            this.columnModel.autoSizeColumn(this.column, "uiColumnResized", skipHeaderOnAutoSize);
          };
          this.eResize.addEventListener("dblclick", autoSizeColListener);
          const touchListener = new TouchListener(this.eResize);
          touchListener.addEventListener(TouchListener.EVENT_DOUBLE_TAP, autoSizeColListener);
          destroyResizeFuncs.push(() => {
            this.eResize.removeEventListener("dblclick", autoSizeColListener);
            touchListener.removeEventListener(TouchListener.EVENT_DOUBLE_TAP, autoSizeColListener);
            touchListener.destroy();
          });
        }
      };
      const removeResize = () => {
        destroyResizeFuncs.forEach((f) => f());
        destroyResizeFuncs.length = 0;
      };
      const refresh = () => {
        const resize = this.column.isResizable();
        const autoSize = !this.gos.get("suppressAutoSize") && !this.column.getColDef().suppressAutoSize;
        const propertyChange = resize !== canResize || autoSize !== canAutosize;
        if (propertyChange) {
          canResize = resize;
          canAutosize = autoSize;
          removeResize();
          addResize();
        }
      };
      refresh();
      this.addDestroyFunc(removeResize);
      this.ctrl.addRefreshFunction(refresh);
    }
    onResizing(finished, resizeAmount) {
      const { column: key, lastResizeAmount, resizeStartWidth } = this;
      const resizeAmountNormalised = this.normaliseResizeAmount(resizeAmount);
      const newWidth = resizeStartWidth + resizeAmountNormalised;
      const columnWidths = [{ key, newWidth }];
      if (this.column.getPinned()) {
        const leftWidth = this.pinnedWidthService.getPinnedLeftWidth();
        const rightWidth = this.pinnedWidthService.getPinnedRightWidth();
        const bodyWidth = getInnerWidth(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) - 50;
        if (leftWidth + rightWidth + (resizeAmountNormalised - lastResizeAmount) > bodyWidth) {
          return;
        }
      }
      this.lastResizeAmount = resizeAmountNormalised;
      this.columnModel.setColumnWidths(columnWidths, this.resizeWithShiftKey, finished, "uiColumnResized");
      if (finished) {
        this.toggleColumnResizing(false);
      }
    }
    onResizeStart(shiftKey) {
      this.resizeStartWidth = this.column.getActualWidth();
      this.lastResizeAmount = 0;
      this.resizeWithShiftKey = shiftKey;
      this.toggleColumnResizing(true);
    }
    toggleColumnResizing(resizing) {
      this.comp.addOrRemoveCssClass("ag-column-resizing", resizing);
    }
    // optionally inverts the drag, depending on pinned and RTL
    // note - this method is duplicated in RenderedHeaderGroupCell - should refactor out?
    normaliseResizeAmount(dragChange) {
      let result = dragChange;
      const notPinningLeft = this.pinned !== "left";
      const pinningRight = this.pinned === "right";
      if (this.gos.get("enableRtl")) {
        if (notPinningLeft) {
          result *= -1;
        }
      } else {
        if (pinningRight) {
          result *= -1;
        }
      }
      return result;
    }
  };
  __decorateClass([
    Autowired("horizontalResizeService")
  ], ResizeFeature.prototype, "horizontalResizeService", 2);
  __decorateClass([
    Autowired("pinnedWidthService")
  ], ResizeFeature.prototype, "pinnedWidthService", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], ResizeFeature.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], ResizeFeature.prototype, "columnModel", 2);
  __decorateClass([
    PostConstruct
  ], ResizeFeature.prototype, "postConstruct", 1);
  var SelectAllFeature = class extends BeanStub {
    constructor(column) {
      super();
      this.cbSelectAllVisible = false;
      this.processingEventFromCheckbox = false;
      this.column = column;
    }
    onSpaceKeyDown(e) {
      const checkbox = this.cbSelectAll;
      if (checkbox.isDisplayed() && !checkbox.getGui().contains(this.gos.getActiveDomElement())) {
        e.preventDefault();
        checkbox.setValue(!checkbox.getValue());
      }
    }
    getCheckboxGui() {
      return this.cbSelectAll.getGui();
    }
    setComp(ctrl) {
      this.headerCellCtrl = ctrl;
      this.cbSelectAll = this.createManagedBean(new AgCheckbox());
      this.cbSelectAll.addCssClass("ag-header-select-all");
      setAriaRole(this.cbSelectAll.getGui(), "presentation");
      this.showOrHideSelectAll();
      this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_SELECTION_CHANGED, this.onSelectionChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_PAGINATION_CHANGED, this.onSelectionChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_MODEL_UPDATED, this.onModelChanged.bind(this));
      this.addManagedListener(this.cbSelectAll, Events.EVENT_FIELD_VALUE_CHANGED, this.onCbSelectAll.bind(this));
      setAriaHidden(this.cbSelectAll.getGui(), true);
      this.cbSelectAll.getInputElement().setAttribute("tabindex", "-1");
      this.refreshSelectAllLabel();
    }
    onNewColumnsLoaded() {
      this.showOrHideSelectAll();
    }
    onDisplayedColumnsChanged() {
      if (!this.isAlive()) {
        return;
      }
      this.showOrHideSelectAll();
    }
    showOrHideSelectAll() {
      this.cbSelectAllVisible = this.isCheckboxSelection();
      this.cbSelectAll.setDisplayed(this.cbSelectAllVisible, { skipAriaHidden: true });
      if (this.cbSelectAllVisible) {
        this.checkRightRowModelType("selectAllCheckbox");
        this.checkSelectionType("selectAllCheckbox");
        this.updateStateOfCheckbox();
      }
      this.refreshSelectAllLabel();
    }
    onModelChanged() {
      if (!this.cbSelectAllVisible) {
        return;
      }
      this.updateStateOfCheckbox();
    }
    onSelectionChanged() {
      if (!this.cbSelectAllVisible) {
        return;
      }
      this.updateStateOfCheckbox();
    }
    updateStateOfCheckbox() {
      if (this.processingEventFromCheckbox) {
        return;
      }
      this.processingEventFromCheckbox = true;
      const allSelected = this.selectionService.getSelectAllState(
        this.isFilteredOnly(),
        this.isCurrentPageOnly()
      );
      this.cbSelectAll.setValue(allSelected);
      const hasNodesToSelect = this.selectionService.hasNodesToSelect(this.isFilteredOnly(), this.isCurrentPageOnly());
      this.cbSelectAll.setDisabled(!hasNodesToSelect);
      this.refreshSelectAllLabel();
      this.processingEventFromCheckbox = false;
    }
    refreshSelectAllLabel() {
      const translate = this.localeService.getLocaleTextFunc();
      const checked = this.cbSelectAll.getValue();
      const ariaStatus = checked ? translate("ariaChecked", "checked") : translate("ariaUnchecked", "unchecked");
      const ariaLabel = translate("ariaRowSelectAll", "Press Space to toggle all rows selection");
      if (!this.cbSelectAllVisible) {
        this.headerCellCtrl.setAriaDescriptionProperty("selectAll", null);
      } else {
        this.headerCellCtrl.setAriaDescriptionProperty("selectAll", `${ariaLabel} (${ariaStatus})`);
      }
      this.cbSelectAll.setInputAriaLabel(`${ariaLabel} (${ariaStatus})`);
      this.headerCellCtrl.announceAriaDescription();
    }
    checkSelectionType(feature) {
      const isMultiSelect = this.gos.get("rowSelection") === "multiple";
      if (!isMultiSelect) {
        console.warn(`AG Grid: ${feature} is only available if using 'multiple' rowSelection.`);
        return false;
      }
      return true;
    }
    checkRightRowModelType(feature) {
      const rowModelType = this.rowModel.getType();
      const rowModelMatches = rowModelType === "clientSide" || rowModelType === "serverSide";
      if (!rowModelMatches) {
        console.warn(`AG Grid: ${feature} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${rowModelType}.`);
        return false;
      }
      return true;
    }
    onCbSelectAll() {
      if (this.processingEventFromCheckbox) {
        return;
      }
      if (!this.cbSelectAllVisible) {
        return;
      }
      const value = this.cbSelectAll.getValue();
      const justFiltered = this.isFilteredOnly();
      const justCurrentPage = this.isCurrentPageOnly();
      let source = "uiSelectAll";
      if (justCurrentPage) {
        source = "uiSelectAllCurrentPage";
      } else if (justFiltered) {
        source = "uiSelectAllFiltered";
      }
      const params = {
        source,
        justFiltered,
        justCurrentPage
      };
      if (value) {
        this.selectionService.selectAllRowNodes(params);
      } else {
        this.selectionService.deselectAllRowNodes(params);
      }
    }
    isCheckboxSelection() {
      let result = this.column.getColDef().headerCheckboxSelection;
      if (typeof result === "function") {
        const func = result;
        const params = this.gos.addGridCommonParams({
          column: this.column,
          colDef: this.column.getColDef()
        });
        result = func(params);
      }
      if (result) {
        return this.checkRightRowModelType("headerCheckboxSelection") && this.checkSelectionType("headerCheckboxSelection");
      }
      return false;
    }
    isFilteredOnly() {
      return !!this.column.getColDef().headerCheckboxSelectionFilteredOnly;
    }
    isCurrentPageOnly() {
      return !!this.column.getColDef().headerCheckboxSelectionCurrentPageOnly;
    }
  };
  __decorateClass([
    Autowired("rowModel")
  ], SelectAllFeature.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("selectionService")
  ], SelectAllFeature.prototype, "selectionService", 2);
  var HeaderCellCtrl = class extends AbstractHeaderCellCtrl {
    constructor(column, beans, parentRowCtrl) {
      super(column, beans, parentRowCtrl);
      this.refreshFunctions = [];
      this.userHeaderClasses = /* @__PURE__ */ new Set();
      this.ariaDescriptionProperties = /* @__PURE__ */ new Map();
      this.column = column;
    }
    setComp(comp, eGui, eResize, eHeaderCompWrapper) {
      this.comp = comp;
      this.setGui(eGui);
      this.updateState();
      this.setupWidth();
      this.setupMovingCss();
      this.setupMenuClass();
      this.setupSortableClass();
      this.setupWrapTextClass();
      this.refreshSpanHeaderHeight();
      this.setupAutoHeight(eHeaderCompWrapper);
      this.addColumnHoverListener();
      this.setupFilterClass();
      this.setupClassesFromColDef();
      this.setupTooltip();
      this.addActiveHeaderMouseListeners();
      this.setupSelectAll();
      this.setupUserComp();
      this.refreshAria();
      this.resizeFeature = this.createManagedBean(new ResizeFeature(this.getPinned(), this.column, eResize, comp, this));
      this.createManagedBean(new HoverFeature([this.column], eGui));
      this.createManagedBean(new SetLeftFeature(this.column, eGui, this.beans));
      this.createManagedBean(new ManagedFocusFeature(
        eGui,
        {
          shouldStopEventPropagation: (e) => this.shouldStopEventPropagation(e),
          onTabKeyDown: () => null,
          handleKeyDown: this.handleKeyDown.bind(this),
          onFocusIn: this.onFocusIn.bind(this),
          onFocusOut: this.onFocusOut.bind(this)
        }
      ));
      this.addResizeAndMoveKeyboardListeners();
      this.addManagedPropertyListeners(["suppressMovableColumns", "suppressMenuHide", "suppressAggFuncInHeader"], this.refresh.bind(this));
      this.addManagedListener(this.column, Column.EVENT_COL_DEF_CHANGED, this.refresh.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, this.onColumnValueChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onColumnRowGroupChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, this.onColumnPivotChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_HEADER_HEIGHT_CHANGED, this.onHeaderHeightChanged.bind(this));
    }
    resizeHeader(delta, shiftKey) {
      var _a, _b;
      if (!this.column.isResizable()) {
        return;
      }
      const actualWidth = this.column.getActualWidth();
      const minWidth = (_a = this.column.getMinWidth()) != null ? _a : 0;
      const maxWidth = (_b = this.column.getMaxWidth()) != null ? _b : Number.MAX_SAFE_INTEGER;
      const newWidth = Math.min(Math.max(actualWidth + delta, minWidth), maxWidth);
      this.beans.columnModel.setColumnWidths([{ key: this.column, newWidth }], shiftKey, true, "uiColumnResized");
    }
    moveHeader(hDirection) {
      const { eGui, column, gos, ctrlsService } = this;
      const pinned = this.getPinned();
      const left = eGui.getBoundingClientRect().left;
      const width = column.getActualWidth();
      const isRtl = gos.get("enableRtl");
      const isLeft = hDirection === 0 !== isRtl;
      const xPosition = ColumnMoveHelper.normaliseX(
        isLeft ? left - 20 : left + width + 20,
        pinned,
        true,
        gos,
        ctrlsService
      );
      ColumnMoveHelper.attemptMoveColumns({
        allMovingColumns: [column],
        isFromHeader: true,
        hDirection,
        xPosition,
        pinned,
        fromEnter: false,
        fakeEvent: false,
        gos,
        columnModel: this.beans.columnModel
      });
      ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(column, "auto");
    }
    setupUserComp() {
      const compDetails = this.lookupUserCompDetails();
      this.setCompDetails(compDetails);
    }
    setCompDetails(compDetails) {
      this.userCompDetails = compDetails;
      this.comp.setUserCompDetails(compDetails);
    }
    lookupUserCompDetails() {
      const params = this.createParams();
      const colDef = this.column.getColDef();
      return this.userComponentFactory.getHeaderCompDetails(colDef, params);
    }
    createParams() {
      const params = this.gos.addGridCommonParams({
        column: this.column,
        displayName: this.displayName,
        enableSorting: this.column.isSortable(),
        enableMenu: this.menuEnabled,
        enableFilterButton: this.openFilterEnabled && this.menuService.isHeaderFilterButtonEnabled(this.column),
        enableFilterIcon: !this.openFilterEnabled || this.menuService.isLegacyMenuEnabled(),
        showColumnMenu: (buttonElement) => {
          this.menuService.showColumnMenu({
            column: this.column,
            buttonElement,
            positionBy: "button"
          });
        },
        showColumnMenuAfterMouseClick: (mouseEvent) => {
          this.menuService.showColumnMenu({
            column: this.column,
            mouseEvent,
            positionBy: "mouse"
          });
        },
        showFilter: (buttonElement) => {
          this.menuService.showFilterMenu({
            column: this.column,
            buttonElement,
            containerType: "columnFilter",
            positionBy: "button"
          });
        },
        progressSort: (multiSort) => {
          this.beans.sortController.progressSort(this.column, !!multiSort, "uiColumnSorted");
        },
        setSort: (sort, multiSort) => {
          this.beans.sortController.setSortForColumn(this.column, sort, !!multiSort, "uiColumnSorted");
        },
        eGridHeader: this.getGui(),
        setTooltip: (value, shouldDisplayTooltip) => {
          this.setupTooltip(value, shouldDisplayTooltip);
        }
      });
      return params;
    }
    setupSelectAll() {
      this.selectAllFeature = this.createManagedBean(new SelectAllFeature(this.column));
      this.selectAllFeature.setComp(this);
    }
    getSelectAllGui() {
      return this.selectAllFeature.getCheckboxGui();
    }
    handleKeyDown(e) {
      super.handleKeyDown(e);
      if (e.key === KeyCode.SPACE) {
        this.selectAllFeature.onSpaceKeyDown(e);
      }
      if (e.key === KeyCode.ENTER) {
        this.onEnterKeyDown(e);
      }
      if (e.key === KeyCode.DOWN && e.altKey) {
        this.showMenuOnKeyPress(e, false);
      }
    }
    onEnterKeyDown(e) {
      if (e.ctrlKey || e.metaKey) {
        this.showMenuOnKeyPress(e, true);
      } else if (this.sortable) {
        const multiSort = e.shiftKey;
        this.beans.sortController.progressSort(this.column, multiSort, "uiColumnSorted");
      }
    }
    showMenuOnKeyPress(e, isFilterShortcut) {
      const headerComp = this.comp.getUserCompInstance();
      if (!headerComp || !(headerComp instanceof HeaderComp)) {
        return;
      }
      if (headerComp.onMenuKeyboardShortcut(isFilterShortcut)) {
        e.preventDefault();
      }
    }
    onFocusIn(e) {
      if (!this.getGui().contains(e.relatedTarget)) {
        const rowIndex = this.getRowIndex();
        this.focusService.setFocusedHeader(rowIndex, this.column);
        this.announceAriaDescription();
      }
      if (this.focusService.isKeyboardMode()) {
        this.setActiveHeader(true);
      }
    }
    onFocusOut(e) {
      if (this.getGui().contains(e.relatedTarget)) {
        return;
      }
      this.setActiveHeader(false);
    }
    setupTooltip(value, shouldDisplayTooltip) {
      if (this.tooltipFeature) {
        this.tooltipFeature = this.destroyBean(this.tooltipFeature);
      }
      const isTooltipWhenTruncated = this.gos.get("tooltipShowMode") === "whenTruncated";
      const eGui = this.eGui;
      const colDef = this.column.getColDef();
      if (!shouldDisplayTooltip && isTooltipWhenTruncated && !colDef.headerComponent) {
        shouldDisplayTooltip = () => {
          const textEl = eGui.querySelector(".ag-header-cell-text");
          if (!textEl) {
            return true;
          }
          return textEl.scrollWidth > textEl.clientWidth;
        };
      }
      const tooltipCtrl = {
        getColumn: () => this.column,
        getColDef: () => this.column.getColDef(),
        getGui: () => eGui,
        getLocation: () => "header",
        getTooltipValue: () => {
          if (value != null) {
            return value;
          }
          const res = this.column.getColDef().headerTooltip;
          return res;
        },
        shouldDisplayTooltip
      };
      const tooltipFeature = this.createManagedBean(new TooltipFeature(tooltipCtrl));
      this.refreshFunctions.push(() => tooltipFeature.refreshToolTip());
    }
    setupClassesFromColDef() {
      const refreshHeaderClasses = () => {
        const colDef = this.column.getColDef();
        const classes = CssClassApplier.getHeaderClassesFromColDef(colDef, this.gos, this.column, null);
        const oldClasses = this.userHeaderClasses;
        this.userHeaderClasses = new Set(classes);
        classes.forEach((c) => {
          if (oldClasses.has(c)) {
            oldClasses.delete(c);
          } else {
            this.comp.addOrRemoveCssClass(c, true);
          }
        });
        oldClasses.forEach((c) => this.comp.addOrRemoveCssClass(c, false));
      };
      this.refreshFunctions.push(refreshHeaderClasses);
      refreshHeaderClasses();
    }
    setDragSource(eSource) {
      this.dragSourceElement = eSource;
      this.removeDragSource();
      if (!eSource || !this.draggable) {
        return;
      }
      const { column, beans, displayName, dragAndDropService, gos } = this;
      const { columnModel } = beans;
      let hideColumnOnExit = !this.gos.get("suppressDragLeaveHidesColumns");
      const dragSource = this.dragSource = {
        type: 1,
        eElement: eSource,
        getDefaultIconName: () => hideColumnOnExit ? DragAndDropService.ICON_HIDE : DragAndDropService.ICON_NOT_ALLOWED,
        getDragItem: () => this.createDragItem(column),
        dragItemName: displayName,
        onDragStarted: () => {
          hideColumnOnExit = !gos.get("suppressDragLeaveHidesColumns");
          column.setMoving(true, "uiColumnMoved");
        },
        onDragStopped: () => column.setMoving(false, "uiColumnMoved"),
        onGridEnter: (dragItem) => {
          var _a;
          if (hideColumnOnExit) {
            const unlockedColumns = ((_a = dragItem == null ? void 0 : dragItem.columns) == null ? void 0 : _a.filter((col) => !col.getColDef().lockVisible)) || [];
            columnModel.setColumnsVisible(unlockedColumns, true, "uiColumnMoved");
          }
        },
        onGridExit: (dragItem) => {
          var _a;
          if (hideColumnOnExit) {
            const unlockedColumns = ((_a = dragItem == null ? void 0 : dragItem.columns) == null ? void 0 : _a.filter((col) => !col.getColDef().lockVisible)) || [];
            columnModel.setColumnsVisible(unlockedColumns, false, "uiColumnMoved");
          }
        }
      };
      dragAndDropService.addDragSource(dragSource, true);
    }
    createDragItem(column) {
      const visibleState = {};
      visibleState[column.getId()] = column.isVisible();
      return {
        columns: [column],
        visibleState
      };
    }
    updateState() {
      this.menuEnabled = this.menuService.isColumnMenuInHeaderEnabled(this.column);
      this.openFilterEnabled = this.menuService.isFilterMenuInHeaderEnabled(this.column);
      this.sortable = this.column.isSortable();
      this.displayName = this.calculateDisplayName();
      this.draggable = this.workOutDraggable();
    }
    addRefreshFunction(func) {
      this.refreshFunctions.push(func);
    }
    refresh() {
      this.updateState();
      this.refreshHeaderComp();
      this.refreshAria();
      this.refreshFunctions.forEach((f) => f());
    }
    refreshHeaderComp() {
      const newCompDetails = this.lookupUserCompDetails();
      const compInstance = this.comp.getUserCompInstance();
      const attemptRefresh = compInstance != null && this.userCompDetails.componentClass == newCompDetails.componentClass;
      const headerCompRefreshed = attemptRefresh ? this.attemptHeaderCompRefresh(newCompDetails.params) : false;
      if (headerCompRefreshed) {
        this.setDragSource(this.dragSourceElement);
      } else {
        this.setCompDetails(newCompDetails);
      }
    }
    attemptHeaderCompRefresh(params) {
      const headerComp = this.comp.getUserCompInstance();
      if (!headerComp) {
        return false;
      }
      if (!headerComp.refresh) {
        return false;
      }
      const res = headerComp.refresh(params);
      return res;
    }
    calculateDisplayName() {
      return this.beans.columnModel.getDisplayNameForColumn(this.column, "header", true);
    }
    checkDisplayName() {
      if (this.displayName !== this.calculateDisplayName()) {
        this.refresh();
      }
    }
    workOutDraggable() {
      const colDef = this.column.getColDef();
      const isSuppressMovableColumns = this.gos.get("suppressMovableColumns");
      const colCanMove = !isSuppressMovableColumns && !colDef.suppressMovable && !colDef.lockPosition;
      return !!colCanMove || !!colDef.enableRowGroup || !!colDef.enablePivot;
    }
    onColumnRowGroupChanged() {
      this.checkDisplayName();
    }
    onColumnPivotChanged() {
      this.checkDisplayName();
    }
    onColumnValueChanged() {
      this.checkDisplayName();
    }
    setupWidth() {
      const listener = () => {
        const columnWidth = this.column.getActualWidth();
        this.comp.setWidth(`${columnWidth}px`);
      };
      this.addManagedListener(this.column, Column.EVENT_WIDTH_CHANGED, listener);
      listener();
    }
    setupMovingCss() {
      const listener = () => {
        this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
      };
      this.addManagedListener(this.column, Column.EVENT_MOVING_CHANGED, listener);
      listener();
    }
    setupMenuClass() {
      const listener = () => {
        this.comp.addOrRemoveCssClass("ag-column-menu-visible", this.column.isMenuVisible());
      };
      this.addManagedListener(this.column, Column.EVENT_MENU_VISIBLE_CHANGED, listener);
      listener();
    }
    setupSortableClass() {
      const updateSortableCssClass = () => {
        this.comp.addOrRemoveCssClass("ag-header-cell-sortable", !!this.sortable);
      };
      updateSortableCssClass();
      this.addRefreshFunction(updateSortableCssClass);
      this.addManagedListener(this.eventService, Column.EVENT_SORT_CHANGED, this.refreshAriaSort.bind(this));
    }
    setupFilterClass() {
      const listener = () => {
        const isFilterActive = this.column.isFilterActive();
        this.comp.addOrRemoveCssClass("ag-header-cell-filtered", isFilterActive);
        this.refreshAria();
      };
      this.addManagedListener(this.column, Column.EVENT_FILTER_ACTIVE_CHANGED, listener);
      listener();
    }
    setupWrapTextClass() {
      const listener = () => {
        const wrapText = !!this.column.getColDef().wrapHeaderText;
        this.comp.addOrRemoveCssClass("ag-header-cell-wrap-text", wrapText);
      };
      listener();
      this.addRefreshFunction(listener);
    }
    onDisplayedColumnsChanged() {
      super.onDisplayedColumnsChanged();
      if (!this.isAlive()) {
        return;
      }
      this.onHeaderHeightChanged();
    }
    onHeaderHeightChanged() {
      this.refreshSpanHeaderHeight();
    }
    refreshSpanHeaderHeight() {
      const { eGui, column, comp, beans } = this;
      if (!column.isSpanHeaderHeight()) {
        eGui.style.removeProperty("top");
        eGui.style.removeProperty("height");
        comp.addOrRemoveCssClass("ag-header-span-height", false);
        comp.addOrRemoveCssClass("ag-header-span-total", false);
        return;
      }
      const { numberOfParents, isSpanningTotal } = this.column.getColumnGroupPaddingInfo();
      comp.addOrRemoveCssClass("ag-header-span-height", numberOfParents > 0);
      const { columnModel } = beans;
      const headerHeight = columnModel.getColumnHeaderRowHeight();
      if (numberOfParents === 0) {
        comp.addOrRemoveCssClass("ag-header-span-total", false);
        eGui.style.setProperty("top", `0px`);
        eGui.style.setProperty("height", `${headerHeight}px`);
        return;
      }
      comp.addOrRemoveCssClass("ag-header-span-total", isSpanningTotal);
      const pivotMode = columnModel.isPivotMode();
      const groupHeaderHeight = pivotMode ? columnModel.getPivotGroupHeaderHeight() : columnModel.getGroupHeaderHeight();
      const extraHeight = numberOfParents * groupHeaderHeight;
      eGui.style.setProperty("top", `${-extraHeight}px`);
      eGui.style.setProperty("height", `${headerHeight + extraHeight}px`);
    }
    setupAutoHeight(wrapperElement) {
      const { columnModel, resizeObserverService } = this.beans;
      const measureHeight = (timesCalled) => {
        if (!this.isAlive()) {
          return;
        }
        const { paddingTop, paddingBottom, borderBottomWidth, borderTopWidth } = getElementSize(this.getGui());
        const extraHeight = paddingTop + paddingBottom + borderBottomWidth + borderTopWidth;
        const wrapperHeight = wrapperElement.offsetHeight;
        const autoHeight = wrapperHeight + extraHeight;
        if (timesCalled < 5) {
          const doc2 = this.beans.gos.getDocument();
          const notYetInDom = !doc2 || !doc2.contains(wrapperElement);
          const possiblyNoContentYet = autoHeight == 0;
          if (notYetInDom || possiblyNoContentYet) {
            window.setTimeout(() => measureHeight(timesCalled + 1), 0);
            return;
          }
        }
        columnModel.setColumnHeaderHeight(this.column, autoHeight);
      };
      let isMeasuring = false;
      let stopResizeObserver;
      const checkMeasuring = () => {
        const newValue = this.column.isAutoHeaderHeight();
        if (newValue && !isMeasuring) {
          startMeasuring();
        }
        if (!newValue && isMeasuring) {
          stopMeasuring();
        }
      };
      const startMeasuring = () => {
        isMeasuring = true;
        measureHeight(0);
        this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", true);
        stopResizeObserver = resizeObserverService.observeResize(wrapperElement, () => measureHeight(0));
      };
      const stopMeasuring = () => {
        isMeasuring = false;
        if (stopResizeObserver) {
          stopResizeObserver();
        }
        this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", false);
        stopResizeObserver = void 0;
      };
      checkMeasuring();
      this.addDestroyFunc(() => stopMeasuring());
      this.addManagedListener(this.column, Column.EVENT_WIDTH_CHANGED, () => isMeasuring && measureHeight(0));
      this.addManagedListener(this.eventService, Column.EVENT_SORT_CHANGED, () => {
        if (isMeasuring) {
          window.setTimeout(() => measureHeight(0));
        }
      });
      this.addRefreshFunction(checkMeasuring);
    }
    refreshAriaSort() {
      if (this.sortable) {
        const translate = this.localeService.getLocaleTextFunc();
        const sort = this.beans.sortController.getDisplaySortForColumn(this.column) || null;
        this.comp.setAriaSort(getAriaSortState(sort));
        this.setAriaDescriptionProperty("sort", translate("ariaSortableColumn", "Press ENTER to sort"));
      } else {
        this.comp.setAriaSort();
        this.setAriaDescriptionProperty("sort", null);
      }
    }
    refreshAriaMenu() {
      if (this.menuEnabled) {
        const translate = this.localeService.getLocaleTextFunc();
        this.setAriaDescriptionProperty("menu", translate("ariaMenuColumn", "Press ALT DOWN to open column menu"));
      } else {
        this.setAriaDescriptionProperty("menu", null);
      }
    }
    refreshAriaFilterButton() {
      if (this.openFilterEnabled && !this.menuService.isLegacyMenuEnabled()) {
        const translate = this.localeService.getLocaleTextFunc();
        this.setAriaDescriptionProperty("filterButton", translate("ariaFilterColumn", "Press CTRL ENTER to open filter"));
      } else {
        this.setAriaDescriptionProperty("filterButton", null);
      }
    }
    refreshAriaFiltered() {
      const translate = this.localeService.getLocaleTextFunc();
      const isFilterActive = this.column.isFilterActive();
      if (isFilterActive) {
        this.setAriaDescriptionProperty("filter", translate("ariaColumnFiltered", "Column Filtered"));
      } else {
        this.setAriaDescriptionProperty("filter", null);
      }
    }
    setAriaDescriptionProperty(property, value) {
      if (value != null) {
        this.ariaDescriptionProperties.set(property, value);
      } else {
        this.ariaDescriptionProperties.delete(property);
      }
    }
    announceAriaDescription() {
      if (!this.eGui.contains(this.beans.gos.getActiveDomElement())) {
        return;
      }
      const ariaDescription = Array.from(this.ariaDescriptionProperties.keys()).sort((a, b) => a === "filter" ? -1 : b.charCodeAt(0) - a.charCodeAt(0)).map((key) => this.ariaDescriptionProperties.get(key)).join(". ");
      this.beans.ariaAnnouncementService.announceValue(ariaDescription);
    }
    refreshAria() {
      this.refreshAriaSort();
      this.refreshAriaMenu();
      this.refreshAriaFilterButton();
      this.refreshAriaFiltered();
    }
    addColumnHoverListener() {
      const listener = () => {
        if (!this.gos.get("columnHoverHighlight")) {
          return;
        }
        const isHovered = this.beans.columnHoverService.isHovered(this.column);
        this.comp.addOrRemoveCssClass("ag-column-hover", isHovered);
      };
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_HOVER_CHANGED, listener);
      listener();
    }
    getColId() {
      return this.column.getColId();
    }
    addActiveHeaderMouseListeners() {
      const listener = (e) => this.handleMouseOverChange(e.type === "mouseenter");
      const clickListener = () => this.dispatchColumnMouseEvent(Events.EVENT_COLUMN_HEADER_CLICKED, this.column);
      const contextMenuListener = (event) => this.handleContextMenuMouseEvent(event, void 0, this.column);
      this.addManagedListener(this.getGui(), "mouseenter", listener);
      this.addManagedListener(this.getGui(), "mouseleave", listener);
      this.addManagedListener(this.getGui(), "click", clickListener);
      this.addManagedListener(this.getGui(), "contextmenu", contextMenuListener);
    }
    handleMouseOverChange(isMouseOver) {
      this.setActiveHeader(isMouseOver);
      const eventType = isMouseOver ? Events.EVENT_COLUMN_HEADER_MOUSE_OVER : Events.EVENT_COLUMN_HEADER_MOUSE_LEAVE;
      const event = {
        type: eventType,
        column: this.column
      };
      this.eventService.dispatchEvent(event);
    }
    setActiveHeader(active) {
      this.comp.addOrRemoveCssClass("ag-header-active", active);
    }
    getAnchorElementForMenu(isFilter) {
      const headerComp = this.comp.getUserCompInstance();
      if (headerComp instanceof HeaderComp) {
        return headerComp.getAnchorElementForMenu(isFilter);
      }
      return this.getGui();
    }
    destroy() {
      super.destroy();
      this.refreshFunctions = null;
      this.selectAllFeature = null;
      this.dragSourceElement = null;
      this.userCompDetails = null;
      this.userHeaderClasses = null;
      this.ariaDescriptionProperties = null;
    }
  };
  var GroupResizeFeature = class extends BeanStub {
    constructor(comp, eResize, pinned, columnGroup) {
      super();
      this.eResize = eResize;
      this.comp = comp;
      this.pinned = pinned;
      this.columnGroup = columnGroup;
    }
    postConstruct() {
      if (!this.columnGroup.isResizable()) {
        this.comp.setResizableDisplayed(false);
        return;
      }
      const finishedWithResizeFunc = this.horizontalResizeService.addResizeBar({
        eResizeBar: this.eResize,
        onResizeStart: this.onResizeStart.bind(this),
        onResizing: this.onResizing.bind(this, false),
        onResizeEnd: this.onResizing.bind(this, true)
      });
      this.addDestroyFunc(finishedWithResizeFunc);
      if (!this.gos.get("suppressAutoSize")) {
        const skipHeaderOnAutoSize = this.gos.get("skipHeaderOnAutoSize");
        this.eResize.addEventListener("dblclick", () => {
          const keys2 = [];
          const leafCols = this.columnGroup.getDisplayedLeafColumns();
          leafCols.forEach((column) => {
            if (!column.getColDef().suppressAutoSize) {
              keys2.push(column.getColId());
            }
          });
          if (keys2.length > 0) {
            this.columnModel.autoSizeColumns({
              columns: keys2,
              skipHeader: skipHeaderOnAutoSize,
              stopAtGroup: this.columnGroup,
              source: "uiColumnResized"
            });
          }
          this.resizeLeafColumnsToFit("uiColumnResized");
        });
      }
    }
    onResizeStart(shiftKey) {
      const initialValues = this.getInitialValues(shiftKey);
      this.storeLocalValues(initialValues);
      this.toggleColumnResizing(true);
    }
    onResizing(finished, resizeAmount, source = "uiColumnResized") {
      const resizeAmountNormalised = this.normaliseDragChange(resizeAmount);
      const width = this.resizeStartWidth + resizeAmountNormalised;
      this.resizeColumnsFromLocalValues(width, source, finished);
    }
    getInitialValues(shiftKey) {
      const columnsToResize = this.getColumnsToResize();
      const resizeStartWidth = this.getInitialSizeOfColumns(columnsToResize);
      const resizeRatios = this.getSizeRatiosOfColumns(columnsToResize, resizeStartWidth);
      const columnSizeAndRatios = {
        columnsToResize,
        resizeStartWidth,
        resizeRatios
      };
      let groupAfter = null;
      if (shiftKey) {
        groupAfter = this.columnModel.getDisplayedGroupAtDirection(this.columnGroup, "After");
      }
      if (groupAfter) {
        const takeFromLeafCols = groupAfter.getDisplayedLeafColumns();
        const groupAfterColumns = columnSizeAndRatios.groupAfterColumns = takeFromLeafCols.filter((col) => col.isResizable());
        const groupAfterStartWidth = columnSizeAndRatios.groupAfterStartWidth = this.getInitialSizeOfColumns(groupAfterColumns);
        columnSizeAndRatios.groupAfterRatios = this.getSizeRatiosOfColumns(groupAfterColumns, groupAfterStartWidth);
      } else {
        columnSizeAndRatios.groupAfterColumns = void 0;
        columnSizeAndRatios.groupAfterStartWidth = void 0;
        columnSizeAndRatios.groupAfterRatios = void 0;
      }
      return columnSizeAndRatios;
    }
    storeLocalValues(initialValues) {
      const {
        columnsToResize,
        resizeStartWidth,
        resizeRatios,
        groupAfterColumns,
        groupAfterStartWidth,
        groupAfterRatios
      } = initialValues;
      this.resizeCols = columnsToResize;
      this.resizeStartWidth = resizeStartWidth;
      this.resizeRatios = resizeRatios;
      this.resizeTakeFromCols = groupAfterColumns;
      this.resizeTakeFromStartWidth = groupAfterStartWidth;
      this.resizeTakeFromRatios = groupAfterRatios;
    }
    clearLocalValues() {
      this.resizeCols = void 0;
      this.resizeRatios = void 0;
      this.resizeTakeFromCols = void 0;
      this.resizeTakeFromRatios = void 0;
    }
    resizeLeafColumnsToFit(source) {
      const preferredSize = this.autoWidthCalculator.getPreferredWidthForColumnGroup(this.columnGroup);
      const initialValues = this.getInitialValues();
      if (preferredSize > initialValues.resizeStartWidth) {
        this.resizeColumns(initialValues, preferredSize, source, true);
      }
    }
    resizeColumnsFromLocalValues(totalWidth, source, finished = true) {
      var _a, _b, _c;
      if (!this.resizeCols || !this.resizeRatios) {
        return;
      }
      const initialValues = {
        columnsToResize: this.resizeCols,
        resizeStartWidth: this.resizeStartWidth,
        resizeRatios: this.resizeRatios,
        groupAfterColumns: (_a = this.resizeTakeFromCols) != null ? _a : void 0,
        groupAfterStartWidth: (_b = this.resizeTakeFromStartWidth) != null ? _b : void 0,
        groupAfterRatios: (_c = this.resizeTakeFromRatios) != null ? _c : void 0
      };
      this.resizeColumns(initialValues, totalWidth, source, finished);
    }
    resizeColumns(initialValues, totalWidth, source, finished = true) {
      const {
        columnsToResize,
        resizeStartWidth,
        resizeRatios,
        groupAfterColumns,
        groupAfterStartWidth,
        groupAfterRatios
      } = initialValues;
      const resizeSets = [];
      resizeSets.push({
        columns: columnsToResize,
        ratios: resizeRatios,
        width: totalWidth
      });
      if (groupAfterColumns) {
        const diff = totalWidth - resizeStartWidth;
        resizeSets.push({
          columns: groupAfterColumns,
          ratios: groupAfterRatios,
          width: groupAfterStartWidth - diff
        });
      }
      this.columnModel.resizeColumnSets({
        resizeSets,
        finished,
        source
      });
      if (finished) {
        this.toggleColumnResizing(false);
      }
    }
    toggleColumnResizing(resizing) {
      this.comp.addOrRemoveCssClass("ag-column-resizing", resizing);
    }
    getColumnsToResize() {
      const leafCols = this.columnGroup.getDisplayedLeafColumns();
      return leafCols.filter((col) => col.isResizable());
    }
    getInitialSizeOfColumns(columns) {
      return columns.reduce(
        (totalWidth, column) => totalWidth + column.getActualWidth(),
        0
      );
    }
    getSizeRatiosOfColumns(columns, initialSizeOfColumns) {
      return columns.map((column) => column.getActualWidth() / initialSizeOfColumns);
    }
    // optionally inverts the drag, depending on pinned and RTL
    // note - this method is duplicated in RenderedHeaderCell - should refactor out?
    normaliseDragChange(dragChange) {
      let result = dragChange;
      if (this.gos.get("enableRtl")) {
        if (this.pinned !== "left") {
          result *= -1;
        }
      } else if (this.pinned === "right") {
        result *= -1;
      }
      return result;
    }
    destroy() {
      super.destroy();
      this.clearLocalValues();
    }
  };
  __decorateClass([
    Autowired("horizontalResizeService")
  ], GroupResizeFeature.prototype, "horizontalResizeService", 2);
  __decorateClass([
    Autowired("autoWidthCalculator")
  ], GroupResizeFeature.prototype, "autoWidthCalculator", 2);
  __decorateClass([
    Autowired("columnModel")
  ], GroupResizeFeature.prototype, "columnModel", 2);
  __decorateClass([
    PostConstruct
  ], GroupResizeFeature.prototype, "postConstruct", 1);
  var GroupWidthFeature = class extends BeanStub {
    constructor(comp, columnGroup) {
      super();
      this.removeChildListenersFuncs = [];
      this.columnGroup = columnGroup;
      this.comp = comp;
    }
    postConstruct() {
      this.addListenersToChildrenColumns();
      this.addManagedListener(this.columnGroup, ColumnGroup.EVENT_DISPLAYED_CHILDREN_CHANGED, this.onDisplayedChildrenChanged.bind(this));
      this.onWidthChanged();
      this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
    }
    addListenersToChildrenColumns() {
      this.removeListenersOnChildrenColumns();
      const widthChangedListener = this.onWidthChanged.bind(this);
      this.columnGroup.getLeafColumns().forEach((column) => {
        column.addEventListener("widthChanged", widthChangedListener);
        column.addEventListener("visibleChanged", widthChangedListener);
        this.removeChildListenersFuncs.push(() => {
          column.removeEventListener("widthChanged", widthChangedListener);
          column.removeEventListener("visibleChanged", widthChangedListener);
        });
      });
    }
    removeListenersOnChildrenColumns() {
      this.removeChildListenersFuncs.forEach((func) => func());
      this.removeChildListenersFuncs = [];
    }
    onDisplayedChildrenChanged() {
      this.addListenersToChildrenColumns();
      this.onWidthChanged();
    }
    onWidthChanged() {
      const columnWidth = this.columnGroup.getActualWidth();
      this.comp.setWidth(`${columnWidth}px`);
      this.comp.addOrRemoveCssClass("ag-hidden", columnWidth === 0);
    }
  };
  __decorateClass([
    PostConstruct
  ], GroupWidthFeature.prototype, "postConstruct", 1);
  var HeaderGroupCellCtrl = class extends AbstractHeaderCellCtrl {
    constructor(columnGroup, beans, parentRowCtrl) {
      super(columnGroup, beans, parentRowCtrl);
      this.onSuppressColMoveChange = () => {
        if (!this.isAlive() || this.isSuppressMoving()) {
          this.removeDragSource();
        } else {
          if (!this.dragSource) {
            const eGui = this.getGui();
            this.setDragSource(eGui);
          }
        }
      };
      this.column = columnGroup;
    }
    setComp(comp, eGui, eResize) {
      this.comp = comp;
      this.setGui(eGui);
      this.displayName = this.beans.columnModel.getDisplayNameForColumnGroup(this.column, "header");
      this.addClasses();
      this.setupMovingCss();
      this.setupExpandable();
      this.setupTooltip();
      this.addDestroyFunc(() => {
        if (this.tooltipFeature) {
          this.tooltipFeature = this.destroyBean(this.tooltipFeature);
        }
      });
      this.setupUserComp();
      this.addHeaderMouseListeners();
      const pinned = this.getParentRowCtrl().getPinned();
      const leafCols = this.column.getProvidedColumnGroup().getLeafColumns();
      this.createManagedBean(new HoverFeature(leafCols, eGui));
      this.createManagedBean(new SetLeftFeature(this.column, eGui, this.beans));
      this.createManagedBean(new GroupWidthFeature(comp, this.column));
      this.resizeFeature = this.createManagedBean(new GroupResizeFeature(comp, eResize, pinned, this.column));
      this.createManagedBean(new ManagedFocusFeature(
        eGui,
        {
          shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
          onTabKeyDown: () => void 0,
          handleKeyDown: this.handleKeyDown.bind(this),
          onFocusIn: this.onFocusIn.bind(this)
        }
      ));
      this.addManagedPropertyListener(Events.EVENT_SUPPRESS_COLUMN_MOVE_CHANGED, this.onSuppressColMoveChange);
      this.addResizeAndMoveKeyboardListeners();
    }
    resizeHeader(delta, shiftKey) {
      if (!this.resizeFeature) {
        return;
      }
      const initialValues = this.resizeFeature.getInitialValues(shiftKey);
      this.resizeFeature.resizeColumns(initialValues, initialValues.resizeStartWidth + delta, "uiColumnResized", true);
    }
    moveHeader(hDirection) {
      const { beans, eGui, column, gos, ctrlsService } = this;
      const isRtl = gos.get("enableRtl");
      const isLeft = hDirection === 0;
      const pinned = this.getPinned();
      const rect = eGui.getBoundingClientRect();
      const left = rect.left;
      const width = rect.width;
      const xPosition = ColumnMoveHelper.normaliseX(
        isLeft !== isRtl ? left - 20 : left + width + 20,
        pinned,
        true,
        gos,
        ctrlsService
      );
      const id = column.getGroupId();
      const headerPosition = this.focusService.getFocusedHeader();
      ColumnMoveHelper.attemptMoveColumns({
        allMovingColumns: this.column.getLeafColumns(),
        isFromHeader: true,
        hDirection,
        xPosition,
        pinned,
        fromEnter: false,
        fakeEvent: false,
        gos,
        columnModel: beans.columnModel
      });
      const displayedLeafColumns = column.getDisplayedLeafColumns();
      const targetColumn = isLeft ? displayedLeafColumns[0] : last(displayedLeafColumns);
      this.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(targetColumn, "auto");
      if (!this.isAlive() && headerPosition) {
        this.restoreFocus(id, column, headerPosition);
      }
    }
    restoreFocus(groupId, previousColumnGroup, previousPosition) {
      const leafCols = previousColumnGroup.getLeafColumns();
      if (!leafCols.length) {
        return;
      }
      const parent = leafCols[0].getParent();
      if (!parent) {
        return;
      }
      const newColumnGroup = this.findGroupWidthId(parent, groupId);
      if (newColumnGroup) {
        this.focusService.focusHeaderPosition({
          headerPosition: __spreadProps(__spreadValues({}, previousPosition), {
            column: newColumnGroup
          })
        });
      }
    }
    findGroupWidthId(columnGroup, id) {
      while (columnGroup) {
        if (columnGroup.getGroupId() === id) {
          return columnGroup;
        }
        columnGroup = columnGroup.getParent();
      }
      return null;
    }
    resizeLeafColumnsToFit(source) {
      if (!this.resizeFeature) {
        return;
      }
      this.resizeFeature.resizeLeafColumnsToFit(source);
    }
    setupUserComp() {
      const params = this.gos.addGridCommonParams({
        displayName: this.displayName,
        columnGroup: this.column,
        setExpanded: (expanded) => {
          this.beans.columnModel.setColumnGroupOpened(this.column.getProvidedColumnGroup(), expanded, "gridInitializing");
        },
        setTooltip: (value, shouldDisplayTooltip) => {
          this.setupTooltip(value, shouldDisplayTooltip);
        }
      });
      const compDetails = this.userComponentFactory.getHeaderGroupCompDetails(params);
      this.comp.setUserCompDetails(compDetails);
    }
    addHeaderMouseListeners() {
      const listener = (e) => this.handleMouseOverChange(e.type === "mouseenter");
      const clickListener = () => this.dispatchColumnMouseEvent(Events.EVENT_COLUMN_HEADER_CLICKED, this.column.getProvidedColumnGroup());
      const contextMenuListener = (event) => this.handleContextMenuMouseEvent(event, void 0, this.column.getProvidedColumnGroup());
      this.addManagedListener(this.getGui(), "mouseenter", listener);
      this.addManagedListener(this.getGui(), "mouseleave", listener);
      this.addManagedListener(this.getGui(), "click", clickListener);
      this.addManagedListener(this.getGui(), "contextmenu", contextMenuListener);
    }
    handleMouseOverChange(isMouseOver) {
      const eventType = isMouseOver ? Events.EVENT_COLUMN_HEADER_MOUSE_OVER : Events.EVENT_COLUMN_HEADER_MOUSE_LEAVE;
      const event = {
        type: eventType,
        column: this.column.getProvidedColumnGroup()
      };
      this.eventService.dispatchEvent(event);
    }
    setupTooltip(value, shouldDisplayTooltip) {
      if (this.tooltipFeature) {
        this.tooltipFeature = this.destroyBean(this.tooltipFeature);
      }
      const colGroupDef = this.column.getColGroupDef();
      const isTooltipWhenTruncated = this.gos.get("tooltipShowMode") === "whenTruncated";
      const eGui = this.eGui;
      if (!shouldDisplayTooltip && isTooltipWhenTruncated && !(colGroupDef == null ? void 0 : colGroupDef.headerGroupComponent)) {
        shouldDisplayTooltip = () => {
          const textEl = eGui.querySelector(".ag-header-group-text");
          if (!textEl) {
            return true;
          }
          return textEl.scrollWidth > textEl.clientWidth;
        };
      }
      const tooltipCtrl = {
        getColumn: () => this.column,
        getGui: () => eGui,
        getLocation: () => "headerGroup",
        getTooltipValue: () => value != null ? value : colGroupDef && colGroupDef.headerTooltip,
        shouldDisplayTooltip
      };
      if (colGroupDef) {
        tooltipCtrl.getColDef = () => colGroupDef;
      }
      this.createBean(new TooltipFeature(tooltipCtrl));
    }
    setupExpandable() {
      const providedColGroup = this.column.getProvidedColumnGroup();
      this.refreshExpanded();
      this.addManagedListener(providedColGroup, ProvidedColumnGroup.EVENT_EXPANDABLE_CHANGED, this.refreshExpanded.bind(this));
      this.addManagedListener(providedColGroup, ProvidedColumnGroup.EVENT_EXPANDED_CHANGED, this.refreshExpanded.bind(this));
    }
    refreshExpanded() {
      const column = this.column;
      this.expandable = column.isExpandable();
      const expanded = column.isExpanded();
      if (this.expandable) {
        this.comp.setAriaExpanded(expanded ? "true" : "false");
      } else {
        this.comp.setAriaExpanded(void 0);
      }
    }
    getColId() {
      return this.column.getUniqueId();
    }
    addClasses() {
      const colGroupDef = this.column.getColGroupDef();
      const classes = CssClassApplier.getHeaderClassesFromColDef(colGroupDef, this.gos, null, this.column);
      if (this.column.isPadding()) {
        classes.push("ag-header-group-cell-no-group");
        const leafCols = this.column.getLeafColumns();
        if (leafCols.every((col) => col.isSpanHeaderHeight())) {
          classes.push("ag-header-span-height");
        }
      } else {
        classes.push("ag-header-group-cell-with-group");
      }
      classes.forEach((c) => this.comp.addOrRemoveCssClass(c, true));
    }
    setupMovingCss() {
      const providedColumnGroup = this.column.getProvidedColumnGroup();
      const leafColumns = providedColumnGroup.getLeafColumns();
      const listener = () => this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
      leafColumns.forEach((col) => {
        this.addManagedListener(col, Column.EVENT_MOVING_CHANGED, listener);
      });
      listener();
    }
    onFocusIn(e) {
      if (!this.eGui.contains(e.relatedTarget)) {
        const rowIndex = this.getRowIndex();
        this.beans.focusService.setFocusedHeader(rowIndex, this.column);
      }
    }
    handleKeyDown(e) {
      super.handleKeyDown(e);
      const wrapperHasFocus = this.getWrapperHasFocus();
      if (!this.expandable || !wrapperHasFocus) {
        return;
      }
      if (e.key === KeyCode.ENTER) {
        const column = this.column;
        const newExpandedValue = !column.isExpanded();
        this.beans.columnModel.setColumnGroupOpened(column.getProvidedColumnGroup(), newExpandedValue, "uiColumnExpanded");
      }
    }
    // unlike columns, this will only get called once, as we don't react on props on column groups
    // (we will always destroy and recreate this comp if something changes)
    setDragSource(eHeaderGroup) {
      if (!this.isAlive() || this.isSuppressMoving()) {
        return;
      }
      this.removeDragSource();
      if (!eHeaderGroup) {
        return;
      }
      const { beans, column, displayName, gos, dragAndDropService } = this;
      const { columnModel } = beans;
      const allLeafColumns = column.getProvidedColumnGroup().getLeafColumns();
      let hideColumnOnExit = !gos.get("suppressDragLeaveHidesColumns");
      const dragSource = this.dragSource = {
        type: 1,
        eElement: eHeaderGroup,
        getDefaultIconName: () => hideColumnOnExit ? DragAndDropService.ICON_HIDE : DragAndDropService.ICON_NOT_ALLOWED,
        dragItemName: displayName,
        // we add in the original group leaf columns, so we move both visible and non-visible items
        getDragItem: () => this.getDragItemForGroup(column),
        onDragStarted: () => {
          hideColumnOnExit = !gos.get("suppressDragLeaveHidesColumns");
          allLeafColumns.forEach((col) => col.setMoving(true, "uiColumnDragged"));
        },
        onDragStopped: () => allLeafColumns.forEach((col) => col.setMoving(false, "uiColumnDragged")),
        onGridEnter: (dragItem) => {
          var _a;
          if (hideColumnOnExit) {
            const unlockedColumns = ((_a = dragItem == null ? void 0 : dragItem.columns) == null ? void 0 : _a.filter((col) => !col.getColDef().lockVisible)) || [];
            columnModel.setColumnsVisible(unlockedColumns, true, "uiColumnMoved");
          }
        },
        onGridExit: (dragItem) => {
          var _a;
          if (hideColumnOnExit) {
            const unlockedColumns = ((_a = dragItem == null ? void 0 : dragItem.columns) == null ? void 0 : _a.filter((col) => !col.getColDef().lockVisible)) || [];
            columnModel.setColumnsVisible(unlockedColumns, false, "uiColumnMoved");
          }
        }
      };
      dragAndDropService.addDragSource(dragSource, true);
    }
    // when moving the columns, we want to move all the columns (contained within the DragItem) in this group in one go,
    // and in the order they are currently in the screen.
    getDragItemForGroup(columnGroup) {
      const allColumnsOriginalOrder = columnGroup.getProvidedColumnGroup().getLeafColumns();
      const visibleState = {};
      allColumnsOriginalOrder.forEach((column) => visibleState[column.getId()] = column.isVisible());
      const allColumnsCurrentOrder = [];
      this.beans.columnModel.getAllDisplayedColumns().forEach((column) => {
        if (allColumnsOriginalOrder.indexOf(column) >= 0) {
          allColumnsCurrentOrder.push(column);
          removeFromArray(allColumnsOriginalOrder, column);
        }
      });
      allColumnsOriginalOrder.forEach((column) => allColumnsCurrentOrder.push(column));
      return {
        columns: allColumnsCurrentOrder,
        visibleState
      };
    }
    isSuppressMoving() {
      let childSuppressesMoving = false;
      this.column.getLeafColumns().forEach((column) => {
        if (column.getColDef().suppressMovable || column.getColDef().lockPosition) {
          childSuppressesMoving = true;
        }
      });
      const result = childSuppressesMoving || this.gos.get("suppressMovableColumns");
      return result;
    }
  };
  var instanceIdSequence5 = 0;
  var HeaderRowCtrl = class extends BeanStub {
    constructor(rowIndex, pinned, type) {
      super();
      this.instanceId = instanceIdSequence5++;
      this.rowIndex = rowIndex;
      this.pinned = pinned;
      this.type = type;
      const typeClass = type == "group" ? `ag-header-row-column-group` : type == "filter" ? `ag-header-row-column-filter` : `ag-header-row-column`;
      this.headerRowClass = `ag-header-row ${typeClass}`;
    }
    postConstruct() {
      this.isPrintLayout = this.gos.isDomLayout("print");
      this.isEnsureDomOrder = this.gos.get("ensureDomOrder");
    }
    getInstanceId() {
      return this.instanceId;
    }
    /**
     * 
     * @param comp Proxy to the actual component
     * @param initCompState Should the component be initialised with the current state of the controller. Default: true
     */
    setComp(comp, initCompState = true) {
      this.comp = comp;
      if (initCompState) {
        this.onRowHeightChanged();
        this.onVirtualColumnsChanged();
      }
      this.setWidth();
      this.addEventListeners();
    }
    getHeaderRowClass() {
      return this.headerRowClass;
    }
    getAriaRowIndex() {
      return this.rowIndex + 1;
    }
    addEventListeners() {
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_RESIZED, this.onColumnResized.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_VIRTUAL_COLUMNS_CHANGED, (params) => this.onVirtualColumnsChanged(params.afterScroll));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_HEADER_HEIGHT_CHANGED, this.onRowHeightChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_GRID_STYLES_CHANGED, this.onRowHeightChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_ADVANCED_FILTER_ENABLED_CHANGED, this.onRowHeightChanged.bind(this));
      this.addManagedPropertyListener("domLayout", this.onDisplayedColumnsChanged.bind(this));
      this.addManagedPropertyListener("ensureDomOrder", (e) => this.isEnsureDomOrder = e.currentValue);
      this.addManagedPropertyListener("headerHeight", this.onRowHeightChanged.bind(this));
      this.addManagedPropertyListener("pivotHeaderHeight", this.onRowHeightChanged.bind(this));
      this.addManagedPropertyListener("groupHeaderHeight", this.onRowHeightChanged.bind(this));
      this.addManagedPropertyListener("pivotGroupHeaderHeight", this.onRowHeightChanged.bind(this));
      this.addManagedPropertyListener("floatingFiltersHeight", this.onRowHeightChanged.bind(this));
    }
    getHeaderCellCtrl(column) {
      if (!this.headerCellCtrls) {
        return;
      }
      return values(this.headerCellCtrls).find((cellCtrl) => cellCtrl.getColumnGroupChild() === column);
    }
    onDisplayedColumnsChanged() {
      this.isPrintLayout = this.gos.isDomLayout("print");
      this.onVirtualColumnsChanged();
      this.setWidth();
      this.onRowHeightChanged();
    }
    getType() {
      return this.type;
    }
    onColumnResized() {
      this.setWidth();
    }
    setWidth() {
      const width = this.getWidthForRow();
      this.comp.setWidth(`${width}px`);
    }
    getWidthForRow() {
      const { columnModel } = this.beans;
      if (this.isPrintLayout) {
        const pinned = this.pinned != null;
        if (pinned) {
          return 0;
        }
        return columnModel.getContainerWidth("right") + columnModel.getContainerWidth("left") + columnModel.getContainerWidth(null);
      }
      return columnModel.getContainerWidth(this.pinned);
    }
    onRowHeightChanged() {
      var { topOffset, rowHeight } = this.getTopAndHeight();
      this.comp.setTop(topOffset + "px");
      this.comp.setHeight(rowHeight + "px");
    }
    getTopAndHeight() {
      const { columnModel, filterManager } = this.beans;
      let headerRowCount = columnModel.getHeaderRowCount();
      const sizes = [];
      let numberOfFloating = 0;
      if (filterManager.hasFloatingFilters()) {
        headerRowCount++;
        numberOfFloating = 1;
      }
      const groupHeight = columnModel.getColumnGroupHeaderRowHeight();
      const headerHeight = columnModel.getColumnHeaderRowHeight();
      const numberOfNonGroups = 1 + numberOfFloating;
      const numberOfGroups = headerRowCount - numberOfNonGroups;
      for (let i = 0; i < numberOfGroups; i++) {
        sizes.push(groupHeight);
      }
      sizes.push(headerHeight);
      for (let i = 0; i < numberOfFloating; i++) {
        sizes.push(columnModel.getFloatingFiltersHeight());
      }
      let topOffset = 0;
      for (let i = 0; i < this.rowIndex; i++) {
        topOffset += sizes[i];
      }
      const rowHeight = sizes[this.rowIndex];
      return { topOffset, rowHeight };
    }
    getPinned() {
      return this.pinned;
    }
    getRowIndex() {
      return this.rowIndex;
    }
    onVirtualColumnsChanged(afterScroll = false) {
      const ctrlsToDisplay = this.getHeaderCtrls();
      const forceOrder = this.isEnsureDomOrder || this.isPrintLayout;
      this.comp.setHeaderCtrls(ctrlsToDisplay, forceOrder, afterScroll);
    }
    getHeaderCtrls() {
      const oldCtrls = this.headerCellCtrls;
      this.headerCellCtrls = /* @__PURE__ */ new Map();
      const columns = this.getColumnsInViewport();
      for (const child of columns) {
        this.recycleAndCreateHeaderCtrls(child, oldCtrls);
      }
      const isFocusedAndDisplayed = (ctrl) => {
        const { focusService, columnModel } = this.beans;
        const isFocused = focusService.isHeaderWrapperFocused(ctrl);
        if (!isFocused) {
          return false;
        }
        const isDisplayed = columnModel.isDisplayed(ctrl.getColumnGroupChild());
        return isDisplayed;
      };
      if (oldCtrls) {
        for (const [id, oldCtrl] of oldCtrls) {
          const keepCtrl = isFocusedAndDisplayed(oldCtrl);
          if (keepCtrl) {
            this.headerCellCtrls.set(id, oldCtrl);
          } else {
            this.destroyBean(oldCtrl);
          }
        }
      }
      const ctrlsToDisplay = Array.from(this.headerCellCtrls.values());
      return ctrlsToDisplay;
    }
    recycleAndCreateHeaderCtrls(headerColumn, oldCtrls) {
      if (!this.headerCellCtrls) {
        return;
      }
      if (headerColumn.isEmptyGroup()) {
        return;
      }
      const idOfChild = headerColumn.getUniqueId();
      let headerCtrl;
      if (oldCtrls) {
        headerCtrl = oldCtrls.get(idOfChild);
        oldCtrls.delete(idOfChild);
      }
      const forOldColumn = headerCtrl && headerCtrl.getColumnGroupChild() != headerColumn;
      if (forOldColumn) {
        this.destroyBean(headerCtrl);
        headerCtrl = void 0;
      }
      if (headerCtrl == null) {
        switch (this.type) {
          case "filter":
            headerCtrl = this.createBean(new HeaderFilterCellCtrl(headerColumn, this.beans, this));
            break;
          case "group":
            headerCtrl = this.createBean(new HeaderGroupCellCtrl(headerColumn, this.beans, this));
            break;
          default:
            headerCtrl = this.createBean(new HeaderCellCtrl(headerColumn, this.beans, this));
            break;
        }
      }
      this.headerCellCtrls.set(idOfChild, headerCtrl);
    }
    getColumnsInViewport() {
      return this.isPrintLayout ? this.getColumnsInViewportPrintLayout() : this.getColumnsInViewportNormalLayout();
    }
    getColumnsInViewportPrintLayout() {
      if (this.pinned != null) {
        return [];
      }
      let viewportColumns = [];
      const actualDepth = this.getActualDepth();
      const { columnModel } = this.beans;
      ["left", null, "right"].forEach((pinned) => {
        const items = columnModel.getVirtualHeaderGroupRow(pinned, actualDepth);
        viewportColumns = viewportColumns.concat(items);
      });
      return viewportColumns;
    }
    getActualDepth() {
      return this.type == "filter" ? this.rowIndex - 1 : this.rowIndex;
    }
    getColumnsInViewportNormalLayout() {
      return this.beans.columnModel.getVirtualHeaderGroupRow(this.pinned, this.getActualDepth());
    }
    focusHeader(column, event) {
      if (!this.headerCellCtrls) {
        return false;
      }
      const allCtrls = Array.from(this.headerCellCtrls.values());
      const ctrl = allCtrls.find((ctrl2) => ctrl2.getColumnGroupChild() == column);
      if (!ctrl) {
        return false;
      }
      return ctrl.focus(event);
    }
    destroy() {
      if (this.headerCellCtrls) {
        this.headerCellCtrls.forEach((ctrl) => {
          this.destroyBean(ctrl);
        });
      }
      this.headerCellCtrls = void 0;
      super.destroy();
    }
  };
  __decorateClass([
    Autowired("beans")
  ], HeaderRowCtrl.prototype, "beans", 2);
  __decorateClass([
    PostConstruct
  ], HeaderRowCtrl.prototype, "postConstruct", 1);
  var HeaderRowContainerCtrl = class extends BeanStub {
    constructor(pinned) {
      super();
      this.hidden = false;
      this.includeFloatingFilter = false;
      this.groupsRowCtrls = [];
      this.pinned = pinned;
    }
    setComp(comp, eGui) {
      this.comp = comp;
      this.eViewport = eGui;
      this.setupCenterWidth();
      this.setupPinnedWidth();
      this.setupDragAndDrop(this.eViewport);
      this.addManagedListener(this.eventService, Events.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_ADVANCED_FILTER_ENABLED_CHANGED, this.onDisplayedColumnsChanged.bind(this));
      this.ctrlsService.registerHeaderContainer(this, this.pinned);
      if (this.columnModel.isReady()) {
        this.refresh();
      }
    }
    setupDragAndDrop(dropContainer) {
      const bodyDropTarget = new BodyDropTarget(this.pinned, dropContainer);
      this.createManagedBean(bodyDropTarget);
    }
    refresh(keepColumns = false) {
      const sequence = new NumberSequence();
      const focusedHeaderPosition = this.focusService.getFocusHeaderToUseAfterRefresh();
      const refreshColumnGroups = () => {
        const groupRowCount = this.columnModel.getHeaderRowCount() - 1;
        this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
        for (let i = 0; i < groupRowCount; i++) {
          const ctrl = this.createBean(new HeaderRowCtrl(
            sequence.next(),
            this.pinned,
            "group"
            /* COLUMN_GROUP */
          ));
          this.groupsRowCtrls.push(ctrl);
        }
      };
      const refreshColumns = () => {
        const rowIndex = sequence.next();
        const needNewInstance = !this.hidden && (this.columnsRowCtrl == null || !keepColumns || this.columnsRowCtrl.getRowIndex() !== rowIndex);
        const shouldDestroyInstance = needNewInstance || this.hidden;
        if (shouldDestroyInstance) {
          this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
        }
        if (needNewInstance) {
          this.columnsRowCtrl = this.createBean(new HeaderRowCtrl(
            rowIndex,
            this.pinned,
            "column"
            /* COLUMN */
          ));
        }
      };
      const refreshFilters = () => {
        this.includeFloatingFilter = this.filterManager.hasFloatingFilters() && !this.hidden;
        const destroyPreviousComp = () => {
          this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
        };
        if (!this.includeFloatingFilter) {
          destroyPreviousComp();
          return;
        }
        const rowIndex = sequence.next();
        if (this.filtersRowCtrl) {
          const rowIndexMismatch = this.filtersRowCtrl.getRowIndex() !== rowIndex;
          if (!keepColumns || rowIndexMismatch) {
            destroyPreviousComp();
          }
        }
        if (!this.filtersRowCtrl) {
          this.filtersRowCtrl = this.createBean(new HeaderRowCtrl(
            rowIndex,
            this.pinned,
            "filter"
            /* FLOATING_FILTER */
          ));
        }
      };
      refreshColumnGroups();
      refreshColumns();
      refreshFilters();
      const allCtrls = this.getAllCtrls();
      this.comp.setCtrls(allCtrls);
      this.restoreFocusOnHeader(focusedHeaderPosition);
    }
    restoreFocusOnHeader(position) {
      if (position == null || position.column.getPinned() != this.pinned) {
        return;
      }
      this.focusService.focusHeaderPosition({ headerPosition: position });
    }
    getAllCtrls() {
      const res = [...this.groupsRowCtrls];
      if (this.columnsRowCtrl) {
        res.push(this.columnsRowCtrl);
      }
      if (this.filtersRowCtrl) {
        res.push(this.filtersRowCtrl);
      }
      return res;
    }
    // grid cols have changed - this also means the number of rows in the header can have
    // changed. so we remove all the old rows and insert new ones for a complete refresh
    onGridColumnsChanged() {
      this.refresh(true);
    }
    onDisplayedColumnsChanged() {
      const includeFloatingFilter = this.filterManager.hasFloatingFilters() && !this.hidden;
      if (this.includeFloatingFilter !== includeFloatingFilter) {
        this.refresh(true);
      }
    }
    setupCenterWidth() {
      if (this.pinned != null) {
        return;
      }
      this.createManagedBean(new CenterWidthFeature((width) => this.comp.setCenterWidth(`${width}px`), true));
    }
    setHorizontalScroll(offset) {
      this.comp.setViewportScrollLeft(offset);
    }
    setupPinnedWidth() {
      if (this.pinned == null) {
        return;
      }
      const pinningLeft = this.pinned === "left";
      const pinningRight = this.pinned === "right";
      this.hidden = true;
      const listener = () => {
        const width = pinningLeft ? this.pinnedWidthService.getPinnedLeftWidth() : this.pinnedWidthService.getPinnedRightWidth();
        if (width == null) {
          return;
        }
        const hidden = width == 0;
        const hiddenChanged = this.hidden !== hidden;
        const isRtl = this.gos.get("enableRtl");
        const scrollbarWidth = this.gos.getScrollbarWidth();
        const addPaddingForScrollbar = this.scrollVisibleService.isVerticalScrollShowing() && (isRtl && pinningLeft || !isRtl && pinningRight);
        const widthWithPadding = addPaddingForScrollbar ? width + scrollbarWidth : width;
        this.comp.setPinnedContainerWidth(`${widthWithPadding}px`);
        this.comp.setDisplayed(!hidden);
        if (hiddenChanged) {
          this.hidden = hidden;
          this.refresh();
        }
      };
      this.addManagedListener(this.eventService, Events.EVENT_LEFT_PINNED_WIDTH_CHANGED, listener);
      this.addManagedListener(this.eventService, Events.EVENT_RIGHT_PINNED_WIDTH_CHANGED, listener);
      this.addManagedListener(this.eventService, Events.EVENT_SCROLL_VISIBILITY_CHANGED, listener);
      this.addManagedListener(this.eventService, Events.EVENT_SCROLLBAR_WIDTH_CHANGED, listener);
    }
    getHeaderCtrlForColumn(column) {
      if (column instanceof Column) {
        if (!this.columnsRowCtrl) {
          return;
        }
        return this.columnsRowCtrl.getHeaderCellCtrl(column);
      }
      if (this.groupsRowCtrls.length === 0) {
        return;
      }
      for (let i = 0; i < this.groupsRowCtrls.length; i++) {
        const ctrl = this.groupsRowCtrls[i].getHeaderCellCtrl(column);
        if (ctrl) {
          return ctrl;
        }
      }
    }
    getHtmlElementForColumnHeader(column) {
      const cellCtrl = this.getHeaderCtrlForColumn(column);
      if (!cellCtrl) {
        return null;
      }
      return cellCtrl.getGui();
    }
    getRowType(rowIndex) {
      const allCtrls = this.getAllCtrls();
      const ctrl = allCtrls[rowIndex];
      return ctrl ? ctrl.getType() : void 0;
    }
    focusHeader(rowIndex, column, event) {
      const allCtrls = this.getAllCtrls();
      const ctrl = allCtrls[rowIndex];
      if (!ctrl) {
        return false;
      }
      return ctrl.focusHeader(column, event);
    }
    getViewport() {
      return this.eViewport;
    }
    getRowCount() {
      return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0);
    }
    destroy() {
      if (this.filtersRowCtrl) {
        this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
      }
      if (this.columnsRowCtrl) {
        this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
      }
      if (this.groupsRowCtrls && this.groupsRowCtrls.length) {
        this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
      }
      super.destroy();
    }
  };
  __decorateClass([
    Autowired("ctrlsService")
  ], HeaderRowContainerCtrl.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("scrollVisibleService")
  ], HeaderRowContainerCtrl.prototype, "scrollVisibleService", 2);
  __decorateClass([
    Autowired("pinnedWidthService")
  ], HeaderRowContainerCtrl.prototype, "pinnedWidthService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], HeaderRowContainerCtrl.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("focusService")
  ], HeaderRowContainerCtrl.prototype, "focusService", 2);
  __decorateClass([
    Autowired("filterManager")
  ], HeaderRowContainerCtrl.prototype, "filterManager", 2);
  var _HeaderRowContainerComp = class _HeaderRowContainerComp2 extends Component {
    constructor(pinned) {
      super();
      this.headerRowComps = {};
      this.rowCompsList = [];
      this.pinned = pinned;
    }
    init() {
      this.selectAndSetTemplate();
      const compProxy = {
        setDisplayed: (displayed) => this.setDisplayed(displayed),
        setCtrls: (ctrls) => this.setCtrls(ctrls),
        // only gets called for center section
        setCenterWidth: (width) => this.eCenterContainer.style.width = width,
        setViewportScrollLeft: (left) => this.getGui().scrollLeft = left,
        // only gets called for pinned sections
        setPinnedContainerWidth: (width) => {
          const eGui = this.getGui();
          eGui.style.width = width;
          eGui.style.maxWidth = width;
          eGui.style.minWidth = width;
        }
      };
      const ctrl = this.createManagedBean(new HeaderRowContainerCtrl(this.pinned));
      ctrl.setComp(compProxy, this.getGui());
    }
    selectAndSetTemplate() {
      const pinnedLeft = this.pinned == "left";
      const pinnedRight = this.pinned == "right";
      const template = pinnedLeft ? _HeaderRowContainerComp2.PINNED_LEFT_TEMPLATE : pinnedRight ? _HeaderRowContainerComp2.PINNED_RIGHT_TEMPLATE : _HeaderRowContainerComp2.CENTER_TEMPLATE;
      this.setTemplate(template);
      this.eRowContainer = this.eCenterContainer ? this.eCenterContainer : this.getGui();
    }
    destroyRowComps() {
      this.setCtrls([]);
    }
    destroyRowComp(rowComp) {
      this.destroyBean(rowComp);
      this.eRowContainer.removeChild(rowComp.getGui());
    }
    setCtrls(ctrls) {
      const oldRowComps = this.headerRowComps;
      this.headerRowComps = {};
      this.rowCompsList = [];
      let prevGui;
      const appendEnsuringDomOrder = (rowComp) => {
        const eGui = rowComp.getGui();
        const notAlreadyIn = eGui.parentElement != this.eRowContainer;
        if (notAlreadyIn) {
          this.eRowContainer.appendChild(eGui);
        }
        if (prevGui) {
          ensureDomOrder(this.eRowContainer, eGui, prevGui);
        }
        prevGui = eGui;
      };
      ctrls.forEach((ctrl) => {
        const ctrlId = ctrl.getInstanceId();
        const existingComp = oldRowComps[ctrlId];
        delete oldRowComps[ctrlId];
        const rowComp = existingComp ? existingComp : this.createBean(new HeaderRowComp(ctrl));
        this.headerRowComps[ctrlId] = rowComp;
        this.rowCompsList.push(rowComp);
        appendEnsuringDomOrder(rowComp);
      });
      getAllValuesInObject(oldRowComps).forEach((c) => this.destroyRowComp(c));
    }
  };
  _HeaderRowContainerComp.PINNED_LEFT_TEMPLATE = /* html */
  `<div class="ag-pinned-left-header" role="rowgroup"></div>`;
  _HeaderRowContainerComp.PINNED_RIGHT_TEMPLATE = /* html */
  `<div class="ag-pinned-right-header" role="rowgroup"></div>`;
  _HeaderRowContainerComp.CENTER_TEMPLATE = /* html */
  `<div class="ag-header-viewport" role="presentation">
            <div class="ag-header-container" ref="eCenterContainer" role="rowgroup"></div>
        </div>`;
  __decorateClass([
    RefSelector("eCenterContainer")
  ], _HeaderRowContainerComp.prototype, "eCenterContainer", 2);
  __decorateClass([
    PostConstruct
  ], _HeaderRowContainerComp.prototype, "init", 1);
  __decorateClass([
    PreDestroy
  ], _HeaderRowContainerComp.prototype, "destroyRowComps", 1);
  var HeaderRowContainerComp = _HeaderRowContainerComp;
  var HeaderNavigationDirection = /* @__PURE__ */ ((HeaderNavigationDirection2) => {
    HeaderNavigationDirection2[HeaderNavigationDirection2["UP"] = 0] = "UP";
    HeaderNavigationDirection2[HeaderNavigationDirection2["DOWN"] = 1] = "DOWN";
    HeaderNavigationDirection2[HeaderNavigationDirection2["LEFT"] = 2] = "LEFT";
    HeaderNavigationDirection2[HeaderNavigationDirection2["RIGHT"] = 3] = "RIGHT";
    return HeaderNavigationDirection2;
  })(HeaderNavigationDirection || {});
  var HeaderNavigationService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.currentHeaderRowWithoutSpan = -1;
    }
    postConstruct() {
      this.ctrlsService.whenReady((p2) => {
        this.gridBodyCon = p2.gridBodyCtrl;
      });
      const eDocument = this.gos.getDocument();
      this.addManagedListener(eDocument, "mousedown", () => this.setCurrentHeaderRowWithoutSpan(-1));
    }
    getHeaderRowCount() {
      const centerHeaderContainer = this.ctrlsService.getHeaderRowContainerCtrl();
      return centerHeaderContainer ? centerHeaderContainer.getRowCount() : 0;
    }
    /*
     * This method navigates grid header vertically
     * @return {boolean} true to preventDefault on the event that caused this navigation.
     */
    navigateVertically(direction, fromHeader, event) {
      if (!fromHeader) {
        fromHeader = this.focusService.getFocusedHeader();
      }
      if (!fromHeader) {
        return false;
      }
      const { headerRowIndex, column } = fromHeader;
      const rowLen = this.getHeaderRowCount();
      const isUp = direction === 0;
      let { headerRowIndex: nextRow, column: nextFocusColumn, headerRowIndexWithoutSpan } = isUp ? this.headerPositionUtils.getColumnVisibleParent(column, headerRowIndex) : this.headerPositionUtils.getColumnVisibleChild(column, headerRowIndex);
      let skipColumn = false;
      if (nextRow < 0) {
        nextRow = 0;
        nextFocusColumn = column;
        skipColumn = true;
      }
      if (nextRow >= rowLen) {
        nextRow = -1;
        this.setCurrentHeaderRowWithoutSpan(-1);
      } else if (headerRowIndexWithoutSpan !== void 0) {
        this.currentHeaderRowWithoutSpan = headerRowIndexWithoutSpan;
      }
      if (!skipColumn && !nextFocusColumn) {
        return false;
      }
      return this.focusService.focusHeaderPosition({
        headerPosition: { headerRowIndex: nextRow, column: nextFocusColumn },
        allowUserOverride: true,
        event
      });
    }
    setCurrentHeaderRowWithoutSpan(row) {
      this.currentHeaderRowWithoutSpan = row;
    }
    /*
     * This method navigates grid header horizontally
     * @return {boolean} true to preventDefault on the event that caused this navigation.
     */
    navigateHorizontally(direction, fromTab = false, event) {
      const focusedHeader = this.focusService.getFocusedHeader();
      const isLeft = direction === 2;
      const isRtl = this.gos.get("enableRtl");
      let nextHeader;
      let normalisedDirection;
      if (this.currentHeaderRowWithoutSpan !== -1) {
        focusedHeader.headerRowIndex = this.currentHeaderRowWithoutSpan;
      } else {
        this.currentHeaderRowWithoutSpan = focusedHeader.headerRowIndex;
      }
      if (isLeft !== isRtl) {
        normalisedDirection = "Before";
        nextHeader = this.headerPositionUtils.findHeader(focusedHeader, normalisedDirection);
      } else {
        normalisedDirection = "After";
        nextHeader = this.headerPositionUtils.findHeader(focusedHeader, normalisedDirection);
      }
      if (nextHeader || !fromTab) {
        return this.focusService.focusHeaderPosition({
          headerPosition: nextHeader,
          direction: normalisedDirection,
          fromTab,
          allowUserOverride: true,
          event
        });
      } else if (fromTab) {
        const userFunc = this.gos.getCallback("tabToNextHeader");
        if (userFunc) {
          return this.focusService.focusHeaderPositionFromUserFunc({
            userFunc,
            headerPosition: nextHeader,
            direction: normalisedDirection
          });
        }
      }
      return this.focusNextHeaderRow(focusedHeader, normalisedDirection, event);
    }
    focusNextHeaderRow(focusedHeader, direction, event) {
      const currentIndex = focusedHeader.headerRowIndex;
      let nextPosition = null;
      let nextRowIndex;
      if (direction === "Before") {
        if (currentIndex > 0) {
          nextRowIndex = currentIndex - 1;
          this.currentHeaderRowWithoutSpan -= 1;
          nextPosition = this.headerPositionUtils.findColAtEdgeForHeaderRow(nextRowIndex, "end");
        }
      } else {
        nextRowIndex = currentIndex + 1;
        if (this.currentHeaderRowWithoutSpan < this.getHeaderRowCount()) {
          this.currentHeaderRowWithoutSpan += 1;
        } else {
          this.setCurrentHeaderRowWithoutSpan(-1);
        }
        nextPosition = this.headerPositionUtils.findColAtEdgeForHeaderRow(nextRowIndex, "start");
      }
      if (!nextPosition) {
        return false;
      }
      const { column, headerRowIndex } = this.headerPositionUtils.getHeaderIndexToFocus(nextPosition.column, nextPosition == null ? void 0 : nextPosition.headerRowIndex);
      return this.focusService.focusHeaderPosition({
        headerPosition: { column, headerRowIndex },
        direction,
        fromTab: true,
        allowUserOverride: true,
        event
      });
    }
    scrollToColumn(column, direction = "After") {
      if (column.getPinned()) {
        return;
      }
      let columnToScrollTo;
      if (column instanceof ColumnGroup) {
        const columns = column.getDisplayedLeafColumns();
        columnToScrollTo = direction === "Before" ? last(columns) : columns[0];
      } else {
        columnToScrollTo = column;
      }
      this.gridBodyCon.getScrollFeature().ensureColumnVisible(columnToScrollTo);
    }
  };
  __decorateClass([
    Autowired("focusService")
  ], HeaderNavigationService.prototype, "focusService", 2);
  __decorateClass([
    Autowired("headerPositionUtils")
  ], HeaderNavigationService.prototype, "headerPositionUtils", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], HeaderNavigationService.prototype, "ctrlsService", 2);
  __decorateClass([
    PostConstruct
  ], HeaderNavigationService.prototype, "postConstruct", 1);
  HeaderNavigationService = __decorateClass([
    Bean("headerNavigationService")
  ], HeaderNavigationService);
  var GridHeaderCtrl = class extends BeanStub {
    setComp(comp, eGui, eFocusableElement) {
      this.comp = comp;
      this.eGui = eGui;
      this.createManagedBean(new ManagedFocusFeature(
        eFocusableElement,
        {
          onTabKeyDown: this.onTabKeyDown.bind(this),
          handleKeyDown: this.handleKeyDown.bind(this),
          onFocusOut: this.onFocusOut.bind(this)
        }
      ));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onPivotModeChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
      this.onPivotModeChanged();
      this.setupHeaderHeight();
      const listener = this.onHeaderContextMenu.bind(this);
      this.addManagedListener(this.eGui, "contextmenu", listener);
      this.mockContextMenuForIPad(listener);
      this.ctrlsService.register("gridHeaderCtrl", this);
    }
    setupHeaderHeight() {
      const listener = this.setHeaderHeight.bind(this);
      listener();
      this.addManagedPropertyListener("headerHeight", listener);
      this.addManagedPropertyListener("pivotHeaderHeight", listener);
      this.addManagedPropertyListener("groupHeaderHeight", listener);
      this.addManagedPropertyListener("pivotGroupHeaderHeight", listener);
      this.addManagedPropertyListener("floatingFiltersHeight", listener);
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, listener);
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_HEADER_HEIGHT_CHANGED, listener);
      this.addManagedListener(this.eventService, Events.EVENT_GRID_STYLES_CHANGED, listener);
      this.addManagedListener(this.eventService, Events.EVENT_ADVANCED_FILTER_ENABLED_CHANGED, listener);
    }
    getHeaderHeight() {
      return this.headerHeight;
    }
    setHeaderHeight() {
      const { columnModel } = this;
      let numberOfFloating = 0;
      let headerRowCount = columnModel.getHeaderRowCount();
      let totalHeaderHeight;
      const hasFloatingFilters = this.filterManager.hasFloatingFilters();
      if (hasFloatingFilters) {
        headerRowCount++;
        numberOfFloating = 1;
      }
      const groupHeight = this.columnModel.getColumnGroupHeaderRowHeight();
      const headerHeight = this.columnModel.getColumnHeaderRowHeight();
      const numberOfNonGroups = 1 + numberOfFloating;
      const numberOfGroups = headerRowCount - numberOfNonGroups;
      totalHeaderHeight = numberOfFloating * columnModel.getFloatingFiltersHeight();
      totalHeaderHeight += numberOfGroups * groupHeight;
      totalHeaderHeight += headerHeight;
      if (this.headerHeight === totalHeaderHeight) {
        return;
      }
      this.headerHeight = totalHeaderHeight;
      const px = `${totalHeaderHeight + 1}px`;
      this.comp.setHeightAndMinHeight(px);
      this.eventService.dispatchEvent({
        type: Events.EVENT_HEADER_HEIGHT_CHANGED
      });
    }
    onPivotModeChanged() {
      const pivotMode = this.columnModel.isPivotMode();
      this.comp.addOrRemoveCssClass("ag-pivot-on", pivotMode);
      this.comp.addOrRemoveCssClass("ag-pivot-off", !pivotMode);
    }
    onDisplayedColumnsChanged() {
      const columns = this.columnModel.getAllDisplayedColumns();
      const shouldAllowOverflow = columns.some((col) => col.isSpanHeaderHeight());
      this.comp.addOrRemoveCssClass("ag-header-allow-overflow", shouldAllowOverflow);
    }
    onTabKeyDown(e) {
      const isRtl = this.gos.get("enableRtl");
      const direction = e.shiftKey !== isRtl ? 2 : 3;
      if (this.headerNavigationService.navigateHorizontally(direction, true, e) || this.focusService.focusNextGridCoreContainer(e.shiftKey)) {
        e.preventDefault();
      }
    }
    handleKeyDown(e) {
      let direction = null;
      switch (e.key) {
        case KeyCode.LEFT:
          direction = 2;
        case KeyCode.RIGHT:
          if (!exists(direction)) {
            direction = 3;
          }
          this.headerNavigationService.navigateHorizontally(direction, false, e);
          break;
        case KeyCode.UP:
          direction = 0;
        case KeyCode.DOWN:
          if (!exists(direction)) {
            direction = 1;
          }
          if (this.headerNavigationService.navigateVertically(direction, null, e)) {
            e.preventDefault();
          }
          break;
        default:
          return;
      }
    }
    onFocusOut(e) {
      const { relatedTarget } = e;
      if (!relatedTarget && this.eGui.contains(this.gos.getActiveDomElement())) {
        return;
      }
      if (!this.eGui.contains(relatedTarget)) {
        this.focusService.clearFocusedHeader();
      }
    }
    onHeaderContextMenu(mouseEvent, touch, touchEvent) {
      if (!mouseEvent && !touchEvent || !this.menuService.isHeaderContextMenuEnabled()) {
        return;
      }
      const { target } = mouseEvent != null ? mouseEvent : touch;
      if (target === this.eGui || target === this.ctrlsService.getHeaderRowContainerCtrl().getViewport()) {
        this.menuService.showHeaderContextMenu(void 0, mouseEvent, touchEvent);
      }
    }
    mockContextMenuForIPad(listener) {
      if (!isIOSUserAgent()) {
        return;
      }
      const touchListener = new TouchListener(this.eGui);
      const longTapListener = (event) => {
        listener(void 0, event.touchStart, event.touchEvent);
      };
      this.addManagedListener(touchListener, TouchListener.EVENT_LONG_TAP, longTapListener);
      this.addDestroyFunc(() => touchListener.destroy());
    }
  };
  __decorateClass([
    Autowired("headerNavigationService")
  ], GridHeaderCtrl.prototype, "headerNavigationService", 2);
  __decorateClass([
    Autowired("focusService")
  ], GridHeaderCtrl.prototype, "focusService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], GridHeaderCtrl.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], GridHeaderCtrl.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("filterManager")
  ], GridHeaderCtrl.prototype, "filterManager", 2);
  __decorateClass([
    Autowired("menuService")
  ], GridHeaderCtrl.prototype, "menuService", 2);
  var _GridHeaderComp = class _GridHeaderComp2 extends Component {
    constructor() {
      super(_GridHeaderComp2.TEMPLATE);
    }
    postConstruct() {
      const compProxy = {
        addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
        setHeightAndMinHeight: (height) => {
          this.getGui().style.height = height;
          this.getGui().style.minHeight = height;
        }
      };
      const ctrl = this.createManagedBean(new GridHeaderCtrl());
      ctrl.setComp(compProxy, this.getGui(), this.getFocusableElement());
      const addContainer = (container) => {
        this.createManagedBean(container);
        this.appendChild(container);
      };
      addContainer(new HeaderRowContainerComp("left"));
      addContainer(new HeaderRowContainerComp(null));
      addContainer(new HeaderRowContainerComp("right"));
    }
  };
  _GridHeaderComp.TEMPLATE = /* html */
  `<div class="ag-header" role="presentation"/>`;
  __decorateClass([
    PostConstruct
  ], _GridHeaderComp.prototype, "postConstruct", 1);
  var GridHeaderComp = _GridHeaderComp;
  var HorizontalResizeService = class extends BeanStub {
    addResizeBar(params) {
      const dragSource = {
        dragStartPixels: params.dragStartPixels || 0,
        eElement: params.eResizeBar,
        onDragStart: this.onDragStart.bind(this, params),
        onDragStop: this.onDragStop.bind(this, params),
        onDragging: this.onDragging.bind(this, params),
        includeTouch: true,
        stopPropagationForTouch: true
      };
      this.dragService.addDragSource(dragSource);
      const finishedWithResizeFunc = () => this.dragService.removeDragSource(dragSource);
      return finishedWithResizeFunc;
    }
    onDragStart(params, mouseEvent) {
      this.dragStartX = mouseEvent.clientX;
      this.setResizeIcons();
      const shiftKey = mouseEvent instanceof MouseEvent && mouseEvent.shiftKey === true;
      params.onResizeStart(shiftKey);
    }
    setResizeIcons() {
      const ctrl = this.ctrlsService.get("gridCtrl");
      ctrl.setResizeCursor(true);
      ctrl.disableUserSelect(true);
    }
    onDragStop(params, mouseEvent) {
      params.onResizeEnd(this.resizeAmount);
      this.resetIcons();
    }
    resetIcons() {
      const ctrl = this.ctrlsService.get("gridCtrl");
      ctrl.setResizeCursor(false);
      ctrl.disableUserSelect(false);
    }
    onDragging(params, mouseEvent) {
      this.resizeAmount = mouseEvent.clientX - this.dragStartX;
      params.onResizing(this.resizeAmount);
    }
  };
  __decorateClass([
    Autowired("dragService")
  ], HorizontalResizeService.prototype, "dragService", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], HorizontalResizeService.prototype, "ctrlsService", 2);
  HorizontalResizeService = __decorateClass([
    Bean("horizontalResizeService")
  ], HorizontalResizeService);
  var StandardMenuFactory = class extends BeanStub {
    hideActiveMenu() {
      if (this.hidePopup) {
        this.hidePopup();
      }
    }
    showMenuAfterMouseEvent(column, mouseEvent, containerType) {
      this.showPopup(column, (eMenu) => {
        this.popupService.positionPopupUnderMouseEvent({
          column,
          type: containerType,
          mouseEvent,
          ePopup: eMenu
        });
      }, containerType, mouseEvent.target, this.menuService.isLegacyMenuEnabled());
    }
    showMenuAfterButtonClick(column, eventSource, containerType) {
      let multiplier = -1;
      let alignSide = "left";
      const isLegacyMenuEnabled = this.menuService.isLegacyMenuEnabled();
      if (!isLegacyMenuEnabled && this.gos.get("enableRtl")) {
        multiplier = 1;
        alignSide = "right";
      }
      let nudgeX = isLegacyMenuEnabled ? void 0 : 4 * multiplier;
      let nudgeY = isLegacyMenuEnabled ? void 0 : 4;
      this.showPopup(column, (eMenu) => {
        this.popupService.positionPopupByComponent({
          type: containerType,
          eventSource,
          ePopup: eMenu,
          nudgeX,
          nudgeY,
          alignSide,
          keepWithinBounds: true,
          position: "under",
          column
        });
      }, containerType, eventSource, isLegacyMenuEnabled);
    }
    showPopup(column, positionCallback, containerType, eventSource, isLegacyMenuEnabled) {
      const comp = column ? this.createBean(new FilterWrapperComp(column, "COLUMN_MENU")) : void 0;
      this.activeMenu = comp;
      if (!(comp == null ? void 0 : comp.hasFilter()) || !column) {
        throw new Error("AG Grid - unable to show popup filter, filter instantiation failed");
      }
      const eMenu = document.createElement("div");
      setAriaRole(eMenu, "presentation");
      eMenu.classList.add("ag-menu");
      if (!isLegacyMenuEnabled) {
        eMenu.classList.add("ag-filter-menu");
      }
      this.tabListener = this.addManagedListener(eMenu, "keydown", (e) => this.trapFocusWithin(e, eMenu));
      eMenu.appendChild(comp == null ? void 0 : comp.getGui());
      let hidePopup;
      const afterGuiDetached = () => comp == null ? void 0 : comp.afterGuiDetached();
      const anchorToElement = this.menuService.isColumnMenuAnchoringEnabled() ? eventSource != null ? eventSource : this.ctrlsService.getGridBodyCtrl().getGui() : void 0;
      const closedCallback = (e) => {
        column.setMenuVisible(false, "contextMenu");
        const isKeyboardEvent2 = e instanceof KeyboardEvent;
        if (this.tabListener) {
          this.tabListener = this.tabListener();
        }
        if (isKeyboardEvent2 && eventSource && isVisible(eventSource)) {
          const focusableEl = this.focusService.findTabbableParent(eventSource);
          if (focusableEl) {
            focusableEl.focus();
          }
        }
        afterGuiDetached();
        this.destroyBean(this.activeMenu);
        this.dispatchVisibleChangedEvent(false, containerType, column);
      };
      const translate = this.localeService.getLocaleTextFunc();
      const ariaLabel = isLegacyMenuEnabled && containerType !== "columnFilter" ? translate("ariaLabelColumnMenu", "Column Menu") : translate("ariaLabelColumnFilter", "Column Filter");
      const addPopupRes = this.popupService.addPopup({
        modal: true,
        eChild: eMenu,
        closeOnEsc: true,
        closedCallback,
        positionCallback: () => positionCallback(eMenu),
        anchorToElement,
        ariaLabel
      });
      if (addPopupRes) {
        this.hidePopup = hidePopup = addPopupRes.hideFunc;
      }
      comp.afterInit().then(() => {
        positionCallback(eMenu);
        comp.afterGuiAttached({ container: containerType, hidePopup });
      });
      column.setMenuVisible(true, "contextMenu");
      this.dispatchVisibleChangedEvent(true, containerType, column);
    }
    trapFocusWithin(e, menu) {
      if (e.key !== KeyCode.TAB || e.defaultPrevented || this.focusService.findNextFocusableElement(menu, false, e.shiftKey)) {
        return;
      }
      e.preventDefault();
      this.focusService.focusInto(menu, e.shiftKey);
    }
    dispatchVisibleChangedEvent(visible, containerType, column) {
      const displayedEvent = {
        type: Events.EVENT_COLUMN_MENU_VISIBLE_CHANGED,
        visible,
        switchingTab: false,
        key: containerType,
        column: column != null ? column : null
      };
      this.eventService.dispatchEvent(displayedEvent);
    }
    isMenuEnabled(column) {
      var _a;
      return column.isFilterAllowed() && ((_a = column.getColDef().menuTabs) != null ? _a : ["filterMenuTab"]).includes("filterMenuTab");
    }
    showMenuAfterContextMenuEvent() {
    }
    destroy() {
      this.destroyBean(this.activeMenu);
      super.destroy();
    }
  };
  __decorateClass([
    Autowired("filterManager")
  ], StandardMenuFactory.prototype, "filterManager", 2);
  __decorateClass([
    Autowired("popupService")
  ], StandardMenuFactory.prototype, "popupService", 2);
  __decorateClass([
    Autowired("focusService")
  ], StandardMenuFactory.prototype, "focusService", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], StandardMenuFactory.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("menuService")
  ], StandardMenuFactory.prototype, "menuService", 2);
  StandardMenuFactory = __decorateClass([
    Bean("filterMenuFactory")
  ], StandardMenuFactory);
  var TabGuardClassNames = /* @__PURE__ */ ((TabGuardClassNames2) => {
    TabGuardClassNames2["TAB_GUARD"] = "ag-tab-guard";
    TabGuardClassNames2["TAB_GUARD_TOP"] = "ag-tab-guard-top";
    TabGuardClassNames2["TAB_GUARD_BOTTOM"] = "ag-tab-guard-bottom";
    return TabGuardClassNames2;
  })(TabGuardClassNames || {});
  var TabGuardCtrl = class extends BeanStub {
    constructor(params) {
      super();
      this.skipTabGuardFocus = false;
      this.forcingFocusOut = false;
      const {
        comp,
        eTopGuard,
        eBottomGuard,
        focusTrapActive,
        forceFocusOutWhenTabGuardsAreEmpty,
        focusInnerElement,
        onFocusIn,
        onFocusOut,
        shouldStopEventPropagation,
        onTabKeyDown,
        handleKeyDown,
        eFocusableElement
      } = params;
      this.comp = comp;
      this.eTopGuard = eTopGuard;
      this.eBottomGuard = eBottomGuard;
      this.providedFocusInnerElement = focusInnerElement;
      this.eFocusableElement = eFocusableElement;
      this.focusTrapActive = !!focusTrapActive;
      this.forceFocusOutWhenTabGuardsAreEmpty = !!forceFocusOutWhenTabGuardsAreEmpty;
      this.providedFocusIn = onFocusIn;
      this.providedFocusOut = onFocusOut;
      this.providedShouldStopEventPropagation = shouldStopEventPropagation;
      this.providedOnTabKeyDown = onTabKeyDown;
      this.providedHandleKeyDown = handleKeyDown;
    }
    postConstruct() {
      this.createManagedBean(new ManagedFocusFeature(
        this.eFocusableElement,
        {
          shouldStopEventPropagation: () => this.shouldStopEventPropagation(),
          onTabKeyDown: (e) => this.onTabKeyDown(e),
          handleKeyDown: (e) => this.handleKeyDown(e),
          onFocusIn: (e) => this.onFocusIn(e),
          onFocusOut: (e) => this.onFocusOut(e)
        }
      ));
      this.activateTabGuards();
      [this.eTopGuard, this.eBottomGuard].forEach(
        (guard) => this.addManagedListener(guard, "focus", this.onFocus.bind(this))
      );
    }
    handleKeyDown(e) {
      if (this.providedHandleKeyDown) {
        this.providedHandleKeyDown(e);
      }
    }
    tabGuardsAreActive() {
      return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
    }
    shouldStopEventPropagation() {
      if (this.providedShouldStopEventPropagation) {
        return this.providedShouldStopEventPropagation();
      }
      return false;
    }
    activateTabGuards() {
      if (this.forcingFocusOut) {
        return;
      }
      const tabIndex = this.gos.get("tabIndex");
      this.comp.setTabIndex(tabIndex.toString());
    }
    deactivateTabGuards() {
      this.comp.setTabIndex();
    }
    onFocus(e) {
      if (this.skipTabGuardFocus) {
        this.skipTabGuardFocus = false;
        return;
      }
      if (this.forceFocusOutWhenTabGuardsAreEmpty) {
        const isEmpty = this.focusService.findFocusableElements(this.eFocusableElement, ".ag-tab-guard").length === 0;
        if (isEmpty) {
          this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
          return;
        }
      }
      const fromBottom = e.target === this.eBottomGuard;
      if (this.providedFocusInnerElement) {
        this.providedFocusInnerElement(fromBottom);
      } else {
        this.focusInnerElement(fromBottom);
      }
    }
    findNextElementOutsideAndFocus(up) {
      const eDocument = this.gos.getDocument();
      const focusableEls = this.focusService.findFocusableElements(eDocument.body, null, true);
      const index = focusableEls.indexOf(up ? this.eTopGuard : this.eBottomGuard);
      if (index === -1) {
        return;
      }
      let start2;
      let end;
      if (up) {
        start2 = 0;
        end = index;
      } else {
        start2 = index + 1;
        end = focusableEls.length;
      }
      const focusableRange = focusableEls.slice(start2, end);
      const targetTabIndex = this.gos.get("tabIndex");
      focusableRange.sort((a, b) => {
        const indexA = parseInt(a.getAttribute("tabindex") || "0");
        const indexB = parseInt(b.getAttribute("tabindex") || "0");
        if (indexB === targetTabIndex) {
          return 1;
        }
        if (indexA === targetTabIndex) {
          return -1;
        }
        if (indexA === 0) {
          return 1;
        }
        if (indexB === 0) {
          return -1;
        }
        return indexA - indexB;
      });
      focusableRange[up ? focusableRange.length - 1 : 0].focus();
    }
    onFocusIn(e) {
      if (this.focusTrapActive) {
        return;
      }
      if (this.providedFocusIn) {
        this.providedFocusIn(e);
      }
      this.deactivateTabGuards();
    }
    onFocusOut(e) {
      if (this.focusTrapActive) {
        return;
      }
      if (this.providedFocusOut) {
        this.providedFocusOut(e);
      }
      if (!this.eFocusableElement.contains(e.relatedTarget)) {
        this.activateTabGuards();
      }
    }
    onTabKeyDown(e) {
      if (this.providedOnTabKeyDown) {
        this.providedOnTabKeyDown(e);
        return;
      }
      if (this.focusTrapActive) {
        return;
      }
      if (e.defaultPrevented) {
        return;
      }
      const tabGuardsAreActive = this.tabGuardsAreActive();
      if (tabGuardsAreActive) {
        this.deactivateTabGuards();
      }
      const nextRoot = this.getNextFocusableElement(e.shiftKey);
      if (tabGuardsAreActive) {
        setTimeout(() => this.activateTabGuards(), 0);
      }
      if (!nextRoot) {
        return;
      }
      nextRoot.focus();
      e.preventDefault();
    }
    focusInnerElement(fromBottom = false) {
      const focusable = this.focusService.findFocusableElements(this.eFocusableElement);
      if (this.tabGuardsAreActive()) {
        focusable.splice(0, 1);
        focusable.splice(focusable.length - 1, 1);
      }
      if (!focusable.length) {
        return;
      }
      focusable[fromBottom ? focusable.length - 1 : 0].focus({ preventScroll: true });
    }
    getNextFocusableElement(backwards) {
      return this.focusService.findNextFocusableElement(this.eFocusableElement, false, backwards);
    }
    forceFocusOutOfContainer(up = false) {
      if (this.forcingFocusOut) {
        return;
      }
      const tabGuardToFocus = up ? this.eTopGuard : this.eBottomGuard;
      this.activateTabGuards();
      this.skipTabGuardFocus = true;
      this.forcingFocusOut = true;
      tabGuardToFocus.focus();
      window.setTimeout(() => {
        this.forcingFocusOut = false;
        this.activateTabGuards();
      });
    }
    isTabGuard(element) {
      return element === this.eTopGuard || element === this.eBottomGuard;
    }
  };
  __decorateClass([
    Autowired("focusService")
  ], TabGuardCtrl.prototype, "focusService", 2);
  __decorateClass([
    PostConstruct
  ], TabGuardCtrl.prototype, "postConstruct", 1);
  var TabGuardComp = class extends Component {
    initialiseTabGuard(params) {
      this.eTopGuard = this.createTabGuard("top");
      this.eBottomGuard = this.createTabGuard("bottom");
      this.eFocusableElement = this.getFocusableElement();
      const tabGuards = [this.eTopGuard, this.eBottomGuard];
      const compProxy = {
        setTabIndex: (tabIndex) => {
          tabGuards.forEach((tabGuard) => tabIndex != null ? tabGuard.setAttribute("tabindex", tabIndex) : tabGuard.removeAttribute("tabindex"));
        }
      };
      this.addTabGuards(this.eTopGuard, this.eBottomGuard);
      this.tabGuardCtrl = this.createManagedBean(new TabGuardCtrl({
        comp: compProxy,
        focusTrapActive: !!params.focusTrapActive,
        eTopGuard: this.eTopGuard,
        eBottomGuard: this.eBottomGuard,
        eFocusableElement: this.eFocusableElement,
        onFocusIn: params.onFocusIn,
        onFocusOut: params.onFocusOut,
        focusInnerElement: params.focusInnerElement,
        handleKeyDown: params.handleKeyDown,
        onTabKeyDown: params.onTabKeyDown,
        shouldStopEventPropagation: params.shouldStopEventPropagation,
        forceFocusOutWhenTabGuardsAreEmpty: params.forceFocusOutWhenTabGuardsAreEmpty
      }));
    }
    createTabGuard(side) {
      const tabGuard = document.createElement("div");
      const cls = side === "top" ? "ag-tab-guard-top" : "ag-tab-guard-bottom";
      tabGuard.classList.add("ag-tab-guard", cls);
      setAriaRole(tabGuard, "presentation");
      return tabGuard;
    }
    addTabGuards(topTabGuard, bottomTabGuard) {
      this.eFocusableElement.insertAdjacentElement("afterbegin", topTabGuard);
      this.eFocusableElement.insertAdjacentElement("beforeend", bottomTabGuard);
    }
    removeAllChildrenExceptTabGuards() {
      const tabGuards = [this.eTopGuard, this.eBottomGuard];
      clearElement(this.getFocusableElement());
      this.addTabGuards(...tabGuards);
    }
    forceFocusOutOfContainer(up = false) {
      this.tabGuardCtrl.forceFocusOutOfContainer(up);
    }
    appendChild(newChild, container) {
      if (!isNodeOrElement(newChild)) {
        newChild = newChild.getGui();
      }
      const { eBottomGuard: bottomTabGuard } = this;
      if (bottomTabGuard) {
        bottomTabGuard.insertAdjacentElement("beforebegin", newChild);
      } else {
        super.appendChild(newChild, container);
      }
    }
  };
  var _TabbedLayout = class _TabbedLayout2 extends TabGuardComp {
    constructor(params) {
      super(_TabbedLayout2.getTemplate(params.cssClass));
      this.items = [];
      this.tabbedItemScrollMap = /* @__PURE__ */ new Map();
      this.params = params;
    }
    postConstruct() {
      this.setupHeader();
      if (this.params.items) {
        this.params.items.forEach((item) => this.addItem(item));
      }
      this.initialiseTabGuard({
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        focusInnerElement: this.focusInnerElement.bind(this),
        focusTrapActive: true
      });
      this.addDestroyFunc(() => {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.activeItem) == null ? void 0 : _a.tabbedItem) == null ? void 0 : _b.afterDetachedCallback) == null ? void 0 : _c.call(_b);
      });
    }
    static getTemplate(cssClass) {
      return (
        /* html */
        `<div class="ag-tabs ${cssClass}">
            <div ref="eHeader"></div>
            <div ref="eBody" role="presentation" class="ag-tabs-body ${cssClass ? `${cssClass}-body` : ""}"></div>
        </div>`
      );
    }
    setupHeader() {
      const { enableCloseButton, cssClass } = this.params;
      const addCssClasses = (el, suffix) => {
        el.classList.add(`ag-tabs-${suffix}`);
        if (cssClass) {
          el.classList.add(`${cssClass}-${suffix}`);
        }
      };
      if (enableCloseButton) {
        this.setupCloseButton(addCssClasses);
        this.eTabHeader = this.gos.getDocument().createElement("div");
        addCssClasses(this.eHeader, "header-wrapper");
        setAriaRole(this.eHeader, "presentation");
        this.eHeader.appendChild(this.eTabHeader);
      } else {
        this.eTabHeader = this.eHeader;
      }
      setAriaRole(this.eTabHeader, "tablist");
      addCssClasses(this.eTabHeader, "header");
    }
    setupCloseButton(addCssClasses) {
      const eDocument = this.gos.getDocument();
      const eCloseButton = eDocument.createElement("button");
      addCssClasses(eCloseButton, "close-button");
      const eIcon = createIconNoSpan(
        "close",
        this.gos,
        void 0,
        true
      );
      setAriaLabel(eCloseButton, this.params.closeButtonAriaLabel);
      eCloseButton.appendChild(eIcon);
      this.addManagedListener(eCloseButton, "click", () => {
        var _a, _b;
        return (_b = (_a = this.params).onCloseClicked) == null ? void 0 : _b.call(_a);
      });
      const eCloseButtonWrapper = eDocument.createElement("div");
      addCssClasses(eCloseButtonWrapper, "close-button-wrapper");
      setAriaRole(eCloseButtonWrapper, "presentation");
      eCloseButtonWrapper.appendChild(eCloseButton);
      this.eHeader.appendChild(eCloseButtonWrapper);
      this.eCloseButton = eCloseButton;
    }
    handleKeyDown(e) {
      switch (e.key) {
        case KeyCode.RIGHT:
        case KeyCode.LEFT:
          if (!this.eTabHeader.contains(this.gos.getActiveDomElement())) {
            return;
          }
          const isRightKey = e.key === KeyCode.RIGHT;
          const isRtl = this.gos.get("enableRtl");
          const currentPosition = this.items.indexOf(this.activeItem);
          const nextPosition = isRightKey !== isRtl ? Math.min(currentPosition + 1, this.items.length - 1) : Math.max(currentPosition - 1, 0);
          if (currentPosition === nextPosition) {
            return;
          }
          e.preventDefault();
          const nextItem = this.items[nextPosition];
          this.showItemWrapper(nextItem);
          nextItem.eHeaderButton.focus();
          break;
        case KeyCode.UP:
        case KeyCode.DOWN:
          e.stopPropagation();
          break;
      }
    }
    onTabKeyDown(e) {
      var _a, _b, _c, _d;
      if (e.defaultPrevented) {
        return;
      }
      const { focusService, eHeader, eBody, activeItem, params } = this;
      const { suppressTrapFocus, enableCloseButton } = params;
      const activeElement = this.gos.getActiveDomElement();
      const target = e.target;
      const backwards = e.shiftKey;
      if (eHeader.contains(activeElement)) {
        e.preventDefault();
        if (enableCloseButton && backwards && !((_a = this.eCloseButton) == null ? void 0 : _a.contains(activeElement))) {
          (_b = this.eCloseButton) == null ? void 0 : _b.focus();
        } else if (suppressTrapFocus && backwards) {
          (_c = this.focusService.findFocusableElementBeforeTabGuard(this.gos.getDocument().body, target)) == null ? void 0 : _c.focus();
        } else {
          this.focusBody(e.shiftKey);
        }
        return;
      }
      let nextEl = null;
      if (focusService.isTargetUnderManagedComponent(eBody, target)) {
        if (backwards) {
          nextEl = this.focusService.findFocusableElementBeforeTabGuard(eBody, target);
        }
        if (!nextEl && !suppressTrapFocus) {
          nextEl = activeItem.eHeaderButton;
        }
      }
      if (!nextEl && eBody.contains(activeElement)) {
        nextEl = focusService.findNextFocusableElement(eBody, false, backwards);
        if (!nextEl) {
          e.preventDefault();
          if (suppressTrapFocus && !backwards) {
            this.forceFocusOutOfContainer(backwards);
          } else if (enableCloseButton && !backwards) {
            (_d = this.eCloseButton) == null ? void 0 : _d.focus();
          } else {
            this.focusHeader();
          }
          return;
        }
      }
      if (nextEl) {
        e.preventDefault();
        nextEl.focus();
      }
    }
    focusInnerElement(fromBottom) {
      if (fromBottom) {
        this.focusHeader();
      } else {
        this.focusBody(true);
      }
    }
    focusHeader(preventScroll) {
      this.activeItem.eHeaderButton.focus({ preventScroll });
    }
    focusBody(fromBottom) {
      this.focusService.focusInto(this.eBody, fromBottom);
    }
    setAfterAttachedParams(params) {
      this.afterAttachedParams = params;
    }
    showFirstItem() {
      if (this.items.length > 0) {
        this.showItemWrapper(this.items[0]);
      }
    }
    addItem(item) {
      const eHeaderButton = document.createElement("span");
      setAriaRole(eHeaderButton, "tab");
      eHeaderButton.setAttribute("tabindex", "-1");
      eHeaderButton.appendChild(item.title);
      eHeaderButton.classList.add("ag-tab");
      this.eTabHeader.appendChild(eHeaderButton);
      setAriaLabel(eHeaderButton, item.titleLabel);
      const wrapper = {
        tabbedItem: item,
        eHeaderButton
      };
      this.items.push(wrapper);
      eHeaderButton.addEventListener("click", this.showItemWrapper.bind(this, wrapper));
    }
    showItem(tabbedItem) {
      const itemWrapper = this.items.find((wrapper) => wrapper.tabbedItem === tabbedItem);
      if (itemWrapper) {
        this.showItemWrapper(itemWrapper);
      }
    }
    showItemWrapper(wrapper) {
      var _a, _b, _c, _d, _e, _f;
      const { tabbedItem, eHeaderButton } = wrapper;
      (_b = (_a = this.params).onItemClicked) == null ? void 0 : _b.call(_a, { item: tabbedItem });
      if (this.activeItem === wrapper) {
        (_d = (_c = this.params).onActiveItemClicked) == null ? void 0 : _d.call(_c);
        return;
      }
      if (this.lastScrollListener) {
        this.lastScrollListener = this.lastScrollListener();
      }
      clearElement(this.eBody);
      tabbedItem.bodyPromise.then((body) => {
        this.eBody.appendChild(body);
        const onlyUnmanaged = !this.focusService.isKeyboardMode();
        if (!this.params.suppressFocusBodyOnOpen) {
          this.focusService.focusInto(this.eBody, false, onlyUnmanaged);
        }
        if (tabbedItem.afterAttachedCallback) {
          tabbedItem.afterAttachedCallback(this.afterAttachedParams);
        }
        if (this.params.keepScrollPosition) {
          const scrollableContainer = tabbedItem.getScrollableContainer && tabbedItem.getScrollableContainer() || body;
          this.lastScrollListener = this.addManagedListener(scrollableContainer, "scroll", () => {
            this.tabbedItemScrollMap.set(tabbedItem.name, scrollableContainer.scrollTop);
          });
          const scrollPosition = this.tabbedItemScrollMap.get(tabbedItem.name);
          if (scrollPosition !== void 0) {
            setTimeout(() => {
              scrollableContainer.scrollTop = scrollPosition;
            }, 0);
          }
        }
      });
      if (this.activeItem) {
        this.activeItem.eHeaderButton.classList.remove("ag-tab-selected");
        (_f = (_e = this.activeItem.tabbedItem).afterDetachedCallback) == null ? void 0 : _f.call(_e);
      }
      eHeaderButton.classList.add("ag-tab-selected");
      this.activeItem = wrapper;
    }
  };
  __decorateClass([
    Autowired("focusService")
  ], _TabbedLayout.prototype, "focusService", 2);
  __decorateClass([
    RefSelector("eHeader")
  ], _TabbedLayout.prototype, "eHeader", 2);
  __decorateClass([
    RefSelector("eBody")
  ], _TabbedLayout.prototype, "eBody", 2);
  __decorateClass([
    PostConstruct
  ], _TabbedLayout.prototype, "postConstruct", 1);
  var TabbedLayout = _TabbedLayout;
  var DEBOUNCE_DELAY = 50;
  var ResizeObserverService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.polyfillFunctions = [];
    }
    observeResize(element, callback) {
      const win = this.gos.getWindow();
      const useBrowserResizeObserver = () => {
        const resizeObserver = new win.ResizeObserver(callback);
        resizeObserver.observe(element);
        return () => resizeObserver.disconnect();
      };
      const usePolyfill = () => {
        var _a, _b;
        let widthLastTime = (_a = element == null ? void 0 : element.clientWidth) != null ? _a : 0;
        let heightLastTime = (_b = element == null ? void 0 : element.clientHeight) != null ? _b : 0;
        let running = true;
        const periodicallyCheckWidthAndHeight = () => {
          var _a2, _b2;
          if (running) {
            const newWidth = (_a2 = element == null ? void 0 : element.clientWidth) != null ? _a2 : 0;
            const newHeight = (_b2 = element == null ? void 0 : element.clientHeight) != null ? _b2 : 0;
            const changed = newWidth !== widthLastTime || newHeight !== heightLastTime;
            if (changed) {
              widthLastTime = newWidth;
              heightLastTime = newHeight;
              callback();
            }
            this.doNextPolyfillTurn(periodicallyCheckWidthAndHeight);
          }
        };
        periodicallyCheckWidthAndHeight();
        return () => running = false;
      };
      const suppressResize = this.gos.get("suppressBrowserResizeObserver");
      const resizeObserverExists = !!win.ResizeObserver;
      if (resizeObserverExists && !suppressResize) {
        return useBrowserResizeObserver();
      }
      return this.getFrameworkOverrides().wrapIncoming(() => usePolyfill(), "resize-observer");
    }
    doNextPolyfillTurn(func) {
      this.polyfillFunctions.push(func);
      this.schedulePolyfill();
    }
    schedulePolyfill() {
      if (this.polyfillScheduled) {
        return;
      }
      const executeAllFuncs = () => {
        const funcs = this.polyfillFunctions;
        this.polyfillScheduled = false;
        this.polyfillFunctions = [];
        funcs.forEach((f) => f());
      };
      this.polyfillScheduled = true;
      window.setTimeout(executeAllFuncs, DEBOUNCE_DELAY);
    }
  };
  ResizeObserverService = __decorateClass([
    Bean("resizeObserverService")
  ], ResizeObserverService);
  var AnimationFrameService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.createTasksP1 = { list: [], sorted: false };
      this.createTasksP2 = { list: [], sorted: false };
      this.destroyTasks = [];
      this.ticking = false;
      this.scrollGoingDown = true;
      this.lastPage = 0;
      this.lastScrollTop = 0;
      this.taskCount = 0;
      this.cancelledTasks = /* @__PURE__ */ new Set();
    }
    setScrollTop(scrollTop) {
      const isPaginationActive = this.gos.get("pagination");
      this.scrollGoingDown = scrollTop >= this.lastScrollTop;
      if (isPaginationActive && scrollTop === 0) {
        const currentPage = this.paginationProxy.getCurrentPage();
        if (currentPage !== this.lastPage) {
          this.lastPage = currentPage;
          this.scrollGoingDown = true;
        }
      }
      this.lastScrollTop = scrollTop;
    }
    init() {
      this.useAnimationFrame = !this.gos.get("suppressAnimationFrame");
    }
    isOn() {
      return this.useAnimationFrame;
    }
    // this method is for our AG Grid sanity only - if animation frames are turned off,
    // then no place in the code should be looking to add any work to be done in animation
    // frames. this stops bugs - where some code is asking for a frame to be executed
    // when it should not.
    verifyAnimationFrameOn(methodName) {
      if (this.useAnimationFrame === false) {
        console.warn(`AG Grid: AnimationFrameService.${methodName} called but animation frames are off`);
      }
    }
    createTask(task, index, list) {
      this.verifyAnimationFrameOn(list);
      const taskItem = { task, index, createOrder: ++this.taskCount };
      this.addTaskToList(this[list], taskItem);
      this.schedule();
    }
    cancelTask(task) {
      this.cancelledTasks.add(task);
    }
    addTaskToList(taskList, task) {
      taskList.list.push(task);
      taskList.sorted = false;
    }
    sortTaskList(taskList) {
      if (taskList.sorted) {
        return;
      }
      const sortDirection = this.scrollGoingDown ? 1 : -1;
      taskList.list.sort((a, b) => a.index !== b.index ? sortDirection * (b.index - a.index) : b.createOrder - a.createOrder);
      taskList.sorted = true;
    }
    addDestroyTask(task) {
      this.verifyAnimationFrameOn("createTasksP3");
      this.destroyTasks.push(task);
      this.schedule();
    }
    executeFrame(millis) {
      this.verifyAnimationFrameOn("executeFrame");
      const p1TaskList = this.createTasksP1;
      const p1Tasks = p1TaskList.list;
      const p2TaskList = this.createTasksP2;
      const p2Tasks = p2TaskList.list;
      const destroyTasks = this.destroyTasks;
      const frameStart = (/* @__PURE__ */ new Date()).getTime();
      let duration = (/* @__PURE__ */ new Date()).getTime() - frameStart;
      const noMaxMillis = millis <= 0;
      const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
      while (noMaxMillis || duration < millis) {
        const gridBodyDidSomething = gridBodyCon.getScrollFeature().scrollGridIfNeeded();
        if (!gridBodyDidSomething) {
          let task;
          if (p1Tasks.length) {
            this.sortTaskList(p1TaskList);
            task = p1Tasks.pop().task;
          } else if (p2Tasks.length) {
            this.sortTaskList(p2TaskList);
            task = p2Tasks.pop().task;
          } else if (destroyTasks.length) {
            task = destroyTasks.pop();
          } else {
            this.cancelledTasks.clear();
            break;
          }
          if (!this.cancelledTasks.has(task)) {
            task();
          }
        }
        duration = (/* @__PURE__ */ new Date()).getTime() - frameStart;
      }
      if (p1Tasks.length || p2Tasks.length || destroyTasks.length) {
        this.requestFrame();
      } else {
        this.stopTicking();
      }
    }
    stopTicking() {
      this.ticking = false;
    }
    flushAllFrames() {
      if (!this.useAnimationFrame) {
        return;
      }
      this.executeFrame(-1);
    }
    schedule() {
      if (!this.useAnimationFrame) {
        return;
      }
      if (!this.ticking) {
        this.ticking = true;
        this.requestFrame();
      }
    }
    requestFrame() {
      const callback = this.executeFrame.bind(this, 60);
      this.requestAnimationFrame(callback);
    }
    requestAnimationFrame(callback) {
      const win = this.gos.getWindow();
      if (win.requestAnimationFrame) {
        win.requestAnimationFrame(callback);
      } else if (win.webkitRequestAnimationFrame) {
        win.webkitRequestAnimationFrame(callback);
      } else {
        win.setTimeout(callback, 0);
      }
    }
    isQueueEmpty() {
      return !this.ticking;
    }
    // a debounce utility used for parts of the app involved with rendering.
    // the advantage over normal debounce is the client can call flushAllFrames()
    // to make sure all rendering is complete. we don't wait any milliseconds,
    // as this is intended to batch calls in one VM turn.
    debounce(func) {
      let pending = false;
      return () => {
        if (!this.isOn()) {
          window.setTimeout(func, 0);
          return;
        }
        if (pending) {
          return;
        }
        pending = true;
        this.addDestroyTask(() => {
          pending = false;
          func();
        });
      };
    }
  };
  __decorateClass([
    Autowired("ctrlsService")
  ], AnimationFrameService.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("paginationProxy")
  ], AnimationFrameService.prototype, "paginationProxy", 2);
  __decorateClass([
    PostConstruct
  ], AnimationFrameService.prototype, "init", 1);
  AnimationFrameService = __decorateClass([
    Bean("animationFrameService")
  ], AnimationFrameService);
  var ClientSideRowModelSteps = /* @__PURE__ */ ((ClientSideRowModelSteps2) => {
    ClientSideRowModelSteps2["EVERYTHING"] = "group";
    ClientSideRowModelSteps2["FILTER"] = "filter";
    ClientSideRowModelSteps2["SORT"] = "sort";
    ClientSideRowModelSteps2["MAP"] = "map";
    ClientSideRowModelSteps2["AGGREGATE"] = "aggregate";
    ClientSideRowModelSteps2["FILTER_AGGREGATES"] = "filter_aggregates";
    ClientSideRowModelSteps2["PIVOT"] = "pivot";
    ClientSideRowModelSteps2["NOTHING"] = "nothing";
    return ClientSideRowModelSteps2;
  })(ClientSideRowModelSteps || {});
  var ExpansionService = class extends BeanStub {
    postConstruct() {
      this.isClientSideRowModel = this.rowModel.getType() === "clientSide";
    }
    expandRows(rowIds) {
      if (!this.isClientSideRowModel) {
        return;
      }
      const rowIdSet = new Set(rowIds);
      this.rowModel.forEachNode((node) => {
        if (node.id && rowIdSet.has(node.id)) {
          node.expanded = true;
        }
      });
      this.onGroupExpandedOrCollapsed();
    }
    getExpandedRows() {
      const expandedRows = [];
      this.rowModel.forEachNode(({ expanded, id }) => {
        if (expanded && id) {
          expandedRows.push(id);
        }
      });
      return expandedRows;
    }
    expandAll(value) {
      if (!this.isClientSideRowModel) {
        return;
      }
      this.rowModel.expandOrCollapseAll(value);
    }
    setRowNodeExpanded(rowNode, expanded, expandParents, forceSync) {
      if (rowNode) {
        if (expandParents && rowNode.parent && rowNode.parent.level !== -1) {
          this.setRowNodeExpanded(rowNode.parent, expanded, expandParents, forceSync);
        }
        rowNode.setExpanded(expanded, void 0, forceSync);
      }
    }
    onGroupExpandedOrCollapsed() {
      if (!this.isClientSideRowModel) {
        return;
      }
      this.rowModel.refreshModel({
        step: "map"
        /* MAP */
      });
    }
  };
  __decorateClass([
    Autowired("rowModel")
  ], ExpansionService.prototype, "rowModel", 2);
  __decorateClass([
    PostConstruct
  ], ExpansionService.prototype, "postConstruct", 1);
  ExpansionService = __decorateClass([
    Bean("expansionService")
  ], ExpansionService);
  var MenuService = class extends BeanStub {
    postConstruct() {
      var _a;
      this.activeMenuFactory = (_a = this.enterpriseMenuFactory) != null ? _a : this.filterMenuFactory;
    }
    showColumnMenu(params) {
      this.showColumnMenuCommon(this.activeMenuFactory, params, "columnMenu");
    }
    showFilterMenu(params) {
      const menuFactory = this.enterpriseMenuFactory && this.isLegacyMenuEnabled() ? this.enterpriseMenuFactory : this.filterMenuFactory;
      this.showColumnMenuCommon(menuFactory, params, params.containerType, true);
    }
    showHeaderContextMenu(column, mouseEvent, touchEvent) {
      this.activeMenuFactory.showMenuAfterContextMenuEvent(column, mouseEvent, touchEvent);
    }
    getContextMenuPosition(rowNode, column) {
      const rowCtrl = this.getRowCtrl(rowNode);
      const eGui = this.getCellGui(rowCtrl, column);
      if (!eGui) {
        if (rowCtrl) {
          return { x: 0, y: rowCtrl.getRowYPosition() };
        }
        return { x: 0, y: 0 };
      }
      const rect = eGui.getBoundingClientRect();
      return {
        x: rect.x + rect.width / 2,
        y: rect.y + rect.height / 2
      };
    }
    showContextMenu(params) {
      var _a, _b, _c;
      const { column, rowNode } = params;
      let { anchorToElement, value } = params;
      if (rowNode && column && value == null) {
        value = rowNode.getValueFromValueService(column);
      }
      if (anchorToElement == null) {
        anchorToElement = this.getContextMenuAnchorElement(rowNode, column);
      }
      (_c = this.contextMenuFactory) == null ? void 0 : _c.onContextMenu(
        (_a = params.mouseEvent) != null ? _a : null,
        (_b = params.touchEvent) != null ? _b : null,
        rowNode != null ? rowNode : null,
        column != null ? column : null,
        value,
        anchorToElement
      );
    }
    showColumnChooser(params) {
      var _a;
      (_a = this.columnChooserFactory) == null ? void 0 : _a.showColumnChooser(params);
    }
    hidePopupMenu() {
      var _a;
      (_a = this.contextMenuFactory) == null ? void 0 : _a.hideActiveMenu();
      this.activeMenuFactory.hideActiveMenu();
    }
    hideColumnChooser() {
      var _a;
      (_a = this.columnChooserFactory) == null ? void 0 : _a.hideActiveColumnChooser();
    }
    isColumnMenuInHeaderEnabled(column) {
      const { suppressMenu, suppressHeaderMenuButton } = column.getColDef();
      const isSuppressMenuButton = suppressHeaderMenuButton != null ? suppressHeaderMenuButton : suppressMenu;
      return !isSuppressMenuButton && this.activeMenuFactory.isMenuEnabled(column) && (this.isLegacyMenuEnabled() || !!this.enterpriseMenuFactory);
    }
    isFilterMenuInHeaderEnabled(column) {
      return !column.getColDef().suppressHeaderFilterButton && this.filterManager.isFilterAllowed(column);
    }
    isHeaderContextMenuEnabled(column) {
      return !(column == null ? void 0 : column.getColDef().suppressHeaderContextMenu) && this.getColumnMenuType() === "new";
    }
    isHeaderMenuButtonAlwaysShowEnabled() {
      return this.isSuppressMenuHide();
    }
    isHeaderMenuButtonEnabled() {
      const menuHides = !this.isSuppressMenuHide();
      const onIpadAndMenuHides = isIOSUserAgent() && menuHides;
      return !onIpadAndMenuHides;
    }
    isHeaderFilterButtonEnabled(column) {
      return this.isFilterMenuInHeaderEnabled(column) && !this.isLegacyMenuEnabled() && !this.isFloatingFilterButtonDisplayed(column);
    }
    isFilterMenuItemEnabled(column) {
      return this.filterManager.isFilterAllowed(column) && !this.isLegacyMenuEnabled() && !this.isFilterMenuInHeaderEnabled(column) && !this.isFloatingFilterButtonDisplayed(column);
    }
    isColumnMenuAnchoringEnabled() {
      return !this.isLegacyMenuEnabled();
    }
    areAdditionalColumnMenuItemsEnabled() {
      return this.getColumnMenuType() === "new";
    }
    isLegacyMenuEnabled() {
      return this.getColumnMenuType() === "legacy";
    }
    isFloatingFilterButtonEnabled(column) {
      var _a;
      const colDef = column.getColDef();
      const legacySuppressFilterButton = (_a = colDef.floatingFilterComponentParams) == null ? void 0 : _a.suppressFilterButton;
      if (legacySuppressFilterButton != null) {
        warnOnce(`As of v31.1, 'colDef.floatingFilterComponentParams.suppressFilterButton' is deprecated. Use 'colDef.suppressFloatingFilterButton' instead.`);
      }
      return colDef.suppressFloatingFilterButton == null ? !legacySuppressFilterButton : !colDef.suppressFloatingFilterButton;
    }
    getColumnMenuType() {
      var _a;
      return (_a = this.gos.get("columnMenu")) != null ? _a : "legacy";
    }
    isFloatingFilterButtonDisplayed(column) {
      return !!column.getColDef().floatingFilter && this.isFloatingFilterButtonEnabled(column);
    }
    isSuppressMenuHide() {
      const suppressMenuHide = this.gos.get("suppressMenuHide");
      if (this.isLegacyMenuEnabled()) {
        return suppressMenuHide;
      } else {
        return this.gos.exists("suppressMenuHide") ? suppressMenuHide : true;
      }
    }
    showColumnMenuCommon(menuFactory, params, containerType, filtersOnly) {
      const { column, positionBy } = params;
      if (positionBy === "button") {
        const { buttonElement } = params;
        menuFactory.showMenuAfterButtonClick(column, buttonElement, containerType, filtersOnly);
      } else if (positionBy === "mouse") {
        const { mouseEvent } = params;
        menuFactory.showMenuAfterMouseEvent(column, mouseEvent, containerType, filtersOnly);
      } else if (column) {
        this.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(column, "auto");
        this.animationFrameService.requestAnimationFrame(() => {
          const headerCellCtrl = this.ctrlsService.getHeaderRowContainerCtrl(column.getPinned()).getHeaderCtrlForColumn(column);
          menuFactory.showMenuAfterButtonClick(column, headerCellCtrl.getAnchorElementForMenu(filtersOnly), containerType, true);
        });
      }
    }
    getRowCtrl(rowNode) {
      const { rowIndex, rowPinned } = rowNode || {};
      if (rowIndex == null) {
        return;
      }
      return this.rowRenderer.getRowByPosition({ rowIndex, rowPinned }) || void 0;
    }
    getCellGui(rowCtrl, column) {
      if (!rowCtrl || !column) {
        return;
      }
      const cellCtrl = rowCtrl.getCellCtrl(column);
      return (cellCtrl == null ? void 0 : cellCtrl.getGui()) || void 0;
    }
    getContextMenuAnchorElement(rowNode, column) {
      const gridBodyEl = this.ctrlsService.getGridBodyCtrl().getGridBodyElement();
      const rowCtrl = this.getRowCtrl(rowNode);
      if (!rowCtrl) {
        return gridBodyEl;
      }
      const cellGui = this.getCellGui(rowCtrl, column);
      if (cellGui) {
        return cellGui;
      }
      if (rowCtrl.isFullWidth()) {
        return rowCtrl.getFullWidthElement();
      }
      return gridBodyEl;
    }
  };
  __decorateClass([
    Autowired("filterMenuFactory")
  ], MenuService.prototype, "filterMenuFactory", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], MenuService.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("animationFrameService")
  ], MenuService.prototype, "animationFrameService", 2);
  __decorateClass([
    Autowired("filterManager")
  ], MenuService.prototype, "filterManager", 2);
  __decorateClass([
    Autowired("rowRenderer")
  ], MenuService.prototype, "rowRenderer", 2);
  __decorateClass([
    Optional("columnChooserFactory")
  ], MenuService.prototype, "columnChooserFactory", 2);
  __decorateClass([
    Optional("contextMenuFactory")
  ], MenuService.prototype, "contextMenuFactory", 2);
  __decorateClass([
    Optional("enterpriseMenuFactory")
  ], MenuService.prototype, "enterpriseMenuFactory", 2);
  __decorateClass([
    PostConstruct
  ], MenuService.prototype, "postConstruct", 1);
  MenuService = __decorateClass([
    Bean("menuService")
  ], MenuService);
  var AutoWidthCalculator = class extends BeanStub {
    postConstruct() {
      this.ctrlsService.whenReady((p2) => {
        this.centerRowContainerCtrl = p2.center;
      });
    }
    // this is the trick: we create a dummy container and clone all the cells
    // into the dummy, then check the dummy's width. then destroy the dummy
    // as we don't need it any more.
    // drawback: only the cells visible on the screen are considered
    getPreferredWidthForColumn(column, skipHeader) {
      const eHeaderCell = this.getHeaderCellForColumn(column);
      if (!eHeaderCell) {
        return -1;
      }
      const elements = this.rowRenderer.getAllCellsForColumn(column);
      if (!skipHeader) {
        elements.push(eHeaderCell);
      }
      return this.addElementsToContainerAndGetWidth(elements);
    }
    getPreferredWidthForColumnGroup(columnGroup) {
      const eHeaderCell = this.getHeaderCellForColumn(columnGroup);
      if (!eHeaderCell) {
        return -1;
      }
      return this.addElementsToContainerAndGetWidth([eHeaderCell]);
    }
    addElementsToContainerAndGetWidth(elements) {
      const eDummyContainer = document.createElement("form");
      eDummyContainer.style.position = "fixed";
      const eBodyContainer = this.centerRowContainerCtrl.getContainerElement();
      elements.forEach((el) => this.cloneItemIntoDummy(el, eDummyContainer));
      eBodyContainer.appendChild(eDummyContainer);
      const dummyContainerWidth = eDummyContainer.offsetWidth;
      eBodyContainer.removeChild(eDummyContainer);
      const autoSizePadding = this.getAutoSizePadding();
      return dummyContainerWidth + autoSizePadding;
    }
    getAutoSizePadding() {
      return this.gos.get("autoSizePadding");
    }
    getHeaderCellForColumn(column) {
      let element = null;
      this.ctrlsService.getHeaderRowContainerCtrls().forEach(
        (container) => {
          const res = container.getHtmlElementForColumnHeader(column);
          if (res != null) {
            element = res;
          }
        }
      );
      return element;
    }
    cloneItemIntoDummy(eCell, eDummyContainer) {
      const eCellClone = eCell.cloneNode(true);
      eCellClone.style.width = "";
      eCellClone.style.position = "static";
      eCellClone.style.left = "";
      const eCloneParent = document.createElement("div");
      const eCloneParentClassList = eCloneParent.classList;
      const isHeader = ["ag-header-cell", "ag-header-group-cell"].some(
        (cls) => eCellClone.classList.contains(cls)
      );
      if (isHeader) {
        eCloneParentClassList.add("ag-header", "ag-header-row");
        eCloneParent.style.position = "static";
      } else {
        eCloneParentClassList.add("ag-row");
      }
      let pointer = eCell.parentElement;
      while (pointer) {
        const isRow = ["ag-header-row", "ag-row"].some(
          (cls) => pointer.classList.contains(cls)
        );
        if (isRow) {
          for (let i = 0; i < pointer.classList.length; i++) {
            const item = pointer.classList[i];
            if (item != "ag-row-position-absolute") {
              eCloneParentClassList.add(item);
            }
          }
          break;
        }
        pointer = pointer.parentElement;
      }
      eCloneParent.appendChild(eCellClone);
      eDummyContainer.appendChild(eCloneParent);
    }
  };
  __decorateClass([
    Autowired("rowRenderer")
  ], AutoWidthCalculator.prototype, "rowRenderer", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], AutoWidthCalculator.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("rowCssClassCalculator")
  ], AutoWidthCalculator.prototype, "rowCssClassCalculator", 2);
  __decorateClass([
    PostConstruct
  ], AutoWidthCalculator.prototype, "postConstruct", 1);
  AutoWidthCalculator = __decorateClass([
    Bean("autoWidthCalculator")
  ], AutoWidthCalculator);
  var StickyRowFeature = class extends BeanStub {
    constructor(createRowCon, destroyRowCtrls) {
      super();
      this.createRowCon = createRowCon;
      this.destroyRowCtrls = destroyRowCtrls;
      this.stickyTopRowCtrls = [];
      this.stickyBottomRowCtrls = [];
      this.topContainerHeight = 0;
      this.bottomContainerHeight = 0;
    }
    postConstruct() {
      this.isClientSide = this.rowModel.getType() === "clientSide";
      this.ctrlsService.whenReady((params) => {
        this.gridBodyCtrl = params.gridBodyCtrl;
      });
    }
    getStickyTopRowCtrls() {
      return this.stickyTopRowCtrls;
    }
    getStickyBottomRowCtrls() {
      return this.stickyBottomRowCtrls;
    }
    /**
     * Get the last pixel of the group, this pixel is used to push the sticky node up out of the viewport.
     */
    getLastPixelOfGroup(row) {
      return this.isClientSide ? this.getClientSideLastPixelOfGroup(row) : this.getServerSideLastPixelOfGroup(row);
    }
    /**
     * Get the first pixel of the group, this pixel is used to push the sticky node down out of the viewport
     */
    getFirstPixelOfGroup(row) {
      if (row.footer) {
        return row.sibling.rowTop + row.sibling.rowHeight - 1;
      }
      if (row.hasChildren()) {
        return row.rowTop - 1;
      }
      return 0;
    }
    getServerSideLastPixelOfGroup(row) {
      var _a, _b, _c, _d;
      if (this.isClientSide) {
        throw new Error("This func should only be called in server side row model.");
      }
      if (row.isExpandable() || row.footer) {
        if (row.master) {
          return row.detailNode.rowTop + row.detailNode.rowHeight;
        }
        const noOrContiguousSiblings = !row.sibling || Math.abs(row.sibling.rowIndex - row.rowIndex) === 1;
        if (noOrContiguousSiblings) {
          let storeBounds = (_a = row.childStore) == null ? void 0 : _a.getStoreBounds();
          if (row.footer) {
            storeBounds = (_b = row.sibling.childStore) == null ? void 0 : _b.getStoreBounds();
          }
          return ((_c = storeBounds == null ? void 0 : storeBounds.heightPx) != null ? _c : 0) + ((_d = storeBounds == null ? void 0 : storeBounds.topPx) != null ? _d : 0);
        }
        if (row.footer) {
          return row.rowTop + row.rowHeight;
        }
        return row.sibling.rowTop + row.sibling.rowHeight;
      }
      return Number.MAX_SAFE_INTEGER;
    }
    getClientSideLastPixelOfGroup(row) {
      if (!this.isClientSide) {
        throw new Error("This func should only be called in client side row model.");
      }
      if (row.isExpandable() || row.footer) {
        const grandTotalAtTop = row.footer && row.rowIndex === 0;
        const noOrContiguousSiblings = !row.sibling || Math.abs(row.sibling.rowIndex - row.rowIndex) === 1;
        if (grandTotalAtTop || noOrContiguousSiblings) {
          let lastAncestor = row.footer ? row.sibling : row;
          while (lastAncestor.isExpandable() && lastAncestor.expanded) {
            if (lastAncestor.master) {
              lastAncestor = lastAncestor.detailNode;
            } else if (lastAncestor.childrenAfterSort) {
              if (lastAncestor.childrenAfterSort.length === 0) {
                break;
              }
              lastAncestor = last(lastAncestor.childrenAfterSort);
            }
          }
          return lastAncestor.rowTop + lastAncestor.rowHeight;
        }
        if (row.footer) {
          return row.rowTop + row.rowHeight;
        }
        return row.sibling.rowTop + row.sibling.rowHeight;
      }
      return Number.MAX_SAFE_INTEGER;
    }
    updateStickyRows(container) {
      const isTop = container === "top";
      let newStickyContainerHeight = 0;
      if (!this.canRowsBeSticky()) {
        return this.refreshNodesAndContainerHeight(container, /* @__PURE__ */ new Set(), newStickyContainerHeight);
      }
      const pixelAtContainerBoundary = isTop ? this.rowRenderer.getFirstVisibleVerticalPixel() : this.rowRenderer.getLastVisibleVerticalPixel();
      const newStickyRows = /* @__PURE__ */ new Set();
      const addStickyRow = (stickyRow) => {
        newStickyRows.add(stickyRow);
        if (isTop) {
          const lastChildBottom = this.getLastPixelOfGroup(stickyRow);
          const stickRowBottom = pixelAtContainerBoundary + newStickyContainerHeight + stickyRow.rowHeight;
          if (lastChildBottom < stickRowBottom) {
            stickyRow.stickyRowTop = newStickyContainerHeight + (lastChildBottom - stickRowBottom);
          } else {
            stickyRow.stickyRowTop = newStickyContainerHeight;
          }
        } else {
          const lastChildBottom = this.getFirstPixelOfGroup(stickyRow);
          const stickRowTop = pixelAtContainerBoundary - (newStickyContainerHeight + stickyRow.rowHeight);
          if (lastChildBottom > stickRowTop) {
            stickyRow.stickyRowTop = newStickyContainerHeight - (lastChildBottom - stickRowTop);
          } else {
            stickyRow.stickyRowTop = newStickyContainerHeight;
          }
        }
        newStickyContainerHeight = 0;
        newStickyRows.forEach((rowNode) => {
          const thisRowLastPx = rowNode.stickyRowTop + rowNode.rowHeight;
          if (newStickyContainerHeight < thisRowLastPx) {
            newStickyContainerHeight = thisRowLastPx;
          }
        });
      };
      const suppressFootersSticky = this.areFooterRowsStickySuppressed();
      const suppressGroupsSticky = this.gos.get("suppressGroupRowsSticky");
      const isRowSticky = (row) => {
        if (!row.displayed) {
          return false;
        }
        if (row.footer) {
          if (suppressFootersSticky === true) {
            return false;
          }
          if (suppressFootersSticky === "grand" && row.level === -1) {
            return false;
          }
          ;
          if (suppressFootersSticky === "group" && row.level > -1) {
            return false;
          }
          ;
          const alreadySticking = newStickyRows.has(row);
          return !alreadySticking;
        }
        if (row.isExpandable()) {
          if (suppressGroupsSticky === true) {
            return false;
          }
          ;
          const alreadySticking = newStickyRows.has(row);
          return !alreadySticking && row.expanded;
        }
        return false;
      };
      for (let i = 0; i < 100; i++) {
        let firstPixelAfterStickyRows = pixelAtContainerBoundary + newStickyContainerHeight;
        if (!isTop) {
          firstPixelAfterStickyRows = pixelAtContainerBoundary - newStickyContainerHeight;
        }
        const firstIndex = this.rowModel.getRowIndexAtPixel(firstPixelAfterStickyRows);
        const firstRow = this.rowModel.getRow(firstIndex);
        if (firstRow == null) {
          break;
        }
        const ancestors = this.getStickyAncestors(firstRow);
        const firstMissingParent = ancestors.find(
          (parent) => (isTop ? parent.rowIndex < firstIndex : parent.rowIndex > firstIndex) && isRowSticky(parent)
        );
        if (firstMissingParent) {
          addStickyRow(firstMissingParent);
          continue;
        }
        const isFirstRowOutsideViewport = isTop ? firstRow.rowTop < firstPixelAfterStickyRows : firstRow.rowTop + firstRow.rowHeight > firstPixelAfterStickyRows;
        if (isFirstRowOutsideViewport && isRowSticky(firstRow)) {
          addStickyRow(firstRow);
          continue;
        }
        break;
      }
      if (!isTop) {
        newStickyRows.forEach((rowNode) => {
          rowNode.stickyRowTop = newStickyContainerHeight - (rowNode.stickyRowTop + rowNode.rowHeight);
        });
      }
      return this.refreshNodesAndContainerHeight(container, newStickyRows, newStickyContainerHeight);
    }
    areFooterRowsStickySuppressed() {
      const suppressFootersSticky = this.gos.get("suppressStickyTotalRow");
      if (suppressFootersSticky === true) {
        return true;
      }
      const suppressGroupRows = !!this.gos.get("groupIncludeFooter") || suppressFootersSticky === "group";
      const suppressGrandRows = !!this.gos.get("groupIncludeTotalFooter") || suppressFootersSticky === "grand";
      if (suppressGroupRows && suppressGrandRows) {
        return true;
      }
      if (suppressGrandRows) {
        return "grand";
      }
      if (suppressGroupRows) {
        return "group";
      }
      return false;
    }
    canRowsBeSticky() {
      const isStickyEnabled = this.gos.isGroupRowsSticky();
      const suppressFootersSticky = this.areFooterRowsStickySuppressed();
      const suppressGroupsSticky = this.gos.get("suppressGroupRowsSticky");
      return isStickyEnabled && (!suppressFootersSticky || !suppressGroupsSticky);
    }
    getStickyAncestors(rowNode) {
      const ancestors = [];
      let p2 = rowNode.footer ? rowNode.sibling : rowNode.parent;
      while (p2) {
        if (p2.sibling) {
          ancestors.push(p2.sibling);
        }
        ancestors.push(p2);
        p2 = p2.parent;
      }
      return ancestors.reverse();
    }
    checkStickyRows() {
      const hasTopUpdated = this.updateStickyRows("top");
      const hasBottomUpdated = this.updateStickyRows("bottom");
      return hasTopUpdated || hasBottomUpdated;
    }
    destroyStickyCtrls() {
      this.refreshNodesAndContainerHeight("top", /* @__PURE__ */ new Set(), 0);
      this.refreshNodesAndContainerHeight("bottom", /* @__PURE__ */ new Set(), 0);
    }
    refreshStickyNode(stickRowNode) {
      const allStickyNodes = /* @__PURE__ */ new Set();
      if (this.stickyTopRowCtrls.some((ctrl) => ctrl.getRowNode() === stickRowNode)) {
        for (let i = 0; i < this.stickyTopRowCtrls.length; i++) {
          const currentNode = this.stickyTopRowCtrls[i].getRowNode();
          if (currentNode !== stickRowNode) {
            allStickyNodes.add(currentNode);
          }
        }
        if (this.refreshNodesAndContainerHeight("top", allStickyNodes, this.topContainerHeight)) {
          this.checkStickyRows();
        }
        return;
      }
      for (let i = 0; i < this.stickyBottomRowCtrls.length; i++) {
        const currentNode = this.stickyBottomRowCtrls[i].getRowNode();
        if (currentNode !== stickRowNode) {
          allStickyNodes.add(currentNode);
        }
      }
      if (this.refreshNodesAndContainerHeight("bottom", allStickyNodes, this.bottomContainerHeight)) {
        this.checkStickyRows();
      }
    }
    /**
     * Destroy old ctrls and create new ctrls where necessary.
     */
    refreshNodesAndContainerHeight(container, newStickyNodes, height) {
      const isTop = container === "top";
      const previousCtrls = isTop ? this.stickyTopRowCtrls : this.stickyBottomRowCtrls;
      const removedCtrlsMap = {};
      const remainingCtrls = [];
      for (let i = 0; i < previousCtrls.length; i++) {
        const node = previousCtrls[i].getRowNode();
        const hasBeenRemoved = !newStickyNodes.has(node);
        if (hasBeenRemoved) {
          removedCtrlsMap[node.id] = previousCtrls[i];
          node.sticky = false;
          continue;
        }
        remainingCtrls.push(previousCtrls[i]);
      }
      const existingNodes = /* @__PURE__ */ new Set();
      for (let i = 0; i < remainingCtrls.length; i++) {
        existingNodes.add(remainingCtrls[i].getRowNode());
      }
      const newCtrls = [];
      newStickyNodes.forEach((node) => {
        if (existingNodes.has(node)) {
          return;
        }
        node.sticky = true;
        newCtrls.push(this.createRowCon(node, false, false));
      });
      let hasSomethingChanged = !!newCtrls.length || remainingCtrls.length !== previousCtrls.length;
      if (isTop) {
        if (this.topContainerHeight !== height) {
          this.topContainerHeight = height;
          this.gridBodyCtrl.setStickyTopHeight(height);
          hasSomethingChanged = true;
        }
      } else {
        if (this.bottomContainerHeight !== height) {
          this.bottomContainerHeight = height;
          this.gridBodyCtrl.setStickyBottomHeight(height);
          hasSomethingChanged = true;
        }
      }
      this.destroyRowCtrls(removedCtrlsMap, false);
      const newCtrlsList = [...remainingCtrls, ...newCtrls];
      newCtrlsList.sort((a, b) => b.getRowNode().rowIndex - a.getRowNode().rowIndex);
      if (!isTop) {
        newCtrlsList.reverse();
      }
      newCtrlsList.forEach((ctrl) => ctrl.setRowTop(ctrl.getRowNode().stickyRowTop));
      if (!hasSomethingChanged) {
        return false;
      }
      if (isTop) {
        this.stickyTopRowCtrls = newCtrlsList;
      } else {
        this.stickyBottomRowCtrls = newCtrlsList;
      }
      return true;
    }
  };
  __decorateClass([
    Autowired("rowModel")
  ], StickyRowFeature.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("rowRenderer")
  ], StickyRowFeature.prototype, "rowRenderer", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], StickyRowFeature.prototype, "ctrlsService", 2);
  __decorateClass([
    PostConstruct
  ], StickyRowFeature.prototype, "postConstruct", 1);
  var RowRenderer = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.destroyFuncsForColumnListeners = [];
      this.rowCtrlsByRowIndex = {};
      this.zombieRowCtrls = {};
      this.allRowCtrls = [];
      this.topRowCtrls = [];
      this.bottomRowCtrls = [];
      this.refreshInProgress = false;
      this.dataFirstRenderedFired = false;
      this.setupRangeSelectionListeners = () => {
        const onRangeSelectionChanged = () => {
          this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onRangeSelectionChanged());
        };
        const onColumnMovedPinnedVisible = () => {
          this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.updateRangeBordersIfRangeCount());
        };
        const addRangeSelectionListeners = () => {
          this.eventService.addEventListener(Events.EVENT_RANGE_SELECTION_CHANGED, onRangeSelectionChanged);
          this.eventService.addEventListener(Events.EVENT_COLUMN_MOVED, onColumnMovedPinnedVisible);
          this.eventService.addEventListener(Events.EVENT_COLUMN_PINNED, onColumnMovedPinnedVisible);
          this.eventService.addEventListener(Events.EVENT_COLUMN_VISIBLE, onColumnMovedPinnedVisible);
        };
        const removeRangeSelectionListeners = () => {
          this.eventService.removeEventListener(Events.EVENT_RANGE_SELECTION_CHANGED, onRangeSelectionChanged);
          this.eventService.removeEventListener(Events.EVENT_COLUMN_MOVED, onColumnMovedPinnedVisible);
          this.eventService.removeEventListener(Events.EVENT_COLUMN_PINNED, onColumnMovedPinnedVisible);
          this.eventService.removeEventListener(Events.EVENT_COLUMN_VISIBLE, onColumnMovedPinnedVisible);
        };
        this.addDestroyFunc(() => removeRangeSelectionListeners());
        this.addManagedPropertyListener("enableRangeSelection", (params) => {
          const isEnabled = params.currentValue;
          if (isEnabled) {
            addRangeSelectionListeners();
          } else {
            removeRangeSelectionListeners();
          }
        });
        const rangeSelectionEnabled = this.gos.get("enableRangeSelection");
        if (rangeSelectionEnabled) {
          addRangeSelectionListeners();
        }
      };
    }
    postConstruct() {
      this.ctrlsService.whenReady((p2) => {
        this.gridBodyCtrl = p2.gridBodyCtrl;
        this.initialise();
      });
    }
    initialise() {
      this.addManagedListener(this.eventService, Events.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL, this.onBodyScroll.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_BODY_HEIGHT_CHANGED, this.redraw.bind(this));
      this.addManagedPropertyListeners(["domLayout", "embedFullWidthRows"], () => this.onDomLayoutChanged());
      this.addManagedPropertyListeners(["suppressMaxRenderedRowRestriction", "rowBuffer"], () => this.redraw());
      this.addManagedPropertyListeners([
        "suppressCellFocus",
        "getBusinessKeyForNode",
        "fullWidthCellRenderer",
        "fullWidthCellRendererParams",
        "rowStyle",
        "getRowStyle",
        "rowClass",
        "getRowClass",
        "rowClassRules",
        "suppressStickyTotalRow",
        "groupRowRenderer",
        "groupRowRendererParams",
        // maybe only needs to refresh FW rows...
        "loadingCellRenderer",
        "loadingCellRendererParams",
        "detailCellRenderer",
        "detailCellRendererParams",
        "enableRangeSelection",
        "enableCellTextSelection"
      ], () => this.redrawRows());
      if (this.gos.isGroupRowsSticky()) {
        const rowModelType = this.rowModel.getType();
        if (rowModelType === "clientSide" || rowModelType === "serverSide") {
          this.stickyRowFeature = this.createManagedBean(new StickyRowFeature(
            this.createRowCon.bind(this),
            this.destroyRowCtrls.bind(this)
          ));
        }
      }
      this.registerCellEventListeners();
      this.initialiseCache();
      this.printLayout = this.gos.isDomLayout("print");
      this.embedFullWidthRows = this.printLayout || this.gos.get("embedFullWidthRows");
      this.redrawAfterModelUpdate();
    }
    initialiseCache() {
      if (this.gos.get("keepDetailRows")) {
        const countProp = this.getKeepDetailRowsCount();
        const count = countProp != null ? countProp : 3;
        this.cachedRowCtrls = new RowCtrlCache(count);
      }
    }
    getKeepDetailRowsCount() {
      return this.gos.get("keepDetailRowsCount");
    }
    getStickyTopRowCtrls() {
      if (!this.stickyRowFeature) {
        return [];
      }
      return this.stickyRowFeature.getStickyTopRowCtrls();
    }
    getStickyBottomRowCtrls() {
      if (!this.stickyRowFeature) {
        return [];
      }
      return this.stickyRowFeature.getStickyBottomRowCtrls();
    }
    updateAllRowCtrls() {
      const liveList = getAllValuesInObject(this.rowCtrlsByRowIndex);
      const zombieList = getAllValuesInObject(this.zombieRowCtrls);
      const cachedList = this.cachedRowCtrls ? this.cachedRowCtrls.getEntries() : [];
      if (zombieList.length > 0 || cachedList.length > 0) {
        this.allRowCtrls = [...liveList, ...zombieList, ...cachedList];
      } else {
        this.allRowCtrls = liveList;
      }
    }
    onCellFocusChanged(event) {
      this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onCellFocused(event));
      this.getFullWidthRowCtrls().forEach((rowCtrl) => rowCtrl.onFullWidthRowFocused(event));
    }
    // in a clean design, each cell would register for each of these events. however when scrolling, all the cells
    // registering and de-registering for events is a performance bottleneck. so we register here once and inform
    // all active cells.
    registerCellEventListeners() {
      this.addManagedListener(this.eventService, Events.EVENT_CELL_FOCUSED, (event) => {
        this.onCellFocusChanged(event);
      });
      this.addManagedListener(this.eventService, Events.EVENT_CELL_FOCUS_CLEARED, () => {
        this.onCellFocusChanged();
      });
      this.addManagedListener(this.eventService, Events.EVENT_FLASH_CELLS, (event) => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onFlashCells(event));
      });
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_HOVER_CHANGED, () => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onColumnHover());
      });
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, () => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onDisplayedColumnsChanged());
      });
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, () => {
        if (this.printLayout) {
          this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onLeftChanged());
        }
      });
      this.setupRangeSelectionListeners();
      this.refreshListenersToColumnsForCellComps();
      this.addManagedListener(this.eventService, Events.EVENT_GRID_COLUMNS_CHANGED, this.refreshListenersToColumnsForCellComps.bind(this));
      this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
    }
    // executes all functions in destroyFuncsForColumnListeners and then clears the list
    removeGridColumnListeners() {
      this.destroyFuncsForColumnListeners.forEach((func) => func());
      this.destroyFuncsForColumnListeners.length = 0;
    }
    // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.
    // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to
    // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here
    // once instead.
    refreshListenersToColumnsForCellComps() {
      this.removeGridColumnListeners();
      const cols = this.columnModel.getAllGridColumns();
      cols.forEach((col) => {
        const forEachCellWithThisCol = (callback) => {
          this.getAllCellCtrls().forEach((cellCtrl) => {
            if (cellCtrl.getColumn() === col) {
              callback(cellCtrl);
            }
          });
        };
        const leftChangedListener = () => {
          forEachCellWithThisCol((cellCtrl) => cellCtrl.onLeftChanged());
        };
        const widthChangedListener = () => {
          forEachCellWithThisCol((cellCtrl) => cellCtrl.onWidthChanged());
        };
        const firstRightPinnedChangedListener = () => {
          forEachCellWithThisCol((cellCtrl) => cellCtrl.onFirstRightPinnedChanged());
        };
        const lastLeftPinnedChangedListener = () => {
          forEachCellWithThisCol((cellCtrl) => cellCtrl.onLastLeftPinnedChanged());
        };
        const colDefChangedListener = () => {
          forEachCellWithThisCol((cellCtrl) => cellCtrl.onColDefChanged());
        };
        col.addEventListener("leftChanged", leftChangedListener);
        col.addEventListener("widthChanged", widthChangedListener);
        col.addEventListener("firstRightPinnedChanged", firstRightPinnedChangedListener);
        col.addEventListener("lastLeftPinnedChanged", lastLeftPinnedChangedListener);
        col.addEventListener("colDefChanged", colDefChangedListener);
        this.destroyFuncsForColumnListeners.push(() => {
          col.removeEventListener("leftChanged", leftChangedListener);
          col.removeEventListener("widthChanged", widthChangedListener);
          col.removeEventListener("firstRightPinnedChanged", firstRightPinnedChangedListener);
          col.removeEventListener("lastLeftPinnedChanged", lastLeftPinnedChangedListener);
          col.removeEventListener("colDefChanged", colDefChangedListener);
        });
      });
    }
    onDomLayoutChanged() {
      const printLayout = this.gos.isDomLayout("print");
      const embedFullWidthRows = printLayout || this.gos.get("embedFullWidthRows");
      const destroyRows = embedFullWidthRows !== this.embedFullWidthRows || this.printLayout !== printLayout;
      this.printLayout = printLayout;
      this.embedFullWidthRows = embedFullWidthRows;
      if (destroyRows) {
        this.redrawAfterModelUpdate({ domLayoutChanged: true });
      }
    }
    // for row models that have datasources, when we update the datasource, we need to force the rowRenderer
    // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.
    datasourceChanged() {
      this.firstRenderedRow = 0;
      this.lastRenderedRow = -1;
      const rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);
      this.removeRowCtrls(rowIndexesToRemove);
    }
    onPageLoaded(event) {
      const params = {
        recycleRows: event.keepRenderedRows,
        animate: event.animate,
        newData: event.newData,
        newPage: event.newPage,
        // because this is a model updated event (not pinned rows), we
        // can skip updating the pinned rows. this is needed so that if user
        // is doing transaction updates, the pinned rows are not getting constantly
        // trashed - or editing cells in pinned rows are not refreshed and put into read mode
        onlyBody: true
      };
      this.redrawAfterModelUpdate(params);
    }
    getAllCellsForColumn(column) {
      const res = [];
      this.getAllRowCtrls().forEach((rowCtrl) => {
        const eCell = rowCtrl.getCellElement(column);
        if (eCell) {
          res.push(eCell);
        }
      });
      return res;
    }
    refreshFloatingRowComps() {
      this.refreshFloatingRows(
        this.topRowCtrls,
        this.pinnedRowModel.getPinnedTopRowData()
      );
      this.refreshFloatingRows(
        this.bottomRowCtrls,
        this.pinnedRowModel.getPinnedBottomRowData()
      );
    }
    getTopRowCtrls() {
      return this.topRowCtrls;
    }
    getCentreRowCtrls() {
      return this.allRowCtrls;
    }
    getBottomRowCtrls() {
      return this.bottomRowCtrls;
    }
    refreshFloatingRows(rowComps, rowNodes) {
      rowComps.forEach((row) => {
        row.destroyFirstPass();
        row.destroySecondPass();
      });
      rowComps.length = 0;
      if (!rowNodes) {
        return;
      }
      rowNodes.forEach((rowNode) => {
        const rowCtrl = new RowCtrl(
          rowNode,
          this.beans,
          false,
          false,
          this.printLayout
        );
        rowComps.push(rowCtrl);
      });
    }
    onPinnedRowDataChanged() {
      const params = {
        recycleRows: true
      };
      this.redrawAfterModelUpdate(params);
    }
    redrawRow(rowNode, suppressEvent = false) {
      var _a;
      if (rowNode.sticky) {
        this.stickyRowFeature.refreshStickyNode(rowNode);
      } else if ((_a = this.cachedRowCtrls) == null ? void 0 : _a.has(rowNode)) {
        this.cachedRowCtrls.removeRow(rowNode);
        return;
      } else {
        const destroyAndRecreateCtrl = (dataStruct) => {
          const ctrl = dataStruct[rowNode.rowIndex];
          if (!ctrl) {
            return;
          }
          if (ctrl.getRowNode() !== rowNode) {
            return;
          }
          ctrl.destroyFirstPass();
          ctrl.destroySecondPass();
          dataStruct[rowNode.rowIndex] = this.createRowCon(rowNode, false, false);
        };
        switch (rowNode.rowPinned) {
          case "top":
            destroyAndRecreateCtrl(this.topRowCtrls);
            break;
          case "bottom":
            destroyAndRecreateCtrl(this.bottomRowCtrls);
            break;
          default:
            destroyAndRecreateCtrl(this.rowCtrlsByRowIndex);
            this.updateAllRowCtrls();
        }
      }
      if (!suppressEvent) {
        this.dispatchDisplayedRowsChanged(false);
      }
    }
    redrawRows(rowNodes) {
      const partialRefresh = rowNodes != null;
      if (partialRefresh) {
        rowNodes == null ? void 0 : rowNodes.forEach((node) => this.redrawRow(node, true));
        this.dispatchDisplayedRowsChanged(false);
        return;
      }
      this.redrawAfterModelUpdate();
    }
    getCellToRestoreFocusToAfterRefresh(params) {
      const focusedCell = (params == null ? void 0 : params.suppressKeepFocus) ? null : this.focusService.getFocusCellToUseAfterRefresh();
      if (focusedCell == null) {
        return null;
      }
      const activeElement = this.gos.getActiveDomElement();
      const cellDomData = this.gos.getDomData(activeElement, CellCtrl.DOM_DATA_KEY_CELL_CTRL);
      const rowDomData = this.gos.getDomData(activeElement, RowCtrl.DOM_DATA_KEY_ROW_CTRL);
      const gridElementFocused = cellDomData || rowDomData;
      return gridElementFocused ? focusedCell : null;
    }
    // gets called from:
    // +) initialisation (in registerGridComp) params = null
    // +) onDomLayoutChanged, params = null
    // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true
    // +) onPinnedRowDataChanged, recycleRows = true
    // +) redrawRows (from Grid API), recycleRows = true/false
    redrawAfterModelUpdate(params = {}) {
      this.getLockOnRefresh();
      const focusedCell = this.getCellToRestoreFocusToAfterRefresh(params);
      this.updateContainerHeights();
      this.scrollToTopIfNewData(params);
      const recycleRows = !params.domLayoutChanged && !!params.recycleRows;
      const animate = params.animate && this.gos.isAnimateRows();
      const rowsToRecycle = recycleRows ? this.getRowsToRecycle() : null;
      if (!recycleRows) {
        this.removeAllRowComps();
      }
      this.workOutFirstAndLastRowsToRender();
      if (this.stickyRowFeature) {
        this.stickyRowFeature.checkStickyRows();
      }
      this.recycleRows(rowsToRecycle, animate);
      this.gridBodyCtrl.updateRowCount();
      if (!params.onlyBody) {
        this.refreshFloatingRowComps();
      }
      this.dispatchDisplayedRowsChanged();
      if (focusedCell != null) {
        this.restoreFocusedCell(focusedCell);
      }
      this.releaseLockOnRefresh();
    }
    scrollToTopIfNewData(params) {
      const scrollToTop = params.newData || params.newPage;
      const suppressScrollToTop = this.gos.get("suppressScrollOnNewData");
      if (scrollToTop && !suppressScrollToTop) {
        this.gridBodyCtrl.getScrollFeature().scrollToTop();
      }
    }
    updateContainerHeights() {
      if (this.printLayout) {
        this.rowContainerHeightService.setModelHeight(null);
        return;
      }
      let containerHeight = this.paginationProxy.getCurrentPageHeight();
      if (containerHeight === 0) {
        containerHeight = 1;
      }
      this.rowContainerHeightService.setModelHeight(containerHeight);
    }
    getLockOnRefresh() {
      if (this.refreshInProgress) {
        throw new Error(
          "AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. Your code probably called a grid API method while the grid was in the render stage. To overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). To see what part of your code that caused the refresh check this stacktrace."
        );
      }
      this.refreshInProgress = true;
    }
    releaseLockOnRefresh() {
      this.refreshInProgress = false;
    }
    isRefreshInProgress() {
      return this.refreshInProgress;
    }
    // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
    // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
    // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
    // edited cell).
    restoreFocusedCell(cellPosition) {
      if (cellPosition) {
        this.focusService.setRestoreFocusedCell(cellPosition);
        this.onCellFocusChanged(this.beans.gos.addGridCommonParams({
          rowIndex: cellPosition.rowIndex,
          column: cellPosition.column,
          rowPinned: cellPosition.rowPinned,
          forceBrowserFocus: true,
          preventScrollOnBrowserFocus: true,
          type: "mock"
        }));
      }
    }
    stopEditing(cancel = false) {
      this.getAllRowCtrls().forEach((rowCtrl) => {
        rowCtrl.stopEditing(cancel);
      });
    }
    getAllCellCtrls() {
      const res = [];
      const rowCtrls = this.getAllRowCtrls();
      const rowCtrlsLength = rowCtrls.length;
      for (let i = 0; i < rowCtrlsLength; i++) {
        const cellCtrls = rowCtrls[i].getAllCellCtrls();
        const cellCtrlsLength = cellCtrls.length;
        for (let j = 0; j < cellCtrlsLength; j++) {
          res.push(cellCtrls[j]);
        }
      }
      return res;
    }
    getAllRowCtrls() {
      const stickyTopRowCtrls = this.stickyRowFeature && this.stickyRowFeature.getStickyTopRowCtrls() || [];
      const stickyBottomRowCtrls = this.stickyRowFeature && this.stickyRowFeature.getStickyBottomRowCtrls() || [];
      const res = [...this.topRowCtrls, ...this.bottomRowCtrls, ...stickyTopRowCtrls, ...stickyBottomRowCtrls];
      for (const key in this.rowCtrlsByRowIndex) {
        res.push(this.rowCtrlsByRowIndex[key]);
      }
      return res;
    }
    addRenderedRowListener(eventName, rowIndex, callback) {
      const rowComp = this.rowCtrlsByRowIndex[rowIndex];
      if (rowComp) {
        rowComp.addEventListener(eventName, callback);
      }
    }
    flashCells(params = {}) {
      this.getCellCtrls(params.rowNodes, params.columns).forEach((cellCtrl) => cellCtrl.flashCell(params));
    }
    refreshCells(params = {}) {
      const refreshCellParams = {
        forceRefresh: params.force,
        newData: false,
        suppressFlash: params.suppressFlash
      };
      this.getCellCtrls(params.rowNodes, params.columns).forEach((cellCtrl) => cellCtrl.refreshOrDestroyCell(refreshCellParams));
      if (params.rowNodes) {
        this.getRowCtrls(params.rowNodes).forEach((rowCtrl) => {
          if (!rowCtrl.isFullWidth()) {
            return;
          }
          const refreshed = rowCtrl.refreshFullWidth();
          if (!refreshed) {
            this.redrawRow(rowCtrl.getRowNode(), true);
          }
        });
        this.dispatchDisplayedRowsChanged(false);
      }
    }
    getCellRendererInstances(params) {
      var _a;
      const cellRenderers = this.getCellCtrls(params.rowNodes, params.columns).map((cellCtrl) => cellCtrl.getCellRenderer()).filter((renderer2) => renderer2 != null);
      if ((_a = params.columns) == null ? void 0 : _a.length) {
        return cellRenderers;
      }
      const fullWidthRenderers = [];
      const rowIdMap = this.mapRowNodes(params.rowNodes);
      this.getAllRowCtrls().forEach((rowCtrl) => {
        if (rowIdMap && !this.isRowInMap(rowCtrl.getRowNode(), rowIdMap)) {
          return;
        }
        if (!rowCtrl.isFullWidth()) {
          return;
        }
        const renderers = rowCtrl.getFullWidthCellRenderers();
        for (let i = 0; i < renderers.length; i++) {
          const renderer2 = renderers[i];
          if (renderer2 != null) {
            fullWidthRenderers.push(renderer2);
          }
        }
      });
      return [...fullWidthRenderers, ...cellRenderers];
    }
    getCellEditorInstances(params) {
      const res = [];
      this.getCellCtrls(params.rowNodes, params.columns).forEach((cellCtrl) => {
        const cellEditor = cellCtrl.getCellEditor();
        if (cellEditor) {
          res.push(cellEditor);
        }
      });
      return res;
    }
    getEditingCells() {
      const res = [];
      this.getAllCellCtrls().forEach((cellCtrl) => {
        if (cellCtrl.isEditing()) {
          const cellPosition = cellCtrl.getCellPosition();
          res.push(cellPosition);
        }
      });
      return res;
    }
    mapRowNodes(rowNodes) {
      if (!rowNodes) {
        return;
      }
      const res = {
        top: {},
        bottom: {},
        normal: {}
      };
      rowNodes.forEach((rowNode) => {
        const id = rowNode.id;
        switch (rowNode.rowPinned) {
          case "top":
            res.top[id] = rowNode;
            break;
          case "bottom":
            res.bottom[id] = rowNode;
            break;
          default:
            res.normal[id] = rowNode;
            break;
        }
      });
      return res;
    }
    isRowInMap(rowNode, rowIdsMap) {
      const id = rowNode.id;
      const floating = rowNode.rowPinned;
      switch (floating) {
        case "top":
          return rowIdsMap.top[id] != null;
        case "bottom":
          return rowIdsMap.bottom[id] != null;
        default:
          return rowIdsMap.normal[id] != null;
      }
    }
    /**
     * @param rowNodes if provided, returns the RowCtrls for the provided rowNodes. otherwise returns all RowCtrls.
     */
    getRowCtrls(rowNodes) {
      const rowIdsMap = this.mapRowNodes(rowNodes);
      const allRowCtrls = this.getAllRowCtrls();
      if (!rowNodes || !rowIdsMap) {
        return allRowCtrls;
      }
      return allRowCtrls.filter((rowCtrl) => {
        const rowNode = rowCtrl.getRowNode();
        return this.isRowInMap(rowNode, rowIdsMap);
      });
    }
    // returns CellCtrl's that match the provided rowNodes and columns. eg if one row node
    // and two columns provided, that identifies 4 cells, so 4 CellCtrl's returned.
    getCellCtrls(rowNodes, columns) {
      let colIdsMap;
      if (exists(columns)) {
        colIdsMap = {};
        columns.forEach((colKey) => {
          const column = this.columnModel.getGridColumn(colKey);
          if (exists(column)) {
            colIdsMap[column.getId()] = true;
          }
        });
      }
      const res = [];
      this.getRowCtrls(rowNodes).forEach((rowCtrl) => {
        rowCtrl.getAllCellCtrls().forEach((cellCtrl) => {
          const colId = cellCtrl.getColumn().getId();
          const excludeColFromRefresh = colIdsMap && !colIdsMap[colId];
          if (excludeColFromRefresh) {
            return;
          }
          res.push(cellCtrl);
        });
      });
      return res;
    }
    destroy() {
      this.removeAllRowComps();
      super.destroy();
    }
    removeAllRowComps() {
      const rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);
      this.removeRowCtrls(rowIndexesToRemove);
      if (this.stickyRowFeature) {
        this.stickyRowFeature.destroyStickyCtrls();
      }
    }
    getRowsToRecycle() {
      const stubNodeIndexes = [];
      iterateObject(this.rowCtrlsByRowIndex, (index, rowCtrl) => {
        const stubNode = rowCtrl.getRowNode().id == null;
        if (stubNode) {
          stubNodeIndexes.push(index);
        }
      });
      this.removeRowCtrls(stubNodeIndexes);
      const ctrlsByIdMap = {};
      iterateObject(this.rowCtrlsByRowIndex, (index, rowCtrl) => {
        const rowNode = rowCtrl.getRowNode();
        ctrlsByIdMap[rowNode.id] = rowCtrl;
      });
      this.rowCtrlsByRowIndex = {};
      return ctrlsByIdMap;
    }
    // takes array of row indexes
    removeRowCtrls(rowsToRemove, suppressAnimation = false) {
      rowsToRemove.forEach((indexToRemove) => {
        const rowCtrl = this.rowCtrlsByRowIndex[indexToRemove];
        if (rowCtrl) {
          rowCtrl.destroyFirstPass(suppressAnimation);
          rowCtrl.destroySecondPass();
        }
        delete this.rowCtrlsByRowIndex[indexToRemove];
      });
    }
    onBodyScroll(e) {
      if (e.direction !== "vertical") {
        return;
      }
      this.redraw({ afterScroll: true });
    }
    // gets called when rows don't change, but viewport does, so after:
    // 1) height of grid body changes, ie number of displayed rows has changed
    // 2) grid scrolled to new position
    // 3) ensure index visible (which is a scroll)
    redraw(params = {}) {
      const { afterScroll } = params;
      let cellFocused;
      if (this.stickyRowFeature && browserSupportsPreventScroll()) {
        cellFocused = this.getCellToRestoreFocusToAfterRefresh() || void 0;
      }
      const oldFirstRow = this.firstRenderedRow;
      const oldLastRow = this.lastRenderedRow;
      this.workOutFirstAndLastRowsToRender();
      let hasStickyRowChanges = false;
      if (this.stickyRowFeature) {
        hasStickyRowChanges = this.stickyRowFeature.checkStickyRows();
      }
      const rangeChanged = this.firstRenderedRow !== oldFirstRow || this.lastRenderedRow !== oldLastRow;
      if (afterScroll && !hasStickyRowChanges && !rangeChanged) {
        return;
      }
      this.getLockOnRefresh();
      this.recycleRows(null, false, afterScroll);
      this.releaseLockOnRefresh();
      this.dispatchDisplayedRowsChanged(afterScroll && !hasStickyRowChanges);
      if (cellFocused != null) {
        const newFocusedCell = this.getCellToRestoreFocusToAfterRefresh();
        if (cellFocused != null && newFocusedCell == null) {
          this.animationFrameService.flushAllFrames();
          this.restoreFocusedCell(cellFocused);
        }
      }
    }
    removeRowCompsNotToDraw(indexesToDraw, suppressAnimation) {
      const indexesToDrawMap = {};
      indexesToDraw.forEach((index) => indexesToDrawMap[index] = true);
      const existingIndexes = Object.keys(this.rowCtrlsByRowIndex);
      const indexesNotToDraw = existingIndexes.filter((index) => !indexesToDrawMap[index]);
      this.removeRowCtrls(indexesNotToDraw, suppressAnimation);
    }
    calculateIndexesToDraw(rowsToRecycle) {
      let indexesToDraw = createArrayOfNumbers(this.firstRenderedRow, this.lastRenderedRow);
      const checkRowToDraw = (indexStr, rowComp) => {
        const index = rowComp.getRowNode().rowIndex;
        if (index == null) {
          return;
        }
        if (index < this.firstRenderedRow || index > this.lastRenderedRow) {
          if (this.doNotUnVirtualiseRow(rowComp)) {
            indexesToDraw.push(index);
          }
        }
      };
      iterateObject(this.rowCtrlsByRowIndex, checkRowToDraw);
      iterateObject(rowsToRecycle, checkRowToDraw);
      indexesToDraw.sort((a, b) => a - b);
      const ret = [];
      for (let i = 0; i < indexesToDraw.length; i++) {
        const currRow = indexesToDraw[i];
        const rowNode = this.paginationProxy.getRow(currRow);
        if (rowNode && !rowNode.sticky) {
          ret.push(currRow);
        }
      }
      return ret;
    }
    recycleRows(rowsToRecycle, animate = false, afterScroll = false) {
      const indexesToDraw = this.calculateIndexesToDraw(rowsToRecycle);
      if (this.printLayout || afterScroll) {
        animate = false;
      }
      this.removeRowCompsNotToDraw(indexesToDraw, !animate);
      const rowCtrls = [];
      indexesToDraw.forEach((rowIndex) => {
        const rowCtrl = this.createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll);
        if (exists(rowCtrl)) {
          rowCtrls.push(rowCtrl);
        }
      });
      if (rowsToRecycle) {
        const useAnimationFrame = afterScroll && !this.gos.get("suppressAnimationFrame") && !this.printLayout;
        if (useAnimationFrame) {
          this.beans.animationFrameService.addDestroyTask(() => {
            this.destroyRowCtrls(rowsToRecycle, animate);
            this.updateAllRowCtrls();
            this.dispatchDisplayedRowsChanged();
          });
        } else {
          this.destroyRowCtrls(rowsToRecycle, animate);
        }
      }
      this.updateAllRowCtrls();
    }
    dispatchDisplayedRowsChanged(afterScroll = false) {
      const event = { type: Events.EVENT_DISPLAYED_ROWS_CHANGED, afterScroll };
      this.eventService.dispatchEvent(event);
    }
    onDisplayedColumnsChanged() {
      const pinningLeft = this.columnModel.isPinningLeft();
      const pinningRight = this.columnModel.isPinningRight();
      const atLeastOneChanged = this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight;
      if (atLeastOneChanged) {
        this.pinningLeft = pinningLeft;
        this.pinningRight = pinningRight;
        if (this.embedFullWidthRows) {
          this.redrawFullWidthEmbeddedRows();
        }
      }
    }
    // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,
    // then it should go into the pinned left area if pinning left, or the center area if not pinning.
    redrawFullWidthEmbeddedRows() {
      const rowsToRemove = [];
      this.getFullWidthRowCtrls().forEach((fullWidthCtrl) => {
        const rowIndex = fullWidthCtrl.getRowNode().rowIndex;
        rowsToRemove.push(rowIndex.toString());
      });
      this.refreshFloatingRowComps();
      this.removeRowCtrls(rowsToRemove);
      this.redraw({ afterScroll: true });
    }
    getFullWidthRowCtrls(rowNodes) {
      const rowNodesMap = this.mapRowNodes(rowNodes);
      return this.getAllRowCtrls().filter((rowCtrl) => {
        if (!rowCtrl.isFullWidth()) {
          return false;
        }
        const rowNode = rowCtrl.getRowNode();
        if (rowNodesMap != null && !this.isRowInMap(rowNode, rowNodesMap)) {
          return false;
        }
        return true;
      });
    }
    createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll) {
      let rowNode;
      let rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
      if (!rowCtrl) {
        rowNode = this.paginationProxy.getRow(rowIndex);
        if (exists(rowNode) && exists(rowsToRecycle) && rowsToRecycle[rowNode.id] && rowNode.alreadyRendered) {
          rowCtrl = rowsToRecycle[rowNode.id];
          rowsToRecycle[rowNode.id] = null;
        }
      }
      const creatingNewRowCtrl = !rowCtrl;
      if (creatingNewRowCtrl) {
        if (!rowNode) {
          rowNode = this.paginationProxy.getRow(rowIndex);
        }
        if (exists(rowNode)) {
          rowCtrl = this.createRowCon(rowNode, animate, afterScroll);
        } else {
          return;
        }
      }
      if (rowNode) {
        rowNode.alreadyRendered = true;
      }
      this.rowCtrlsByRowIndex[rowIndex] = rowCtrl;
      return rowCtrl;
    }
    destroyRowCtrls(rowCtrlsMap, animate) {
      const executeInAWhileFuncs = [];
      iterateObject(rowCtrlsMap, (nodeId, rowCtrl) => {
        if (!rowCtrl) {
          return;
        }
        if (this.cachedRowCtrls && rowCtrl.isCacheable()) {
          this.cachedRowCtrls.addRow(rowCtrl);
          return;
        }
        rowCtrl.destroyFirstPass(!animate);
        if (animate) {
          this.zombieRowCtrls[rowCtrl.getInstanceId()] = rowCtrl;
          executeInAWhileFuncs.push(() => {
            rowCtrl.destroySecondPass();
            delete this.zombieRowCtrls[rowCtrl.getInstanceId()];
          });
        } else {
          rowCtrl.destroySecondPass();
        }
      });
      if (animate) {
        executeInAWhileFuncs.push(() => {
          this.updateAllRowCtrls();
          this.dispatchDisplayedRowsChanged();
        });
        executeInAWhile(executeInAWhileFuncs);
      }
    }
    getRowBuffer() {
      return this.gos.get("rowBuffer");
    }
    getRowBufferInPixels() {
      const rowsToBuffer = this.getRowBuffer();
      const defaultRowHeight = this.gos.getRowHeightAsNumber();
      return rowsToBuffer * defaultRowHeight;
    }
    workOutFirstAndLastRowsToRender() {
      this.rowContainerHeightService.updateOffset();
      let newFirst;
      let newLast;
      if (!this.paginationProxy.isRowsToRender()) {
        newFirst = 0;
        newLast = -1;
      } else if (this.printLayout) {
        this.environment.refreshRowHeightVariable();
        newFirst = this.paginationProxy.getPageFirstRow();
        newLast = this.paginationProxy.getPageLastRow();
      } else {
        const bufferPixels = this.getRowBufferInPixels();
        const gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();
        const suppressRowVirtualisation = this.gos.get("suppressRowVirtualisation");
        let rowHeightsChanged = false;
        let firstPixel;
        let lastPixel;
        do {
          const paginationOffset = this.paginationProxy.getPixelOffset();
          const { pageFirstPixel, pageLastPixel } = this.paginationProxy.getCurrentPagePixelRange();
          const divStretchOffset = this.rowContainerHeightService.getDivStretchOffset();
          const bodyVRange = gridBodyCtrl.getScrollFeature().getVScrollPosition();
          const bodyTopPixel = bodyVRange.top;
          const bodyBottomPixel = bodyVRange.bottom;
          if (suppressRowVirtualisation) {
            firstPixel = pageFirstPixel + divStretchOffset;
            lastPixel = pageLastPixel + divStretchOffset;
          } else {
            firstPixel = Math.max(bodyTopPixel + paginationOffset - bufferPixels, pageFirstPixel) + divStretchOffset;
            lastPixel = Math.min(bodyBottomPixel + paginationOffset + bufferPixels, pageLastPixel) + divStretchOffset;
          }
          this.firstVisibleVPixel = Math.max(bodyTopPixel + paginationOffset, pageFirstPixel) + divStretchOffset;
          this.lastVisibleVPixel = Math.min(bodyBottomPixel + paginationOffset, pageLastPixel) + divStretchOffset;
          rowHeightsChanged = this.ensureAllRowsInRangeHaveHeightsCalculated(firstPixel, lastPixel);
        } while (rowHeightsChanged);
        let firstRowIndex = this.paginationProxy.getRowIndexAtPixel(firstPixel);
        let lastRowIndex = this.paginationProxy.getRowIndexAtPixel(lastPixel);
        const pageFirstRow = this.paginationProxy.getPageFirstRow();
        const pageLastRow = this.paginationProxy.getPageLastRow();
        if (firstRowIndex < pageFirstRow) {
          firstRowIndex = pageFirstRow;
        }
        if (lastRowIndex > pageLastRow) {
          lastRowIndex = pageLastRow;
        }
        newFirst = firstRowIndex;
        newLast = lastRowIndex;
      }
      const rowLayoutNormal = this.gos.isDomLayout("normal");
      const suppressRowCountRestriction = this.gos.get("suppressMaxRenderedRowRestriction");
      const rowBufferMaxSize = Math.max(this.getRowBuffer(), 500);
      if (rowLayoutNormal && !suppressRowCountRestriction) {
        if (newLast - newFirst > rowBufferMaxSize) {
          newLast = newFirst + rowBufferMaxSize;
        }
      }
      const firstDiffers = newFirst !== this.firstRenderedRow;
      const lastDiffers = newLast !== this.lastRenderedRow;
      if (firstDiffers || lastDiffers) {
        this.firstRenderedRow = newFirst;
        this.lastRenderedRow = newLast;
        const event = {
          type: Events.EVENT_VIEWPORT_CHANGED,
          firstRow: newFirst,
          lastRow: newLast
        };
        this.eventService.dispatchEvent(event);
      }
    }
    /**
     * This event will only be fired once, and is queued until after the browser next renders.
     * This allows us to fire an event during the start of the render cycle, when we first see data being rendered
     * but not execute the event until all of the data has finished being rendered to the dom.
     */
    dispatchFirstDataRenderedEvent() {
      if (this.dataFirstRenderedFired) {
        return;
      }
      this.dataFirstRenderedFired = true;
      const event = {
        type: Events.EVENT_FIRST_DATA_RENDERED,
        firstRow: this.firstRenderedRow,
        lastRow: this.lastRenderedRow
      };
      window.requestAnimationFrame(() => {
        this.beans.eventService.dispatchEvent(event);
      });
    }
    ensureAllRowsInRangeHaveHeightsCalculated(topPixel, bottomPixel) {
      const res = this.paginationProxy.ensureRowHeightsValid(topPixel, bottomPixel, -1, -1);
      if (res) {
        this.updateContainerHeights();
      }
      return res;
    }
    getFirstVisibleVerticalPixel() {
      return this.firstVisibleVPixel;
    }
    getLastVisibleVerticalPixel() {
      return this.lastVisibleVPixel;
    }
    getFirstVirtualRenderedRow() {
      return this.firstRenderedRow;
    }
    getLastVirtualRenderedRow() {
      return this.lastRenderedRow;
    }
    // check that none of the rows to remove are editing or focused as:
    // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,
    //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered
    //    the edit is reset - so we want to keep it rendered.
    // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,
    //    otherwise the user can range select and drag (with focus cell going out of the viewport)
    //    and then ctrl+c, nothing will happen if cell is removed from dom.
    // c) if detail record of master detail, as users complained that the context of detail rows
    //    was getting lost when detail row out of view. eg user expands to show detail row,
    //    then manipulates the detail panel (eg sorts the detail grid), then context is lost
    //    after detail panel is scrolled out of / into view.
    doNotUnVirtualiseRow(rowComp) {
      const REMOVE_ROW = false;
      const KEEP_ROW = true;
      const rowNode = rowComp.getRowNode();
      const rowHasFocus = this.focusService.isRowNodeFocused(rowNode);
      const rowIsEditing = rowComp.isEditing();
      const rowIsDetail = rowNode.detail;
      const mightWantToKeepRow = rowHasFocus || rowIsEditing || rowIsDetail;
      if (!mightWantToKeepRow) {
        return REMOVE_ROW;
      }
      const rowNodePresent = this.paginationProxy.isRowPresent(rowNode);
      return rowNodePresent ? KEEP_ROW : REMOVE_ROW;
    }
    createRowCon(rowNode, animate, afterScroll) {
      const rowCtrlFromCache = this.cachedRowCtrls ? this.cachedRowCtrls.getRow(rowNode) : null;
      if (rowCtrlFromCache) {
        return rowCtrlFromCache;
      }
      const suppressAnimationFrame = this.gos.get("suppressAnimationFrame");
      const useAnimationFrameForCreate = afterScroll && !suppressAnimationFrame && !this.printLayout;
      const res = new RowCtrl(
        rowNode,
        this.beans,
        animate,
        useAnimationFrameForCreate,
        this.printLayout
      );
      return res;
    }
    getRenderedNodes() {
      const renderedRows = this.rowCtrlsByRowIndex;
      return Object.values(renderedRows).map((rowCtrl) => rowCtrl.getRowNode());
    }
    getRowByPosition(rowPosition) {
      let rowCtrl;
      const { rowIndex } = rowPosition;
      switch (rowPosition.rowPinned) {
        case "top":
          rowCtrl = this.topRowCtrls[rowIndex];
          break;
        case "bottom":
          rowCtrl = this.bottomRowCtrls[rowIndex];
          break;
        default:
          rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
          if (!rowCtrl) {
            rowCtrl = this.getStickyTopRowCtrls().find((ctrl) => ctrl.getRowNode().rowIndex === rowIndex) || null;
            if (!rowCtrl) {
              rowCtrl = this.getStickyBottomRowCtrls().find((ctrl) => ctrl.getRowNode().rowIndex === rowIndex) || null;
            }
          }
          break;
      }
      return rowCtrl;
    }
    // returns true if any row between startIndex and endIndex is rendered. used by
    // SSRM or IRM, as they don't want to purge visible blocks from cache.
    isRangeInRenderedViewport(startIndex, endIndex) {
      const parentClosed = startIndex == null || endIndex == null;
      if (parentClosed) {
        return false;
      }
      const blockAfterViewport = startIndex > this.lastRenderedRow;
      const blockBeforeViewport = endIndex < this.firstRenderedRow;
      const blockInsideViewport = !blockBeforeViewport && !blockAfterViewport;
      return blockInsideViewport;
    }
  };
  __decorateClass([
    Autowired("animationFrameService")
  ], RowRenderer.prototype, "animationFrameService", 2);
  __decorateClass([
    Autowired("paginationProxy")
  ], RowRenderer.prototype, "paginationProxy", 2);
  __decorateClass([
    Autowired("columnModel")
  ], RowRenderer.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("pinnedRowModel")
  ], RowRenderer.prototype, "pinnedRowModel", 2);
  __decorateClass([
    Autowired("rowModel")
  ], RowRenderer.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("focusService")
  ], RowRenderer.prototype, "focusService", 2);
  __decorateClass([
    Autowired("beans")
  ], RowRenderer.prototype, "beans", 2);
  __decorateClass([
    Autowired("rowContainerHeightService")
  ], RowRenderer.prototype, "rowContainerHeightService", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], RowRenderer.prototype, "ctrlsService", 2);
  __decorateClass([
    PostConstruct
  ], RowRenderer.prototype, "postConstruct", 1);
  RowRenderer = __decorateClass([
    Bean("rowRenderer")
  ], RowRenderer);
  var RowCtrlCache = class {
    constructor(maxCount) {
      this.entriesMap = {};
      this.entriesList = [];
      this.maxCount = maxCount;
    }
    addRow(rowCtrl) {
      this.entriesMap[rowCtrl.getRowNode().id] = rowCtrl;
      this.entriesList.push(rowCtrl);
      rowCtrl.setCached(true);
      if (this.entriesList.length > this.maxCount) {
        const rowCtrlToDestroy = this.entriesList[0];
        rowCtrlToDestroy.destroyFirstPass();
        rowCtrlToDestroy.destroySecondPass();
        this.removeFromCache(rowCtrlToDestroy);
      }
    }
    getRow(rowNode) {
      if (rowNode == null || rowNode.id == null) {
        return null;
      }
      const res = this.entriesMap[rowNode.id];
      if (!res) {
        return null;
      }
      this.removeFromCache(res);
      res.setCached(false);
      const rowNodeMismatch = res.getRowNode() != rowNode;
      return rowNodeMismatch ? null : res;
    }
    has(rowNode) {
      return this.entriesMap[rowNode.id] != null;
    }
    removeRow(rowNode) {
      const rowNodeId = rowNode.id;
      const ctrl = this.entriesMap[rowNodeId];
      delete this.entriesMap[rowNodeId];
      removeFromArray(this.entriesList, ctrl);
    }
    removeFromCache(rowCtrl) {
      const rowNodeId = rowCtrl.getRowNode().id;
      delete this.entriesMap[rowNodeId];
      removeFromArray(this.entriesList, rowCtrl);
    }
    getEntries() {
      return this.entriesList;
    }
  };
  var PinnedRowModel = class extends BeanStub {
    init() {
      this.setPinnedTopRowData();
      this.setPinnedBottomRowData();
      this.addManagedPropertyListener("pinnedTopRowData", () => this.setPinnedTopRowData());
      this.addManagedPropertyListener("pinnedBottomRowData", () => this.setPinnedBottomRowData());
    }
    isEmpty(floating) {
      const rows = floating === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
      return missingOrEmpty(rows);
    }
    isRowsToRender(floating) {
      return !this.isEmpty(floating);
    }
    getRowAtPixel(pixel, floating) {
      const rows = floating === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
      if (missingOrEmpty(rows)) {
        return 0;
      }
      for (let i = 0; i < rows.length; i++) {
        const rowNode = rows[i];
        const rowTopPixel = rowNode.rowTop + rowNode.rowHeight - 1;
        if (rowTopPixel >= pixel) {
          return i;
        }
      }
      return rows.length - 1;
    }
    setPinnedTopRowData() {
      const rowData = this.gos.get("pinnedTopRowData");
      this.pinnedTopRows = this.createNodesFromData(rowData, true);
      const event = {
        type: Events.EVENT_PINNED_ROW_DATA_CHANGED
      };
      this.eventService.dispatchEvent(event);
    }
    setPinnedBottomRowData() {
      const rowData = this.gos.get("pinnedBottomRowData");
      this.pinnedBottomRows = this.createNodesFromData(rowData, false);
      const event = {
        type: Events.EVENT_PINNED_ROW_DATA_CHANGED
      };
      this.eventService.dispatchEvent(event);
    }
    createNodesFromData(allData, isTop) {
      const rowNodes = [];
      if (allData) {
        let nextRowTop = 0;
        allData.forEach((dataItem, index) => {
          const rowNode = new RowNode(this.beans);
          rowNode.data = dataItem;
          const idPrefix = isTop ? RowNode.ID_PREFIX_TOP_PINNED : RowNode.ID_PREFIX_BOTTOM_PINNED;
          rowNode.id = idPrefix + index;
          rowNode.rowPinned = isTop ? "top" : "bottom";
          rowNode.setRowTop(nextRowTop);
          rowNode.setRowHeight(this.gos.getRowHeightForNode(rowNode).height);
          rowNode.setRowIndex(index);
          nextRowTop += rowNode.rowHeight;
          rowNodes.push(rowNode);
        });
      }
      return rowNodes;
    }
    getPinnedTopRowData() {
      return this.pinnedTopRows;
    }
    getPinnedBottomRowData() {
      return this.pinnedBottomRows;
    }
    getPinnedTopTotalHeight() {
      return this.getTotalHeight(this.pinnedTopRows);
    }
    getPinnedTopRowCount() {
      return this.pinnedTopRows ? this.pinnedTopRows.length : 0;
    }
    getPinnedBottomRowCount() {
      return this.pinnedBottomRows ? this.pinnedBottomRows.length : 0;
    }
    getPinnedTopRow(index) {
      return this.pinnedTopRows[index];
    }
    getPinnedBottomRow(index) {
      return this.pinnedBottomRows[index];
    }
    forEachPinnedTopRow(callback) {
      if (missingOrEmpty(this.pinnedTopRows)) {
        return;
      }
      this.pinnedTopRows.forEach(callback);
    }
    forEachPinnedBottomRow(callback) {
      if (missingOrEmpty(this.pinnedBottomRows)) {
        return;
      }
      this.pinnedBottomRows.forEach(callback);
    }
    getPinnedBottomTotalHeight() {
      return this.getTotalHeight(this.pinnedBottomRows);
    }
    getTotalHeight(rowNodes) {
      if (!rowNodes || rowNodes.length === 0) {
        return 0;
      }
      const lastNode = last(rowNodes);
      return lastNode.rowTop + lastNode.rowHeight;
    }
  };
  __decorateClass([
    Autowired("beans")
  ], PinnedRowModel.prototype, "beans", 2);
  __decorateClass([
    PostConstruct
  ], PinnedRowModel.prototype, "init", 1);
  PinnedRowModel = __decorateClass([
    Bean("pinnedRowModel")
  ], PinnedRowModel);
  var ServerSideTransactionResultStatus = /* @__PURE__ */ ((ServerSideTransactionResultStatus2) => {
    ServerSideTransactionResultStatus2["Applied"] = "Applied";
    ServerSideTransactionResultStatus2["StoreNotFound"] = "StoreNotFound";
    ServerSideTransactionResultStatus2["StoreLoading"] = "StoreLoading";
    ServerSideTransactionResultStatus2["StoreWaitingToLoad"] = "StoreWaitingToLoad";
    ServerSideTransactionResultStatus2["StoreLoadingFailed"] = "StoreLoadingFailed";
    ServerSideTransactionResultStatus2["StoreWrongType"] = "StoreWrongType";
    ServerSideTransactionResultStatus2["Cancelled"] = "Cancelled";
    ServerSideTransactionResultStatus2["StoreNotStarted"] = "StoreNotStarted";
    return ServerSideTransactionResultStatus2;
  })(ServerSideTransactionResultStatus || {});
  var ChangedPath = class {
    constructor(keepingColumns, rootNode) {
      this.active = true;
      this.nodeIdsToColumns = {};
      this.mapToItems = {};
      this.keepingColumns = keepingColumns;
      this.pathRoot = {
        rowNode: rootNode,
        children: null
      };
      this.mapToItems[rootNode.id] = this.pathRoot;
    }
    // can be set inactive by:
    // a) ClientSideRowModel, if no transactions or
    // b) PivotService, if secondary columns changed
    setInactive() {
      this.active = false;
    }
    isActive() {
      return this.active;
    }
    depthFirstSearchChangedPath(pathItem, callback) {
      if (pathItem.children) {
        for (let i = 0; i < pathItem.children.length; i++) {
          this.depthFirstSearchChangedPath(pathItem.children[i], callback);
        }
      }
      callback(pathItem.rowNode);
    }
    depthFirstSearchEverything(rowNode, callback, traverseEverything) {
      if (rowNode.childrenAfterGroup) {
        for (let i = 0; i < rowNode.childrenAfterGroup.length; i++) {
          const childNode = rowNode.childrenAfterGroup[i];
          if (childNode.childrenAfterGroup) {
            this.depthFirstSearchEverything(rowNode.childrenAfterGroup[i], callback, traverseEverything);
          } else if (traverseEverything) {
            callback(childNode);
          }
        }
      }
      callback(rowNode);
    }
    // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback
    // will be called for child nodes in addition to parent nodes.
    forEachChangedNodeDepthFirst(callback, traverseLeafNodes = false, includeUnchangedNodes = false) {
      if (this.active && !includeUnchangedNodes) {
        this.depthFirstSearchChangedPath(this.pathRoot, callback);
      } else {
        this.depthFirstSearchEverything(this.pathRoot.rowNode, callback, traverseLeafNodes);
      }
    }
    executeFromRootNode(callback) {
      callback(this.pathRoot.rowNode);
    }
    createPathItems(rowNode) {
      let pointer = rowNode;
      let newEntryCount = 0;
      while (!this.mapToItems[pointer.id]) {
        const newEntry = {
          rowNode: pointer,
          children: null
        };
        this.mapToItems[pointer.id] = newEntry;
        newEntryCount++;
        pointer = pointer.parent;
      }
      return newEntryCount;
    }
    populateColumnsMap(rowNode, columns) {
      if (!this.keepingColumns || !columns) {
        return;
      }
      let pointer = rowNode;
      while (pointer) {
        if (!this.nodeIdsToColumns[pointer.id]) {
          this.nodeIdsToColumns[pointer.id] = {};
        }
        columns.forEach((col) => this.nodeIdsToColumns[pointer.id][col.getId()] = true);
        pointer = pointer.parent;
      }
    }
    linkPathItems(rowNode, newEntryCount) {
      let pointer = rowNode;
      for (let i = 0; i < newEntryCount; i++) {
        const thisItem = this.mapToItems[pointer.id];
        const parentItem = this.mapToItems[pointer.parent.id];
        if (!parentItem.children) {
          parentItem.children = [];
        }
        parentItem.children.push(thisItem);
        pointer = pointer.parent;
      }
    }
    // called by
    // 1) change detection (provides cols) and
    // 2) groupStage if doing transaction update (doesn't provide cols)
    addParentNode(rowNode, columns) {
      if (!rowNode || rowNode.isRowPinned()) {
        return;
      }
      const newEntryCount = this.createPathItems(rowNode);
      this.linkPathItems(rowNode, newEntryCount);
      this.populateColumnsMap(rowNode, columns);
    }
    canSkip(rowNode) {
      return this.active && !this.mapToItems[rowNode.id];
    }
    getValueColumnsForNode(rowNode, valueColumns) {
      if (!this.keepingColumns) {
        return valueColumns;
      }
      const colsForThisNode = this.nodeIdsToColumns[rowNode.id];
      const result = valueColumns.filter((col) => colsForThisNode[col.getId()]);
      return result;
    }
    getNotValueColumnsForNode(rowNode, valueColumns) {
      if (!this.keepingColumns) {
        return null;
      }
      const colsForThisNode = this.nodeIdsToColumns[rowNode.id];
      const result = valueColumns.filter((col) => !colsForThisNode[col.getId()]);
      return result;
    }
  };
  var _RowNodeBlock = class _RowNodeBlock2 extends BeanStub {
    constructor(id) {
      super();
      this.state = _RowNodeBlock2.STATE_WAITING_TO_LOAD;
      this.version = 0;
      this.id = id;
    }
    getId() {
      return this.id;
    }
    load() {
      this.state = _RowNodeBlock2.STATE_LOADING;
      this.loadFromDatasource();
    }
    getVersion() {
      return this.version;
    }
    setStateWaitingToLoad() {
      this.version++;
      this.state = _RowNodeBlock2.STATE_WAITING_TO_LOAD;
    }
    getState() {
      return this.state;
    }
    pageLoadFailed(version2) {
      const requestMostRecentAndLive = this.isRequestMostRecentAndLive(version2);
      if (requestMostRecentAndLive) {
        this.state = _RowNodeBlock2.STATE_FAILED;
        this.processServerFail();
      }
      this.dispatchLoadCompleted(false);
    }
    success(version2, params) {
      this.successCommon(version2, params);
    }
    pageLoaded(version2, rows, lastRow) {
      this.successCommon(version2, { rowData: rows, rowCount: lastRow });
    }
    isRequestMostRecentAndLive(version2) {
      const thisIsMostRecentRequest = version2 === this.version;
      const weAreNotDestroyed = this.isAlive();
      return thisIsMostRecentRequest && weAreNotDestroyed;
    }
    successCommon(version2, params) {
      this.dispatchLoadCompleted();
      const requestMostRecentAndLive = this.isRequestMostRecentAndLive(version2);
      if (requestMostRecentAndLive) {
        this.state = _RowNodeBlock2.STATE_LOADED;
        this.processServerResult(params);
      }
    }
    dispatchLoadCompleted(success = true) {
      const event = {
        type: _RowNodeBlock2.EVENT_LOAD_COMPLETE,
        success,
        block: this
      };
      this.dispatchEvent(event);
    }
  };
  _RowNodeBlock.EVENT_LOAD_COMPLETE = "loadComplete";
  _RowNodeBlock.STATE_WAITING_TO_LOAD = "needsLoading";
  _RowNodeBlock.STATE_LOADING = "loading";
  _RowNodeBlock.STATE_LOADED = "loaded";
  _RowNodeBlock.STATE_FAILED = "failed";
  var RowNodeBlock = _RowNodeBlock;
  var RowNodeBlockLoader = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.activeBlockLoadsCount = 0;
      this.blocks = [];
      this.active = true;
    }
    postConstruct() {
      this.maxConcurrentRequests = this.getMaxConcurrentDatasourceRequests();
      const blockLoadDebounceMillis = this.gos.get("blockLoadDebounceMillis");
      if (blockLoadDebounceMillis && blockLoadDebounceMillis > 0) {
        this.checkBlockToLoadDebounce = _.debounce(this.performCheckBlocksToLoad.bind(this), blockLoadDebounceMillis);
      }
    }
    setBeans(loggerFactory) {
      this.logger = loggerFactory.create("RowNodeBlockLoader");
    }
    getMaxConcurrentDatasourceRequests() {
      const res = this.gos.get("maxConcurrentDatasourceRequests");
      if (res == null) {
        return 2;
      }
      if (res <= 0) {
        return;
      }
      return res;
    }
    addBlock(block) {
      this.blocks.push(block);
      block.addEventListener(RowNodeBlock.EVENT_LOAD_COMPLETE, this.loadComplete.bind(this));
      this.checkBlockToLoad();
    }
    removeBlock(block) {
      _.removeFromArray(this.blocks, block);
    }
    destroy() {
      super.destroy();
      this.active = false;
    }
    loadComplete() {
      this.activeBlockLoadsCount--;
      this.checkBlockToLoad();
      this.dispatchEvent({ type: RowNodeBlockLoader.BLOCK_LOADED_EVENT });
      if (this.activeBlockLoadsCount == 0) {
        this.dispatchEvent({ type: RowNodeBlockLoader.BLOCK_LOADER_FINISHED_EVENT });
      }
    }
    checkBlockToLoad() {
      if (this.checkBlockToLoadDebounce) {
        this.checkBlockToLoadDebounce();
      } else {
        this.performCheckBlocksToLoad();
      }
    }
    performCheckBlocksToLoad() {
      if (!this.active) {
        return;
      }
      this.printCacheStatus();
      if (this.maxConcurrentRequests != null && this.activeBlockLoadsCount >= this.maxConcurrentRequests) {
        this.logger.log(`checkBlockToLoad: max loads exceeded`);
        return;
      }
      const loadAvailability = this.getAvailableLoadingCount();
      const blocksToLoad = this.blocks.filter((block) => block.getState() === RowNodeBlock.STATE_WAITING_TO_LOAD).slice(0, loadAvailability);
      this.registerLoads(blocksToLoad.length);
      blocksToLoad.forEach((block) => block.load());
      this.printCacheStatus();
    }
    getBlockState() {
      if (this.gos.isRowModelType("serverSide")) {
        const ssrm = this.rowModel;
        return ssrm.getBlockStates();
      }
      const result = {};
      this.blocks.forEach((block) => {
        const { id, state } = block.getBlockStateJson();
        result[id] = state;
      });
      return result;
    }
    printCacheStatus() {
      if (this.logger.isLogging()) {
        this.logger.log(`printCacheStatus: activePageLoadsCount = ${this.activeBlockLoadsCount}, blocks = ${JSON.stringify(this.getBlockState())}`);
      }
    }
    isLoading() {
      return this.activeBlockLoadsCount > 0;
    }
    registerLoads(count) {
      this.activeBlockLoadsCount += count;
    }
    getAvailableLoadingCount() {
      return this.maxConcurrentRequests !== void 0 ? this.maxConcurrentRequests - this.activeBlockLoadsCount : void 0;
    }
  };
  RowNodeBlockLoader.BLOCK_LOADED_EVENT = "blockLoaded";
  RowNodeBlockLoader.BLOCK_LOADER_FINISHED_EVENT = "blockLoaderFinished";
  __decorateClass([
    Autowired("rowModel")
  ], RowNodeBlockLoader.prototype, "rowModel", 2);
  __decorateClass([
    PostConstruct
  ], RowNodeBlockLoader.prototype, "postConstruct", 1);
  __decorateClass([
    __decorateParam(0, Qualifier("loggerFactory"))
  ], RowNodeBlockLoader.prototype, "setBeans", 1);
  RowNodeBlockLoader = __decorateClass([
    Bean("rowNodeBlockLoader")
  ], RowNodeBlockLoader);
  var PaginationProxy = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.currentPage = 0;
      this.topDisplayedRowIndex = 0;
      this.bottomDisplayedRowIndex = 0;
      this.pixelOffset = 0;
      this.masterRowCount = 0;
    }
    postConstruct() {
      this.active = this.gos.get("pagination");
      this.pageSizeFromGridOptions = this.gos.get("paginationPageSize");
      this.paginateChildRows = this.isPaginateChildRows();
      this.addManagedListener(this.eventService, Events.EVENT_MODEL_UPDATED, this.onModelUpdated.bind(this));
      this.addManagedPropertyListener("pagination", this.onPaginationGridOptionChanged.bind(this));
      this.addManagedPropertyListener("paginationPageSize", this.onPageSizeGridOptionChanged.bind(this));
      this.onModelUpdated();
    }
    ensureRowHeightsValid(startPixel, endPixel, startLimitIndex, endLimitIndex) {
      const res = this.rowModel.ensureRowHeightsValid(startPixel, endPixel, this.getPageFirstRow(), this.getPageLastRow());
      if (res) {
        this.calculatePages();
      }
      return res;
    }
    isPaginateChildRows() {
      const shouldPaginate = this.gos.get("groupRemoveSingleChildren") || this.gos.get("groupRemoveLowestSingleChildren");
      if (shouldPaginate) {
        return true;
      }
      return this.gos.get("paginateChildRows");
    }
    onModelUpdated(modelUpdatedEvent) {
      this.calculatePages();
      const paginationChangedEvent = {
        type: Events.EVENT_PAGINATION_CHANGED,
        animate: modelUpdatedEvent ? modelUpdatedEvent.animate : false,
        newData: modelUpdatedEvent ? modelUpdatedEvent.newData : false,
        newPage: modelUpdatedEvent ? modelUpdatedEvent.newPage : false,
        newPageSize: modelUpdatedEvent ? modelUpdatedEvent.newPageSize : false,
        keepRenderedRows: modelUpdatedEvent ? modelUpdatedEvent.keepRenderedRows : false
      };
      this.eventService.dispatchEvent(paginationChangedEvent);
    }
    onPaginationGridOptionChanged() {
      this.active = this.gos.get("pagination");
      this.calculatePages();
      const paginationChangedEvent = {
        type: Events.EVENT_PAGINATION_CHANGED,
        animate: false,
        newData: false,
        newPage: false,
        newPageSize: false,
        // important to keep rendered rows, otherwise every time grid is resized,
        // we would destroy all the rows.
        keepRenderedRows: true
      };
      this.eventService.dispatchEvent(paginationChangedEvent);
    }
    onPageSizeGridOptionChanged() {
      this.setPageSize(this.gos.get("paginationPageSize"), "gridOptions");
    }
    goToPage(page) {
      if (!this.active || this.currentPage === page || typeof this.currentPage !== "number") {
        return;
      }
      this.currentPage = page;
      this.calculatePages();
      const paginationChangedEvent = {
        type: Events.EVENT_PAGINATION_CHANGED,
        animate: false,
        newData: false,
        newPage: true,
        newPageSize: false,
        keepRenderedRows: false
      };
      this.eventService.dispatchEvent(paginationChangedEvent);
    }
    getPixelOffset() {
      return this.pixelOffset;
    }
    getRow(index) {
      return this.rowModel.getRow(index);
    }
    getRowNode(id) {
      return this.rowModel.getRowNode(id);
    }
    getRowIndexAtPixel(pixel) {
      return this.rowModel.getRowIndexAtPixel(pixel);
    }
    getCurrentPageHeight() {
      if (missing(this.topRowBounds) || missing(this.bottomRowBounds)) {
        return 0;
      }
      return Math.max(this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight - this.topRowBounds.rowTop, 0);
    }
    getCurrentPagePixelRange() {
      const pageFirstPixel = this.topRowBounds ? this.topRowBounds.rowTop : 0;
      const pageLastPixel = this.bottomRowBounds ? this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight : 0;
      return { pageFirstPixel, pageLastPixel };
    }
    isRowPresent(rowNode) {
      if (!this.rowModel.isRowPresent(rowNode)) {
        return false;
      }
      const nodeIsInPage = rowNode.rowIndex >= this.topDisplayedRowIndex && rowNode.rowIndex <= this.bottomDisplayedRowIndex;
      return nodeIsInPage;
    }
    isEmpty() {
      return this.rowModel.isEmpty();
    }
    isRowsToRender() {
      return this.rowModel.isRowsToRender();
    }
    forEachNode(callback) {
      return this.rowModel.forEachNode(callback);
    }
    forEachNodeOnPage(callback) {
      const firstRow = this.getPageFirstRow();
      const lastRow = this.getPageLastRow();
      for (let i = firstRow; i <= lastRow; i++) {
        const node = this.getRow(i);
        if (node) {
          callback(node);
        }
      }
    }
    getType() {
      return this.rowModel.getType();
    }
    getRowBounds(index) {
      const res = this.rowModel.getRowBounds(index);
      res.rowIndex = index;
      return res;
    }
    getPageFirstRow() {
      return this.topRowBounds ? this.topRowBounds.rowIndex : -1;
    }
    getPageLastRow() {
      return this.bottomRowBounds ? this.bottomRowBounds.rowIndex : -1;
    }
    getRowCount() {
      return this.rowModel.getRowCount();
    }
    getPageForIndex(index) {
      return Math.floor(index / this.pageSize);
    }
    goToPageWithIndex(index) {
      if (!this.active) {
        return;
      }
      const pageNumber = this.getPageForIndex(index);
      this.goToPage(pageNumber);
    }
    isRowInPage(row) {
      if (!this.active) {
        return true;
      }
      const rowPage = this.getPageForIndex(row.rowIndex);
      return rowPage === this.currentPage;
    }
    isLastPageFound() {
      return this.rowModel.isLastRowIndexKnown();
    }
    getCurrentPage() {
      return this.currentPage;
    }
    goToNextPage() {
      this.goToPage(this.currentPage + 1);
    }
    goToPreviousPage() {
      this.goToPage(this.currentPage - 1);
    }
    goToFirstPage() {
      this.goToPage(0);
    }
    goToLastPage() {
      const rowCount = this.rowModel.getRowCount();
      const lastPage = Math.floor(rowCount / this.pageSize);
      this.goToPage(lastPage);
    }
    getPageSize() {
      return this.pageSize;
    }
    getTotalPages() {
      return this.totalPages;
    }
    /** This is only for state setting before data has been loaded */
    setPage(page) {
      this.currentPage = page;
    }
    get pageSize() {
      if (exists(this.pageSizeAutoCalculated)) {
        return this.pageSizeAutoCalculated;
      }
      if (exists(this.pageSizeFromPageSizeSelector)) {
        return this.pageSizeFromPageSizeSelector;
      }
      if (exists(this.pageSizeFromInitialState)) {
        return this.pageSizeFromInitialState;
      }
      if (exists(this.pageSizeFromGridOptions)) {
        return this.pageSizeFromGridOptions;
      }
      return this.defaultPageSize;
    }
    unsetAutoCalculatedPageSize() {
      if (this.pageSizeAutoCalculated === void 0) {
        return;
      }
      const oldPageSize = this.pageSizeAutoCalculated;
      this.pageSizeAutoCalculated = void 0;
      if (this.pageSize === oldPageSize) {
        return;
      }
      this.calculatePages();
      const paginationChangedEvent = {
        type: Events.EVENT_PAGINATION_CHANGED,
        animate: false,
        newData: false,
        newPage: false,
        newPageSize: true,
        keepRenderedRows: false
      };
      this.eventService.dispatchEvent(paginationChangedEvent);
    }
    setPageSize(size2, source) {
      const currentSize = this.pageSize;
      switch (source) {
        case "autoCalculated":
          this.pageSizeAutoCalculated = size2;
          break;
        case "pageSizeSelector":
          this.pageSizeFromPageSizeSelector = size2;
          if (this.currentPage !== 0) {
            this.goToFirstPage();
          }
          break;
        case "initialState":
          this.pageSizeFromInitialState = size2;
          break;
        case "gridOptions":
          this.pageSizeFromGridOptions = size2;
          this.pageSizeFromInitialState = void 0;
          this.pageSizeFromPageSizeSelector = void 0;
          if (this.currentPage !== 0) {
            this.goToFirstPage();
          }
          break;
      }
      if (currentSize !== this.pageSize) {
        this.calculatePages();
        const paginationChangedEvent = {
          type: Events.EVENT_PAGINATION_CHANGED,
          animate: false,
          newData: false,
          newPage: false,
          newPageSize: true,
          keepRenderedRows: true
        };
        this.eventService.dispatchEvent(paginationChangedEvent);
      }
    }
    calculatePages() {
      if (this.active) {
        if (this.paginateChildRows) {
          this.calculatePagesAllRows();
        } else {
          this.calculatePagesMasterRowsOnly();
        }
      } else {
        this.calculatedPagesNotActive();
      }
      this.topRowBounds = this.rowModel.getRowBounds(this.topDisplayedRowIndex);
      if (this.topRowBounds) {
        this.topRowBounds.rowIndex = this.topDisplayedRowIndex;
      }
      this.bottomRowBounds = this.rowModel.getRowBounds(this.bottomDisplayedRowIndex);
      if (this.bottomRowBounds) {
        this.bottomRowBounds.rowIndex = this.bottomDisplayedRowIndex;
      }
      this.setPixelOffset(exists(this.topRowBounds) ? this.topRowBounds.rowTop : 0);
    }
    setPixelOffset(value) {
      if (this.pixelOffset === value) {
        return;
      }
      this.pixelOffset = value;
      this.eventService.dispatchEvent({ type: Events.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED });
    }
    setZeroRows() {
      this.masterRowCount = 0;
      this.topDisplayedRowIndex = 0;
      this.bottomDisplayedRowIndex = -1;
      this.currentPage = 0;
      this.totalPages = 0;
    }
    adjustCurrentPageIfInvalid() {
      if (this.currentPage >= this.totalPages) {
        this.currentPage = this.totalPages - 1;
      }
      if (!isFinite(this.currentPage) || isNaN(this.currentPage) || this.currentPage < 0) {
        this.currentPage = 0;
      }
    }
    calculatePagesMasterRowsOnly() {
      this.masterRowCount = this.rowModel.getTopLevelRowCount();
      if (this.masterRowCount <= 0) {
        this.setZeroRows();
        return;
      }
      const masterLastRowIndex = this.masterRowCount - 1;
      this.totalPages = Math.floor(masterLastRowIndex / this.pageSize) + 1;
      this.adjustCurrentPageIfInvalid();
      const masterPageStartIndex = this.pageSize * this.currentPage;
      let masterPageEndIndex = this.pageSize * (this.currentPage + 1) - 1;
      if (masterPageEndIndex > masterLastRowIndex) {
        masterPageEndIndex = masterLastRowIndex;
      }
      this.topDisplayedRowIndex = this.rowModel.getTopLevelRowDisplayedIndex(masterPageStartIndex);
      if (masterPageEndIndex === masterLastRowIndex) {
        this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
      } else {
        const firstIndexNotToShow = this.rowModel.getTopLevelRowDisplayedIndex(masterPageEndIndex + 1);
        this.bottomDisplayedRowIndex = firstIndexNotToShow - 1;
      }
    }
    getMasterRowCount() {
      return this.masterRowCount;
    }
    calculatePagesAllRows() {
      this.masterRowCount = this.rowModel.getRowCount();
      if (this.masterRowCount === 0) {
        this.setZeroRows();
        return;
      }
      const maxRowIndex = this.masterRowCount - 1;
      this.totalPages = Math.floor(maxRowIndex / this.pageSize) + 1;
      this.adjustCurrentPageIfInvalid();
      this.topDisplayedRowIndex = this.pageSize * this.currentPage;
      this.bottomDisplayedRowIndex = this.pageSize * (this.currentPage + 1) - 1;
      if (this.bottomDisplayedRowIndex > maxRowIndex) {
        this.bottomDisplayedRowIndex = maxRowIndex;
      }
    }
    calculatedPagesNotActive() {
      this.setPageSize(void 0, "autoCalculated");
      this.totalPages = 1;
      this.currentPage = 0;
      this.topDisplayedRowIndex = 0;
      this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
    }
  };
  __decorateClass([
    Autowired("rowModel")
  ], PaginationProxy.prototype, "rowModel", 2);
  __decorateClass([
    PostConstruct
  ], PaginationProxy.prototype, "postConstruct", 1);
  PaginationProxy = __decorateClass([
    Bean("paginationProxy")
  ], PaginationProxy);
  var StylingService = class extends BeanStub {
    processAllCellClasses(colDef, params, onApplicableClass, onNotApplicableClass) {
      this.processClassRules(void 0, colDef.cellClassRules, params, onApplicableClass, onNotApplicableClass);
      this.processStaticCellClasses(colDef, params, onApplicableClass);
    }
    processClassRules(previousClassRules, classRules, params, onApplicableClass, onNotApplicableClass) {
      if (classRules == null && previousClassRules == null) {
        return;
      }
      const classesToApply = {};
      const classesToRemove = {};
      const forEachSingleClass = (className, callback) => {
        className.split(" ").forEach((singleClass) => {
          if (singleClass.trim() == "")
            return;
          callback(singleClass);
        });
      };
      if (classRules) {
        const classNames = Object.keys(classRules);
        for (let i = 0; i < classNames.length; i++) {
          const className = classNames[i];
          const rule = classRules[className];
          let resultOfRule;
          if (typeof rule === "string") {
            resultOfRule = this.expressionService.evaluate(rule, params);
          } else if (typeof rule === "function") {
            resultOfRule = rule(params);
          }
          forEachSingleClass(className, (singleClass) => {
            resultOfRule ? classesToApply[singleClass] = true : classesToRemove[singleClass] = true;
          });
        }
      }
      if (previousClassRules && onNotApplicableClass) {
        Object.keys(previousClassRules).forEach((className) => forEachSingleClass(className, (singleClass) => {
          if (!classesToApply[singleClass]) {
            classesToRemove[singleClass] = true;
          }
        }));
      }
      if (onNotApplicableClass) {
        Object.keys(classesToRemove).forEach(onNotApplicableClass);
      }
      Object.keys(classesToApply).forEach(onApplicableClass);
    }
    getStaticCellClasses(colDef, params) {
      const { cellClass } = colDef;
      if (!cellClass) {
        return [];
      }
      let classOrClasses;
      if (typeof cellClass === "function") {
        const cellClassFunc = cellClass;
        classOrClasses = cellClassFunc(params);
      } else {
        classOrClasses = cellClass;
      }
      if (typeof classOrClasses === "string") {
        classOrClasses = [classOrClasses];
      }
      return classOrClasses || [];
    }
    processStaticCellClasses(colDef, params, onApplicableClass) {
      const classOrClasses = this.getStaticCellClasses(colDef, params);
      classOrClasses.forEach((cssClassItem) => {
        onApplicableClass(cssClassItem);
      });
    }
  };
  __decorateClass([
    Autowired("expressionService")
  ], StylingService.prototype, "expressionService", 2);
  StylingService = __decorateClass([
    Bean("stylingService")
  ], StylingService);
  var AgToggleButton = class extends AgCheckbox {
    constructor(config) {
      super(config, "ag-toggle-button");
    }
    setValue(value, silent) {
      super.setValue(value, silent);
      this.addOrRemoveCssClass("ag-selected", this.getValue());
      return this;
    }
  };
  var AgInputTextArea = class extends AgAbstractInputField {
    constructor(config) {
      super(config, "ag-text-area", null, "textarea");
    }
    setValue(value, silent) {
      const ret = super.setValue(value, silent);
      this.eInput.value = value;
      return ret;
    }
    setCols(cols) {
      this.eInput.cols = cols;
      return this;
    }
    setRows(rows) {
      this.eInput.rows = rows;
      return this;
    }
  };
  var AgInputDateField = class extends AgInputTextField {
    constructor(config) {
      super(config, "ag-date-field", "date");
    }
    postConstruct() {
      super.postConstruct();
      this.addManagedListener(this.eInput, "wheel", this.onWheel.bind(this));
      const usingSafari = isBrowserSafari();
      this.addManagedListener(this.eInput, "mousedown", () => {
        if (this.isDisabled() || usingSafari) {
          return;
        }
        this.eInput.focus();
      });
      this.eInput.step = "any";
    }
    onWheel(e) {
      if (this.gos.getActiveDomElement() === this.eInput) {
        e.preventDefault();
      }
    }
    setMin(minDate) {
      var _a;
      const min = minDate instanceof Date ? (_a = serialiseDate(minDate != null ? minDate : null, false)) != null ? _a : void 0 : minDate;
      if (this.min === min) {
        return this;
      }
      this.min = min;
      addOrRemoveAttribute(this.eInput, "min", min);
      return this;
    }
    setMax(maxDate) {
      var _a;
      const max = maxDate instanceof Date ? (_a = serialiseDate(maxDate != null ? maxDate : null, false)) != null ? _a : void 0 : maxDate;
      if (this.max === max) {
        return this;
      }
      this.max = max;
      addOrRemoveAttribute(this.eInput, "max", max);
      return this;
    }
    setStep(step) {
      if (this.step === step) {
        return this;
      }
      this.step = step;
      addOrRemoveAttribute(this.eInput, "step", step);
      return this;
    }
    getDate() {
      var _a;
      if (!this.eInput.validity.valid) {
        return void 0;
      }
      return (_a = parseDateTimeFromString(this.getValue())) != null ? _a : void 0;
    }
    setDate(date, silent) {
      this.setValue(serialiseDate(date != null ? date : null, false), silent);
    }
  };
  var AgInputRange = class extends AgAbstractInputField {
    constructor(config) {
      super(config, "ag-range-field", "range");
    }
    postConstruct() {
      super.postConstruct();
      const { min, max, step } = this.config;
      if (min != null) {
        this.setMinValue(min);
      }
      if (max != null) {
        this.setMaxValue(max);
      }
      this.setStep(step || 1);
    }
    addInputListeners() {
      this.addManagedListener(this.eInput, "input", (e) => {
        const value = e.target.value;
        this.setValue(value);
      });
    }
    setMinValue(value) {
      this.min = value;
      this.eInput.setAttribute("min", value.toString());
      return this;
    }
    setMaxValue(value) {
      this.max = value;
      this.eInput.setAttribute("max", value.toString());
      return this;
    }
    setStep(value) {
      this.eInput.setAttribute("step", value.toString());
      return this;
    }
    setValue(value, silent) {
      if (this.min != null) {
        value = Math.max(parseFloat(value), this.min).toString();
      }
      if (this.max != null) {
        value = Math.min(parseFloat(value), this.max).toString();
      }
      const ret = super.setValue(value, silent);
      this.eInput.value = value;
      return ret;
    }
  };
  var RichSelectRow = class extends Component {
    constructor(params, wrapperEl) {
      super(
        /* html */
        `<div class="ag-rich-select-row" role="presentation"></div>`
      );
      this.params = params;
      this.wrapperEl = wrapperEl;
    }
    postConstruct() {
      this.addManagedListener(this.getGui(), "click", this.onClick.bind(this));
    }
    setState(value) {
      let formattedValue = "";
      if (this.params.valueFormatter) {
        formattedValue = this.params.valueFormatter(value);
      }
      const rendererSuccessful = this.populateWithRenderer(value, formattedValue);
      if (!rendererSuccessful) {
        this.populateWithoutRenderer(value, formattedValue);
      }
      this.value = value;
    }
    highlightString(matchString) {
      const { parsedValue } = this;
      if (this.params.cellRenderer || !exists(parsedValue)) {
        return;
      }
      let hasMatch = exists(matchString);
      if (hasMatch) {
        const index = parsedValue == null ? void 0 : parsedValue.toLocaleLowerCase().indexOf(matchString.toLocaleLowerCase());
        if (index >= 0) {
          const highlightEndIndex = index + matchString.length;
          const startPart = escapeString(parsedValue.slice(0, index), true);
          const highlightedPart = escapeString(parsedValue.slice(index, highlightEndIndex), true);
          const endPart = escapeString(parsedValue.slice(highlightEndIndex));
          this.renderValueWithoutRenderer(`${startPart}<span class="ag-rich-select-row-text-highlight">${highlightedPart}</span>${endPart}`);
        } else {
          hasMatch = false;
        }
      }
      if (!hasMatch) {
        this.renderValueWithoutRenderer(parsedValue);
      }
    }
    updateHighlighted(highlighted) {
      var _a;
      const eGui = this.getGui();
      const parentId = `ag-rich-select-row-${this.getCompId()}`;
      (_a = eGui.parentElement) == null ? void 0 : _a.setAttribute("id", parentId);
      if (highlighted) {
        const parentAriaEl = this.getParentComponent().getAriaElement();
        setAriaActiveDescendant(parentAriaEl, parentId);
        this.wrapperEl.setAttribute("data-active-option", parentId);
      }
      setAriaSelected(eGui.parentElement, highlighted);
      this.addOrRemoveCssClass("ag-rich-select-row-selected", highlighted);
    }
    populateWithoutRenderer(value, valueFormatted) {
      const eDocument = this.gos.getDocument();
      const eGui = this.getGui();
      const span = eDocument.createElement("span");
      span.style.overflow = "hidden";
      span.style.textOverflow = "ellipsis";
      const parsedValue = escapeString(exists(valueFormatted) ? valueFormatted : value, true);
      this.parsedValue = exists(parsedValue) ? parsedValue : null;
      eGui.appendChild(span);
      this.renderValueWithoutRenderer(parsedValue);
      this.setTooltip({
        newTooltipText: this.parsedValue,
        shouldDisplayTooltip: () => span.scrollWidth > span.clientWidth
      });
    }
    renderValueWithoutRenderer(value) {
      const span = this.getGui().querySelector("span");
      if (!span) {
        return;
      }
      span.innerHTML = exists(value) ? value : "&nbsp;";
    }
    populateWithRenderer(value, valueFormatted) {
      let cellRendererPromise;
      let userCompDetails;
      if (this.params.cellRenderer) {
        userCompDetails = this.userComponentFactory.getCellRendererDetails(this.params, {
          value,
          valueFormatted,
          setTooltip: (value2, shouldDisplayTooltip) => {
            this.setTooltip({ newTooltipText: value2, shouldDisplayTooltip });
          }
        });
      }
      if (userCompDetails) {
        cellRendererPromise = userCompDetails.newAgStackInstance();
      }
      if (cellRendererPromise) {
        bindCellRendererToHtmlElement(cellRendererPromise, this.getGui());
      }
      if (cellRendererPromise) {
        cellRendererPromise.then((childComponent) => {
          this.addDestroyFunc(() => {
            this.getContext().destroyBean(childComponent);
          });
        });
        return true;
      }
      return false;
    }
    onClick() {
      const parent = this.getParentComponent();
      const event = {
        type: Events.EVENT_FIELD_PICKER_VALUE_SELECTED,
        fromEnterKey: false,
        value: this.value
      };
      parent == null ? void 0 : parent.dispatchEvent(event);
    }
  };
  __decorateClass([
    Autowired("userComponentFactory")
  ], RichSelectRow.prototype, "userComponentFactory", 2);
  __decorateClass([
    PostConstruct
  ], RichSelectRow.prototype, "postConstruct", 1);
  var _VirtualList = class _VirtualList2 extends TabGuardComp {
    constructor(params) {
      super(_VirtualList2.getTemplate((params == null ? void 0 : params.cssIdentifier) || "default"));
      this.renderedRows = /* @__PURE__ */ new Map();
      this.rowHeight = 20;
      this.pageSize = -1;
      this.isScrolling = false;
      this.isHeightFromTheme = true;
      const { cssIdentifier = "default", ariaRole = "listbox", listName } = params || {};
      this.cssIdentifier = cssIdentifier;
      this.ariaRole = ariaRole;
      this.listName = listName;
    }
    postConstruct() {
      this.addScrollListener();
      this.rowHeight = this.getItemHeight();
      this.addResizeObserver();
      this.initialiseTabGuard({
        onFocusIn: (e) => this.onFocusIn(e),
        onFocusOut: (e) => this.onFocusOut(e),
        focusInnerElement: (fromBottom) => this.focusInnerElement(fromBottom),
        onTabKeyDown: (e) => this.onTabKeyDown(e),
        handleKeyDown: (e) => this.handleKeyDown(e)
      });
      this.setAriaProperties();
      this.addManagedListener(this.eventService, Events.EVENT_GRID_STYLES_CHANGED, this.onGridStylesChanged.bind(this));
    }
    onGridStylesChanged() {
      this.rowHeight = this.getItemHeight();
      this.refresh();
    }
    setAriaProperties() {
      const translate = this.localeService.getLocaleTextFunc();
      const listName = translate("ariaDefaultListName", this.listName || "List");
      const ariaEl = this.eContainer;
      setAriaRole(ariaEl, this.ariaRole);
      setAriaLabel(ariaEl, listName);
    }
    addResizeObserver() {
      const listener = () => this.animationFrameService.requestAnimationFrame(() => this.drawVirtualRows());
      const destroyObserver = this.resizeObserverService.observeResize(this.getGui(), listener);
      this.addDestroyFunc(destroyObserver);
    }
    focusInnerElement(fromBottom) {
      this.focusRow(fromBottom ? this.model.getRowCount() - 1 : 0);
    }
    onFocusIn(e) {
      const target = e.target;
      if (target.classList.contains("ag-virtual-list-item")) {
        this.lastFocusedRowIndex = getAriaPosInSet(target) - 1;
      }
    }
    onFocusOut(e) {
      if (!this.getFocusableElement().contains(e.relatedTarget)) {
        this.lastFocusedRowIndex = null;
      }
    }
    handleKeyDown(e) {
      switch (e.key) {
        case KeyCode.UP:
        case KeyCode.DOWN:
          if (this.navigate(e.key === KeyCode.UP)) {
            e.preventDefault();
          }
          break;
        case KeyCode.PAGE_HOME:
        case KeyCode.PAGE_END:
        case KeyCode.PAGE_UP:
        case KeyCode.PAGE_DOWN:
          if (this.navigateToPage(e.key) !== null) {
            e.preventDefault();
          }
          break;
      }
    }
    onTabKeyDown(e) {
      if (this.navigate(e.shiftKey)) {
        e.preventDefault();
      } else {
        stopPropagationForAgGrid(e);
        this.forceFocusOutOfContainer(e.shiftKey);
      }
    }
    navigate(up) {
      if (this.lastFocusedRowIndex == null) {
        return false;
      }
      const nextRow = this.lastFocusedRowIndex + (up ? -1 : 1);
      if (nextRow < 0 || nextRow >= this.model.getRowCount()) {
        return false;
      }
      this.focusRow(nextRow);
      return true;
    }
    navigateToPage(key, fromItem = "focused") {
      let hasFocus = false;
      if (fromItem === "focused") {
        fromItem = this.getLastFocusedRow();
        hasFocus = true;
      }
      const rowCount = this.model.getRowCount() - 1;
      let newIndex = -1;
      if (key === KeyCode.PAGE_HOME) {
        newIndex = 0;
      } else if (key === KeyCode.PAGE_END) {
        newIndex = rowCount;
      } else if (key === KeyCode.PAGE_DOWN) {
        newIndex = Math.min(fromItem + this.pageSize, rowCount);
      } else if (key === KeyCode.PAGE_UP) {
        newIndex = Math.max(fromItem - this.pageSize, 0);
      }
      if (newIndex === -1) {
        return null;
      }
      if (hasFocus) {
        this.focusRow(newIndex);
      } else {
        this.ensureIndexVisible(newIndex);
      }
      return newIndex;
    }
    getLastFocusedRow() {
      return this.lastFocusedRowIndex;
    }
    focusRow(rowNumber) {
      if (this.isScrolling) {
        return;
      }
      this.isScrolling = true;
      this.ensureIndexVisible(rowNumber);
      this.animationFrameService.requestAnimationFrame(() => {
        this.isScrolling = false;
        if (!this.isAlive()) {
          return;
        }
        const renderedRow = this.renderedRows.get(rowNumber);
        if (renderedRow) {
          renderedRow.eDiv.focus();
        }
      });
    }
    getComponentAt(rowIndex) {
      const comp = this.renderedRows.get(rowIndex);
      return comp && comp.rowComponent;
    }
    forEachRenderedRow(func) {
      this.renderedRows.forEach((value, key) => func(value.rowComponent, key));
    }
    static getTemplate(cssIdentifier) {
      return (
        /* html */
        `<div class="ag-virtual-list-viewport ag-${cssIdentifier}-virtual-list-viewport" role="presentation">
                <div class="ag-virtual-list-container ag-${cssIdentifier}-virtual-list-container" ref="eContainer"></div>
            </div>`
      );
    }
    getItemHeight() {
      if (!this.isHeightFromTheme) {
        return this.rowHeight;
      }
      return this.environment.getListItemHeight();
    }
    /**
     * Returns true if the view had to be scrolled, otherwise, false.
     */
    ensureIndexVisible(index, scrollPartialIntoView = true) {
      const lastRow = this.model.getRowCount();
      if (typeof index !== "number" || index < 0 || index >= lastRow) {
        console.warn("AG Grid: invalid row index for ensureIndexVisible: " + index);
        return false;
      }
      const rowTopPixel = index * this.rowHeight;
      const rowBottomPixel = rowTopPixel + this.rowHeight;
      const eGui = this.getGui();
      const viewportTopPixel = eGui.scrollTop;
      const viewportHeight = eGui.offsetHeight;
      const viewportBottomPixel = viewportTopPixel + viewportHeight;
      const diff = scrollPartialIntoView ? 0 : this.rowHeight;
      const viewportScrolledPastRow = viewportTopPixel > rowTopPixel + diff;
      const viewportScrolledBeforeRow = viewportBottomPixel < rowBottomPixel - diff;
      if (viewportScrolledPastRow) {
        eGui.scrollTop = rowTopPixel;
        return true;
      }
      if (viewportScrolledBeforeRow) {
        const newScrollPosition = rowBottomPixel - viewportHeight;
        eGui.scrollTop = newScrollPosition;
        return true;
      }
      return false;
    }
    setComponentCreator(componentCreator) {
      this.componentCreator = componentCreator;
    }
    setComponentUpdater(componentUpdater) {
      this.componentUpdater = componentUpdater;
    }
    getRowHeight() {
      return this.rowHeight;
    }
    getScrollTop() {
      return this.getGui().scrollTop;
    }
    setRowHeight(rowHeight) {
      this.isHeightFromTheme = false;
      this.rowHeight = rowHeight;
      this.refresh();
    }
    refresh(softRefresh) {
      if (this.model == null || !this.isAlive()) {
        return;
      }
      const rowCount = this.model.getRowCount();
      this.eContainer.style.height = `${rowCount * this.rowHeight}px`;
      waitUntil(
        () => this.eContainer.clientHeight >= rowCount * this.rowHeight,
        () => {
          if (!this.isAlive()) {
            return;
          }
          if (this.canSoftRefresh(softRefresh)) {
            this.drawVirtualRows(true);
          } else {
            this.clearVirtualRows();
            this.drawVirtualRows();
          }
        }
      );
    }
    canSoftRefresh(softRefresh) {
      return !!(softRefresh && this.renderedRows.size && typeof this.model.areRowsEqual === "function" && this.componentUpdater);
    }
    clearVirtualRows() {
      this.renderedRows.forEach((_2, rowIndex) => this.removeRow(rowIndex));
    }
    drawVirtualRows(softRefresh) {
      if (!this.isAlive() || !this.model) {
        return;
      }
      const gui = this.getGui();
      const topPixel = gui.scrollTop;
      const bottomPixel = topPixel + gui.offsetHeight;
      const firstRow = Math.floor(topPixel / this.rowHeight);
      const lastRow = Math.floor(bottomPixel / this.rowHeight);
      this.pageSize = Math.floor((bottomPixel - topPixel) / this.rowHeight);
      this.ensureRowsRendered(firstRow, lastRow, softRefresh);
    }
    ensureRowsRendered(start2, finish, softRefresh) {
      this.renderedRows.forEach((_2, rowIndex) => {
        if ((rowIndex < start2 || rowIndex > finish) && rowIndex !== this.lastFocusedRowIndex) {
          this.removeRow(rowIndex);
        }
      });
      if (softRefresh) {
        this.refreshRows();
      }
      for (let rowIndex = start2; rowIndex <= finish; rowIndex++) {
        if (this.renderedRows.has(rowIndex)) {
          continue;
        }
        if (rowIndex < this.model.getRowCount()) {
          this.insertRow(rowIndex);
        }
      }
    }
    insertRow(rowIndex) {
      const value = this.model.getRow(rowIndex);
      const eDiv = document.createElement("div");
      eDiv.classList.add("ag-virtual-list-item", `ag-${this.cssIdentifier}-virtual-list-item`);
      setAriaRole(eDiv, this.ariaRole === "tree" ? "treeitem" : "option");
      setAriaSetSize(eDiv, this.model.getRowCount());
      setAriaPosInSet(eDiv, rowIndex + 1);
      eDiv.setAttribute("tabindex", "-1");
      eDiv.style.height = `${this.rowHeight}px`;
      eDiv.style.top = `${this.rowHeight * rowIndex}px`;
      const rowComponent = this.componentCreator(value, eDiv);
      rowComponent.addGuiEventListener("focusin", () => this.lastFocusedRowIndex = rowIndex);
      eDiv.appendChild(rowComponent.getGui());
      if (this.renderedRows.has(rowIndex - 1)) {
        this.renderedRows.get(rowIndex - 1).eDiv.insertAdjacentElement("afterend", eDiv);
      } else if (this.renderedRows.has(rowIndex + 1)) {
        this.renderedRows.get(rowIndex + 1).eDiv.insertAdjacentElement("beforebegin", eDiv);
      } else {
        this.eContainer.appendChild(eDiv);
      }
      this.renderedRows.set(rowIndex, { rowComponent, eDiv, value });
    }
    removeRow(rowIndex) {
      const component = this.renderedRows.get(rowIndex);
      this.eContainer.removeChild(component.eDiv);
      this.destroyBean(component.rowComponent);
      this.renderedRows.delete(rowIndex);
    }
    refreshRows() {
      const rowCount = this.model.getRowCount();
      this.renderedRows.forEach((row, rowIndex) => {
        var _a, _b;
        if (rowIndex >= rowCount) {
          this.removeRow(rowIndex);
        } else {
          const newValue = this.model.getRow(rowIndex);
          if ((_b = (_a = this.model).areRowsEqual) == null ? void 0 : _b.call(_a, row.value, newValue)) {
            this.componentUpdater(newValue, row.rowComponent);
          } else {
            this.removeRow(rowIndex);
          }
        }
      });
    }
    addScrollListener() {
      this.addGuiEventListener("scroll", () => this.drawVirtualRows(), { passive: true });
    }
    setModel(model) {
      this.model = model;
    }
    getAriaElement() {
      return this.eContainer;
    }
    destroy() {
      if (!this.isAlive()) {
        return;
      }
      this.clearVirtualRows();
      super.destroy();
    }
  };
  __decorateClass([
    Autowired("resizeObserverService")
  ], _VirtualList.prototype, "resizeObserverService", 2);
  __decorateClass([
    Autowired("animationFrameService")
  ], _VirtualList.prototype, "animationFrameService", 2);
  __decorateClass([
    RefSelector("eContainer")
  ], _VirtualList.prototype, "eContainer", 2);
  __decorateClass([
    PostConstruct
  ], _VirtualList.prototype, "postConstruct", 1);
  var VirtualList = _VirtualList;
  var TEMPLATE2 = (
    /* html */
    `
    <div class="ag-picker-field" role="presentation">
        <div ref="eLabel"></div>
            <div ref="eWrapper" class="ag-wrapper ag-picker-field-wrapper ag-rich-select-value ag-picker-collapsed">
            <div ref="eDisplayField" class="ag-picker-field-display"></div>
            <ag-input-text-field ref="eInput" class="ag-rich-select-field-input"></ag-input-text-field>
            <div ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
        </div>
    </div>`
  );
  var AgRichSelect = class extends AgPickerField {
    constructor(config) {
      var _a, _b;
      super(__spreadProps(__spreadValues({
        pickerAriaLabelKey: "ariaLabelRichSelectField",
        pickerAriaLabelValue: "Rich Select Field",
        pickerType: "ag-list",
        className: "ag-rich-select",
        pickerIcon: "smallDown",
        ariaRole: "combobox",
        template: (_a = config == null ? void 0 : config.template) != null ? _a : TEMPLATE2,
        modalPicker: false
      }, config), {
        // maxPickerHeight needs to be set after expanding `config`
        maxPickerHeight: (_b = config == null ? void 0 : config.maxPickerHeight) != null ? _b : "calc(var(--ag-row-height) * 6.5)"
      }));
      this.searchString = "";
      this.highlightedItem = -1;
      this.lastRowHovered = -1;
      this.searchStringCreator = null;
      const { cellRowHeight, value, valueList, searchStringCreator } = config || {};
      if (cellRowHeight != null) {
        this.cellRowHeight = cellRowHeight;
      }
      if (value !== void 0) {
        this.value = value;
      }
      if (valueList != null) {
        this.values = valueList;
      }
      if (searchStringCreator) {
        this.searchStringCreator = searchStringCreator;
      }
    }
    postConstruct() {
      super.postConstruct();
      this.createLoadingElement();
      this.createListComponent();
      const { allowTyping, placeholder } = this.config;
      if (allowTyping) {
        this.eInput.setAutoComplete(false).setInputPlaceholder(placeholder);
        this.eDisplayField.classList.add("ag-hidden");
      } else {
        this.eInput.setDisplayed(false);
      }
      this.eWrapper.tabIndex = this.gos.get("tabIndex");
      const { searchDebounceDelay = 300 } = this.config;
      this.clearSearchString = debounce2(this.clearSearchString, searchDebounceDelay);
      this.renderSelectedValue();
      if (allowTyping) {
        this.eInput.onValueChange((value) => this.searchTextFromString(value));
        this.addManagedListener(this.eWrapper, "focus", this.onWrapperFocus.bind(this));
      }
      this.addManagedListener(this.eWrapper, "focusout", this.onWrapperFocusOut.bind(this));
    }
    createLoadingElement() {
      const eDocument = this.gos.getDocument();
      const translate = this.localeService.getLocaleTextFunc();
      const el = eDocument.createElement("div");
      el.classList.add("ag-loading-text");
      el.innerText = translate("loadingOoo", "Loading...");
      this.eLoading = el;
    }
    createListComponent() {
      this.listComponent = this.createBean(new VirtualList({ cssIdentifier: "rich-select" }));
      this.listComponent.setComponentCreator(this.createRowComponent.bind(this));
      const componentUpdater = (item, component) => {
      };
      this.listComponent.setComponentUpdater(componentUpdater);
      this.listComponent.setParentComponent(this);
      this.addManagedListener(this.listComponent, Events.EVENT_FIELD_PICKER_VALUE_SELECTED, (e) => {
        this.onListValueSelected(e.value, e.fromEnterKey);
      });
      const { cellRowHeight } = this;
      if (cellRowHeight) {
        this.listComponent.setRowHeight(cellRowHeight);
      }
      const eListGui = this.listComponent.getGui();
      const eListAriaEl = this.listComponent.getAriaElement();
      this.addManagedListener(eListGui, "mousemove", this.onPickerMouseMove.bind(this));
      this.addManagedListener(eListGui, "mousedown", (e) => e.preventDefault());
      eListGui.classList.add("ag-rich-select-list");
      const listId = `ag-rich-select-list-${this.listComponent.getCompId()}`;
      eListAriaEl.setAttribute("id", listId);
      const translate = this.localeService.getLocaleTextFunc();
      const ariaLabel = translate(this.config.pickerAriaLabelKey, this.config.pickerAriaLabelValue);
      setAriaLabel(eListAriaEl, ariaLabel);
      setAriaControls(this.eWrapper, eListAriaEl);
    }
    renderSelectedValue() {
      const { value, eDisplayField, config } = this;
      const { allowTyping, initialInputValue } = this.config;
      const valueFormatted = this.config.valueFormatter ? this.config.valueFormatter(value) : value;
      if (allowTyping) {
        this.eInput.setValue(initialInputValue != null ? initialInputValue : valueFormatted);
        return;
      }
      let userCompDetails;
      if (config.cellRenderer) {
        userCompDetails = this.userComponentFactory.getCellRendererDetails(this.config, {
          value,
          valueFormatted
        });
      }
      let userCompDetailsPromise;
      if (userCompDetails) {
        userCompDetailsPromise = userCompDetails.newAgStackInstance();
      }
      if (userCompDetailsPromise) {
        clearElement(eDisplayField);
        bindCellRendererToHtmlElement(userCompDetailsPromise, eDisplayField);
        userCompDetailsPromise.then((renderer2) => {
          this.addDestroyFunc(() => this.getContext().destroyBean(renderer2));
        });
      } else {
        if (exists(this.value)) {
          eDisplayField.innerText = valueFormatted;
          eDisplayField.classList.remove("ag-display-as-placeholder");
        } else {
          const { placeholder } = config;
          if (exists(placeholder)) {
            eDisplayField.innerHTML = `${escapeString(placeholder)}`;
            eDisplayField.classList.add("ag-display-as-placeholder");
          } else {
            clearElement(eDisplayField);
          }
        }
        this.setTooltip({
          newTooltipText: valueFormatted != null ? valueFormatted : null,
          shouldDisplayTooltip: () => this.eDisplayField.scrollWidth > this.eDisplayField.clientWidth
        });
      }
    }
    getCurrentValueIndex() {
      const { currentList, value } = this;
      if (value == null || !currentList) {
        return -1;
      }
      for (let i = 0; i < currentList.length; i++) {
        if (currentList[i] === value) {
          return i;
        }
      }
      return -1;
    }
    highlightFilterMatch() {
      var _a;
      (_a = this.listComponent) == null ? void 0 : _a.forEachRenderedRow((cmp, idx) => {
        cmp.highlightString(this.searchString);
      });
    }
    highlightSelectedValue(index) {
      var _a;
      if (index == null) {
        index = this.getCurrentValueIndex();
      }
      this.highlightedItem = index;
      (_a = this.listComponent) == null ? void 0 : _a.forEachRenderedRow((cmp, idx) => {
        const highlighted = index === -1 ? false : this.highlightedItem === idx;
        cmp.updateHighlighted(highlighted);
      });
    }
    setRowHeight(height) {
      if (height !== this.cellRowHeight) {
        this.cellRowHeight = height;
      }
      if (this.listComponent) {
        this.listComponent.setRowHeight(height);
      }
    }
    createPickerComponent() {
      const { values: values2 } = this;
      if (values2) {
        this.setValueList({ valueList: values2 });
      }
      return this.listComponent;
    }
    setSearchStringCreator(searchStringFn) {
      this.searchStringCreator = searchStringFn;
    }
    setValueList(params) {
      const { valueList, refresh } = params;
      if (!this.listComponent) {
        return;
      }
      if (this.currentList === valueList) {
        return;
      }
      this.currentList = valueList;
      this.listComponent.setModel({
        getRowCount: () => valueList.length,
        getRow: (index) => valueList[index],
        areRowsEqual: (oldRow, newRow) => oldRow === newRow
      });
      if (refresh) {
        if (!this.values) {
          this.values = valueList;
          if (this.isPickerDisplayed) {
            this.showCurrentValueInPicker();
          }
        } else {
          this.listComponent.refresh(true);
        }
      }
    }
    showPicker() {
      super.showPicker();
      this.showCurrentValueInPicker();
      this.displayOrHidePicker();
    }
    showCurrentValueInPicker() {
      var _a, _b;
      if (!this.listComponent) {
        return;
      }
      if (!this.currentList) {
        if (this.isPickerDisplayed && this.eLoading) {
          this.listComponent.appendChild(this.eLoading);
        }
        return;
      }
      if ((_a = this.eLoading) == null ? void 0 : _a.offsetParent) {
        (_b = this.eLoading.parentElement) == null ? void 0 : _b.removeChild(this.eLoading);
      }
      const currentValueIndex = this.getCurrentValueIndex();
      if (currentValueIndex !== -1) {
        this.listComponent.refresh();
        this.listComponent.ensureIndexVisible(currentValueIndex);
        this.listComponent.refresh(true);
        this.highlightSelectedValue(currentValueIndex);
      } else {
        this.listComponent.refresh();
      }
    }
    beforeHidePicker() {
      this.highlightedItem = -1;
      super.beforeHidePicker();
    }
    onWrapperFocus() {
      if (!this.eInput) {
        return;
      }
      const focusableEl = this.eInput.getFocusableElement();
      focusableEl.focus();
      focusableEl.select();
    }
    onWrapperFocusOut(e) {
      if (!this.eWrapper.contains(e.relatedTarget)) {
        this.hidePicker();
      }
    }
    buildSearchStringFromKeyboardEvent(searchKey) {
      let { key } = searchKey;
      if (key === KeyCode.BACKSPACE) {
        this.searchString = this.searchString.slice(0, -1);
        key = "";
      } else if (!isEventFromPrintableCharacter(searchKey)) {
        return;
      }
      searchKey.preventDefault();
      this.searchTextFromCharacter(key);
    }
    searchTextFromCharacter(char) {
      this.searchString += char;
      this.runSearch();
      this.clearSearchString();
    }
    searchTextFromString(str) {
      if (str == null) {
        str = "";
      }
      this.searchString = str;
      this.runSearch();
    }
    buildSearchStrings(values2) {
      const { valueFormatter = (value) => value } = this.config;
      let searchStrings;
      if (typeof values2[0] === "number" || typeof values2[0] === "string") {
        searchStrings = values2.map((v) => valueFormatter(v));
      } else if (typeof values2[0] === "object" && this.searchStringCreator) {
        searchStrings = this.searchStringCreator(values2);
      }
      return searchStrings;
    }
    getSuggestionsAndFilteredValues(searchValue, valueList) {
      let suggestions = [];
      let filteredValues = [];
      if (!searchValue.length) {
        return { suggestions, filteredValues };
      }
      ;
      const { searchType = "fuzzy", filterList } = this.config;
      if (searchType === "fuzzy") {
        const fuzzySearchResult = fuzzySuggestions(this.searchString, valueList, true);
        suggestions = fuzzySearchResult.values;
        const indices = fuzzySearchResult.indices;
        if (filterList && indices.length) {
          for (let i = 0; i < indices.length; i++) {
            filteredValues.push(this.values[indices[i]]);
          }
        }
      } else {
        suggestions = valueList.filter((val, idx) => {
          const currentValue = val.toLocaleLowerCase();
          const valueToMatch = this.searchString.toLocaleLowerCase();
          const isMatch = searchType === "match" ? currentValue.startsWith(valueToMatch) : currentValue.indexOf(valueToMatch) !== -1;
          if (filterList && isMatch) {
            filteredValues.push(this.values[idx]);
          }
          return isMatch;
        });
      }
      return { suggestions, filteredValues };
    }
    filterListModel(filteredValues) {
      const { filterList } = this.config;
      if (!filterList) {
        return;
      }
      this.setValueList({ valueList: filteredValues, refresh: true });
      this.alignPickerToComponent();
    }
    runSearch() {
      var _a, _b;
      const { values: values2 } = this;
      const searchStrings = this.buildSearchStrings(values2);
      if (!searchStrings) {
        this.highlightSelectedValue(-1);
        return;
      }
      const { suggestions, filteredValues } = this.getSuggestionsAndFilteredValues(this.searchString, searchStrings);
      const { filterList, highlightMatch, searchType = "fuzzy" } = this.config;
      const filterValueLen = filteredValues.length;
      const shouldFilter = !!(filterList && this.searchString !== "");
      this.filterListModel(shouldFilter ? filteredValues : values2);
      if (suggestions.length) {
        const topSuggestionIndex = shouldFilter ? 0 : searchStrings.indexOf(suggestions[0]);
        this.selectListItem(topSuggestionIndex);
      } else {
        this.highlightSelectedValue(-1);
        if (!shouldFilter || filterValueLen) {
          (_a = this.listComponent) == null ? void 0 : _a.ensureIndexVisible(0);
        } else if (shouldFilter) {
          this.getAriaElement().removeAttribute("data-active-option");
          const eListAriaEl = (_b = this.listComponent) == null ? void 0 : _b.getAriaElement();
          if (eListAriaEl) {
            setAriaActiveDescendant(eListAriaEl, null);
          }
        }
      }
      if (highlightMatch && searchType !== "fuzzy") {
        this.highlightFilterMatch();
      }
      this.displayOrHidePicker();
    }
    displayOrHidePicker() {
      var _a;
      const eListGui = (_a = this.listComponent) == null ? void 0 : _a.getGui();
      const toggleValue = this.currentList ? this.currentList.length === 0 : false;
      eListGui == null ? void 0 : eListGui.classList.toggle("ag-hidden", toggleValue);
    }
    clearSearchString() {
      this.searchString = "";
    }
    selectListItem(index, preventUnnecessaryScroll) {
      if (!this.isPickerDisplayed || !this.currentList || !this.listComponent || index < 0 || index >= this.currentList.length) {
        return;
      }
      const wasScrolled = this.listComponent.ensureIndexVisible(index, !preventUnnecessaryScroll);
      if (wasScrolled && !preventUnnecessaryScroll) {
        this.listComponent.refresh(true);
      }
      this.highlightSelectedValue(index);
    }
    setValue(value, silent, fromPicker) {
      const index = this.currentList ? this.currentList.indexOf(value) : -1;
      if (index === -1) {
        return this;
      }
      this.value = value;
      if (!fromPicker) {
        this.selectListItem(index);
      }
      this.renderSelectedValue();
      return super.setValue(value, silent);
    }
    createRowComponent(value) {
      const row = new RichSelectRow(this.config, this.eWrapper);
      row.setParentComponent(this.listComponent);
      this.getContext().createBean(row);
      row.setState(value);
      const { highlightMatch, searchType = "fuzzy" } = this.config;
      if (highlightMatch && searchType !== "fuzzy") {
        row.highlightString(this.searchString);
      }
      return row;
    }
    getRowForMouseEvent(e) {
      const { listComponent } = this;
      if (!listComponent) {
        return -1;
      }
      const eGui = listComponent == null ? void 0 : listComponent.getGui();
      const rect = eGui.getBoundingClientRect();
      const scrollTop = listComponent.getScrollTop();
      const mouseY = e.clientY - rect.top + scrollTop;
      return Math.floor(mouseY / listComponent.getRowHeight());
    }
    onPickerMouseMove(e) {
      if (!this.listComponent) {
        return;
      }
      const row = this.getRowForMouseEvent(e);
      if (row !== -1 && row != this.lastRowHovered) {
        this.lastRowHovered = row;
        this.selectListItem(row, true);
      }
    }
    onNavigationKeyDown(event, key) {
      event.preventDefault();
      const isDown = key === KeyCode.DOWN;
      if (!this.isPickerDisplayed && isDown) {
        this.showPicker();
        return;
      }
      const oldIndex = this.highlightedItem;
      const diff = isDown ? 1 : -1;
      const newIndex = oldIndex === -1 ? 0 : oldIndex + diff;
      this.selectListItem(newIndex);
    }
    onPageNavigation(key) {
      var _a;
      if (!this.isPickerDisplayed) {
        return;
      }
      const newIndex = (_a = this.listComponent) == null ? void 0 : _a.navigateToPage(key, this.highlightedItem);
      if (newIndex != null) {
        this.animationFrameService.requestAnimationFrame(() => {
          if (!this.isAlive()) {
            return null;
          }
          this.highlightSelectedValue(newIndex);
        });
      }
    }
    onEnterKeyDown(e) {
      if (!this.isPickerDisplayed) {
        return;
      }
      e.preventDefault();
      if (this.currentList) {
        this.onListValueSelected(this.currentList[this.highlightedItem], true);
      }
    }
    onTabKeyDown() {
      if (!this.isPickerDisplayed || !this.currentList) {
        return;
      }
      this.setValue(this.currentList[this.highlightedItem], false, true);
    }
    onListValueSelected(value, fromEnterKey) {
      this.setValue(value, false, true);
      this.dispatchPickerEvent(value, fromEnterKey);
      this.hidePicker();
    }
    dispatchPickerEvent(value, fromEnterKey) {
      const event = {
        type: Events.EVENT_FIELD_PICKER_VALUE_SELECTED,
        fromEnterKey,
        value
      };
      this.dispatchEvent(event);
    }
    getFocusableElement() {
      const { allowTyping } = this.config;
      if (allowTyping) {
        return this.eInput.getFocusableElement();
      }
      return super.getFocusableElement();
    }
    onKeyDown(event) {
      const key = event.key;
      const { allowTyping } = this.config;
      switch (key) {
        case KeyCode.LEFT:
        case KeyCode.RIGHT:
          if (!allowTyping) {
            event.preventDefault();
          }
          break;
        case KeyCode.PAGE_HOME:
        case KeyCode.PAGE_END:
          if (allowTyping) {
            event.preventDefault();
            const inputEl = this.eInput.getInputElement();
            const target = key === KeyCode.PAGE_HOME ? 0 : inputEl.value.length;
            inputEl.setSelectionRange(target, target);
            break;
          }
        case KeyCode.PAGE_UP:
        case KeyCode.PAGE_DOWN:
          event.preventDefault();
          this.onPageNavigation(key);
          break;
        case KeyCode.DOWN:
        case KeyCode.UP:
          this.onNavigationKeyDown(event, key);
          break;
        case KeyCode.ESCAPE:
          if (this.isPickerDisplayed) {
            if (isVisible(this.listComponent.getGui())) {
              event.preventDefault();
              stopPropagationForAgGrid(event);
            }
            this.hidePicker();
          }
          break;
        case KeyCode.ENTER:
          this.onEnterKeyDown(event);
          break;
        case KeyCode.TAB:
          this.onTabKeyDown();
          break;
        default:
          if (!allowTyping) {
            this.buildSearchStringFromKeyboardEvent(event);
          }
      }
    }
    destroy() {
      if (this.listComponent) {
        this.destroyBean(this.listComponent);
        this.listComponent = void 0;
      }
      this.eLoading = void 0;
      super.destroy();
    }
  };
  __decorateClass([
    Autowired("userComponentFactory")
  ], AgRichSelect.prototype, "userComponentFactory", 2);
  __decorateClass([
    Autowired("animationFrameService")
  ], AgRichSelect.prototype, "animationFrameService", 2);
  __decorateClass([
    RefSelector("eInput")
  ], AgRichSelect.prototype, "eInput", 2);
  var _AgSlider = class _AgSlider2 extends AgAbstractLabel {
    constructor(config) {
      super(config, _AgSlider2.TEMPLATE);
      this.labelAlignment = "top";
    }
    init() {
      this.eSlider.addCssClass("ag-slider-field");
      const { minValue, maxValue, textFieldWidth, step, value, onValueChange } = this.config;
      if (minValue != null) {
        this.setMinValue(minValue);
      }
      if (maxValue != null) {
        this.setMaxValue(maxValue);
      }
      if (textFieldWidth != null) {
        this.setTextFieldWidth(textFieldWidth);
      }
      if (step != null) {
        this.setStep(step);
      }
      if (value != null) {
        this.setValue(value);
      }
      if (onValueChange != null) {
        this.onValueChange(onValueChange);
      }
    }
    onValueChange(callbackFn) {
      const eventChanged = Events.EVENT_FIELD_VALUE_CHANGED;
      this.addManagedListener(this.eText, eventChanged, () => {
        const textValue = parseFloat(this.eText.getValue());
        this.eSlider.setValue(textValue.toString(), true);
        callbackFn(textValue || 0);
      });
      this.addManagedListener(this.eSlider, eventChanged, () => {
        const sliderValue = this.eSlider.getValue();
        this.eText.setValue(sliderValue, true);
        callbackFn(parseFloat(sliderValue));
      });
      return this;
    }
    setSliderWidth(width) {
      this.eSlider.setWidth(width);
      return this;
    }
    setTextFieldWidth(width) {
      this.eText.setWidth(width);
      return this;
    }
    setMinValue(minValue) {
      this.eSlider.setMinValue(minValue);
      this.eText.setMin(minValue);
      return this;
    }
    setMaxValue(maxValue) {
      this.eSlider.setMaxValue(maxValue);
      this.eText.setMax(maxValue);
      return this;
    }
    getValue() {
      return this.eText.getValue();
    }
    setValue(value, silent) {
      if (this.getValue() === value) {
        return this;
      }
      this.eText.setValue(value, true);
      this.eSlider.setValue(value, true);
      if (!silent) {
        this.dispatchEvent({ type: Events.EVENT_FIELD_VALUE_CHANGED });
      }
      return this;
    }
    setStep(step) {
      this.eSlider.setStep(step);
      this.eText.setStep(step);
      return this;
    }
  };
  _AgSlider.TEMPLATE = /* html */
  `<div class="ag-slider">
            <label ref="eLabel"></label>
            <div class="ag-wrapper ag-slider-wrapper">
                <ag-input-range ref="eSlider"></ag-input-range>
                <ag-input-number-field ref="eText"></ag-input-number-field>
            </div>
        </div>`;
  __decorateClass([
    RefSelector("eLabel")
  ], _AgSlider.prototype, "eLabel", 2);
  __decorateClass([
    RefSelector("eSlider")
  ], _AgSlider.prototype, "eSlider", 2);
  __decorateClass([
    RefSelector("eText")
  ], _AgSlider.prototype, "eText", 2);
  __decorateClass([
    PostConstruct
  ], _AgSlider.prototype, "init", 1);
  var AgSlider = _AgSlider;
  var _AgGroupComponent = class _AgGroupComponent2 extends Component {
    constructor(params = {}) {
      super(_AgGroupComponent2.getTemplate(params));
      this.params = params;
      this.suppressEnabledCheckbox = true;
      this.suppressToggleExpandOnEnableChange = false;
      const {
        enabled,
        items,
        suppressEnabledCheckbox,
        expanded,
        suppressToggleExpandOnEnableChange,
        useToggle: toggleMode
      } = params;
      this.cssIdentifier = params.cssIdentifier || "default";
      this.enabled = enabled != null ? enabled : true;
      this.items = items || [];
      this.useToggle = toggleMode != null ? toggleMode : false;
      this.alignItems = params.alignItems || "center";
      this.expanded = expanded == null ? true : expanded;
      if (suppressEnabledCheckbox != null) {
        this.suppressEnabledCheckbox = suppressEnabledCheckbox;
      }
      if (suppressToggleExpandOnEnableChange != null) {
        this.suppressToggleExpandOnEnableChange = suppressToggleExpandOnEnableChange;
      }
    }
    static getTemplate(params) {
      const cssIdentifier = params.cssIdentifier || "default";
      const direction = params.direction || "vertical";
      return (
        /* html */
        `
            <div class="ag-group ag-${cssIdentifier}-group" role="presentation">
                <div ref="eToolbar" class="ag-group-toolbar ag-${cssIdentifier}-group-toolbar">
                    <ag-checkbox ref="cbGroupEnabled"></ag-checkbox>
                </div>
                <div ref="eContainer" class="ag-group-container ag-group-container-${direction} ag-${cssIdentifier}-group-container"></div>
            </div>
        `
      );
    }
    postConstruct() {
      this.setupTitleBar();
      if (this.items.length) {
        const initialItems = this.items;
        this.items = [];
        this.addItems(initialItems);
      }
      const localeTextFunc = this.localeService.getLocaleTextFunc();
      this.cbGroupEnabled.setLabel(localeTextFunc("enabled", "Enabled"));
      if (this.enabled) {
        this.setEnabled(this.enabled, void 0, true);
      }
      this.setAlignItems(this.alignItems);
      const { onEnableChange, suppressOpenCloseIcons } = this.params;
      this.hideEnabledCheckbox(this.suppressEnabledCheckbox);
      this.hideOpenCloseIcons(suppressOpenCloseIcons != null ? suppressOpenCloseIcons : false);
      this.refreshChildDisplay();
      setDisplayed(this.eContainer, this.expanded);
      this.cbGroupEnabled.onValueChange((newSelection) => {
        this.setEnabled(newSelection, true, this.suppressToggleExpandOnEnableChange);
        this.dispatchEnableChangeEvent(newSelection);
      });
      if (onEnableChange != null) {
        this.onEnableChange(onEnableChange);
      }
    }
    refreshChildDisplay() {
      var _a;
      setDisplayed(this.eToolbar, this.expanded && !this.suppressEnabledCheckbox);
      (_a = this.eTitleBar) == null ? void 0 : _a.refreshOnExpand(this.expanded);
    }
    isExpanded() {
      return this.expanded;
    }
    setAlignItems(alignment) {
      if (this.alignItems !== alignment) {
        this.removeCssClass(`ag-group-item-alignment-${this.alignItems}`);
      }
      this.alignItems = alignment;
      const newCls = `ag-group-item-alignment-${this.alignItems}`;
      this.addCssClass(newCls);
      return this;
    }
    toggleGroupExpand(expanded) {
      var _a;
      let silent = false;
      if (((_a = this.eTitleBar) == null ? void 0 : _a.isSuppressCollapse()) && !this.useToggle) {
        expanded = true;
        silent = true;
      } else {
        expanded = expanded != null ? expanded : !this.expanded;
        if (this.expanded === expanded) {
          return this;
        }
      }
      this.expanded = expanded;
      this.refreshChildDisplay();
      setDisplayed(this.eContainer, expanded);
      if (!silent) {
        this.dispatchEvent({ type: expanded ? _AgGroupComponent2.EVENT_EXPANDED : _AgGroupComponent2.EVENT_COLLAPSED });
      }
      return this;
    }
    addItems(items) {
      items.forEach((item) => this.addItem(item));
    }
    prependItem(item) {
      this.insertItem(item, true);
    }
    addItem(item) {
      this.insertItem(item, false);
    }
    insertItem(item, prepend) {
      const container = this.eContainer;
      const el = item instanceof Component ? item.getGui() : item;
      el.classList.add("ag-group-item", `ag-${this.cssIdentifier}-group-item`);
      if (prepend) {
        container.insertAdjacentElement("afterbegin", el);
        this.items.unshift(el);
      } else {
        container.appendChild(el);
        this.items.push(el);
      }
    }
    hideItem(hide, index) {
      const itemToHide = this.items[index];
      setDisplayed(itemToHide, !hide);
    }
    getItemIndex(item) {
      const el = item instanceof Component ? item.getGui() : item;
      return this.items.indexOf(el);
    }
    setTitle(title) {
      var _a;
      (_a = this.eTitleBar) == null ? void 0 : _a.setTitle(title);
      return this;
    }
    addTitleBarWidget(el) {
      var _a;
      (_a = this.eTitleBar) == null ? void 0 : _a.addWidget(el);
      return this;
    }
    addCssClassToTitleBar(cssClass) {
      var _a;
      (_a = this.eTitleBar) == null ? void 0 : _a.addCssClass(cssClass);
    }
    dispatchEnableChangeEvent(enabled) {
      const event = {
        type: _AgGroupComponent2.EVENT_ENABLE_CHANGE,
        enabled
      };
      this.dispatchEvent(event);
    }
    setEnabled(enabled, skipToggle, skipExpand) {
      var _a;
      this.enabled = enabled;
      this.refreshDisabledStyles();
      if (!skipExpand) {
        this.toggleGroupExpand(enabled);
      }
      if (!skipToggle) {
        this.cbGroupEnabled.setValue(enabled);
        (_a = this.eToggle) == null ? void 0 : _a.setValue(enabled);
      }
      return this;
    }
    isEnabled() {
      return this.enabled;
    }
    onEnableChange(callbackFn) {
      this.addManagedListener(this, _AgGroupComponent2.EVENT_ENABLE_CHANGE, (event) => callbackFn(event.enabled));
      return this;
    }
    hideEnabledCheckbox(hide) {
      this.suppressEnabledCheckbox = hide;
      this.refreshChildDisplay();
      this.refreshDisabledStyles();
      return this;
    }
    hideOpenCloseIcons(hide) {
      var _a;
      (_a = this.eTitleBar) == null ? void 0 : _a.hideOpenCloseIcons(hide);
      return this;
    }
    refreshDisabledStyles() {
      var _a;
      const disabled = !this.enabled;
      this.eContainer.classList.toggle("ag-disabled", disabled);
      (_a = this.eTitleBar) == null ? void 0 : _a.refreshDisabledStyles(this.suppressEnabledCheckbox && disabled);
      this.eContainer.classList.toggle("ag-disabled-group-container", disabled);
    }
    setupTitleBar() {
      const titleBar = this.useToggle ? this.createToggleTitleBar() : this.createDefaultTitleBar();
      this.eToolbar.insertAdjacentElement("beforebegin", titleBar.getGui());
    }
    createDefaultTitleBar() {
      const titleBar = this.createManagedBean(new DefaultTitleBar(this.params));
      this.eTitleBar = titleBar;
      titleBar.refreshOnExpand(this.expanded);
      this.addManagedListener(titleBar, DefaultTitleBar.EVENT_EXPAND_CHANGED, (event) => this.toggleGroupExpand(event.expanded));
      return titleBar;
    }
    createToggleTitleBar() {
      var _a;
      const eToggle = this.createManagedBean(new AgToggleButton({
        value: this.enabled,
        label: this.params.title,
        labelAlignment: "left",
        labelWidth: "flex",
        onValueChange: (enabled) => {
          this.setEnabled(enabled, true);
          this.dispatchEnableChangeEvent(enabled);
        }
      }));
      eToggle.addCssClass("ag-group-title-bar");
      eToggle.addCssClass(`ag-${(_a = this.params.cssIdentifier) != null ? _a : "default"}-group-title-bar ag-unselectable`);
      this.eToggle = eToggle;
      this.toggleGroupExpand(this.enabled);
      return eToggle;
    }
  };
  _AgGroupComponent.EVENT_EXPANDED = "expanded";
  _AgGroupComponent.EVENT_COLLAPSED = "collapsed";
  _AgGroupComponent.EVENT_ENABLE_CHANGE = "enableChange";
  __decorateClass([
    RefSelector("eToolbar")
  ], _AgGroupComponent.prototype, "eToolbar", 2);
  __decorateClass([
    RefSelector("cbGroupEnabled")
  ], _AgGroupComponent.prototype, "cbGroupEnabled", 2);
  __decorateClass([
    RefSelector("eContainer")
  ], _AgGroupComponent.prototype, "eContainer", 2);
  __decorateClass([
    PostConstruct
  ], _AgGroupComponent.prototype, "postConstruct", 1);
  var AgGroupComponent = _AgGroupComponent;
  var TITLE_BAR_DISABLED_CLASS = "ag-disabled-group-title-bar";
  var _DefaultTitleBar = class _DefaultTitleBar2 extends Component {
    constructor(params = {}) {
      super(_DefaultTitleBar2.getTemplate(params));
      this.suppressOpenCloseIcons = false;
      const { title, suppressOpenCloseIcons } = params;
      if (!!title && title.length > 0) {
        this.title = title;
      }
      if (suppressOpenCloseIcons != null) {
        this.suppressOpenCloseIcons = suppressOpenCloseIcons;
      }
    }
    static getTemplate(params) {
      var _a;
      const cssIdentifier = (_a = params.cssIdentifier) != null ? _a : "default";
      return (
        /* html */
        `
            <div class="ag-group-title-bar ag-${cssIdentifier}-group-title-bar ag-unselectable" role="button">
                <span class="ag-group-title-bar-icon ag-${cssIdentifier}-group-title-bar-icon" ref="eGroupOpenedIcon" role="presentation"></span>
                <span class="ag-group-title-bar-icon ag-${cssIdentifier}-group-title-bar-icon" ref="eGroupClosedIcon" role="presentation"></span>
                <span ref="eTitle" class="ag-group-title ag-${cssIdentifier}-group-title"></span>
            </div>
        `
      );
    }
    postConstruct() {
      this.setTitle(this.title);
      this.hideOpenCloseIcons(this.suppressOpenCloseIcons);
      this.setupExpandContract();
    }
    setupExpandContract() {
      this.eGroupClosedIcon.appendChild(createIcon("columnSelectClosed", this.gos, null));
      this.eGroupOpenedIcon.appendChild(createIcon("columnSelectOpen", this.gos, null));
      this.addManagedListener(this.getGui(), "click", () => this.dispatchExpandChanged());
      this.addManagedListener(this.getGui(), "keydown", (e) => {
        switch (e.key) {
          case KeyCode.ENTER:
          case KeyCode.SPACE:
            e.preventDefault();
            this.dispatchExpandChanged();
            break;
          case KeyCode.RIGHT:
          case KeyCode.LEFT:
            e.preventDefault();
            this.dispatchExpandChanged(e.key === KeyCode.RIGHT);
            break;
        }
      });
    }
    refreshOnExpand(expanded) {
      this.refreshAriaStatus(expanded);
      this.refreshOpenCloseIcons(expanded);
    }
    refreshAriaStatus(expanded) {
      if (!this.suppressOpenCloseIcons) {
        setAriaExpanded(this.getGui(), expanded);
      }
    }
    refreshOpenCloseIcons(expanded) {
      const showIcon = !this.suppressOpenCloseIcons;
      setDisplayed(this.eGroupOpenedIcon, showIcon && expanded);
      setDisplayed(this.eGroupClosedIcon, showIcon && !expanded);
    }
    isSuppressCollapse() {
      return this.suppressOpenCloseIcons;
    }
    dispatchExpandChanged(expanded) {
      const event = {
        type: _DefaultTitleBar2.EVENT_EXPAND_CHANGED,
        expanded
      };
      this.dispatchEvent(event);
    }
    setTitle(title) {
      const eGui = this.getGui();
      const hasTitle = !!title && title.length > 0;
      title = hasTitle ? title : void 0;
      this.eTitle.textContent = title != null ? title : "";
      setDisplayed(eGui, hasTitle);
      if (title !== this.title) {
        this.title = title;
      }
      const disabled = eGui.classList.contains(TITLE_BAR_DISABLED_CLASS);
      this.refreshDisabledStyles(disabled);
      return this;
    }
    addWidget(el) {
      this.getGui().appendChild(el);
      return this;
    }
    hideOpenCloseIcons(hide) {
      this.suppressOpenCloseIcons = hide;
      if (hide) {
        this.dispatchExpandChanged(true);
      }
      return this;
    }
    refreshDisabledStyles(disabled) {
      const eGui = this.getGui();
      if (disabled) {
        eGui.classList.add(TITLE_BAR_DISABLED_CLASS);
        eGui.removeAttribute("tabindex");
      } else {
        eGui.classList.remove(TITLE_BAR_DISABLED_CLASS);
        if (typeof this.title === "string") {
          eGui.setAttribute("tabindex", "0");
        } else {
          eGui.removeAttribute("tabindex");
        }
      }
    }
  };
  _DefaultTitleBar.EVENT_EXPAND_CHANGED = "expandedChanged";
  __decorateClass([
    RefSelector("eGroupOpenedIcon")
  ], _DefaultTitleBar.prototype, "eGroupOpenedIcon", 2);
  __decorateClass([
    RefSelector("eGroupClosedIcon")
  ], _DefaultTitleBar.prototype, "eGroupClosedIcon", 2);
  __decorateClass([
    RefSelector("eTitle")
  ], _DefaultTitleBar.prototype, "eTitle", 2);
  __decorateClass([
    PostConstruct
  ], _DefaultTitleBar.prototype, "postConstruct", 1);
  var DefaultTitleBar = _DefaultTitleBar;
  var AgMenuList = class extends TabGuardComp {
    constructor(level = 0, params) {
      super(
        /* html */
        `<div class="ag-menu-list" role="tree"></div>`
      );
      this.level = level;
      this.menuItems = [];
      this.params = params != null ? params : {
        column: null,
        node: null,
        value: null
      };
    }
    postConstruct() {
      this.initialiseTabGuard({
        onTabKeyDown: (e) => this.onTabKeyDown(e),
        handleKeyDown: (e) => this.handleKeyDown(e),
        onFocusIn: (e) => this.handleFocusIn(e),
        onFocusOut: (e) => this.handleFocusOut(e)
      });
    }
    onTabKeyDown(e) {
      const parent = this.getParentComponent();
      const parentGui = parent && parent.getGui();
      const isManaged = parentGui && parentGui.classList.contains("ag-focus-managed");
      if (!isManaged) {
        e.preventDefault();
      }
      if (e.shiftKey) {
        this.closeIfIsChild(e);
      }
    }
    handleKeyDown(e) {
      switch (e.key) {
        case KeyCode.UP:
        case KeyCode.RIGHT:
        case KeyCode.DOWN:
        case KeyCode.LEFT:
          e.preventDefault();
          this.handleNavKey(e.key);
          break;
        case KeyCode.ESCAPE:
          if (this.closeIfIsChild()) {
            stopPropagationForAgGrid(e);
          }
          break;
      }
    }
    handleFocusIn(e) {
      var _a, _b;
      const oldFocusedElement = e.relatedTarget;
      if (!this.tabGuardCtrl.isTabGuard(oldFocusedElement) && (this.getGui().contains(oldFocusedElement) || ((_b = (_a = this.activeMenuItem) == null ? void 0 : _a.getSubMenuGui()) == null ? void 0 : _b.contains(oldFocusedElement)))) {
        return;
      }
      if (this.activeMenuItem) {
        this.activeMenuItem.activate();
      } else {
        this.activateFirstItem();
      }
    }
    handleFocusOut(e) {
      var _a;
      const newFocusedElement = e.relatedTarget;
      if (!this.activeMenuItem || this.getGui().contains(newFocusedElement) || ((_a = this.activeMenuItem.getSubMenuGui()) == null ? void 0 : _a.contains(newFocusedElement))) {
        return;
      }
      if (!this.activeMenuItem.isSubMenuOpening()) {
        this.activeMenuItem.deactivate();
      }
    }
    clearActiveItem() {
      if (this.activeMenuItem) {
        this.activeMenuItem.deactivate();
        this.activeMenuItem = null;
      }
    }
    addMenuItems(menuItems) {
      if (menuItems == null) {
        return;
      }
      AgPromise.all(menuItems.map((menuItemOrString) => {
        if (menuItemOrString === "separator") {
          return AgPromise.resolve({ eGui: this.createSeparator() });
        } else if (typeof menuItemOrString === "string") {
          console.warn(`AG Grid: unrecognised menu item ${menuItemOrString}`);
          return AgPromise.resolve({ eGui: null });
        } else {
          return this.addItem(menuItemOrString);
        }
      })).then((elements) => {
        elements.forEach((element) => {
          if (element == null ? void 0 : element.eGui) {
            this.appendChild(element.eGui);
            if (element.comp) {
              this.menuItems.push(element.comp);
            }
          }
        });
      });
    }
    addItem(menuItemDef) {
      const menuItem = this.createManagedBean(new AgMenuItemComponent());
      return menuItem.init({
        menuItemDef,
        isAnotherSubMenuOpen: () => this.menuItems.some((m) => m.isSubMenuOpen()),
        level: this.level,
        contextParams: this.params
      }).then(() => {
        menuItem.setParentComponent(this);
        this.addManagedListener(menuItem, AgMenuItemComponent.EVENT_CLOSE_MENU, (event) => {
          this.dispatchEvent(event);
        });
        this.addManagedListener(menuItem, AgMenuItemComponent.EVENT_MENU_ITEM_ACTIVATED, (event) => {
          if (this.activeMenuItem && this.activeMenuItem !== event.menuItem) {
            this.activeMenuItem.deactivate();
          }
          this.activeMenuItem = event.menuItem;
        });
        return {
          comp: menuItem,
          eGui: menuItem.getGui()
        };
      });
    }
    activateFirstItem() {
      const item = this.menuItems.filter((currentItem) => !currentItem.isDisabled())[0];
      if (!item) {
        return;
      }
      item.activate();
    }
    createSeparator() {
      const separatorHtml = (
        /* html */
        `
            <div class="ag-menu-separator" aria-hidden="true">
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
            </div>`
      );
      return loadTemplate(separatorHtml);
    }
    handleNavKey(key) {
      switch (key) {
        case KeyCode.UP:
        case KeyCode.DOWN:
          const nextItem = this.findNextItem(key === KeyCode.UP);
          if (nextItem && nextItem !== this.activeMenuItem) {
            nextItem.activate();
          }
          return;
      }
      const left = this.gos.get("enableRtl") ? KeyCode.RIGHT : KeyCode.LEFT;
      if (key === left) {
        this.closeIfIsChild();
      } else {
        this.openChild();
      }
    }
    closeIfIsChild(e) {
      const parentItem = this.getParentComponent();
      if (parentItem && parentItem instanceof AgMenuItemComponent) {
        if (e) {
          e.preventDefault();
        }
        parentItem.closeSubMenu();
        parentItem.getGui().focus();
        return true;
      }
      return false;
    }
    openChild() {
      if (this.activeMenuItem) {
        this.activeMenuItem.openSubMenu(true);
      }
    }
    findNextItem(up) {
      const items = this.menuItems.filter((item) => !item.isDisabled());
      if (!items.length) {
        return;
      }
      if (!this.activeMenuItem) {
        return up ? last(items) : items[0];
      }
      if (up) {
        items.reverse();
      }
      let nextItem;
      let foundCurrent = false;
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        if (!foundCurrent) {
          if (item === this.activeMenuItem) {
            foundCurrent = true;
          }
          continue;
        }
        nextItem = item;
        break;
      }
      if (foundCurrent && !nextItem) {
        return items[0];
      }
      return nextItem || this.activeMenuItem;
    }
    destroy() {
      this.clearActiveItem();
      super.destroy();
    }
  };
  __decorateClass([
    Autowired("focusService")
  ], AgMenuList.prototype, "focusService", 2);
  __decorateClass([
    PostConstruct
  ], AgMenuList.prototype, "postConstruct", 1);
  var AgMenuPanel = class extends TabGuardComp {
    constructor(wrappedComponent) {
      super();
      this.wrappedComponent = wrappedComponent;
      this.setTemplateFromElement(wrappedComponent.getGui());
    }
    postConstruct() {
      this.initialiseTabGuard({
        onTabKeyDown: (e) => this.onTabKeyDown(e),
        handleKeyDown: (e) => this.handleKeyDown(e)
      });
    }
    handleKeyDown(e) {
      if (e.key === KeyCode.ESCAPE) {
        this.closePanel();
      }
    }
    onTabKeyDown(e) {
      if (e.defaultPrevented) {
        return;
      }
      this.closePanel();
      e.preventDefault();
    }
    closePanel() {
      const menuItem = this.parentComponent;
      menuItem.closeSubMenu();
      setTimeout(() => menuItem.getGui().focus(), 0);
    }
  };
  __decorateClass([
    PostConstruct
  ], AgMenuPanel.prototype, "postConstruct", 1);
  var _AgMenuItemComponent = class _AgMenuItemComponent2 extends BeanStub {
    constructor() {
      super(...arguments);
      this.isActive = false;
      this.subMenuIsOpen = false;
      this.subMenuIsOpening = false;
      this.suppressRootStyles = true;
      this.suppressAria = true;
      this.suppressFocus = true;
    }
    init(params) {
      var _a, _b;
      const { menuItemDef, isAnotherSubMenuOpen, level, childComponent, contextParams } = params;
      this.params = params.menuItemDef;
      this.level = level;
      this.isAnotherSubMenuOpen = isAnotherSubMenuOpen;
      this.childComponent = childComponent;
      this.contextParams = contextParams;
      this.cssClassPrefix = (_b = (_a = this.params.menuItemParams) == null ? void 0 : _a.cssClassPrefix) != null ? _b : "ag-menu-option";
      const compDetails = this.userComponentFactory.getMenuItemCompDetails(this.params, __spreadProps(__spreadValues({}, menuItemDef), {
        level,
        isAnotherSubMenuOpen,
        openSubMenu: (activateFirstItem) => this.openSubMenu(activateFirstItem),
        closeSubMenu: () => this.closeSubMenu(),
        closeMenu: (event) => this.closeMenu(event),
        updateTooltip: (tooltip, shouldDisplayTooltip) => this.refreshTooltip(tooltip, shouldDisplayTooltip),
        onItemActivated: () => this.onItemActivated()
      }));
      return compDetails.newAgStackInstance().then((comp) => {
        var _a2;
        this.menuItemComp = comp;
        const configureDefaults = (_a2 = comp.configureDefaults) == null ? void 0 : _a2.call(comp);
        if (configureDefaults) {
          this.configureDefaults(configureDefaults === true ? void 0 : configureDefaults);
        }
      });
    }
    addListeners(eGui, params) {
      if (!(params == null ? void 0 : params.suppressClick)) {
        this.addManagedListener(eGui, "click", (e) => this.onItemSelected(e));
      }
      if (!(params == null ? void 0 : params.suppressKeyboardSelect)) {
        this.addManagedListener(eGui, "keydown", (e) => {
          if (e.key === KeyCode.ENTER || e.key === KeyCode.SPACE) {
            e.preventDefault();
            this.onItemSelected(e);
          }
        });
      }
      if (!(params == null ? void 0 : params.suppressMouseDown)) {
        this.addManagedListener(eGui, "mousedown", (e) => {
          e.stopPropagation();
          e.preventDefault();
        });
      }
      if (!(params == null ? void 0 : params.suppressMouseOver)) {
        this.addManagedListener(eGui, "mouseenter", () => this.onMouseEnter());
        this.addManagedListener(eGui, "mouseleave", () => this.onMouseLeave());
      }
    }
    isDisabled() {
      return !!this.params.disabled;
    }
    openSubMenu(activateFirstItem = false) {
      var _a, _b;
      this.closeSubMenu();
      if (!this.params.subMenu) {
        return;
      }
      this.subMenuIsOpening = true;
      const ePopup = loadTemplate(
        /* html */
        `<div class="ag-menu" role="presentation"></div>`
      );
      this.eSubMenuGui = ePopup;
      let destroySubMenu;
      let afterGuiAttached = () => {
        this.subMenuIsOpening = false;
      };
      if (this.childComponent) {
        const menuPanel = this.createBean(new AgMenuPanel(this.childComponent));
        menuPanel.setParentComponent(this);
        const subMenuGui = menuPanel.getGui();
        const mouseEvent = "mouseenter";
        const mouseEnterListener = () => this.cancelDeactivate();
        subMenuGui.addEventListener(mouseEvent, mouseEnterListener);
        destroySubMenu = () => subMenuGui.removeEventListener(mouseEvent, mouseEnterListener);
        ePopup.appendChild(subMenuGui);
        if (this.childComponent.afterGuiAttached) {
          afterGuiAttached = () => {
            this.childComponent.afterGuiAttached();
            this.subMenuIsOpening = false;
          };
        }
      } else if (this.params.subMenu) {
        const childMenu = this.createBean(new AgMenuList(this.level + 1, this.contextParams));
        childMenu.setParentComponent(this);
        childMenu.addMenuItems(this.params.subMenu);
        ePopup.appendChild(childMenu.getGui());
        this.addManagedListener(childMenu, _AgMenuItemComponent2.EVENT_CLOSE_MENU, (e) => this.dispatchEvent(e));
        childMenu.addGuiEventListener("mouseenter", () => this.cancelDeactivate());
        destroySubMenu = () => this.destroyBean(childMenu);
        if (activateFirstItem) {
          afterGuiAttached = () => {
            childMenu.activateFirstItem();
            this.subMenuIsOpening = false;
          };
        }
      }
      const positionCallback = this.popupService.positionPopupForMenu.bind(
        this.popupService,
        { eventSource: this.eGui, ePopup }
      );
      const translate = this.localeService.getLocaleTextFunc();
      const addPopupRes = this.popupService.addPopup({
        modal: true,
        eChild: ePopup,
        positionCallback,
        anchorToElement: this.eGui,
        ariaLabel: translate("ariaLabelSubMenu", "SubMenu"),
        afterGuiAttached
      });
      this.subMenuIsOpen = true;
      this.setAriaExpanded(true);
      this.hideSubMenu = () => {
        var _a2, _b2;
        if (addPopupRes) {
          addPopupRes.hideFunc();
        }
        this.subMenuIsOpen = false;
        this.setAriaExpanded(false);
        destroySubMenu();
        (_b2 = (_a2 = this.menuItemComp).setExpanded) == null ? void 0 : _b2.call(_a2, false);
        this.eSubMenuGui = void 0;
      };
      (_b = (_a = this.menuItemComp).setExpanded) == null ? void 0 : _b.call(_a, true);
    }
    setAriaExpanded(expanded) {
      if (!this.suppressAria) {
        setAriaExpanded(this.eGui, expanded);
      }
    }
    closeSubMenu() {
      if (!this.hideSubMenu) {
        return;
      }
      this.hideSubMenu();
      this.hideSubMenu = null;
      this.setAriaExpanded(false);
    }
    isSubMenuOpen() {
      return this.subMenuIsOpen;
    }
    isSubMenuOpening() {
      return this.subMenuIsOpening;
    }
    activate(openSubMenu) {
      var _a, _b;
      this.cancelActivate();
      if (this.params.disabled) {
        return;
      }
      this.isActive = true;
      if (!this.suppressRootStyles) {
        this.eGui.classList.add(`${this.cssClassPrefix}-active`);
      }
      (_b = (_a = this.menuItemComp).setActive) == null ? void 0 : _b.call(_a, true);
      if (!this.suppressFocus) {
        this.eGui.focus({ preventScroll: true });
      }
      if (openSubMenu && this.params.subMenu) {
        window.setTimeout(() => {
          if (this.isAlive() && this.isActive) {
            this.openSubMenu();
          }
        }, 300);
      }
      this.onItemActivated();
    }
    deactivate() {
      var _a, _b;
      this.cancelDeactivate();
      if (!this.suppressRootStyles) {
        this.eGui.classList.remove(`${this.cssClassPrefix}-active`);
      }
      (_b = (_a = this.menuItemComp).setActive) == null ? void 0 : _b.call(_a, false);
      this.isActive = false;
      if (this.subMenuIsOpen) {
        this.hideSubMenu();
      }
    }
    getGui() {
      return this.menuItemComp.getGui();
    }
    getParentComponent() {
      return this.parentComponent;
    }
    setParentComponent(component) {
      this.parentComponent = component;
    }
    getSubMenuGui() {
      return this.eSubMenuGui;
    }
    onItemSelected(event) {
      var _a, _b;
      (_b = (_a = this.menuItemComp).select) == null ? void 0 : _b.call(_a);
      if (this.params.action) {
        this.getFrameworkOverrides().wrapOutgoing(() => this.params.action(this.gos.addGridCommonParams(__spreadValues({}, this.contextParams))));
      } else {
        this.openSubMenu(event && event.type === "keydown");
      }
      if (this.params.subMenu && !this.params.action || this.params.suppressCloseOnSelect) {
        return;
      }
      this.closeMenu(event);
    }
    closeMenu(event) {
      const e = {
        type: _AgMenuItemComponent2.EVENT_CLOSE_MENU
      };
      if (event) {
        if (event instanceof MouseEvent) {
          e.mouseEvent = event;
        } else {
          e.keyboardEvent = event;
        }
      }
      this.dispatchEvent(e);
    }
    onItemActivated() {
      const event = {
        type: _AgMenuItemComponent2.EVENT_MENU_ITEM_ACTIVATED,
        menuItem: this
      };
      this.dispatchEvent(event);
    }
    cancelActivate() {
      if (this.activateTimeoutId) {
        window.clearTimeout(this.activateTimeoutId);
        this.activateTimeoutId = 0;
      }
    }
    cancelDeactivate() {
      if (this.deactivateTimeoutId) {
        window.clearTimeout(this.deactivateTimeoutId);
        this.deactivateTimeoutId = 0;
      }
    }
    onMouseEnter() {
      this.cancelDeactivate();
      if (this.isAnotherSubMenuOpen()) {
        this.activateTimeoutId = window.setTimeout(() => this.activate(true), _AgMenuItemComponent2.ACTIVATION_DELAY);
      } else {
        this.activate(true);
      }
    }
    onMouseLeave() {
      this.cancelActivate();
      if (this.isSubMenuOpen()) {
        this.deactivateTimeoutId = window.setTimeout(() => this.deactivate(), _AgMenuItemComponent2.ACTIVATION_DELAY);
      } else {
        this.deactivate();
      }
    }
    configureDefaults(params) {
      var _a, _b, _c;
      if (!this.menuItemComp) {
        setTimeout(() => this.configureDefaults(params));
        return;
      }
      let eGui = this.menuItemComp.getGui();
      const rootElement = (_b = (_a = this.menuItemComp).getRootElement) == null ? void 0 : _b.call(_a);
      if (rootElement) {
        if (!(params == null ? void 0 : params.suppressRootStyles)) {
          eGui.classList.add("ag-menu-option-custom");
        }
        eGui = rootElement;
      }
      this.eGui = eGui;
      this.suppressRootStyles = !!(params == null ? void 0 : params.suppressRootStyles);
      if (!this.suppressRootStyles) {
        eGui.classList.add(this.cssClassPrefix);
        (_c = this.params.cssClasses) == null ? void 0 : _c.forEach((it) => eGui.classList.add(it));
        if (this.params.disabled) {
          eGui.classList.add(`${this.cssClassPrefix}-disabled`);
        }
      }
      if (!(params == null ? void 0 : params.suppressTooltip)) {
        this.refreshTooltip(this.params.tooltip);
      }
      this.suppressAria = !!(params == null ? void 0 : params.suppressAria);
      if (!this.suppressAria) {
        setAriaRole(eGui, "treeitem");
        setAriaLevel(eGui, this.level + 1);
        if (this.params.disabled) {
          setAriaDisabled(eGui, true);
        }
      }
      if (!(params == null ? void 0 : params.suppressTabIndex)) {
        eGui.setAttribute("tabindex", "-1");
      }
      if (!this.params.disabled) {
        this.addListeners(eGui, params);
      }
      this.suppressFocus = !!(params == null ? void 0 : params.suppressFocus);
    }
    refreshTooltip(tooltip, shouldDisplayTooltip) {
      this.tooltip = tooltip;
      if (this.tooltipFeature) {
        this.tooltipFeature = this.destroyBean(this.tooltipFeature);
      }
      if (!tooltip || !this.menuItemComp) {
        return;
      }
      this.tooltipFeature = this.createBean(new TooltipFeature({
        getGui: () => this.getGui(),
        getTooltipValue: () => this.tooltip,
        getLocation: () => "menu",
        shouldDisplayTooltip
      }));
    }
    destroy() {
      if (this.tooltipFeature) {
        this.tooltipFeature = this.destroyBean(this.tooltipFeature);
      }
      super.destroy();
    }
  };
  _AgMenuItemComponent.EVENT_CLOSE_MENU = "closeMenu";
  _AgMenuItemComponent.EVENT_MENU_ITEM_ACTIVATED = "menuItemActivated";
  _AgMenuItemComponent.ACTIVATION_DELAY = 80;
  __decorateClass([
    Autowired("popupService")
  ], _AgMenuItemComponent.prototype, "popupService", 2);
  __decorateClass([
    Autowired("userComponentFactory")
  ], _AgMenuItemComponent.prototype, "userComponentFactory", 2);
  var AgMenuItemComponent = _AgMenuItemComponent;
  var _AgPanel = class _AgPanel2 extends Component {
    constructor(config) {
      super(_AgPanel2.getTemplate(config));
      this.config = config;
      this.closable = true;
    }
    static getTemplate(config) {
      const cssIdentifier = config.cssIdentifier || "default";
      return (
        /* html */
        `<div class="ag-panel ag-${cssIdentifier}-panel" tabindex="-1">
            <div ref="eTitleBar" class="ag-panel-title-bar ag-${cssIdentifier}-panel-title-bar ag-unselectable">
                <span ref="eTitle" class="ag-panel-title-bar-title ag-${cssIdentifier}-panel-title-bar-title"></span>
                <div ref="eTitleBarButtons" class="ag-panel-title-bar-buttons ag-${cssIdentifier}-panel-title-bar-buttons"></div>
            </div>
            <div ref="eContentWrapper" class="ag-panel-content-wrapper ag-${cssIdentifier}-panel-content-wrapper"></div>
        </div>`
      );
    }
    postConstruct() {
      const {
        component,
        closable,
        hideTitleBar,
        title,
        minWidth = 250,
        width,
        minHeight = 250,
        height,
        centered,
        popup,
        x,
        y
      } = this.config;
      this.positionableFeature = new PositionableFeature(this.getGui(), {
        minWidth,
        width,
        minHeight,
        height,
        centered,
        x,
        y,
        popup,
        calculateTopBuffer: () => this.positionableFeature.getHeight() - this.getBodyHeight()
      });
      this.createManagedBean(this.positionableFeature);
      const eGui = this.getGui();
      if (component) {
        this.setBodyComponent(component);
      }
      if (!hideTitleBar) {
        if (title) {
          this.setTitle(title);
        }
        this.setClosable(closable != null ? closable : this.closable);
      } else {
        setDisplayed(this.eTitleBar, false);
      }
      this.addManagedListener(this.eTitleBar, "mousedown", (e) => {
        if (eGui.contains(e.relatedTarget) || eGui.contains(this.gos.getActiveDomElement()) || this.eTitleBarButtons.contains(e.target)) {
          e.preventDefault();
          return;
        }
        const focusEl = this.eContentWrapper.querySelector("button, [href], input, select, textarea, [tabindex]");
        if (focusEl) {
          focusEl.focus();
        }
      });
      if (popup && this.positionableFeature.isPositioned()) {
        return;
      }
      if (this.renderComponent) {
        this.renderComponent();
      }
      this.positionableFeature.initialisePosition();
      this.eContentWrapper.style.height = "0";
    }
    renderComponent() {
      const eGui = this.getGui();
      eGui.focus();
      this.close = () => {
        eGui.parentElement.removeChild(eGui);
        this.destroy();
      };
    }
    getHeight() {
      return this.positionableFeature.getHeight();
    }
    setHeight(height) {
      this.positionableFeature.setHeight(height);
    }
    getWidth() {
      return this.positionableFeature.getWidth();
    }
    setWidth(width) {
      this.positionableFeature.setWidth(width);
    }
    setClosable(closable) {
      if (closable !== this.closable) {
        this.closable = closable;
      }
      if (closable) {
        const closeButtonComp = this.closeButtonComp = new Component(_AgPanel2.CLOSE_BTN_TEMPLATE);
        this.getContext().createBean(closeButtonComp);
        const eGui = closeButtonComp.getGui();
        const child = createIconNoSpan("close", this.gos);
        child.classList.add("ag-panel-title-bar-button-icon");
        eGui.appendChild(child);
        this.addTitleBarButton(closeButtonComp);
        closeButtonComp.addManagedListener(eGui, "click", this.onBtClose.bind(this));
      } else if (this.closeButtonComp) {
        const eGui = this.closeButtonComp.getGui();
        eGui.parentElement.removeChild(eGui);
        this.closeButtonComp = this.destroyBean(this.closeButtonComp);
      }
    }
    setBodyComponent(bodyComponent) {
      bodyComponent.setParentComponent(this);
      this.eContentWrapper.appendChild(bodyComponent.getGui());
    }
    addTitleBarButton(button, position) {
      const eTitleBarButtons = this.eTitleBarButtons;
      const buttons = eTitleBarButtons.children;
      const len = buttons.length;
      if (position == null) {
        position = len;
      }
      position = Math.max(0, Math.min(position, len));
      button.addCssClass("ag-panel-title-bar-button");
      const eGui = button.getGui();
      if (position === 0) {
        eTitleBarButtons.insertAdjacentElement("afterbegin", eGui);
      } else if (position === len) {
        eTitleBarButtons.insertAdjacentElement("beforeend", eGui);
      } else {
        buttons[position - 1].insertAdjacentElement("afterend", eGui);
      }
      button.setParentComponent(this);
    }
    getBodyHeight() {
      return getInnerHeight(this.eContentWrapper);
    }
    getBodyWidth() {
      return getInnerWidth(this.eContentWrapper);
    }
    setTitle(title) {
      this.eTitle.innerText = title;
    }
    // called when user hits the 'x' in the top right
    onBtClose() {
      this.close();
    }
    destroy() {
      if (this.closeButtonComp) {
        this.closeButtonComp = this.destroyBean(this.closeButtonComp);
      }
      const eGui = this.getGui();
      if (eGui && isVisible(eGui)) {
        this.close();
      }
      super.destroy();
    }
  };
  _AgPanel.CLOSE_BTN_TEMPLATE = /* html */
  `<div class="ag-button"></div>`;
  __decorateClass([
    RefSelector("eContentWrapper")
  ], _AgPanel.prototype, "eContentWrapper", 2);
  __decorateClass([
    RefSelector("eTitleBar")
  ], _AgPanel.prototype, "eTitleBar", 2);
  __decorateClass([
    RefSelector("eTitleBarButtons")
  ], _AgPanel.prototype, "eTitleBarButtons", 2);
  __decorateClass([
    RefSelector("eTitle")
  ], _AgPanel.prototype, "eTitle", 2);
  __decorateClass([
    PostConstruct
  ], _AgPanel.prototype, "postConstruct", 1);
  var AgPanel = _AgPanel;
  var AgDialog = class extends AgPanel {
    constructor(config) {
      super(__spreadProps(__spreadValues({}, config), { popup: true }));
      this.isMaximizable = false;
      this.isMaximized = false;
      this.maximizeListeners = [];
      this.resizeListenerDestroy = null;
      this.lastPosition = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }
    postConstruct() {
      const eGui = this.getGui();
      const { movable, resizable, maximizable } = this.config;
      this.addCssClass("ag-dialog");
      super.postConstruct();
      this.addManagedListener(eGui, "focusin", (e) => {
        this.popupService.bringPopupToFront(eGui);
      });
      if (movable) {
        this.setMovable(movable);
      }
      if (maximizable) {
        this.setMaximizable(maximizable);
      }
      if (resizable) {
        this.setResizable(resizable);
      }
    }
    renderComponent() {
      const eGui = this.getGui();
      const { alwaysOnTop, modal, title, afterGuiAttached } = this.config;
      const translate = this.localeService.getLocaleTextFunc();
      const addPopupRes = this.popupService.addPopup({
        modal,
        eChild: eGui,
        closeOnEsc: true,
        closedCallback: this.onClosed.bind(this),
        alwaysOnTop,
        ariaLabel: title || translate("ariaLabelDialog", "Dialog"),
        afterGuiAttached
      });
      if (addPopupRes) {
        this.close = addPopupRes.hideFunc;
      }
    }
    onClosed(event) {
      var _a, _b;
      this.destroy();
      (_b = (_a = this.config).closedCallback) == null ? void 0 : _b.call(_a, event);
    }
    toggleMaximize() {
      const position = this.positionableFeature.getPosition();
      if (this.isMaximized) {
        const { x, y, width, height } = this.lastPosition;
        this.setWidth(width);
        this.setHeight(height);
        this.positionableFeature.offsetElement(x, y);
      } else {
        this.lastPosition.width = this.getWidth();
        this.lastPosition.height = this.getHeight();
        this.lastPosition.x = position.x;
        this.lastPosition.y = position.y;
        this.positionableFeature.offsetElement(0, 0);
        this.setHeight("100%");
        this.setWidth("100%");
      }
      this.isMaximized = !this.isMaximized;
      this.refreshMaximizeIcon();
    }
    refreshMaximizeIcon() {
      setDisplayed(this.maximizeIcon, !this.isMaximized);
      setDisplayed(this.minimizeIcon, this.isMaximized);
    }
    clearMaximizebleListeners() {
      if (this.maximizeListeners.length) {
        this.maximizeListeners.forEach((destroyListener) => destroyListener());
        this.maximizeListeners.length = 0;
      }
      if (this.resizeListenerDestroy) {
        this.resizeListenerDestroy();
        this.resizeListenerDestroy = null;
      }
    }
    destroy() {
      this.maximizeButtonComp = this.destroyBean(this.maximizeButtonComp);
      this.clearMaximizebleListeners();
      super.destroy();
    }
    setResizable(resizable) {
      this.positionableFeature.setResizable(resizable);
    }
    setMovable(movable) {
      this.positionableFeature.setMovable(movable, this.eTitleBar);
    }
    setMaximizable(maximizable) {
      if (!maximizable) {
        this.clearMaximizebleListeners();
        if (this.maximizeButtonComp) {
          this.destroyBean(this.maximizeButtonComp);
          this.maximizeButtonComp = this.maximizeIcon = this.minimizeIcon = void 0;
        }
        return;
      }
      const eTitleBar = this.eTitleBar;
      if (!eTitleBar || maximizable === this.isMaximizable) {
        return;
      }
      const maximizeButtonComp = this.buildMaximizeAndMinimizeElements();
      this.refreshMaximizeIcon();
      maximizeButtonComp.addManagedListener(maximizeButtonComp.getGui(), "click", this.toggleMaximize.bind(this));
      this.addTitleBarButton(maximizeButtonComp, 0);
      this.maximizeListeners.push(
        this.addManagedListener(eTitleBar, "dblclick", this.toggleMaximize.bind(this))
      );
      this.resizeListenerDestroy = this.addManagedListener(this, "resize", () => {
        this.isMaximized = false;
        this.refreshMaximizeIcon();
      });
    }
    buildMaximizeAndMinimizeElements() {
      const maximizeButtonComp = this.maximizeButtonComp = this.createBean(new Component(
        /* html */
        `<div class="ag-dialog-button"></span>`
      ));
      const eGui = maximizeButtonComp.getGui();
      this.maximizeIcon = createIconNoSpan("maximize", this.gos);
      eGui.appendChild(this.maximizeIcon);
      this.maximizeIcon.classList.add("ag-panel-title-bar-button-icon");
      this.minimizeIcon = createIconNoSpan("minimize", this.gos);
      eGui.appendChild(this.minimizeIcon);
      this.minimizeIcon.classList.add("ag-panel-title-bar-button-icon");
      return maximizeButtonComp;
    }
  };
  __decorateClass([
    Autowired("popupService")
  ], AgDialog.prototype, "popupService", 2);
  var instanceIdSeq = 0;
  var PopupService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.popupList = [];
    }
    postConstruct() {
      this.ctrlsService.whenReady((p2) => {
        this.gridCtrl = p2.gridCtrl;
      });
      this.addManagedListener(this.eventService, Events.EVENT_GRID_STYLES_CHANGED, this.handleThemeChange.bind(this));
    }
    getPopupParent() {
      const ePopupParent = this.gos.get("popupParent");
      if (ePopupParent) {
        return ePopupParent;
      }
      return this.gridCtrl.getGui();
    }
    positionPopupForMenu(params) {
      const { eventSource, ePopup } = params;
      const popupIdx = this.getPopupIndex(ePopup);
      if (popupIdx !== -1) {
        const popup = this.popupList[popupIdx];
        popup.alignedToElement = eventSource;
      }
      const sourceRect = eventSource.getBoundingClientRect();
      const parentRect = this.getParentRect();
      const y = this.keepXYWithinBounds(
        ePopup,
        sourceRect.top - parentRect.top,
        0
        /* vertical */
      );
      const minWidth = ePopup.clientWidth > 0 ? ePopup.clientWidth : 200;
      ePopup.style.minWidth = `${minWidth}px`;
      const widthOfParent = parentRect.right - parentRect.left;
      const maxX = widthOfParent - minWidth;
      let x;
      if (this.gos.get("enableRtl")) {
        x = xLeftPosition();
        if (x < 0) {
          x = xRightPosition();
          this.setAlignedStyles(ePopup, "left");
        }
        if (x > maxX) {
          x = 0;
          this.setAlignedStyles(ePopup, "right");
        }
      } else {
        x = xRightPosition();
        if (x > maxX) {
          x = xLeftPosition();
          this.setAlignedStyles(ePopup, "right");
        }
        if (x < 0) {
          x = 0;
          this.setAlignedStyles(ePopup, "left");
        }
      }
      ePopup.style.left = `${x}px`;
      ePopup.style.top = `${y}px`;
      function xRightPosition() {
        return sourceRect.right - parentRect.left - 2;
      }
      function xLeftPosition() {
        return sourceRect.left - parentRect.left - minWidth;
      }
    }
    positionPopupUnderMouseEvent(params) {
      const { ePopup, nudgeX, nudgeY, skipObserver } = params;
      this.positionPopup({
        ePopup,
        nudgeX,
        nudgeY,
        keepWithinBounds: true,
        skipObserver,
        updatePosition: () => this.calculatePointerAlign(params.mouseEvent),
        postProcessCallback: () => this.callPostProcessPopup(params.type, params.ePopup, null, params.mouseEvent, params.column, params.rowNode)
      });
    }
    calculatePointerAlign(e) {
      const parentRect = this.getParentRect();
      return {
        x: e.clientX - parentRect.left,
        y: e.clientY - parentRect.top
      };
    }
    positionPopupByComponent(params) {
      const { ePopup, nudgeX, nudgeY, keepWithinBounds, eventSource, alignSide = "left", position = "over", column, rowNode, type } = params;
      const sourceRect = eventSource.getBoundingClientRect();
      const parentRect = this.getParentRect();
      const popupIdx = this.getPopupIndex(ePopup);
      if (popupIdx !== -1) {
        const popup = this.popupList[popupIdx];
        popup.alignedToElement = eventSource;
      }
      const updatePosition = () => {
        let x = sourceRect.left - parentRect.left;
        if (alignSide === "right") {
          x -= ePopup.offsetWidth - sourceRect.width;
        }
        let y;
        if (position === "over") {
          y = sourceRect.top - parentRect.top;
          this.setAlignedStyles(ePopup, "over");
        } else {
          this.setAlignedStyles(ePopup, "under");
          const alignSide2 = this.shouldRenderUnderOrAbove(ePopup, sourceRect, parentRect, params.nudgeY || 0);
          if (alignSide2 === "under") {
            y = sourceRect.top - parentRect.top + sourceRect.height;
          } else {
            y = sourceRect.top - ePopup.offsetHeight - (nudgeY || 0) * 2 - parentRect.top;
          }
        }
        return { x, y };
      };
      this.positionPopup({
        ePopup,
        nudgeX,
        nudgeY,
        keepWithinBounds,
        updatePosition,
        postProcessCallback: () => this.callPostProcessPopup(type, ePopup, eventSource, null, column, rowNode)
      });
    }
    shouldRenderUnderOrAbove(ePopup, targetCompRect, parentRect, nudgeY) {
      const spaceAvailableUnder = parentRect.bottom - targetCompRect.bottom;
      const spaceAvailableAbove = targetCompRect.top - parentRect.top;
      const spaceRequired = ePopup.offsetHeight + nudgeY;
      if (spaceAvailableUnder > spaceRequired) {
        return "under";
      }
      if (spaceAvailableAbove > spaceRequired || spaceAvailableAbove > spaceAvailableUnder) {
        return "above";
      }
      return "under";
    }
    setAlignedStyles(ePopup, positioned) {
      const popupIdx = this.getPopupIndex(ePopup);
      if (popupIdx === -1) {
        return;
      }
      const popup = this.popupList[popupIdx];
      const { alignedToElement } = popup;
      if (!alignedToElement) {
        return;
      }
      const positions = ["right", "left", "over", "above", "under"];
      positions.forEach((position) => {
        alignedToElement.classList.remove(`ag-has-popup-positioned-${position}`);
        ePopup.classList.remove(`ag-popup-positioned-${position}`);
      });
      if (!positioned) {
        return;
      }
      alignedToElement.classList.add(`ag-has-popup-positioned-${positioned}`);
      ePopup.classList.add(`ag-popup-positioned-${positioned}`);
    }
    callPostProcessPopup(type, ePopup, eventSource, mouseEvent, column, rowNode) {
      const callback = this.gos.getCallback("postProcessPopup");
      if (callback) {
        const params = {
          column,
          rowNode,
          ePopup,
          type,
          eventSource,
          mouseEvent
        };
        callback(params);
      }
    }
    positionPopup(params) {
      const { ePopup, keepWithinBounds, nudgeX, nudgeY, skipObserver, updatePosition } = params;
      const lastSize = { width: 0, height: 0 };
      const updatePopupPosition = (fromResizeObserver = false) => {
        let { x, y } = updatePosition();
        if (fromResizeObserver && ePopup.clientWidth === lastSize.width && ePopup.clientHeight === lastSize.height) {
          return;
        }
        lastSize.width = ePopup.clientWidth;
        lastSize.height = ePopup.clientHeight;
        if (nudgeX) {
          x += nudgeX;
        }
        if (nudgeY) {
          y += nudgeY;
        }
        if (keepWithinBounds) {
          x = this.keepXYWithinBounds(
            ePopup,
            x,
            1
            /* horizontal */
          );
          y = this.keepXYWithinBounds(
            ePopup,
            y,
            0
            /* vertical */
          );
        }
        ePopup.style.left = `${x}px`;
        ePopup.style.top = `${y}px`;
        if (params.postProcessCallback) {
          params.postProcessCallback();
        }
      };
      updatePopupPosition();
      if (!skipObserver) {
        const resizeObserverDestroyFunc = this.resizeObserverService.observeResize(ePopup, () => updatePopupPosition(true));
        setTimeout(() => resizeObserverDestroyFunc(), PopupService.WAIT_FOR_POPUP_CONTENT_RESIZE);
      }
    }
    getActivePopups() {
      return this.popupList.map((popup) => popup.element);
    }
    getPopupList() {
      return this.popupList;
    }
    getParentRect() {
      const eDocument = this.gos.getDocument();
      let popupParent = this.getPopupParent();
      if (popupParent === eDocument.body) {
        popupParent = eDocument.documentElement;
      } else if (getComputedStyle(popupParent).position === "static") {
        popupParent = popupParent.offsetParent;
      }
      return getElementRectWithOffset(popupParent);
    }
    keepXYWithinBounds(ePopup, position, direction) {
      const isVertical = direction === 0;
      const sizeProperty = isVertical ? "clientHeight" : "clientWidth";
      const anchorProperty = isVertical ? "top" : "left";
      const offsetProperty = isVertical ? "offsetHeight" : "offsetWidth";
      const scrollPositionProperty = isVertical ? "scrollTop" : "scrollLeft";
      const eDocument = this.gos.getDocument();
      const docElement = eDocument.documentElement;
      const popupParent = this.getPopupParent();
      const parentRect = popupParent.getBoundingClientRect();
      const documentRect = eDocument.documentElement.getBoundingClientRect();
      const isBody = popupParent === eDocument.body;
      const offsetSize = ePopup[offsetProperty];
      const getSize = isVertical ? getAbsoluteHeight : getAbsoluteWidth;
      let sizeOfParent = isBody ? getSize(docElement) + docElement[scrollPositionProperty] : popupParent[sizeProperty];
      if (isBody) {
        sizeOfParent -= Math.abs(documentRect[anchorProperty] - parentRect[anchorProperty]);
      }
      const max = sizeOfParent - offsetSize;
      return Math.min(Math.max(position, 0), Math.abs(max));
    }
    addPopup(params) {
      const eDocument = this.gos.getDocument();
      const { eChild, ariaLabel, alwaysOnTop, positionCallback, anchorToElement } = params;
      if (!eDocument) {
        console.warn("AG Grid: could not find the document, document is empty");
        return { hideFunc: () => {
        } };
      }
      const pos = this.getPopupIndex(eChild);
      if (pos !== -1) {
        const popup = this.popupList[pos];
        return { hideFunc: popup.hideFunc };
      }
      this.initialisePopupPosition(eChild);
      const wrapperEl = this.createPopupWrapper(eChild, ariaLabel, !!alwaysOnTop);
      const removeListeners = this.addEventListenersToPopup(__spreadProps(__spreadValues({}, params), { wrapperEl }));
      if (positionCallback) {
        positionCallback();
      }
      this.addPopupToPopupList(eChild, wrapperEl, removeListeners, anchorToElement);
      return {
        hideFunc: removeListeners
      };
    }
    initialisePopupPosition(element) {
      const ePopupParent = this.getPopupParent();
      const ePopupParentRect = ePopupParent.getBoundingClientRect();
      if (!exists(element.style.top)) {
        element.style.top = `${ePopupParentRect.top * -1}px`;
      }
      if (!exists(element.style.left)) {
        element.style.left = `${ePopupParentRect.left * -1}px`;
      }
    }
    createPopupWrapper(element, ariaLabel, alwaysOnTop) {
      const ePopupParent = this.getPopupParent();
      const eWrapper = document.createElement("div");
      const { allThemes } = this.environment.getTheme();
      if (allThemes.length) {
        eWrapper.classList.add(...allThemes);
      }
      eWrapper.classList.add("ag-popup");
      element.classList.add(
        this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr",
        "ag-popup-child"
      );
      if (!element.hasAttribute("role")) {
        setAriaRole(element, "dialog");
      }
      setAriaLabel(element, ariaLabel);
      eWrapper.appendChild(element);
      ePopupParent.appendChild(eWrapper);
      if (alwaysOnTop) {
        this.setAlwaysOnTop(element, true);
      } else {
        this.bringPopupToFront(element);
      }
      return eWrapper;
    }
    handleThemeChange() {
      const { allThemes } = this.environment.getTheme();
      for (const popup of this.popupList) {
        for (const className of Array.from(popup.wrapper.classList)) {
          if (className.startsWith("ag-theme-")) {
            popup.wrapper.classList.remove(className);
          }
        }
        if (allThemes.length) {
          popup.wrapper.classList.add(...allThemes);
        }
      }
    }
    addEventListenersToPopup(params) {
      const eDocument = this.gos.getDocument();
      const ePopupParent = this.getPopupParent();
      const { wrapperEl, eChild: popupEl, closedCallback, afterGuiAttached, closeOnEsc, modal } = params;
      let popupHidden = false;
      const hidePopupOnKeyboardEvent = (event) => {
        if (!wrapperEl.contains(this.gos.getActiveDomElement())) {
          return;
        }
        const key = event.key;
        if (key === KeyCode.ESCAPE && !isStopPropagationForAgGrid(event)) {
          removeListeners({ keyboardEvent: event });
        }
      };
      const hidePopupOnMouseEvent = (event) => removeListeners({ mouseEvent: event });
      const hidePopupOnTouchEvent = (event) => removeListeners({ touchEvent: event });
      const removeListeners = (popupParams = {}) => {
        const { mouseEvent, touchEvent, keyboardEvent, forceHide } = popupParams;
        if (!forceHide && // we don't hide popup if the event was on the child, or any
        // children of this child
        (this.isEventFromCurrentPopup({ mouseEvent, touchEvent }, popupEl) || // this method should only be called once. the client can have different
        // paths, each one wanting to close, so this method may be called multiple times.
        popupHidden)) {
          return;
        }
        popupHidden = true;
        ePopupParent.removeChild(wrapperEl);
        eDocument.removeEventListener("keydown", hidePopupOnKeyboardEvent);
        eDocument.removeEventListener("mousedown", hidePopupOnMouseEvent);
        eDocument.removeEventListener("touchstart", hidePopupOnTouchEvent);
        eDocument.removeEventListener("contextmenu", hidePopupOnMouseEvent);
        this.eventService.removeEventListener(Events.EVENT_DRAG_STARTED, hidePopupOnMouseEvent);
        if (closedCallback) {
          closedCallback(mouseEvent || touchEvent || keyboardEvent);
        }
        this.removePopupFromPopupList(popupEl);
      };
      if (afterGuiAttached) {
        afterGuiAttached({ hidePopup: removeListeners });
      }
      window.setTimeout(() => {
        if (closeOnEsc) {
          eDocument.addEventListener("keydown", hidePopupOnKeyboardEvent);
        }
        if (modal) {
          eDocument.addEventListener("mousedown", hidePopupOnMouseEvent);
          this.eventService.addEventListener(Events.EVENT_DRAG_STARTED, hidePopupOnMouseEvent);
          eDocument.addEventListener("touchstart", hidePopupOnTouchEvent);
          eDocument.addEventListener("contextmenu", hidePopupOnMouseEvent);
        }
      }, 0);
      return removeListeners;
    }
    addPopupToPopupList(element, wrapperEl, removeListeners, anchorToElement) {
      this.popupList.push({
        element,
        wrapper: wrapperEl,
        hideFunc: removeListeners,
        instanceId: instanceIdSeq++,
        isAnchored: !!anchorToElement
      });
      if (anchorToElement) {
        this.setPopupPositionRelatedToElement(element, anchorToElement);
      }
    }
    getPopupIndex(el) {
      return this.popupList.findIndex((p2) => p2.element === el);
    }
    setPopupPositionRelatedToElement(popupEl, relativeElement) {
      const popupIndex = this.getPopupIndex(popupEl);
      if (popupIndex === -1) {
        return;
      }
      const popup = this.popupList[popupIndex];
      if (popup.stopAnchoringPromise) {
        popup.stopAnchoringPromise.then((destroyFunc) => destroyFunc && destroyFunc());
      }
      popup.stopAnchoringPromise = void 0;
      popup.isAnchored = false;
      if (!relativeElement) {
        return;
      }
      const destroyPositionTracker = this.keepPopupPositionedRelativeTo({
        element: relativeElement,
        ePopup: popupEl,
        hidePopup: popup.hideFunc
      });
      popup.stopAnchoringPromise = destroyPositionTracker;
      popup.isAnchored = true;
      return destroyPositionTracker;
    }
    removePopupFromPopupList(element) {
      this.setAlignedStyles(element, null);
      this.setPopupPositionRelatedToElement(element, null);
      this.popupList = this.popupList.filter((p2) => p2.element !== element);
    }
    keepPopupPositionedRelativeTo(params) {
      const eParent = this.getPopupParent();
      const parentRect = eParent.getBoundingClientRect();
      const { element, ePopup } = params;
      const sourceRect = element.getBoundingClientRect();
      const initialDiffTop = parentRect.top - sourceRect.top;
      const initialDiffLeft = parentRect.left - sourceRect.left;
      let lastDiffTop = initialDiffTop;
      let lastDiffLeft = initialDiffLeft;
      const topPx = ePopup.style.top;
      const top = parseInt(topPx.substring(0, topPx.length - 1), 10);
      const leftPx = ePopup.style.left;
      const left = parseInt(leftPx.substring(0, leftPx.length - 1), 10);
      return new AgPromise((resolve2) => {
        this.getFrameworkOverrides().setInterval(() => {
          const pRect = eParent.getBoundingClientRect();
          const sRect = element.getBoundingClientRect();
          const elementNotInDom = sRect.top == 0 && sRect.left == 0 && sRect.height == 0 && sRect.width == 0;
          if (elementNotInDom) {
            params.hidePopup();
            return;
          }
          const currentDiffTop = pRect.top - sRect.top;
          if (currentDiffTop != lastDiffTop) {
            const newTop = this.keepXYWithinBounds(
              ePopup,
              top + initialDiffTop - currentDiffTop,
              0
              /* vertical */
            );
            ePopup.style.top = `${newTop}px`;
          }
          lastDiffTop = currentDiffTop;
          const currentDiffLeft = pRect.left - sRect.left;
          if (currentDiffLeft != lastDiffLeft) {
            const newLeft = this.keepXYWithinBounds(
              ePopup,
              left + initialDiffLeft - currentDiffLeft,
              1
              /* horizontal */
            );
            ePopup.style.left = `${newLeft}px`;
          }
          lastDiffLeft = currentDiffLeft;
        }, 200).then((intervalId) => {
          const result = () => {
            if (intervalId != null) {
              window.clearInterval(intervalId);
            }
          };
          resolve2(result);
        });
      });
    }
    hasAnchoredPopup() {
      return this.popupList.some((popup) => popup.isAnchored);
    }
    isEventFromCurrentPopup(params, target) {
      const { mouseEvent, touchEvent } = params;
      const event = mouseEvent ? mouseEvent : touchEvent;
      if (!event) {
        return false;
      }
      const indexOfThisChild = this.getPopupIndex(target);
      if (indexOfThisChild === -1) {
        return false;
      }
      for (let i = indexOfThisChild; i < this.popupList.length; i++) {
        const popup = this.popupList[i];
        if (isElementInEventPath(popup.element, event)) {
          return true;
        }
      }
      return this.isElementWithinCustomPopup(event.target);
    }
    isElementWithinCustomPopup(el) {
      const eDocument = this.gos.getDocument();
      while (el && el !== eDocument.body) {
        if (el.classList.contains("ag-custom-component-popup") || el.parentElement === null) {
          return true;
        }
        el = el.parentElement;
      }
      return false;
    }
    getWrapper(ePopup) {
      while (!ePopup.classList.contains("ag-popup") && ePopup.parentElement) {
        ePopup = ePopup.parentElement;
      }
      return ePopup.classList.contains("ag-popup") ? ePopup : null;
    }
    setAlwaysOnTop(ePopup, alwaysOnTop) {
      const eWrapper = this.getWrapper(ePopup);
      if (!eWrapper) {
        return;
      }
      eWrapper.classList.toggle("ag-always-on-top", !!alwaysOnTop);
      if (alwaysOnTop) {
        this.bringPopupToFront(eWrapper);
      }
    }
    bringPopupToFront(ePopup) {
      const parent = this.getPopupParent();
      const popupList = Array.prototype.slice.call(parent.querySelectorAll(".ag-popup"));
      const popupLen = popupList.length;
      const alwaysOnTopList = Array.prototype.slice.call(parent.querySelectorAll(".ag-popup.ag-always-on-top"));
      const onTopLength = alwaysOnTopList.length;
      const eWrapper = this.getWrapper(ePopup);
      if (!eWrapper || popupLen <= 1 || !parent.contains(ePopup)) {
        return;
      }
      const pos = popupList.indexOf(eWrapper);
      const innerEls = eWrapper.querySelectorAll("div");
      const innerElsScrollMap = [];
      innerEls.forEach((el) => {
        if (el.scrollTop !== 0) {
          innerElsScrollMap.push([el, el.scrollTop]);
        }
      });
      if (onTopLength) {
        const isPopupAlwaysOnTop = eWrapper.classList.contains("ag-always-on-top");
        if (isPopupAlwaysOnTop) {
          if (pos !== popupLen - 1) {
            last(alwaysOnTopList).insertAdjacentElement("afterend", eWrapper);
          }
        } else if (pos !== popupLen - onTopLength - 1) {
          alwaysOnTopList[0].insertAdjacentElement("beforebegin", eWrapper);
        }
      } else if (pos !== popupLen - 1) {
        last(popupList).insertAdjacentElement("afterend", eWrapper);
      }
      while (innerElsScrollMap.length) {
        const currentEl = innerElsScrollMap.pop();
        currentEl[0].scrollTop = currentEl[1];
      }
    }
  };
  PopupService.WAIT_FOR_POPUP_CONTENT_RESIZE = 200;
  __decorateClass([
    Autowired("focusService")
  ], PopupService.prototype, "focusService", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], PopupService.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("resizeObserverService")
  ], PopupService.prototype, "resizeObserverService", 2);
  __decorateClass([
    PostConstruct
  ], PopupService.prototype, "postConstruct", 1);
  PopupService = __decorateClass([
    Bean("popupService")
  ], PopupService);
  var AgAutocompleteRow = class extends Component {
    constructor() {
      super(
        /* html */
        `
        <div class="ag-autocomplete-row" role="presentation">
            <div class="ag-autocomplete-row-label"></div>
        </div>`
      );
      this.hasHighlighting = false;
    }
    setState(value, selected) {
      this.value = value;
      this.render();
      this.updateSelected(selected);
    }
    updateSelected(selected) {
      this.addOrRemoveCssClass("ag-autocomplete-row-selected", selected);
    }
    setSearchString(searchString) {
      var _a;
      let keepHighlighting = false;
      if (exists(searchString)) {
        const index = (_a = this.value) == null ? void 0 : _a.toLocaleLowerCase().indexOf(searchString.toLocaleLowerCase());
        if (index >= 0) {
          keepHighlighting = true;
          this.hasHighlighting = true;
          const highlightEndIndex = index + searchString.length;
          const startPart = escapeString(this.value.slice(0, index));
          const highlightedPart = escapeString(this.value.slice(index, highlightEndIndex));
          const endPart = escapeString(this.value.slice(highlightEndIndex));
          this.getGui().lastElementChild.innerHTML = `${startPart}<b>${highlightedPart}</b>${endPart}`;
        }
      }
      if (!keepHighlighting && this.hasHighlighting) {
        this.hasHighlighting = false;
        this.render();
      }
    }
    render() {
      var _a;
      this.getGui().lastElementChild.innerHTML = (_a = escapeString(this.value)) != null ? _a : "&nbsp;";
    }
  };
  var _AgAutocompleteList = class _AgAutocompleteList2 extends PopupComponent {
    constructor(params) {
      super(_AgAutocompleteList2.TEMPLATE);
      this.params = params;
      this.searchString = "";
    }
    destroy() {
      super.destroy();
    }
    init() {
      this.autocompleteEntries = this.params.autocompleteEntries;
      this.virtualList = this.createManagedBean(new VirtualList({ cssIdentifier: "autocomplete" }));
      this.virtualList.setComponentCreator(this.createRowComponent.bind(this));
      this.eList.appendChild(this.virtualList.getGui());
      this.virtualList.setModel({
        getRowCount: () => this.autocompleteEntries.length,
        getRow: (index) => this.autocompleteEntries[index]
      });
      const virtualListGui = this.virtualList.getGui();
      this.addManagedListener(virtualListGui, "click", () => this.params.onConfirmed());
      this.addManagedListener(virtualListGui, "mousemove", this.onMouseMove.bind(this));
      this.addManagedListener(virtualListGui, "mousedown", (e) => e.preventDefault());
      this.setSelectedValue(0);
    }
    onNavigationKeyDown(event, key) {
      event.preventDefault();
      const oldIndex = this.autocompleteEntries.indexOf(this.selectedValue);
      const newIndex = key === KeyCode.UP ? oldIndex - 1 : oldIndex + 1;
      this.checkSetSelectedValue(newIndex);
    }
    setSearch(searchString) {
      this.searchString = searchString;
      if (exists(searchString)) {
        this.runSearch();
      } else {
        this.autocompleteEntries = this.params.autocompleteEntries;
        this.virtualList.refresh();
        this.checkSetSelectedValue(0);
      }
      this.updateSearchInList();
    }
    runContainsSearch(searchString, searchStrings) {
      let topMatch;
      let topMatchStartsWithSearchString = false;
      const lowerCaseSearchString = searchString.toLocaleLowerCase();
      const allMatches = searchStrings.filter((string) => {
        const lowerCaseString = string.toLocaleLowerCase();
        const index = lowerCaseString.indexOf(lowerCaseSearchString);
        const startsWithSearchString = index === 0;
        const isMatch = index >= 0;
        if (isMatch && (!topMatch || !topMatchStartsWithSearchString && startsWithSearchString || topMatchStartsWithSearchString === startsWithSearchString && string.length < topMatch.length)) {
          topMatch = string;
          topMatchStartsWithSearchString = startsWithSearchString;
        }
        return isMatch;
      });
      if (!topMatch && allMatches.length) {
        topMatch = allMatches[0];
      }
      return { topMatch, allMatches };
    }
    runSearch() {
      var _a, _b;
      const { autocompleteEntries } = this.params;
      const searchStrings = autocompleteEntries.map((v) => {
        var _a2;
        return (_a2 = v.displayValue) != null ? _a2 : v.key;
      });
      let matchingStrings;
      let topSuggestion;
      if (this.params.useFuzzySearch) {
        matchingStrings = fuzzySuggestions(this.searchString, searchStrings, true).values;
        topSuggestion = matchingStrings.length ? matchingStrings[0] : void 0;
      } else {
        const containsMatches = this.runContainsSearch(this.searchString, searchStrings);
        matchingStrings = containsMatches.allMatches;
        topSuggestion = containsMatches.topMatch;
      }
      let filteredEntries = autocompleteEntries.filter(({ key, displayValue }) => matchingStrings.includes(displayValue != null ? displayValue : key));
      if (!filteredEntries.length && this.selectedValue && ((_b = (_a = this.params) == null ? void 0 : _a.forceLastSelection) == null ? void 0 : _b.call(_a, this.selectedValue, this.searchString))) {
        filteredEntries = [this.selectedValue];
      }
      this.autocompleteEntries = filteredEntries;
      this.virtualList.refresh();
      if (!topSuggestion) {
        return;
      }
      const topSuggestionIndex = matchingStrings.indexOf(topSuggestion);
      this.checkSetSelectedValue(topSuggestionIndex);
    }
    updateSearchInList() {
      this.virtualList.forEachRenderedRow((row) => row.setSearchString(this.searchString));
    }
    checkSetSelectedValue(index) {
      if (index >= 0 && index < this.autocompleteEntries.length) {
        this.setSelectedValue(index);
      }
    }
    setSelectedValue(index) {
      const value = this.autocompleteEntries[index];
      if (this.selectedValue === value) {
        return;
      }
      this.selectedValue = value;
      this.virtualList.ensureIndexVisible(index);
      this.virtualList.forEachRenderedRow((cmp, idx) => {
        cmp.updateSelected(index === idx);
      });
    }
    createRowComponent(value) {
      var _a;
      const row = new AgAutocompleteRow();
      this.getContext().createBean(row);
      row.setState((_a = value.displayValue) != null ? _a : value.key, value === this.selectedValue);
      return row;
    }
    onMouseMove(mouseEvent) {
      const rect = this.virtualList.getGui().getBoundingClientRect();
      const scrollTop = this.virtualList.getScrollTop();
      const mouseY = mouseEvent.clientY - rect.top + scrollTop;
      const row = Math.floor(mouseY / this.virtualList.getRowHeight());
      this.checkSetSelectedValue(row);
    }
    afterGuiAttached() {
      this.virtualList.refresh();
    }
    getSelectedValue() {
      var _a;
      if (!this.autocompleteEntries.length) {
        return null;
      }
      ;
      return (_a = this.selectedValue) != null ? _a : null;
    }
  };
  _AgAutocompleteList.TEMPLATE = /* html */
  `<div class="ag-autocomplete-list-popup">
            <div ref="eList" class="ag-autocomplete-list"></div>
        <div>`;
  __decorateClass([
    RefSelector("eList")
  ], _AgAutocompleteList.prototype, "eList", 2);
  __decorateClass([
    PostConstruct
  ], _AgAutocompleteList.prototype, "init", 1);
  var AgAutocompleteList = _AgAutocompleteList;
  var _AgAutocomplete = class _AgAutocomplete2 extends Component {
    constructor() {
      super(
        /* html */
        `
            <div class="ag-autocomplete" role="presentation">
                <ag-input-text-field ref="eAutocompleteInput"></ag-input-text-field>
            </div>`
      );
      this.isListOpen = false;
      this.lastPosition = 0;
      this.valid = true;
    }
    postConstruct() {
      this.eAutocompleteInput.onValueChange((value) => this.onValueChanged(value));
      this.eAutocompleteInput.getInputElement().setAttribute("autocomplete", "off");
      this.addGuiEventListener("keydown", this.onKeyDown.bind(this));
      this.addGuiEventListener("click", this.updatePositionAndList.bind(this));
      this.addDestroyFunc(() => {
        this.destroyBean(this.autocompleteList);
      });
      this.addGuiEventListener("focusout", () => this.onFocusOut());
    }
    onValueChanged(value) {
      const parsedValue = makeNull(value);
      this.updateValue(parsedValue);
      this.updateAutocompleteList(parsedValue);
    }
    updateValue(value) {
      this.updateLastPosition();
      this.dispatchEvent({
        type: _AgAutocomplete2.EVENT_VALUE_CHANGED,
        value
      });
      this.validate(value);
    }
    updateAutocompleteList(value) {
      var _a, _b, _c, _d;
      const autocompleteListParams = (_b = (_a = this.listGenerator) == null ? void 0 : _a.call(this, value, this.lastPosition)) != null ? _b : { enabled: false };
      if (!autocompleteListParams.type || autocompleteListParams.type !== ((_c = this.autocompleteListParams) == null ? void 0 : _c.type)) {
        if (this.isListOpen) {
          this.closeList();
        }
      }
      this.autocompleteListParams = autocompleteListParams;
      if ((_d = this.autocompleteListParams) == null ? void 0 : _d.enabled) {
        if (!this.isListOpen) {
          this.openList();
        }
        const { searchString } = this.autocompleteListParams;
        this.autocompleteList.setSearch(searchString != null ? searchString : "");
      } else {
        if (this.isListOpen) {
          this.closeList();
        }
      }
    }
    onKeyDown(event) {
      const key = event.key;
      this.updateLastPosition();
      switch (key) {
        case KeyCode.ENTER:
          this.onEnterKeyDown(event);
          break;
        case KeyCode.TAB:
          this.onTabKeyDown(event);
          break;
        case KeyCode.DOWN:
        case KeyCode.UP:
          this.onUpDownKeyDown(event, key);
          break;
        case KeyCode.LEFT:
        case KeyCode.RIGHT:
        case KeyCode.PAGE_HOME:
        case KeyCode.PAGE_END:
          setTimeout(() => {
            this.updatePositionAndList();
          });
          break;
        case KeyCode.ESCAPE:
          this.onEscapeKeyDown(event);
          break;
        case KeyCode.SPACE:
          if (event.ctrlKey && !this.isListOpen) {
            event.preventDefault();
            this.forceOpenList();
          }
          break;
      }
    }
    confirmSelection() {
      var _a;
      const selectedValue = (_a = this.autocompleteList) == null ? void 0 : _a.getSelectedValue();
      if (selectedValue) {
        this.closeList();
        this.dispatchEvent({
          type: _AgAutocomplete2.EVENT_OPTION_SELECTED,
          value: this.getValue(),
          position: this.lastPosition,
          updateEntry: selectedValue,
          autocompleteType: this.autocompleteListParams.type
        });
      }
    }
    onTabKeyDown(event) {
      if (this.isListOpen) {
        event.preventDefault();
        event.stopPropagation();
        this.confirmSelection();
      }
    }
    onEnterKeyDown(event) {
      event.preventDefault();
      if (this.isListOpen) {
        this.confirmSelection();
      } else {
        this.onCompleted();
      }
    }
    onUpDownKeyDown(event, key) {
      var _a;
      event.preventDefault();
      if (!this.isListOpen) {
        this.forceOpenList();
      } else {
        (_a = this.autocompleteList) == null ? void 0 : _a.onNavigationKeyDown(event, key);
      }
    }
    onEscapeKeyDown(event) {
      if (this.isListOpen) {
        event.preventDefault();
        event.stopPropagation();
        this.closeList();
        this.setCaret(this.lastPosition, true);
      }
    }
    onFocusOut() {
      if (this.isListOpen) {
        this.closeList();
      }
    }
    updatePositionAndList() {
      var _a;
      this.updateLastPosition();
      this.updateAutocompleteList((_a = this.eAutocompleteInput.getValue()) != null ? _a : null);
    }
    setCaret(position, setFocus) {
      const eDocument = this.gos.getDocument();
      const activeEl = this.gos.getActiveDomElement();
      if (setFocus && (!activeEl || activeEl === eDocument.body)) {
        this.eAutocompleteInput.getFocusableElement().focus();
      }
      const eInput = this.eAutocompleteInput.getInputElement();
      eInput.setSelectionRange(position, position);
      if (position === eInput.value.length) {
        eInput.scrollLeft = eInput.scrollWidth;
      }
    }
    forceOpenList() {
      this.onValueChanged(this.eAutocompleteInput.getValue());
    }
    updateLastPosition() {
      var _a;
      this.lastPosition = (_a = this.eAutocompleteInput.getInputElement().selectionStart) != null ? _a : 0;
    }
    validate(value) {
      var _a;
      if (!this.validator) {
        return;
      }
      this.validationMessage = this.validator(value);
      this.eAutocompleteInput.getInputElement().setCustomValidity((_a = this.validationMessage) != null ? _a : "");
      this.valid = !this.validationMessage;
      this.dispatchEvent({
        type: _AgAutocomplete2.EVENT_VALID_CHANGED,
        isValid: this.valid,
        validationMessage: this.validationMessage
      });
    }
    openList() {
      this.isListOpen = true;
      this.autocompleteList = this.createBean(new AgAutocompleteList({
        autocompleteEntries: this.autocompleteListParams.entries,
        onConfirmed: () => this.confirmSelection(),
        forceLastSelection: this.forceLastSelection
      }));
      const ePopupGui = this.autocompleteList.getGui();
      const positionParams = {
        ePopup: ePopupGui,
        type: "autocomplete",
        eventSource: this.getGui(),
        position: "under",
        alignSide: this.gos.get("enableRtl") ? "right" : "left",
        keepWithinBounds: true
      };
      const addPopupRes = this.popupService.addPopup({
        eChild: ePopupGui,
        anchorToElement: this.getGui(),
        positionCallback: () => this.popupService.positionPopupByComponent(positionParams),
        ariaLabel: this.listAriaLabel
      });
      this.hidePopup = addPopupRes.hideFunc;
      this.autocompleteList.afterGuiAttached();
    }
    closeList() {
      this.isListOpen = false;
      this.hidePopup();
      this.destroyBean(this.autocompleteList);
      this.autocompleteList = null;
    }
    onCompleted() {
      if (this.isListOpen) {
        this.closeList();
      }
      this.dispatchEvent({
        type: _AgAutocomplete2.EVENT_VALUE_CONFIRMED,
        value: this.getValue(),
        isValid: this.isValid()
      });
    }
    getValue() {
      return makeNull(this.eAutocompleteInput.getValue());
    }
    setInputPlaceholder(placeholder) {
      this.eAutocompleteInput.setInputPlaceholder(placeholder);
      return this;
    }
    setInputAriaLabel(label) {
      this.eAutocompleteInput.setInputAriaLabel(label);
      return this;
    }
    setListAriaLabel(label) {
      this.listAriaLabel = label;
      return this;
    }
    setListGenerator(listGenerator) {
      this.listGenerator = listGenerator;
      return this;
    }
    setValidator(validator) {
      this.validator = validator;
      return this;
    }
    isValid() {
      return this.valid;
    }
    setValue(params) {
      const { value, position, silent, updateListOnlyIfOpen, restoreFocus } = params;
      this.eAutocompleteInput.setValue(value, true);
      this.setCaret(position != null ? position : this.lastPosition, restoreFocus);
      if (!silent) {
        this.updateValue(value);
      }
      if (!updateListOnlyIfOpen || this.isListOpen) {
        this.updateAutocompleteList(value);
      }
    }
    setForceLastSelection(forceLastSelection) {
      this.forceLastSelection = forceLastSelection;
      return this;
    }
    setInputDisabled(disabled) {
      this.eAutocompleteInput.setDisabled(disabled);
      return this;
    }
  };
  _AgAutocomplete.EVENT_VALUE_CHANGED = "eventValueChanged";
  _AgAutocomplete.EVENT_VALUE_CONFIRMED = "eventValueConfirmed";
  _AgAutocomplete.EVENT_OPTION_SELECTED = "eventOptionSelected";
  _AgAutocomplete.EVENT_VALID_CHANGED = "eventValidChanged";
  __decorateClass([
    Autowired("popupService")
  ], _AgAutocomplete.prototype, "popupService", 2);
  __decorateClass([
    RefSelector("eAutocompleteInput")
  ], _AgAutocomplete.prototype, "eAutocompleteInput", 2);
  __decorateClass([
    PostConstruct
  ], _AgAutocomplete.prototype, "postConstruct", 1);
  var AgAutocomplete = _AgAutocomplete;
  var _PillDragComp = class _PillDragComp2 extends Component {
    constructor(dragSourceDropTarget, ghost, horizontal, template) {
      super();
      this.dragSourceDropTarget = dragSourceDropTarget;
      this.ghost = ghost;
      this.horizontal = horizontal;
      this.template = template;
    }
    init() {
      var _a;
      this.setTemplate((_a = this.template) != null ? _a : _PillDragComp2.TEMPLATE);
      const eGui = this.getGui();
      this.addElementClasses(eGui);
      this.addElementClasses(this.eDragHandle, "drag-handle");
      this.addElementClasses(this.eText, "text");
      this.addElementClasses(this.eButton, "button");
      this.eDragHandle.appendChild(createIconNoSpan("columnDrag", this.gos));
      this.eButton.appendChild(createIconNoSpan("cancel", this.gos));
      this.setupComponents();
      if (!this.ghost && this.isDraggable()) {
        this.addDragSource();
      }
      this.setupAria();
      this.setupTooltip();
      this.activateTabIndex();
      this.refreshDraggable();
    }
    isDraggable() {
      return true;
    }
    refreshDraggable() {
      this.eDragHandle.classList.toggle("ag-column-select-column-readonly", !this.isDraggable());
    }
    setupAria() {
      const translate = this.localeService.getLocaleTextFunc();
      const ariaInstructions = [this.getAriaDisplayName()];
      this.addAdditionalAriaInstructions(ariaInstructions, translate);
      setAriaLabel(this.getGui(), ariaInstructions.join(". "));
    }
    addAdditionalAriaInstructions(ariaInstructions, translate) {
      if (this.isRemovable()) {
        const deleteAria = translate("ariaDropZoneColumnComponentDescription", "Press DELETE to remove");
        ariaInstructions.push(deleteAria);
      }
    }
    setupTooltip() {
      const refresh = () => {
        const newTooltipText = this.getTooltip();
        this.setTooltip({ newTooltipText });
      };
      refresh();
      this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, refresh);
    }
    getDragSourceId() {
      return void 0;
    }
    getDefaultIconName() {
      return DragAndDropService.ICON_NOT_ALLOWED;
    }
    addDragSource() {
      const { dragAndDropService, eDragHandle } = this;
      const getDragItem = this.createGetDragItem();
      const defaultIconName = this.getDefaultIconName();
      const dragSource = {
        type: this.getDragSourceType(),
        sourceId: this.getDragSourceId(),
        eElement: eDragHandle,
        getDefaultIconName: () => defaultIconName,
        getDragItem,
        dragItemName: this.getDisplayName()
      };
      dragAndDropService.addDragSource(dragSource, true);
      this.addDestroyFunc(() => dragAndDropService.removeDragSource(dragSource));
    }
    setupComponents() {
      this.setTextValue();
      this.setupRemove();
      if (this.ghost) {
        this.addCssClass("ag-column-drop-cell-ghost");
      }
    }
    isRemovable() {
      return true;
    }
    refreshRemove() {
      setDisplayed(this.eButton, this.isRemovable());
    }
    setupRemove() {
      this.refreshRemove();
      const agEvent = { type: _PillDragComp2.EVENT_COLUMN_REMOVE };
      this.addGuiEventListener("keydown", (e) => this.onKeyDown(e));
      this.addManagedListener(this.eButton, "click", (mouseEvent) => {
        this.dispatchEvent(agEvent);
        mouseEvent.stopPropagation();
      });
      const touchListener = new TouchListener(this.eButton);
      this.addManagedListener(touchListener, TouchListener.EVENT_TAP, () => {
        this.dispatchEvent(agEvent);
      });
      this.addDestroyFunc(touchListener.destroy.bind(touchListener));
    }
    onKeyDown(e) {
      const isDelete = e.key === KeyCode.DELETE;
      if (isDelete) {
        if (this.isRemovable()) {
          e.preventDefault();
          this.dispatchEvent({ type: _PillDragComp2.EVENT_COLUMN_REMOVE });
        }
      }
    }
    getDisplayValue() {
      return this.getDisplayName();
    }
    setTextValue() {
      const displayValue = this.getDisplayValue();
      const displayValueSanitised = escapeString(displayValue);
      this.eText.innerHTML = displayValueSanitised;
    }
    addElementClasses(el, suffix) {
      suffix = suffix ? `-${suffix}` : "";
      const direction = this.horizontal ? "horizontal" : "vertical";
      el.classList.add(`ag-column-drop-cell${suffix}`, `ag-column-drop-${direction}-cell${suffix}`);
    }
    destroy() {
      super.destroy();
      this.dragSourceDropTarget = null;
    }
  };
  _PillDragComp.EVENT_COLUMN_REMOVE = "columnRemove";
  _PillDragComp.TEMPLATE = /* html */
  `<span role="option">
          <span ref="eDragHandle" class="ag-drag-handle ag-column-drop-cell-drag-handle" role="presentation"></span>
          <span ref="eText" class="ag-column-drop-cell-text" aria-hidden="true"></span>
          <span ref="eButton" class="ag-column-drop-cell-button" role="presentation"></span>
        </span>`;
  __decorateClass([
    Autowired("dragAndDropService")
  ], _PillDragComp.prototype, "dragAndDropService", 2);
  __decorateClass([
    RefSelector("eText")
  ], _PillDragComp.prototype, "eText", 2);
  __decorateClass([
    RefSelector("eDragHandle")
  ], _PillDragComp.prototype, "eDragHandle", 2);
  __decorateClass([
    RefSelector("eButton")
  ], _PillDragComp.prototype, "eButton", 2);
  __decorateClass([
    PostConstruct
  ], _PillDragComp.prototype, "init", 1);
  var PillDragComp = _PillDragComp;
  var _PillDropZonePanel = class _PillDropZonePanel2 extends Component {
    constructor(horizontal) {
      super(
        /* html */
        `<div class="ag-unselectable" role="presentation"></div>`
      );
      this.horizontal = horizontal;
      this.state = _PillDropZonePanel2.STATE_NOT_DRAGGING;
      this.guiDestroyFunctions = [];
      this.childPillComponents = [];
      this.resizeEnabled = false;
      this.addElementClasses(this.getGui());
      this.ePillDropList = document.createElement("div");
      this.addElementClasses(this.ePillDropList, "list");
      setAriaRole(this.ePillDropList, "listbox");
    }
    isHorizontal() {
      return this.horizontal;
    }
    toggleResizable(resizable) {
      this.positionableFeature.setResizable(resizable ? { bottom: true } : false);
      this.resizeEnabled = resizable;
    }
    isSourceEventFromTarget(draggingEvent) {
      const { dropZoneTarget, dragSource } = draggingEvent;
      return dropZoneTarget.contains(dragSource.eElement);
    }
    destroy() {
      this.destroyGui();
      super.destroy();
    }
    destroyGui() {
      this.guiDestroyFunctions.forEach((func) => func());
      this.guiDestroyFunctions.length = 0;
      this.childPillComponents.length = 0;
      clearElement(this.getGui());
      clearElement(this.ePillDropList);
    }
    init(params) {
      this.params = params != null ? params : {};
      this.createManagedBean(new ManagedFocusFeature(
        this.getFocusableElement(),
        {
          handleKeyDown: this.handleKeyDown.bind(this)
        }
      ));
      this.setupDropTarget();
      this.positionableFeature = new PositionableFeature(this.getGui(), { minHeight: 100 });
      this.createManagedBean(this.positionableFeature);
      this.refreshGui();
      setAriaLabel(this.ePillDropList, this.getAriaLabel());
    }
    handleKeyDown(e) {
      const isVertical = !this.horizontal;
      let isNext = e.key === KeyCode.DOWN;
      let isPrevious = e.key === KeyCode.UP;
      if (!isVertical) {
        const isRtl = this.gos.get("enableRtl");
        isNext = !isRtl && e.key === KeyCode.RIGHT || isRtl && e.key === KeyCode.LEFT;
        isPrevious = !isRtl && e.key === KeyCode.LEFT || isRtl && e.key === KeyCode.RIGHT;
      }
      if (!isNext && !isPrevious) {
        return;
      }
      const el = this.focusService.findNextFocusableElement(
        this.getFocusableElement(),
        false,
        isPrevious
      );
      if (el) {
        e.preventDefault();
        el.focus();
      }
    }
    addElementClasses(el, suffix) {
      suffix = suffix ? `-${suffix}` : "";
      const direction = this.horizontal ? "horizontal" : "vertical";
      el.classList.add(`ag-column-drop${suffix}`, `ag-column-drop-${direction}${suffix}`);
    }
    setupDropTarget() {
      this.dropTarget = {
        getContainer: this.getGui.bind(this),
        getIconName: this.getIconName.bind(this),
        onDragging: this.onDragging.bind(this),
        onDragEnter: this.onDragEnter.bind(this),
        onDragLeave: this.onDragLeave.bind(this),
        onDragStop: this.onDragStop.bind(this),
        isInterestedIn: this.isInterestedIn.bind(this)
      };
      this.dragAndDropService.addDropTarget(this.dropTarget);
    }
    minimumAllowedNewInsertIndex() {
      return 0;
    }
    checkInsertIndex(draggingEvent) {
      const newIndex = this.getNewInsertIndex(draggingEvent);
      if (newIndex < 0) {
        return false;
      }
      const minimumAllowedIndex = this.minimumAllowedNewInsertIndex();
      const newAdjustedIndex = Math.max(minimumAllowedIndex, newIndex);
      const changed = newAdjustedIndex !== this.insertIndex;
      if (changed) {
        this.insertIndex = newAdjustedIndex;
      }
      return changed;
    }
    getNewInsertIndex(draggingEvent) {
      const mouseEvent = draggingEvent.event;
      const mouseLocation = this.horizontal ? mouseEvent.clientX : mouseEvent.clientY;
      const boundsList = this.childPillComponents.map((comp) => comp.getGui().getBoundingClientRect());
      const hoveredIndex = boundsList.findIndex((rect) => this.horizontal ? rect.right > mouseLocation && rect.left < mouseLocation : rect.top < mouseLocation && rect.bottom > mouseLocation);
      if (hoveredIndex === -1) {
        const enableRtl = this.gos.get("enableRtl");
        const isLast = boundsList.every((rect) => mouseLocation > (this.horizontal ? rect.right : rect.bottom));
        if (isLast) {
          return enableRtl && this.horizontal ? 0 : this.childPillComponents.length;
        }
        const isFirst = boundsList.every((rect) => mouseLocation < (this.horizontal ? rect.left : rect.top));
        if (isFirst) {
          return enableRtl && this.horizontal ? this.childPillComponents.length : 0;
        }
        return this.insertIndex;
      }
      if (this.insertIndex <= hoveredIndex) {
        return hoveredIndex + 1;
      }
      return hoveredIndex;
    }
    checkDragStartedBySelf(draggingEvent) {
      if (this.state !== _PillDropZonePanel2.STATE_NOT_DRAGGING) {
        return;
      }
      this.state = _PillDropZonePanel2.STATE_REARRANGE_ITEMS;
      this.potentialDndItems = this.getItems(draggingEvent.dragSource.getDragItem());
      this.refreshGui();
      this.checkInsertIndex(draggingEvent);
      this.refreshGui();
    }
    onDragging(draggingEvent) {
      this.checkDragStartedBySelf(draggingEvent);
      if (this.checkInsertIndex(draggingEvent)) {
        this.refreshGui();
      }
    }
    handleDragEnterEnd(draggingEvent) {
    }
    onDragEnter(draggingEvent) {
      const dragItems = this.getItems(draggingEvent.dragSource.getDragItem());
      this.state = _PillDropZonePanel2.STATE_NEW_ITEMS_IN;
      const goodDragItems = dragItems.filter((item) => this.isItemDroppable(item, draggingEvent));
      const alreadyPresent = goodDragItems.every((item) => this.childPillComponents.map((cmp) => cmp.getItem()).indexOf(item) !== -1);
      if (goodDragItems.length === 0) {
        return;
      }
      this.potentialDndItems = goodDragItems;
      if (alreadyPresent) {
        this.state = _PillDropZonePanel2.STATE_NOT_DRAGGING;
        return;
      }
      this.handleDragEnterEnd(draggingEvent);
      this.checkInsertIndex(draggingEvent);
      this.refreshGui();
    }
    isPotentialDndItems() {
      return existsAndNotEmpty(this.potentialDndItems);
    }
    handleDragLeaveEnd(draggingEvent) {
    }
    onDragLeave(draggingEvent) {
      if (this.state === _PillDropZonePanel2.STATE_REARRANGE_ITEMS) {
        const items = this.getItems(draggingEvent.dragSource.getDragItem());
        this.removeItems(items);
      }
      if (this.isPotentialDndItems()) {
        this.handleDragLeaveEnd(draggingEvent);
        this.potentialDndItems = [];
        this.refreshGui();
      }
      this.state = _PillDropZonePanel2.STATE_NOT_DRAGGING;
    }
    refreshOnDragStop() {
      return true;
    }
    onDragStop() {
      if (this.isPotentialDndItems()) {
        let success = false;
        if (this.state === _PillDropZonePanel2.STATE_NEW_ITEMS_IN) {
          this.addItems(this.potentialDndItems);
          success = true;
        } else {
          success = this.rearrangeItems(this.potentialDndItems);
        }
        this.potentialDndItems = [];
        if (this.refreshOnDragStop() || !success) {
          this.refreshGui();
        }
      }
      this.state = _PillDropZonePanel2.STATE_NOT_DRAGGING;
    }
    removeItems(itemsToRemove) {
      const newItemList = this.getExistingItems().filter((item) => !includes(itemsToRemove, item));
      this.updateItems(newItemList);
    }
    addItems(itemsToAdd) {
      if (!itemsToAdd) {
        return;
      }
      const newItemList = this.getExistingItems().slice();
      const itemsToAddNoDuplicates = itemsToAdd.filter((item) => newItemList.indexOf(item) < 0);
      insertArrayIntoArray(newItemList, itemsToAddNoDuplicates, this.insertIndex);
      this.updateItems(newItemList);
    }
    addItem(item) {
      this.insertIndex = this.getExistingItems().length;
      this.addItems([item]);
      this.refreshGui();
    }
    rearrangeItems(itemsToAdd) {
      const newItemList = this.getNonGhostItems().slice();
      insertArrayIntoArray(newItemList, itemsToAdd, this.insertIndex);
      if (areEqual(newItemList, this.getExistingItems())) {
        return false;
      }
      this.updateItems(newItemList);
      return true;
    }
    refreshGui() {
      const scrollTop = this.ePillDropList.scrollTop;
      const resizeEnabled = this.resizeEnabled;
      const focusedIndex = this.getFocusedItem();
      let alternateElement = this.focusService.findNextFocusableElement();
      if (!alternateElement) {
        alternateElement = this.focusService.findNextFocusableElement(void 0, false, true);
      }
      this.toggleResizable(false);
      this.destroyGui();
      this.addIconAndTitleToGui();
      this.addEmptyMessageToGui();
      this.addItemsToGui();
      if (!this.isHorizontal()) {
        this.ePillDropList.scrollTop = scrollTop;
      }
      if (resizeEnabled) {
        this.toggleResizable(resizeEnabled);
      }
      if (this.focusService.isKeyboardMode()) {
        this.restoreFocus(focusedIndex, alternateElement);
      }
    }
    getFocusedItem() {
      const eGui = this.getGui();
      const activeElement = this.gos.getActiveDomElement();
      if (!eGui.contains(activeElement)) {
        return -1;
      }
      const items = Array.from(eGui.querySelectorAll(".ag-column-drop-cell"));
      return items.indexOf(activeElement);
    }
    restoreFocus(index, alternateElement) {
      const eGui = this.getGui();
      const items = Array.from(eGui.querySelectorAll(".ag-column-drop-cell"));
      if (index === -1) {
        return;
      }
      if (items.length === 0) {
        alternateElement.focus();
      }
      const indexToFocus = Math.min(items.length - 1, index);
      const el = items[indexToFocus];
      if (el) {
        el.focus();
      }
    }
    focusList(fromBottom) {
      const index = fromBottom ? this.childPillComponents.length - 1 : 0;
      this.restoreFocus(index, this.getFocusableElement());
    }
    getNonGhostItems() {
      const existingItems = this.getExistingItems();
      if (this.isPotentialDndItems()) {
        return existingItems.filter((item) => !includes(this.potentialDndItems, item));
      }
      return existingItems;
    }
    addItemsToGui() {
      const nonGhostItems = this.getNonGhostItems();
      const itemsToAddToGui = nonGhostItems.map((item) => this.createItemComponent(item, false));
      if (this.isPotentialDndItems()) {
        const dndItems = this.potentialDndItems.map((item) => this.createItemComponent(item, true));
        if (this.insertIndex >= itemsToAddToGui.length) {
          itemsToAddToGui.push(...dndItems);
        } else {
          itemsToAddToGui.splice(this.insertIndex, 0, ...dndItems);
        }
      }
      this.appendChild(this.ePillDropList);
      itemsToAddToGui.forEach((itemComponent, index) => {
        if (index > 0) {
          this.addArrow(this.ePillDropList);
        }
        this.ePillDropList.appendChild(itemComponent.getGui());
      });
      this.addAriaLabelsToComponents();
    }
    addAriaLabelsToComponents() {
      this.childPillComponents.forEach((comp, idx) => {
        const eGui = comp.getGui();
        setAriaPosInSet(eGui, idx + 1);
        setAriaSetSize(eGui, this.childPillComponents.length);
      });
    }
    createItemComponent(item, ghost) {
      const itemComponent = this.createPillComponent(item, this.dropTarget, ghost, this.horizontal);
      itemComponent.addEventListener(PillDragComp.EVENT_COLUMN_REMOVE, this.removeItems.bind(this, [item]));
      this.context.createBean(itemComponent);
      this.guiDestroyFunctions.push(() => this.destroyBean(itemComponent));
      if (!ghost) {
        this.childPillComponents.push(itemComponent);
      }
      return itemComponent;
    }
    addIconAndTitleToGui() {
      const { title, icon: eGroupIcon } = this.params;
      if (!title || !eGroupIcon) {
        return;
      }
      const eTitleBar = document.createElement("div");
      setAriaHidden(eTitleBar, true);
      this.addElementClasses(eTitleBar, "title-bar");
      this.addElementClasses(eGroupIcon, "icon");
      this.addOrRemoveCssClass("ag-column-drop-empty", this.isExistingItemsEmpty());
      eTitleBar.appendChild(eGroupIcon);
      if (!this.horizontal) {
        const eTitle = document.createElement("span");
        this.addElementClasses(eTitle, "title");
        eTitle.innerHTML = title;
        eTitleBar.appendChild(eTitle);
      }
      this.appendChild(eTitleBar);
    }
    isExistingItemsEmpty() {
      return this.getExistingItems().length === 0;
    }
    addEmptyMessageToGui() {
      const { emptyMessage } = this.params;
      if (!emptyMessage || !this.isExistingItemsEmpty() || this.isPotentialDndItems()) {
        return;
      }
      const eMessage = document.createElement("span");
      eMessage.innerHTML = emptyMessage;
      this.addElementClasses(eMessage, "empty-message");
      this.ePillDropList.appendChild(eMessage);
    }
    addArrow(eParent) {
      if (this.horizontal) {
        const enableRtl = this.gos.get("enableRtl");
        const icon = createIconNoSpan(enableRtl ? "smallLeft" : "smallRight", this.gos);
        this.addElementClasses(icon, "cell-separator");
        eParent.appendChild(icon);
      }
    }
  };
  _PillDropZonePanel.STATE_NOT_DRAGGING = "notDragging";
  _PillDropZonePanel.STATE_NEW_ITEMS_IN = "newItemsIn";
  _PillDropZonePanel.STATE_REARRANGE_ITEMS = "rearrangeItems";
  __decorateClass([
    Autowired("focusService")
  ], _PillDropZonePanel.prototype, "focusService", 2);
  __decorateClass([
    Autowired("dragAndDropService")
  ], _PillDropZonePanel.prototype, "dragAndDropService", 2);
  var PillDropZonePanel = _PillDropZonePanel;
  var PASSIVE_EVENTS2 = ["touchstart", "touchend", "touchmove", "touchcancel"];
  var VanillaFrameworkOverrides = class {
    constructor(frameworkName = "javascript") {
      this.frameworkName = frameworkName;
      this.renderingEngine = "vanilla";
      this.wrapIncoming = (callback) => callback();
      this.wrapOutgoing = (callback) => callback();
    }
    setInterval(action, timeout) {
      return new AgPromise((resolve2) => {
        resolve2(window.setInterval(action, timeout));
      });
    }
    // for Vanilla JS, we just add the event to the element
    addEventListener(element, type, listener, useCapture) {
      const isPassive = includes(PASSIVE_EVENTS2, type);
      element.addEventListener(type, listener, { capture: !!useCapture, passive: isPassive });
    }
    get shouldWrapOutgoing() {
      return false;
    }
    frameworkComponent(name) {
      return null;
    }
    isFrameworkComponent(comp) {
      return false;
    }
    getDocLink(path) {
      const framework = this.frameworkName === "solid" ? "react" : this.frameworkName;
      return `https://www.ag-grid.com/${framework}-data-grid${path ? `/${path}` : ""}`;
    }
  };
  var CellNavigationService = class extends BeanStub {
    // returns null if no cell to focus on, ie at the end of the grid
    getNextCellToFocus(key, focusedCell, ctrlPressed = false) {
      if (ctrlPressed) {
        return this.getNextCellToFocusWithCtrlPressed(key, focusedCell);
      }
      return this.getNextCellToFocusWithoutCtrlPressed(key, focusedCell);
    }
    getNextCellToFocusWithCtrlPressed(key, focusedCell) {
      const upKey = key === KeyCode.UP;
      const downKey = key === KeyCode.DOWN;
      const leftKey = key === KeyCode.LEFT;
      let column;
      let rowIndex;
      if (upKey || downKey) {
        rowIndex = upKey ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();
        column = focusedCell.column;
      } else {
        const allColumns = this.columnModel.getAllDisplayedColumns();
        const isRtl = this.gos.get("enableRtl");
        rowIndex = focusedCell.rowIndex;
        column = leftKey !== isRtl ? allColumns[0] : last(allColumns);
      }
      return {
        rowIndex,
        rowPinned: null,
        column
      };
    }
    getNextCellToFocusWithoutCtrlPressed(key, focusedCell) {
      let pointer = focusedCell;
      let finished = false;
      while (!finished) {
        switch (key) {
          case KeyCode.UP:
            pointer = this.getCellAbove(pointer);
            break;
          case KeyCode.DOWN:
            pointer = this.getCellBelow(pointer);
            break;
          case KeyCode.RIGHT:
            if (this.gos.get("enableRtl")) {
              pointer = this.getCellToLeft(pointer);
            } else {
              pointer = this.getCellToRight(pointer);
            }
            break;
          case KeyCode.LEFT:
            if (this.gos.get("enableRtl")) {
              pointer = this.getCellToRight(pointer);
            } else {
              pointer = this.getCellToLeft(pointer);
            }
            break;
          default:
            pointer = null;
            console.warn("AG Grid: unknown key for navigation " + key);
            break;
        }
        if (pointer) {
          finished = this.isCellGoodToFocusOn(pointer);
        } else {
          finished = true;
        }
      }
      return pointer;
    }
    isCellGoodToFocusOn(gridCell) {
      const column = gridCell.column;
      let rowNode;
      switch (gridCell.rowPinned) {
        case "top":
          rowNode = this.pinnedRowModel.getPinnedTopRow(gridCell.rowIndex);
          break;
        case "bottom":
          rowNode = this.pinnedRowModel.getPinnedBottomRow(gridCell.rowIndex);
          break;
        default:
          rowNode = this.rowModel.getRow(gridCell.rowIndex);
          break;
      }
      if (!rowNode) {
        return false;
      }
      const suppressNavigable = column.isSuppressNavigable(rowNode);
      return !suppressNavigable;
    }
    getCellToLeft(lastCell) {
      if (!lastCell) {
        return null;
      }
      const colToLeft = this.columnModel.getDisplayedColBefore(lastCell.column);
      if (!colToLeft) {
        return null;
      }
      return {
        rowIndex: lastCell.rowIndex,
        column: colToLeft,
        rowPinned: lastCell.rowPinned
      };
    }
    getCellToRight(lastCell) {
      if (!lastCell) {
        return null;
      }
      const colToRight = this.columnModel.getDisplayedColAfter(lastCell.column);
      if (!colToRight) {
        return null;
      }
      return {
        rowIndex: lastCell.rowIndex,
        column: colToRight,
        rowPinned: lastCell.rowPinned
      };
    }
    getRowBelow(rowPosition) {
      const index = rowPosition.rowIndex;
      const pinned = rowPosition.rowPinned;
      if (this.isLastRowInContainer(rowPosition)) {
        switch (pinned) {
          case "bottom":
            return null;
          case "top":
            if (this.rowModel.isRowsToRender()) {
              return { rowIndex: this.paginationProxy.getPageFirstRow(), rowPinned: null };
            }
            if (this.pinnedRowModel.isRowsToRender("bottom")) {
              return { rowIndex: 0, rowPinned: "bottom" };
            }
            return null;
          default:
            if (this.pinnedRowModel.isRowsToRender("bottom")) {
              return { rowIndex: 0, rowPinned: "bottom" };
            }
            return null;
        }
      }
      const rowNode = this.rowModel.getRow(rowPosition.rowIndex);
      const nextStickyPosition = this.getNextStickyPosition(rowNode);
      if (nextStickyPosition) {
        return nextStickyPosition;
      }
      return { rowIndex: index + 1, rowPinned: pinned };
    }
    getNextStickyPosition(rowNode, up) {
      if (!this.gos.isGroupRowsSticky() || !rowNode || !rowNode.sticky) {
        return;
      }
      const isTopCtrls = this.rowRenderer.getStickyTopRowCtrls().some((ctrl) => ctrl.getRowNode().rowIndex === rowNode.rowIndex);
      let stickyRowCtrls = [];
      if (isTopCtrls) {
        stickyRowCtrls = [...this.rowRenderer.getStickyTopRowCtrls()].sort(
          (a, b) => a.getRowNode().rowIndex - b.getRowNode().rowIndex
        );
      } else {
        stickyRowCtrls = [...this.rowRenderer.getStickyBottomRowCtrls()].sort(
          (a, b) => b.getRowNode().rowIndex - a.getRowNode().rowIndex
        );
      }
      const diff = up ? -1 : 1;
      const idx = stickyRowCtrls.findIndex((ctrl) => ctrl.getRowNode().rowIndex === rowNode.rowIndex);
      const nextCtrl = stickyRowCtrls[idx + diff];
      if (nextCtrl) {
        return { rowIndex: nextCtrl.getRowNode().rowIndex, rowPinned: null };
      }
    }
    getCellBelow(lastCell) {
      if (!lastCell) {
        return null;
      }
      const rowBelow = this.getRowBelow(lastCell);
      if (rowBelow) {
        return {
          rowIndex: rowBelow.rowIndex,
          column: lastCell.column,
          rowPinned: rowBelow.rowPinned
        };
      }
      return null;
    }
    isLastRowInContainer(rowPosition) {
      const pinned = rowPosition.rowPinned;
      const index = rowPosition.rowIndex;
      if (pinned === "top") {
        const lastTopIndex = this.pinnedRowModel.getPinnedTopRowData().length - 1;
        return lastTopIndex <= index;
      }
      if (pinned === "bottom") {
        const lastBottomIndex = this.pinnedRowModel.getPinnedBottomRowData().length - 1;
        return lastBottomIndex <= index;
      }
      const lastBodyIndex = this.paginationProxy.getPageLastRow();
      return lastBodyIndex <= index;
    }
    getRowAbove(rowPosition) {
      const index = rowPosition.rowIndex;
      const pinned = rowPosition.rowPinned;
      const isFirstRow = pinned ? index === 0 : index === this.paginationProxy.getPageFirstRow();
      if (isFirstRow) {
        if (pinned === "top") {
          return null;
        }
        if (!pinned) {
          if (this.pinnedRowModel.isRowsToRender("top")) {
            return this.getLastFloatingTopRow();
          }
          return null;
        }
        if (this.rowModel.isRowsToRender()) {
          return this.getLastBodyCell();
        }
        if (this.pinnedRowModel.isRowsToRender("top")) {
          return this.getLastFloatingTopRow();
        }
        return null;
      }
      const rowNode = this.rowModel.getRow(rowPosition.rowIndex);
      const nextStickyPosition = this.getNextStickyPosition(rowNode, true);
      if (nextStickyPosition) {
        return nextStickyPosition;
      }
      return { rowIndex: index - 1, rowPinned: pinned };
    }
    getCellAbove(lastCell) {
      if (!lastCell) {
        return null;
      }
      const rowAbove = this.getRowAbove({ rowIndex: lastCell.rowIndex, rowPinned: lastCell.rowPinned });
      if (rowAbove) {
        return {
          rowIndex: rowAbove.rowIndex,
          column: lastCell.column,
          rowPinned: rowAbove.rowPinned
        };
      }
      return null;
    }
    getLastBodyCell() {
      const lastBodyRow = this.paginationProxy.getPageLastRow();
      return { rowIndex: lastBodyRow, rowPinned: null };
    }
    getLastFloatingTopRow() {
      const lastFloatingRow = this.pinnedRowModel.getPinnedTopRowData().length - 1;
      return { rowIndex: lastFloatingRow, rowPinned: "top" };
    }
    getNextTabbedCell(gridCell, backwards) {
      if (backwards) {
        return this.getNextTabbedCellBackwards(gridCell);
      }
      return this.getNextTabbedCellForwards(gridCell);
    }
    getNextTabbedCellForwards(gridCell) {
      const displayedColumns = this.columnModel.getAllDisplayedColumns();
      let newRowIndex = gridCell.rowIndex;
      let newFloating = gridCell.rowPinned;
      let newColumn = this.columnModel.getDisplayedColAfter(gridCell.column);
      if (!newColumn) {
        newColumn = displayedColumns[0];
        const rowBelow = this.getRowBelow(gridCell);
        if (missing(rowBelow)) {
          return null;
        }
        if (!rowBelow.rowPinned && !this.paginationProxy.isRowInPage(rowBelow)) {
          return null;
        }
        newRowIndex = rowBelow ? rowBelow.rowIndex : null;
        newFloating = rowBelow ? rowBelow.rowPinned : null;
      }
      return { rowIndex: newRowIndex, column: newColumn, rowPinned: newFloating };
    }
    getNextTabbedCellBackwards(gridCell) {
      const displayedColumns = this.columnModel.getAllDisplayedColumns();
      let newRowIndex = gridCell.rowIndex;
      let newFloating = gridCell.rowPinned;
      let newColumn = this.columnModel.getDisplayedColBefore(gridCell.column);
      if (!newColumn) {
        newColumn = last(displayedColumns);
        const rowAbove = this.getRowAbove({ rowIndex: gridCell.rowIndex, rowPinned: gridCell.rowPinned });
        if (missing(rowAbove)) {
          return null;
        }
        if (!rowAbove.rowPinned && !this.paginationProxy.isRowInPage(rowAbove)) {
          return null;
        }
        newRowIndex = rowAbove ? rowAbove.rowIndex : null;
        newFloating = rowAbove ? rowAbove.rowPinned : null;
      }
      return { rowIndex: newRowIndex, column: newColumn, rowPinned: newFloating };
    }
  };
  __decorateClass([
    Autowired("columnModel")
  ], CellNavigationService.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("rowModel")
  ], CellNavigationService.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("rowRenderer")
  ], CellNavigationService.prototype, "rowRenderer", 2);
  __decorateClass([
    Autowired("pinnedRowModel")
  ], CellNavigationService.prototype, "pinnedRowModel", 2);
  __decorateClass([
    Autowired("paginationProxy")
  ], CellNavigationService.prototype, "paginationProxy", 2);
  CellNavigationService = __decorateClass([
    Bean("cellNavigationService")
  ], CellNavigationService);
  var AlignedGridsService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.consuming = false;
    }
    setBeans(loggerFactory) {
      this.logger = loggerFactory.create("AlignedGridsService");
    }
    getAlignedGridApis() {
      var _a;
      let alignedGrids = (_a = this.gos.get("alignedGrids")) != null ? _a : [];
      const isCallbackConfig = typeof alignedGrids === "function";
      if (typeof alignedGrids === "function") {
        alignedGrids = alignedGrids();
      }
      const seeUrl = () => `See ${this.getFrameworkOverrides().getDocLink("aligned-grids")}`;
      const apis = alignedGrids.map((alignedGrid) => {
        var _a2;
        if (!alignedGrid) {
          errorOnce(`alignedGrids contains an undefined option.`);
          if (!isCallbackConfig) {
            errorOnce(`You may want to configure via a callback to avoid setup race conditions:
                     "alignedGrids: () => [linkedGrid]"`);
          }
          errorOnce(seeUrl());
          return;
        }
        if (alignedGrid instanceof GridApi) {
          return alignedGrid;
        }
        const refOrComp = alignedGrid;
        if ("current" in refOrComp) {
          return (_a2 = refOrComp.current) == null ? void 0 : _a2.api;
        } else {
          if (!refOrComp.api) {
            errorOnce(`alignedGrids - No api found on the linked grid. If you are passing gridOptions to alignedGrids since v31 this is no longer valid. ${seeUrl()}`);
          }
          return refOrComp.api;
        }
      }).filter((api) => !!api && !api.isDestroyed());
      return apis;
    }
    init() {
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, this.fireColumnEvent.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, this.fireColumnEvent.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PINNED, this.fireColumnEvent.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_GROUP_OPENED, this.fireColumnEvent.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_RESIZED, this.fireColumnEvent.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL, this.fireScrollEvent.bind(this));
    }
    // common logic across all the fire methods
    fireEvent(callback) {
      if (this.consuming) {
        return;
      }
      this.getAlignedGridApis().forEach((api) => {
        if (api.isDestroyed()) {
          return;
        }
        const alignedGridService = api.__getAlignedGridService();
        callback(alignedGridService);
      });
    }
    // common logic across all consume methods. very little common logic, however extracting
    // guarantees consistency across the methods.
    onEvent(callback) {
      this.consuming = true;
      callback();
      this.consuming = false;
    }
    fireColumnEvent(event) {
      this.fireEvent((alignedGridsService) => {
        alignedGridsService.onColumnEvent(event);
      });
    }
    fireScrollEvent(event) {
      if (event.direction !== "horizontal") {
        return;
      }
      this.fireEvent((alignedGridsService) => {
        alignedGridsService.onScrollEvent(event);
      });
    }
    onScrollEvent(event) {
      this.onEvent(() => {
        const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
        gridBodyCon.getScrollFeature().setHorizontalScrollPosition(event.left, true);
      });
    }
    getMasterColumns(event) {
      const result = [];
      if (event.columns) {
        event.columns.forEach((column) => {
          result.push(column);
        });
      } else if (event.column) {
        result.push(event.column);
      }
      return result;
    }
    getColumnIds(event) {
      const result = [];
      if (event.columns) {
        event.columns.forEach((column) => {
          result.push(column.getColId());
        });
      } else if (event.column) {
        result.push(event.column.getColId());
      }
      return result;
    }
    onColumnEvent(event) {
      this.onEvent(() => {
        switch (event.type) {
          case Events.EVENT_COLUMN_MOVED:
          case Events.EVENT_COLUMN_VISIBLE:
          case Events.EVENT_COLUMN_PINNED:
          case Events.EVENT_COLUMN_RESIZED:
            const colEvent = event;
            this.processColumnEvent(colEvent);
            break;
          case Events.EVENT_COLUMN_GROUP_OPENED:
            const groupOpenedEvent = event;
            this.processGroupOpenedEvent(groupOpenedEvent);
            break;
          case Events.EVENT_COLUMN_PIVOT_CHANGED:
            console.warn("AG Grid: pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid.");
            break;
        }
      });
    }
    processGroupOpenedEvent(groupOpenedEvent) {
      groupOpenedEvent.columnGroups.forEach((masterGroup) => {
        let otherColumnGroup = null;
        if (masterGroup) {
          const groupId = masterGroup.getGroupId();
          otherColumnGroup = this.columnModel.getProvidedColumnGroup(groupId);
        }
        if (masterGroup && !otherColumnGroup) {
          return;
        }
        this.logger.log("onColumnEvent-> processing " + groupOpenedEvent + " expanded = " + masterGroup.isExpanded());
        this.columnModel.setColumnGroupOpened(otherColumnGroup, masterGroup.isExpanded(), "alignedGridChanged");
      });
    }
    processColumnEvent(colEvent) {
      var _a;
      const masterColumn = colEvent.column;
      let otherColumn = null;
      if (masterColumn) {
        otherColumn = this.columnModel.getPrimaryColumn(masterColumn.getColId());
      }
      if (masterColumn && !otherColumn) {
        return;
      }
      const masterColumns = this.getMasterColumns(colEvent);
      switch (colEvent.type) {
        case Events.EVENT_COLUMN_MOVED:
          {
            const movedEvent = colEvent;
            const srcColState = colEvent.api.getColumnState();
            const destColState = srcColState.map((s) => ({ colId: s.colId }));
            this.columnModel.applyColumnState(
              { state: destColState, applyOrder: true },
              "alignedGridChanged"
            );
            this.logger.log(`onColumnEvent-> processing ${colEvent.type} toIndex = ${movedEvent.toIndex}`);
          }
          break;
        case Events.EVENT_COLUMN_VISIBLE:
          {
            const visibleEvent = colEvent;
            const srcColState = colEvent.api.getColumnState();
            const destColState = srcColState.map((s) => ({ colId: s.colId, hide: s.hide }));
            this.columnModel.applyColumnState({ state: destColState }, "alignedGridChanged");
            this.logger.log(`onColumnEvent-> processing ${colEvent.type} visible = ${visibleEvent.visible}`);
          }
          break;
        case Events.EVENT_COLUMN_PINNED:
          {
            const pinnedEvent = colEvent;
            const srcColState = colEvent.api.getColumnState();
            const destColState = srcColState.map((s) => ({ colId: s.colId, pinned: s.pinned }));
            this.columnModel.applyColumnState({ state: destColState }, "alignedGridChanged");
            this.logger.log(`onColumnEvent-> processing ${colEvent.type} pinned = ${pinnedEvent.pinned}`);
          }
          break;
        case Events.EVENT_COLUMN_RESIZED:
          const resizedEvent = colEvent;
          const columnWidths = {};
          masterColumns.forEach((column) => {
            this.logger.log(`onColumnEvent-> processing ${colEvent.type} actualWidth = ${column.getActualWidth()}`);
            columnWidths[column.getId()] = { key: column.getColId(), newWidth: column.getActualWidth() };
          });
          (_a = resizedEvent.flexColumns) == null ? void 0 : _a.forEach((col) => {
            if (columnWidths[col.getId()]) {
              delete columnWidths[col.getId()];
            }
          });
          this.columnModel.setColumnWidths(Object.values(columnWidths), false, resizedEvent.finished, "alignedGridChanged");
          break;
      }
      const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
      const isVerticalScrollShowing2 = gridBodyCon.isVerticalScrollShowing();
      this.getAlignedGridApis().forEach((api) => {
        api.setGridOption("alwaysShowVerticalScroll", isVerticalScrollShowing2);
      });
    }
  };
  __decorateClass([
    Autowired("columnModel")
  ], AlignedGridsService.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], AlignedGridsService.prototype, "ctrlsService", 2);
  __decorateClass([
    __decorateParam(0, Qualifier("loggerFactory"))
  ], AlignedGridsService.prototype, "setBeans", 1);
  __decorateClass([
    PostConstruct
  ], AlignedGridsService.prototype, "init", 1);
  AlignedGridsService = __decorateClass([
    Bean("alignedGridsService")
  ], AlignedGridsService);
  var SelectionService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.selectedNodes = /* @__PURE__ */ new Map();
      this.lastRowNode = null;
    }
    init() {
      this.rowSelection = this.gos.get("rowSelection");
      this.groupSelectsChildren = this.gos.get("groupSelectsChildren");
      this.addManagedPropertyListeners(["groupSelectsChildren", "rowSelection"], () => {
        this.groupSelectsChildren = this.gos.get("groupSelectsChildren");
        this.rowSelection = this.gos.get("rowSelection");
        this.deselectAllRowNodes({ source: "api" });
      });
      this.addManagedListener(this.eventService, Events.EVENT_ROW_SELECTED, this.onRowSelected.bind(this));
    }
    destroy() {
      super.destroy();
      this.resetNodes();
      this.lastRowNode = null;
    }
    isMultiselect() {
      return this.rowSelection === "multiple";
    }
    setNodesSelected(params) {
      var _a;
      const {
        newValue,
        clearSelection,
        suppressFinishActions,
        rangeSelect,
        nodes,
        event,
        source = "api"
      } = params;
      if (nodes.length === 0)
        return 0;
      if (nodes.length > 1 && !this.isMultiselect()) {
        console.warn(`AG Grid: cannot multi select while rowSelection='single'`);
        return 0;
      }
      const groupSelectsFiltered = this.groupSelectsChildren && params.groupSelectsFiltered === true;
      const filteredNodes = nodes.map((node) => node.footer ? node.sibling : node);
      if (rangeSelect) {
        if (nodes.length > 1) {
          console.warn("AG Grid: cannot range select while selecting multiple rows");
          return 0;
        }
        let toNode = null;
        if (source === "checkboxSelected" && newValue === false && this.lastRowNode) {
          if (this.lastRowNode.id) {
            toNode = this.lastRowNode;
          } else {
            this.lastRowNode = null;
          }
        }
        if (toNode == null) {
          toNode = this.getLastSelectedNode();
        }
        if (toNode) {
          const fromNode = filteredNodes[0];
          const newRowClicked = fromNode !== toNode;
          if (newRowClicked && this.isMultiselect()) {
            return this.selectRange(fromNode, toNode, newValue, source);
          }
        }
      }
      this.lastRowNode = newValue ? null : filteredNodes[0];
      let updatedCount = 0;
      for (let i = 0; i < filteredNodes.length; i++) {
        const node = filteredNodes[i];
        const skipThisNode = groupSelectsFiltered && node.group;
        if (!skipThisNode) {
          const thisNodeWasSelected = node.selectThisNode(newValue, event, source);
          if (thisNodeWasSelected) {
            updatedCount++;
          }
        }
        if (this.groupSelectsChildren && ((_a = node.childrenAfterGroup) == null ? void 0 : _a.length)) {
          updatedCount += this.selectChildren(node, newValue, groupSelectsFiltered, source);
        }
      }
      if (!suppressFinishActions) {
        const clearOtherNodes = newValue && (clearSelection || !this.isMultiselect());
        if (clearOtherNodes) {
          updatedCount += this.clearOtherNodes(filteredNodes[0], source);
        }
        if (updatedCount > 0) {
          this.updateGroupsFromChildrenSelections(source);
          const event2 = {
            type: Events.EVENT_SELECTION_CHANGED,
            source
          };
          this.eventService.dispatchEvent(event2);
        }
      }
      return updatedCount;
    }
    // selects all rows between this node and the last selected node (or the top if this is the first selection).
    // not to be mixed up with 'cell range selection' where you drag the mouse, this is row range selection, by
    // holding down 'shift'.
    selectRange(fromNode, toNode, value = true, source) {
      const nodesToSelect = this.rowModel.getNodesInRangeForSelection(fromNode, toNode);
      let updatedCount = 0;
      nodesToSelect.forEach((rowNode) => {
        if (rowNode.group && this.groupSelectsChildren) {
          return;
        }
        const nodeWasSelected = rowNode.selectThisNode(value, void 0, source);
        if (nodeWasSelected) {
          updatedCount++;
        }
      });
      this.updateGroupsFromChildrenSelections(source);
      const event = {
        type: Events.EVENT_SELECTION_CHANGED,
        source
      };
      this.eventService.dispatchEvent(event);
      return updatedCount;
    }
    selectChildren(node, newValue, groupSelectsFiltered, source) {
      const children = groupSelectsFiltered ? node.childrenAfterAggFilter : node.childrenAfterGroup;
      if (missing(children)) {
        return 0;
      }
      return this.setNodesSelected({
        newValue,
        clearSelection: false,
        suppressFinishActions: true,
        groupSelectsFiltered,
        source,
        nodes: children
      });
    }
    getLastSelectedNode() {
      const selectedKeys = Array.from(this.selectedNodes.keys());
      if (selectedKeys.length == 0) {
        return null;
      }
      const node = this.selectedNodes.get(last(selectedKeys));
      if (node) {
        return node;
      }
      return null;
    }
    getSelectedNodes() {
      const selectedNodes = [];
      this.selectedNodes.forEach((rowNode) => {
        if (rowNode) {
          selectedNodes.push(rowNode);
        }
      });
      return selectedNodes;
    }
    getSelectedRows() {
      const selectedRows = [];
      this.selectedNodes.forEach((rowNode) => {
        if (rowNode && rowNode.data) {
          selectedRows.push(rowNode.data);
        }
      });
      return selectedRows;
    }
    getSelectionCount() {
      return this.selectedNodes.size;
    }
    /**
     * This method is used by the CSRM to remove groups which are being disposed of,
     * events do not need fired in this case
     */
    filterFromSelection(predicate) {
      const newSelectedNodes = /* @__PURE__ */ new Map();
      this.selectedNodes.forEach((rowNode, key) => {
        const passesPredicate = rowNode && predicate(rowNode);
        if (passesPredicate) {
          newSelectedNodes.set(key, rowNode);
        }
      });
      this.selectedNodes = newSelectedNodes;
    }
    // should only be called if groupSelectsChildren=true
    updateGroupsFromChildrenSelections(source, changedPath) {
      if (!this.groupSelectsChildren) {
        return false;
      }
      if (this.rowModel.getType() !== "clientSide") {
        return false;
      }
      const clientSideRowModel = this.rowModel;
      const rootNode = clientSideRowModel.getRootNode();
      if (!changedPath) {
        changedPath = new ChangedPath(true, rootNode);
        changedPath.setInactive();
      }
      let selectionChanged = false;
      changedPath.forEachChangedNodeDepthFirst((rowNode) => {
        if (rowNode !== rootNode) {
          const selected = rowNode.calculateSelectedFromChildren();
          selectionChanged = rowNode.selectThisNode(selected === null ? false : selected, void 0, source) || selectionChanged;
        }
      });
      return selectionChanged;
    }
    clearOtherNodes(rowNodeToKeepSelected, source) {
      const groupsToRefresh = /* @__PURE__ */ new Map();
      let updatedCount = 0;
      this.selectedNodes.forEach((otherRowNode) => {
        if (otherRowNode && otherRowNode.id !== rowNodeToKeepSelected.id) {
          const rowNode = this.selectedNodes.get(otherRowNode.id);
          updatedCount += rowNode.setSelectedParams({
            newValue: false,
            clearSelection: false,
            suppressFinishActions: true,
            source
          });
          if (this.groupSelectsChildren && otherRowNode.parent) {
            groupsToRefresh.set(otherRowNode.parent.id, otherRowNode.parent);
          }
        }
      });
      groupsToRefresh.forEach((group) => {
        const selected = group.calculateSelectedFromChildren();
        group.selectThisNode(selected === null ? false : selected, void 0, source);
      });
      return updatedCount;
    }
    onRowSelected(event) {
      const rowNode = event.node;
      if (this.groupSelectsChildren && rowNode.group) {
        return;
      }
      if (rowNode.isSelected()) {
        this.selectedNodes.set(rowNode.id, rowNode);
      } else {
        this.selectedNodes.delete(rowNode.id);
      }
    }
    syncInRowNode(rowNode, oldNode) {
      this.syncInOldRowNode(rowNode, oldNode);
      this.syncInNewRowNode(rowNode);
    }
    // if the id has changed for the node, then this means the rowNode
    // is getting used for a different data item, which breaks
    // our selectedNodes, as the node now is mapped by the old id
    // which is inconsistent. so to keep the old node as selected,
    // we swap in the clone (with the old id and old data). this means
    // the oldNode is effectively a daemon we keep a reference to,
    // so if client calls api.getSelectedNodes(), it gets the daemon
    // in the result. when the client un-selects, the reference to the
    // daemon is removed. the daemon, because it's an oldNode, is not
    // used by the grid for rendering, it's a copy of what the node used
    // to be like before the id was changed.
    syncInOldRowNode(rowNode, oldNode) {
      const oldNodeHasDifferentId = exists(oldNode) && rowNode.id !== oldNode.id;
      if (oldNodeHasDifferentId && oldNode) {
        const id = oldNode.id;
        const oldNodeSelected = this.selectedNodes.get(id) == rowNode;
        if (oldNodeSelected) {
          this.selectedNodes.set(oldNode.id, oldNode);
        }
      }
    }
    syncInNewRowNode(rowNode) {
      if (this.selectedNodes.has(rowNode.id)) {
        rowNode.setSelectedInitialValue(true);
        this.selectedNodes.set(rowNode.id, rowNode);
      } else {
        rowNode.setSelectedInitialValue(false);
      }
    }
    reset(source) {
      const selectionCount = this.getSelectionCount();
      this.resetNodes();
      if (selectionCount) {
        const event = {
          type: Events.EVENT_SELECTION_CHANGED,
          source
        };
        this.eventService.dispatchEvent(event);
      }
    }
    resetNodes() {
      var _a;
      (_a = this.selectedNodes) == null ? void 0 : _a.clear();
    }
    // returns a list of all nodes at 'best cost' - a feature to be used
    // with groups / trees. if a group has all it's children selected,
    // then the group appears in the result, but not the children.
    // Designed for use with 'children' as the group selection type,
    // where groups don't actually appear in the selection normally.
    getBestCostNodeSelection() {
      if (this.rowModel.getType() !== "clientSide") {
        return;
      }
      const clientSideRowModel = this.rowModel;
      const topLevelNodes = clientSideRowModel.getTopLevelNodes();
      if (topLevelNodes === null) {
        return;
      }
      const result = [];
      function traverse2(nodes) {
        for (let i = 0, l = nodes.length; i < l; i++) {
          const node = nodes[i];
          if (node.isSelected()) {
            result.push(node);
          } else {
            const maybeGroup = node;
            if (maybeGroup.group && maybeGroup.children) {
              traverse2(maybeGroup.children);
            }
          }
        }
      }
      traverse2(topLevelNodes);
      return result;
    }
    isEmpty() {
      let count = 0;
      this.selectedNodes.forEach((rowNode) => {
        if (rowNode) {
          count++;
        }
      });
      return count === 0;
    }
    deselectAllRowNodes(params) {
      const callback = (rowNode) => rowNode.selectThisNode(false, void 0, source);
      const rowModelClientSide = this.rowModel.getType() === "clientSide";
      const { source, justFiltered, justCurrentPage } = params;
      if (justCurrentPage || justFiltered) {
        if (!rowModelClientSide) {
          console.error("AG Grid: selecting just filtered only works when gridOptions.rowModelType='clientSide'");
          return;
        }
        this.getNodesToSelect(justFiltered, justCurrentPage).forEach(callback);
      } else {
        this.selectedNodes.forEach((rowNode) => {
          if (rowNode) {
            callback(rowNode);
          }
        });
        this.reset(source);
      }
      if (rowModelClientSide && this.groupSelectsChildren) {
        this.updateGroupsFromChildrenSelections(source);
      }
      const event = {
        type: Events.EVENT_SELECTION_CHANGED,
        source
      };
      this.eventService.dispatchEvent(event);
    }
    getSelectedCounts(justFiltered, justCurrentPage) {
      let selectedCount = 0;
      let notSelectedCount = 0;
      const callback = (node) => {
        if (this.groupSelectsChildren && node.group) {
          return;
        }
        if (node.isSelected()) {
          selectedCount++;
        } else if (!node.selectable) {
        } else {
          notSelectedCount++;
        }
      };
      this.getNodesToSelect(justFiltered, justCurrentPage).forEach(callback);
      return { selectedCount, notSelectedCount };
    }
    getSelectAllState(justFiltered, justCurrentPage) {
      const { selectedCount, notSelectedCount } = this.getSelectedCounts(justFiltered, justCurrentPage);
      if (selectedCount === 0 && notSelectedCount === 0) {
        return false;
      }
      if (selectedCount > 0 && notSelectedCount > 0) {
        return null;
      }
      return selectedCount > 0;
    }
    hasNodesToSelect(justFiltered = false, justCurrentPage = false) {
      return this.getNodesToSelect(justFiltered, justCurrentPage).filter((node) => node.selectable).length > 0;
    }
    /**
     * @param justFiltered whether to just include nodes which have passed the filter
     * @param justCurrentPage whether to just include nodes on the current page
     * @returns all nodes including unselectable nodes which are the target of this selection attempt
     */
    getNodesToSelect(justFiltered = false, justCurrentPage = false) {
      if (this.rowModel.getType() !== "clientSide") {
        throw new Error(`selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`);
      }
      const nodes = [];
      if (justCurrentPage) {
        this.paginationProxy.forEachNodeOnPage((node) => {
          if (!node.group) {
            nodes.push(node);
            return;
          }
          if (!node.expanded) {
            const recursivelyAddChildren = (child) => {
              var _a;
              nodes.push(child);
              if ((_a = child.childrenAfterFilter) == null ? void 0 : _a.length) {
                child.childrenAfterFilter.forEach(recursivelyAddChildren);
              }
            };
            recursivelyAddChildren(node);
            return;
          }
          if (!this.groupSelectsChildren) {
            nodes.push(node);
          }
        });
        return nodes;
      }
      const clientSideRowModel = this.rowModel;
      if (justFiltered) {
        clientSideRowModel.forEachNodeAfterFilter((node) => {
          nodes.push(node);
        });
        return nodes;
      }
      clientSideRowModel.forEachNode((node) => {
        nodes.push(node);
      });
      return nodes;
    }
    selectAllRowNodes(params) {
      if (this.rowModel.getType() !== "clientSide") {
        throw new Error(`selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`);
      }
      const { source, justFiltered, justCurrentPage } = params;
      const callback = (rowNode) => rowNode.selectThisNode(true, void 0, source);
      this.getNodesToSelect(justFiltered, justCurrentPage).forEach(callback);
      if (this.rowModel.getType() === "clientSide" && this.groupSelectsChildren) {
        this.updateGroupsFromChildrenSelections(source);
      }
      const event = {
        type: Events.EVENT_SELECTION_CHANGED,
        source
      };
      this.eventService.dispatchEvent(event);
    }
    getSelectionState() {
      const selectedIds = [];
      this.selectedNodes.forEach((node) => {
        if (node == null ? void 0 : node.id) {
          selectedIds.push(node.id);
        }
      });
      return selectedIds.length ? selectedIds : null;
    }
    setSelectionState(state, source) {
      if (!Array.isArray(state)) {
        return;
      }
      const rowIds = new Set(state);
      const nodes = [];
      this.rowModel.forEachNode((node) => {
        if (rowIds.has(node.id)) {
          nodes.push(node);
        }
      });
      this.setNodesSelected({
        newValue: true,
        nodes,
        source
      });
    }
  };
  __decorateClass([
    Autowired("rowModel")
  ], SelectionService.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("paginationProxy")
  ], SelectionService.prototype, "paginationProxy", 2);
  __decorateClass([
    PostConstruct
  ], SelectionService.prototype, "init", 1);
  SelectionService = __decorateClass([
    Bean("selectionService")
  ], SelectionService);
  var ColumnApi = class {
    constructor(gridAp) {
      this.viaApi = (funcName, ...args) => {
        warnOnce(`Since v31, 'columnApi.${funcName}' is deprecated and moved to 'api.${funcName}'.`);
        return this.api[funcName](...args);
      };
      this.api = gridAp;
    }
    /** @deprecated v31 use `api.sizeColumnsToFit()` instead.   */
    sizeColumnsToFit(gridWidth) {
      this.viaApi("sizeColumnsToFit", gridWidth);
    }
    /** @deprecated v31 use `api.setColumnGroupOpened() instead. */
    setColumnGroupOpened(group, newValue) {
      this.viaApi("setColumnGroupOpened", group, newValue);
    }
    /** @deprecated v31 use `api.getColumnGroup() instead. */
    getColumnGroup(name, instanceId) {
      return this.viaApi("getColumnGroup", name, instanceId);
    }
    /** @deprecated v31 use `api.getProvidedColumnGroup() instead. */
    getProvidedColumnGroup(name) {
      return this.viaApi("getProvidedColumnGroup", name);
    }
    /** @deprecated v31 use `api.getDisplayNameForColumn() instead. */
    getDisplayNameForColumn(column, location2) {
      return this.viaApi("getDisplayNameForColumn", column, location2);
    }
    /** @deprecated v31 use `api.getDisplayNameForColumnGroup() instead. */
    getDisplayNameForColumnGroup(columnGroup, location2) {
      return this.viaApi("getDisplayNameForColumnGroup", columnGroup, location2);
    }
    /** @deprecated v31 use `api.getColumn() instead. */
    getColumn(key) {
      return this.viaApi("getColumn", key);
    }
    /** @deprecated v31 use `api.getColumns() instead. */
    getColumns() {
      return this.viaApi("getColumns");
    }
    /** @deprecated v31 use `api.applyColumnState() instead. */
    applyColumnState(params) {
      return this.viaApi("applyColumnState", params);
    }
    /** @deprecated v31 use `api.getColumnState() instead. */
    getColumnState() {
      return this.viaApi("getColumnState");
    }
    /** @deprecated v31 use `api.resetColumnState() instead. */
    resetColumnState() {
      this.viaApi("resetColumnState");
    }
    /** @deprecated v31 use `api.getColumnGroupState() instead. */
    getColumnGroupState() {
      return this.viaApi("getColumnGroupState");
    }
    /** @deprecated v31 use `api.setColumnGroupState() instead. */
    setColumnGroupState(stateItems) {
      this.viaApi("setColumnGroupState", stateItems);
    }
    /** @deprecated v31 use `api.resetColumnGroupState() instead. */
    resetColumnGroupState() {
      this.viaApi("resetColumnGroupState");
    }
    /** @deprecated v31 use `api.isPinning() instead. */
    isPinning() {
      return this.viaApi("isPinning");
    }
    /** @deprecated v31 use `api.isPinningLeft() instead. */
    isPinningLeft() {
      return this.viaApi("isPinningLeft");
    }
    /** @deprecated v31 use `api.isPinningRight() instead. */
    isPinningRight() {
      return this.viaApi("isPinningRight");
    }
    /** @deprecated v31 use `api.getDisplayedColAfter() instead. */
    getDisplayedColAfter(col) {
      return this.viaApi("getDisplayedColAfter", col);
    }
    /** @deprecated v31 use `api.getDisplayedColBefore() instead. */
    getDisplayedColBefore(col) {
      return this.viaApi("getDisplayedColBefore", col);
    }
    /** @deprecated v31 use `api.setColumnVisible() instead. */
    setColumnVisible(key, visible) {
      this.viaApi("setColumnVisible", key, visible);
    }
    /** @deprecated v31 use `api.setColumnsVisible() instead. */
    setColumnsVisible(keys2, visible) {
      this.viaApi("setColumnsVisible", keys2, visible);
    }
    /** @deprecated v31 use `api.setColumnPinned() instead. */
    setColumnPinned(key, pinned) {
      this.viaApi("setColumnPinned", key, pinned);
    }
    /** @deprecated v31 use `api.setColumnsPinned() instead. */
    setColumnsPinned(keys2, pinned) {
      this.viaApi("setColumnsPinned", keys2, pinned);
    }
    /** @deprecated v31 use `api.getAllGridColumns() instead. */
    getAllGridColumns() {
      return this.viaApi("getAllGridColumns");
    }
    /** @deprecated v31 use `api.getDisplayedLeftColumns() instead. */
    getDisplayedLeftColumns() {
      return this.viaApi("getDisplayedLeftColumns");
    }
    /** @deprecated v31 use `api.getDisplayedCenterColumns() instead. */
    getDisplayedCenterColumns() {
      return this.viaApi("getDisplayedCenterColumns");
    }
    /** @deprecated v31 use `api.getDisplayedRightColumns() instead. */
    getDisplayedRightColumns() {
      return this.viaApi("getDisplayedRightColumns");
    }
    /** @deprecated v31 use `api.getAllDisplayedColumns() instead. */
    getAllDisplayedColumns() {
      return this.viaApi("getAllDisplayedColumns");
    }
    /** @deprecated v31 use `api.getAllDisplayedVirtualColumns() instead. */
    getAllDisplayedVirtualColumns() {
      return this.viaApi("getAllDisplayedVirtualColumns");
    }
    /** @deprecated v31 use `api.moveColumn() instead. */
    moveColumn(key, toIndex) {
      this.viaApi("moveColumn", key, toIndex);
    }
    /** @deprecated v31 use `api.moveColumnByIndex() instead. */
    moveColumnByIndex(fromIndex, toIndex) {
      this.viaApi("moveColumnByIndex", fromIndex, toIndex);
    }
    /** @deprecated v31 use `api.moveColumns() instead. */
    moveColumns(columnsToMoveKeys, toIndex) {
      this.viaApi("moveColumns", columnsToMoveKeys, toIndex);
    }
    /** @deprecated v31 use `api.moveRowGroupColumn() instead. */
    moveRowGroupColumn(fromIndex, toIndex) {
      this.viaApi("moveRowGroupColumn", fromIndex, toIndex);
    }
    /** @deprecated v31 use `api.setColumnAggFunc() instead. */
    setColumnAggFunc(key, aggFunc) {
      this.viaApi("setColumnAggFunc", key, aggFunc);
    }
    /** @deprecated v31 use `api.setColumnWidth() instead. */
    setColumnWidth(key, newWidth, finished = true, source) {
      this.viaApi("setColumnWidth", key, newWidth, finished, source);
    }
    /** @deprecated v31 use `api.setColumnWidths() instead. */
    setColumnWidths(columnWidths, finished = true, source) {
      this.viaApi("setColumnWidths", columnWidths, finished, source);
    }
    /** @deprecated v31 use `api.setPivotMode() instead. */
    setPivotMode(pivotMode) {
      this.viaApi("setPivotMode", pivotMode);
    }
    /** @deprecated v31 use `api.isPivotMode() instead. */
    isPivotMode() {
      return this.viaApi("isPivotMode");
    }
    /** @deprecated v31 use `api.getPivotResultColumn() instead. */
    getPivotResultColumn(pivotKeys, valueColKey) {
      return this.viaApi("getPivotResultColumn", pivotKeys, valueColKey);
    }
    /** @deprecated v31 use `api.setValueColumns() instead. */
    setValueColumns(colKeys) {
      this.viaApi("setValueColumns", colKeys);
    }
    /** @deprecated v31 use `api.getValueColumns() instead. */
    getValueColumns() {
      return this.viaApi("getValueColumns");
    }
    /** @deprecated v31 use `api.removeValueColumn() instead. */
    removeValueColumn(colKey) {
      this.viaApi("removeValueColumn", colKey);
    }
    /** @deprecated v31 use `api.removeValueColumns() instead. */
    removeValueColumns(colKeys) {
      this.viaApi("removeValueColumns", colKeys);
    }
    /** @deprecated v31 use `api.addValueColumn() instead. */
    addValueColumn(colKey) {
      this.viaApi("addValueColumn", colKey);
    }
    /** @deprecated v31 use `api.addValueColumns() instead. */
    addValueColumns(colKeys) {
      this.viaApi("addValueColumns", colKeys);
    }
    /** @deprecated v31 use `api.setRowGroupColumns() instead. */
    setRowGroupColumns(colKeys) {
      this.viaApi("setRowGroupColumns", colKeys);
    }
    /** @deprecated v31 use `api.removeRowGroupColumn() instead. */
    removeRowGroupColumn(colKey) {
      this.viaApi("removeRowGroupColumn", colKey);
    }
    /** @deprecated v31 use `api.removeRowGroupColumns() instead. */
    removeRowGroupColumns(colKeys) {
      this.viaApi("removeRowGroupColumns", colKeys);
    }
    /** @deprecated v31 use `api.addRowGroupColumn() instead. */
    addRowGroupColumn(colKey) {
      this.viaApi("addRowGroupColumn", colKey);
    }
    /** @deprecated v31 use `api.addRowGroupColumns() instead. */
    addRowGroupColumns(colKeys) {
      this.viaApi("addRowGroupColumns", colKeys);
    }
    /** @deprecated v31 use `api.getRowGroupColumns() instead. */
    getRowGroupColumns() {
      return this.viaApi("getRowGroupColumns");
    }
    /** @deprecated v31 use `api.setPivotColumns() instead. */
    setPivotColumns(colKeys) {
      this.viaApi("setPivotColumns", colKeys);
    }
    /** @deprecated v31 use `api.removePivotColumn() instead. */
    removePivotColumn(colKey) {
      this.viaApi("removePivotColumn", colKey);
    }
    /** @deprecated v31 use `api.removePivotColumns() instead. */
    removePivotColumns(colKeys) {
      this.viaApi("removePivotColumns", colKeys);
    }
    /** @deprecated v31 use `api.addPivotColumn() instead. */
    addPivotColumn(colKey) {
      this.viaApi("addPivotColumn", colKey);
    }
    /** @deprecated v31 use `api.addPivotColumns() instead. */
    addPivotColumns(colKeys) {
      this.viaApi("addPivotColumns", colKeys);
    }
    /** @deprecated v31 use `api.getPivotColumns() instead. */
    getPivotColumns() {
      return this.viaApi("getPivotColumns");
    }
    /** @deprecated v31 use `api.getLeftDisplayedColumnGroups() instead. */
    getLeftDisplayedColumnGroups() {
      return this.viaApi("getLeftDisplayedColumnGroups");
    }
    /** @deprecated v31 use `api.getCenterDisplayedColumnGroups() instead. */
    getCenterDisplayedColumnGroups() {
      return this.viaApi("getCenterDisplayedColumnGroups");
    }
    /** @deprecated v31 use `api.getRightDisplayedColumnGroups() instead. */
    getRightDisplayedColumnGroups() {
      return this.viaApi("getRightDisplayedColumnGroups");
    }
    /** @deprecated v31 use `api.getAllDisplayedColumnGroups() instead. */
    getAllDisplayedColumnGroups() {
      return this.viaApi("getAllDisplayedColumnGroups");
    }
    /** @deprecated v31 use `api.autoSizeColumn() instead. */
    autoSizeColumn(key, skipHeader) {
      return this.viaApi("autoSizeColumn", key, skipHeader);
    }
    /** @deprecated v31 use `api.autoSizeColumns() instead. */
    autoSizeColumns(keys2, skipHeader) {
      this.viaApi("autoSizeColumns", keys2, skipHeader);
    }
    /** @deprecated v31 use `api.autoSizeAllColumns() instead. */
    autoSizeAllColumns(skipHeader) {
      this.viaApi("autoSizeAllColumns", skipHeader);
    }
    /** @deprecated v31 use `api.setPivotResultColumns() instead. */
    setPivotResultColumns(colDefs) {
      this.viaApi("setPivotResultColumns", colDefs);
    }
    /** @deprecated v31 use `api.getPivotResultColumns() instead. */
    getPivotResultColumns() {
      return this.viaApi("getPivotResultColumns");
    }
  };
  __decorateClass([
    Autowired("gridApi")
  ], ColumnApi.prototype, "api", 2);
  ColumnApi = __decorateClass([
    Bean("columnApi")
  ], ColumnApi);
  var ValueService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.initialised = false;
      this.isSsrm = false;
    }
    init() {
      this.isSsrm = this.gos.isRowModelType("serverSide");
      this.cellExpressions = this.gos.get("enableCellExpressions");
      this.isTreeData = this.gos.get("treeData");
      this.initialised = true;
      const listener = (event) => this.callColumnCellValueChangedHandler(event);
      const async = this.gos.useAsyncEvents();
      this.eventService.addEventListener(Events.EVENT_CELL_VALUE_CHANGED, listener, async);
      this.addDestroyFunc(() => this.eventService.removeEventListener(Events.EVENT_CELL_VALUE_CHANGED, listener, async));
      this.addManagedPropertyListener("treeData", (propChange) => this.isTreeData = propChange.currentValue);
    }
    getValue(column, rowNode, forFilter = false, ignoreAggData = false) {
      if (!this.initialised) {
        this.init();
      }
      if (!rowNode) {
        return;
      }
      const colDef = column.getColDef();
      const field = colDef.field;
      const colId = column.getColId();
      const data = rowNode.data;
      let result;
      const groupDataExists = rowNode.groupData && rowNode.groupData[colId] !== void 0;
      const aggDataExists = !ignoreAggData && rowNode.aggData && rowNode.aggData[colId] !== void 0;
      const ignoreSsrmAggData = this.isSsrm && ignoreAggData && !!column.getColDef().aggFunc;
      const ssrmFooterGroupCol = this.isSsrm && rowNode.footer && rowNode.field && (column.getColDef().showRowGroup === true || column.getColDef().showRowGroup === rowNode.field);
      if (forFilter && colDef.filterValueGetter) {
        result = this.executeFilterValueGetter(colDef.filterValueGetter, data, column, rowNode);
      } else if (this.isTreeData && aggDataExists) {
        result = rowNode.aggData[colId];
      } else if (this.isTreeData && colDef.valueGetter) {
        result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);
      } else if (this.isTreeData && (field && data)) {
        result = getValueUsingField(data, field, column.isFieldContainsDots());
      } else if (groupDataExists) {
        result = rowNode.groupData[colId];
      } else if (aggDataExists) {
        result = rowNode.aggData[colId];
      } else if (colDef.valueGetter) {
        result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);
      } else if (ssrmFooterGroupCol) {
        result = getValueUsingField(data, rowNode.field, column.isFieldContainsDots());
      } else if (field && data && !ignoreSsrmAggData) {
        result = getValueUsingField(data, field, column.isFieldContainsDots());
      }
      if (this.cellExpressions && typeof result === "string" && result.indexOf("=") === 0) {
        const cellValueGetter = result.substring(1);
        result = this.executeValueGetter(cellValueGetter, data, column, rowNode);
      }
      if (result == null) {
        const openedGroup = this.getOpenedGroup(rowNode, column);
        if (openedGroup != null) {
          return openedGroup;
        }
      }
      return result;
    }
    parseValue(column, rowNode, newValue, oldValue) {
      const colDef = column.getColDef();
      const params = this.gos.addGridCommonParams({
        node: rowNode,
        data: rowNode == null ? void 0 : rowNode.data,
        oldValue,
        newValue,
        colDef,
        column
      });
      const valueParser = colDef.valueParser;
      if (exists(valueParser)) {
        if (typeof valueParser === "function") {
          return valueParser(params);
        }
        return this.expressionService.evaluate(valueParser, params);
      }
      return newValue;
    }
    formatValue(column, node, value, suppliedFormatter, useFormatterFromColumn = true) {
      let result = null;
      let formatter;
      const colDef = column.getColDef();
      if (suppliedFormatter) {
        formatter = suppliedFormatter;
      } else if (useFormatterFromColumn) {
        formatter = colDef.valueFormatter;
      }
      if (formatter) {
        const params = this.gos.addGridCommonParams({
          value,
          node,
          data: node ? node.data : null,
          colDef,
          column
        });
        if (typeof formatter === "function") {
          result = formatter(params);
        } else {
          result = this.expressionService.evaluate(formatter, params);
        }
      } else if (colDef.refData) {
        return colDef.refData[value] || "";
      }
      if (result == null && Array.isArray(value)) {
        result = value.join(", ");
      }
      return result;
    }
    getOpenedGroup(rowNode, column) {
      if (!this.gos.get("showOpenedGroup")) {
        return;
      }
      const colDef = column.getColDef();
      if (!colDef.showRowGroup) {
        return;
      }
      const showRowGroup = column.getColDef().showRowGroup;
      let pointer = rowNode.parent;
      while (pointer != null) {
        if (pointer.rowGroupColumn && (showRowGroup === true || showRowGroup === pointer.rowGroupColumn.getColId())) {
          return pointer.key;
        }
        pointer = pointer.parent;
      }
      return void 0;
    }
    /**
     * Sets the value of a GridCell
     * @param rowNode The `RowNode` to be updated
     * @param colKey The `Column` to be updated
     * @param newValue The new value to be set
     * @param eventSource The event source
     * @returns `True` if the value has been updated, otherwise`False`.
     */
    setValue(rowNode, colKey, newValue, eventSource) {
      const column = this.columnModel.getPrimaryColumn(colKey);
      if (!rowNode || !column) {
        return false;
      }
      if (missing(rowNode.data)) {
        rowNode.data = {};
      }
      const { field, valueSetter } = column.getColDef();
      if (missing(field) && missing(valueSetter)) {
        console.warn(`AG Grid: you need either field or valueSetter set on colDef for editing to work`);
        return false;
      }
      if (!this.dataTypeService.checkType(column, newValue)) {
        console.warn(`AG Grid: Data type of the new value does not match the cell data type of the column`);
        return false;
      }
      const params = this.gos.addGridCommonParams({
        node: rowNode,
        data: rowNode.data,
        oldValue: this.getValue(column, rowNode),
        newValue,
        colDef: column.getColDef(),
        column
      });
      params.newValue = newValue;
      let valueWasDifferent;
      if (exists(valueSetter)) {
        if (typeof valueSetter === "function") {
          valueWasDifferent = valueSetter(params);
        } else {
          valueWasDifferent = this.expressionService.evaluate(valueSetter, params);
        }
      } else {
        valueWasDifferent = this.setValueUsingField(rowNode.data, field, newValue, column.isFieldContainsDots());
      }
      if (valueWasDifferent === void 0) {
        valueWasDifferent = true;
      }
      if (!valueWasDifferent) {
        return false;
      }
      rowNode.resetQuickFilterAggregateText();
      this.valueCache.onDataChanged();
      params.newValue = this.getValue(column, rowNode);
      const event = {
        type: Events.EVENT_CELL_VALUE_CHANGED,
        event: null,
        rowIndex: rowNode.rowIndex,
        rowPinned: rowNode.rowPinned,
        column: params.column,
        api: params.api,
        columnApi: params.columnApi,
        colDef: params.colDef,
        context: params.context,
        data: rowNode.data,
        node: rowNode,
        oldValue: params.oldValue,
        newValue: params.newValue,
        value: params.newValue,
        source: eventSource
      };
      this.eventService.dispatchEvent(event);
      return true;
    }
    callColumnCellValueChangedHandler(event) {
      const onCellValueChanged = event.colDef.onCellValueChanged;
      if (typeof onCellValueChanged === "function") {
        this.getFrameworkOverrides().wrapOutgoing(() => {
          onCellValueChanged({
            node: event.node,
            data: event.data,
            oldValue: event.oldValue,
            newValue: event.newValue,
            colDef: event.colDef,
            column: event.column,
            api: event.api,
            columnApi: event.columnApi,
            context: event.context
          });
        });
      }
    }
    setValueUsingField(data, field, newValue, isFieldContainsDots) {
      if (!field) {
        return false;
      }
      let valuesAreSame = false;
      if (!isFieldContainsDots) {
        valuesAreSame = data[field] === newValue;
        if (!valuesAreSame) {
          data[field] = newValue;
        }
      } else {
        const fieldPieces = field.split(".");
        let currentObject = data;
        while (fieldPieces.length > 0 && currentObject) {
          const fieldPiece = fieldPieces.shift();
          if (fieldPieces.length === 0) {
            valuesAreSame = currentObject[fieldPiece] === newValue;
            if (!valuesAreSame) {
              currentObject[fieldPiece] = newValue;
            }
          } else {
            currentObject = currentObject[fieldPiece];
          }
        }
      }
      return !valuesAreSame;
    }
    executeFilterValueGetter(valueGetter, data, column, rowNode) {
      const params = this.gos.addGridCommonParams({
        data,
        node: rowNode,
        column,
        colDef: column.getColDef(),
        getValue: this.getValueCallback.bind(this, rowNode)
      });
      if (typeof valueGetter === "function") {
        return valueGetter(params);
      }
      return this.expressionService.evaluate(valueGetter, params);
    }
    executeValueGetter(valueGetter, data, column, rowNode) {
      const colId = column.getColId();
      const valueFromCache = this.valueCache.getValue(rowNode, colId);
      if (valueFromCache !== void 0) {
        return valueFromCache;
      }
      const params = this.gos.addGridCommonParams({
        data,
        node: rowNode,
        column,
        colDef: column.getColDef(),
        getValue: this.getValueCallback.bind(this, rowNode)
      });
      let result;
      if (typeof valueGetter === "function") {
        result = valueGetter(params);
      } else {
        result = this.expressionService.evaluate(valueGetter, params);
      }
      this.valueCache.setValue(rowNode, colId, result);
      return result;
    }
    getValueCallback(node, field) {
      const otherColumn = this.columnModel.getPrimaryColumn(field);
      if (otherColumn) {
        return this.getValue(otherColumn, node);
      }
      return null;
    }
    // used by row grouping and pivot, to get key for a row. col can be a pivot col or a row grouping col
    getKeyForNode(col, rowNode) {
      const value = this.getValue(col, rowNode);
      const keyCreator = col.getColDef().keyCreator;
      let result = value;
      if (keyCreator) {
        const keyParams = this.gos.addGridCommonParams({
          value,
          colDef: col.getColDef(),
          column: col,
          node: rowNode,
          data: rowNode.data
        });
        result = keyCreator(keyParams);
      }
      if (typeof result === "string" || result == null) {
        return result;
      }
      result = String(result);
      if (result === "[object Object]") {
        warnOnce("a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (se AG Grid docs) or b) to toString() on the object to return a key");
      }
      return result;
    }
  };
  __decorateClass([
    Autowired("expressionService")
  ], ValueService.prototype, "expressionService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], ValueService.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("valueCache")
  ], ValueService.prototype, "valueCache", 2);
  __decorateClass([
    Autowired("dataTypeService")
  ], ValueService.prototype, "dataTypeService", 2);
  __decorateClass([
    PostConstruct
  ], ValueService.prototype, "init", 1);
  ValueService = __decorateClass([
    Bean("valueService")
  ], ValueService);
  var ExpressionService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.expressionToFunctionCache = {};
    }
    setBeans(loggerFactory) {
      this.logger = loggerFactory.create("ExpressionService");
    }
    evaluate(expression, params) {
      if (typeof expression === "string") {
        return this.evaluateExpression(expression, params);
      } else {
        console.error("AG Grid: value should be either a string or a function", expression);
      }
    }
    evaluateExpression(expression, params) {
      try {
        const javaScriptFunction = this.createExpressionFunction(expression);
        const result = javaScriptFunction(
          params.value,
          params.context,
          params.oldValue,
          params.newValue,
          params.value,
          params.node,
          params.data,
          params.colDef,
          params.rowIndex,
          params.api,
          params.columnApi,
          params.getValue,
          params.column,
          params.columnGroup
        );
        return result;
      } catch (e) {
        console.log("Processing of the expression failed");
        console.log("Expression = " + expression);
        console.log("Params =", params);
        console.log("Exception = " + e);
        return null;
      }
    }
    createExpressionFunction(expression) {
      if (this.expressionToFunctionCache[expression]) {
        return this.expressionToFunctionCache[expression];
      }
      const functionBody = this.createFunctionBody(expression);
      const theFunction = new Function("x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, columnApi, getValue, column, columnGroup", functionBody);
      this.expressionToFunctionCache[expression] = theFunction;
      return theFunction;
    }
    createFunctionBody(expression) {
      if (expression.indexOf("return") >= 0) {
        return expression;
      } else {
        return "return " + expression + ";";
      }
    }
  };
  __decorateClass([
    __decorateParam(0, Qualifier("loggerFactory"))
  ], ExpressionService.prototype, "setBeans", 1);
  ExpressionService = __decorateClass([
    Bean("expressionService")
  ], ExpressionService);
  var LoggerFactory = class extends BeanStub {
    setBeans(gos) {
      this.logging = gos.get("debug");
    }
    create(name) {
      return new Logger(name, this.isLogging.bind(this));
    }
    isLogging() {
      return this.logging;
    }
  };
  __decorateClass([
    __decorateParam(0, Qualifier("gridOptionsService"))
  ], LoggerFactory.prototype, "setBeans", 1);
  LoggerFactory = __decorateClass([
    Bean("loggerFactory")
  ], LoggerFactory);
  var Logger = class {
    constructor(name, isLoggingFunc) {
      this.name = name;
      this.isLoggingFunc = isLoggingFunc;
    }
    isLogging() {
      return this.isLoggingFunc();
    }
    log(message) {
      if (this.isLoggingFunc()) {
        console.log("AG Grid." + this.name + ": " + message);
      }
    }
  };
  var GridCtrl = class extends BeanStub {
    setComp(view, eGridDiv, eGui) {
      this.view = view;
      this.eGridHostDiv = eGridDiv;
      this.eGui = eGui;
      this.eGui.setAttribute("grid-id", this.context.getGridId());
      this.dragAndDropService.addDropTarget({
        getContainer: () => this.eGui,
        isInterestedIn: (type) => type === 1 || type === 0,
        getIconName: () => DragAndDropService.ICON_NOT_ALLOWED
      });
      this.mouseEventService.stampTopLevelGridCompWithGridInstance(eGridDiv);
      this.createManagedBean(new LayoutFeature(this.view));
      this.addRtlSupport();
      const unsubscribeFromResize = this.resizeObserverService.observeResize(
        this.eGridHostDiv,
        this.onGridSizeChanged.bind(this)
      );
      this.addDestroyFunc(() => unsubscribeFromResize());
      this.ctrlsService.register("gridCtrl", this);
    }
    isDetailGrid() {
      var _a;
      const el = this.focusService.findTabbableParent(this.getGui());
      return ((_a = el == null ? void 0 : el.getAttribute("row-id")) == null ? void 0 : _a.startsWith("detail")) || false;
    }
    showDropZones() {
      return ModuleRegistry.__isRegistered("@ag-grid-enterprise/row-grouping", this.context.getGridId());
    }
    showSideBar() {
      return ModuleRegistry.__isRegistered("@ag-grid-enterprise/side-bar", this.context.getGridId());
    }
    showStatusBar() {
      return ModuleRegistry.__isRegistered("@ag-grid-enterprise/status-bar", this.context.getGridId());
    }
    showWatermark() {
      return ModuleRegistry.__isRegistered("@ag-grid-enterprise/core", this.context.getGridId());
    }
    onGridSizeChanged() {
      const event = {
        type: Events.EVENT_GRID_SIZE_CHANGED,
        clientWidth: this.eGridHostDiv.clientWidth,
        clientHeight: this.eGridHostDiv.clientHeight
      };
      this.eventService.dispatchEvent(event);
    }
    addRtlSupport() {
      const cssClass = this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr";
      this.view.setRtlClass(cssClass);
    }
    destroyGridUi() {
      this.view.destroyGridUi();
    }
    getGui() {
      return this.eGui;
    }
    setResizeCursor(on) {
      this.view.setCursor(on ? "ew-resize" : null);
    }
    disableUserSelect(on) {
      this.view.setUserSelect(on ? "none" : null);
    }
    focusNextInnerContainer(backwards) {
      const focusableContainers = this.view.getFocusableContainers();
      const activeEl = this.gos.getActiveDomElement();
      const idxWithFocus = focusableContainers.findIndex((container) => container.contains(activeEl));
      const nextIdx = idxWithFocus + (backwards ? -1 : 1);
      if (nextIdx <= 0 || nextIdx >= focusableContainers.length) {
        return false;
      }
      return this.focusService.focusInto(focusableContainers[nextIdx]);
    }
    focusInnerElement(fromBottom) {
      const focusableContainers = this.view.getFocusableContainers();
      const allColumns = this.columnModel.getAllDisplayedColumns();
      if (fromBottom) {
        if (focusableContainers.length > 1) {
          return this.focusService.focusInto(last(focusableContainers), true);
        }
        const lastColumn = last(allColumns);
        if (this.focusService.focusGridView(lastColumn, true)) {
          return true;
        }
      }
      if (this.gos.get("headerHeight") === 0 || this.gos.get("suppressHeaderFocus")) {
        if (this.focusService.focusGridView(allColumns[0])) {
          return true;
        }
        for (let i = 1; i < focusableContainers.length; i++) {
          if (this.focusService.focusInto(focusableContainers[i])) {
            return true;
          }
        }
        return false;
      }
      return this.focusService.focusFirstHeader();
    }
    forceFocusOutOfContainer(up = false) {
      this.view.forceFocusOutOfContainer(up);
    }
  };
  __decorateClass([
    Autowired("focusService")
  ], GridCtrl.prototype, "focusService", 2);
  __decorateClass([
    Autowired("resizeObserverService")
  ], GridCtrl.prototype, "resizeObserverService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], GridCtrl.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], GridCtrl.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("mouseEventService")
  ], GridCtrl.prototype, "mouseEventService", 2);
  __decorateClass([
    Autowired("dragAndDropService")
  ], GridCtrl.prototype, "dragAndDropService", 2);
  var GridComp = class extends TabGuardComp {
    constructor(eGridDiv) {
      super();
      this.eGridDiv = eGridDiv;
    }
    postConstruct() {
      this.logger = this.loggerFactory.create("GridComp");
      const compProxy = {
        destroyGridUi: () => this.destroyBean(this),
        setRtlClass: (cssClass) => this.addCssClass(cssClass),
        forceFocusOutOfContainer: this.forceFocusOutOfContainer.bind(this),
        updateLayoutClasses: this.updateLayoutClasses.bind(this),
        getFocusableContainers: this.getFocusableContainers.bind(this),
        setUserSelect: (value) => {
          this.getGui().style.userSelect = value != null ? value : "";
          this.getGui().style.webkitUserSelect = value != null ? value : "";
        },
        setCursor: (value) => {
          this.getGui().style.cursor = value != null ? value : "";
        }
      };
      this.ctrl = this.createManagedBean(new GridCtrl());
      const template = this.createTemplate();
      this.setTemplate(template);
      this.ctrl.setComp(compProxy, this.eGridDiv, this.getGui());
      this.insertGridIntoDom();
      this.initialiseTabGuard({
        // we want to override the default behaviour to do nothing for onTabKeyDown
        onTabKeyDown: () => void 0,
        focusInnerElement: (fromBottom) => this.ctrl.focusInnerElement(fromBottom),
        forceFocusOutWhenTabGuardsAreEmpty: true
      });
    }
    insertGridIntoDom() {
      const eGui = this.getGui();
      this.eGridDiv.appendChild(eGui);
      this.addDestroyFunc(() => {
        this.eGridDiv.removeChild(eGui);
        this.logger.log("Grid removed from DOM");
      });
    }
    updateLayoutClasses(cssClass, params) {
      const eRootWrapperBodyClassList = this.eRootWrapperBody.classList;
      eRootWrapperBodyClassList.toggle("ag-layout-auto-height", params.autoHeight);
      eRootWrapperBodyClassList.toggle("ag-layout-normal", params.normal);
      eRootWrapperBodyClassList.toggle("ag-layout-print", params.print);
      this.addOrRemoveCssClass("ag-layout-auto-height", params.autoHeight);
      this.addOrRemoveCssClass("ag-layout-normal", params.normal);
      this.addOrRemoveCssClass("ag-layout-print", params.print);
    }
    createTemplate() {
      const dropZones = this.ctrl.showDropZones() ? "<ag-grid-header-drop-zones></ag-grid-header-drop-zones>" : "";
      const sideBar = this.ctrl.showSideBar() ? '<ag-side-bar ref="sideBar"></ag-side-bar>' : "";
      const statusBar = this.ctrl.showStatusBar() ? '<ag-status-bar ref="statusBar"></ag-status-bar>' : "";
      const watermark = this.ctrl.showWatermark() ? "<ag-watermark></ag-watermark>" : "";
      const template = (
        /* html */
        `<div class="ag-root-wrapper" role="presentation">
                ${dropZones}
                <div class="ag-root-wrapper-body" ref="rootWrapperBody" role="presentation">
                    <ag-grid-body ref="gridBody"></ag-grid-body>
                    ${sideBar}
                </div>
                ${statusBar}
                <ag-pagination></ag-pagination>
                ${watermark}
            </div>`
      );
      return template;
    }
    getFocusableElement() {
      return this.eRootWrapperBody;
    }
    getFocusableContainers() {
      const focusableContainers = [
        this.gridBodyComp.getGui()
      ];
      if (this.sideBarComp) {
        focusableContainers.push(
          this.sideBarComp.getGui()
        );
      }
      return focusableContainers.filter((el) => isVisible(el));
    }
  };
  __decorateClass([
    Autowired("loggerFactory")
  ], GridComp.prototype, "loggerFactory", 2);
  __decorateClass([
    RefSelector("gridBody")
  ], GridComp.prototype, "gridBodyComp", 2);
  __decorateClass([
    RefSelector("sideBar")
  ], GridComp.prototype, "sideBarComp", 2);
  __decorateClass([
    RefSelector("rootWrapperBody")
  ], GridComp.prototype, "eRootWrapperBody", 2);
  __decorateClass([
    PostConstruct
  ], GridComp.prototype, "postConstruct", 1);
  var SortController = class extends BeanStub {
    progressSort(column, multiSort, source) {
      const nextDirection = this.getNextSortDirection(column);
      this.setSortForColumn(column, nextDirection, multiSort, source);
    }
    setSortForColumn(column, sort, multiSort, source) {
      if (sort !== "asc" && sort !== "desc") {
        sort = null;
      }
      const isColumnsSortingCoupledToGroup = this.gos.isColumnsSortingCoupledToGroup();
      let columnsToUpdate = [column];
      if (isColumnsSortingCoupledToGroup) {
        if (column.getColDef().showRowGroup) {
          const rowGroupColumns = this.columnModel.getSourceColumnsForGroupColumn(column);
          const sortableRowGroupColumns = rowGroupColumns == null ? void 0 : rowGroupColumns.filter((col) => col.isSortable());
          if (sortableRowGroupColumns) {
            columnsToUpdate = [column, ...sortableRowGroupColumns];
          }
        }
      }
      columnsToUpdate.forEach((col) => col.setSort(sort, source));
      const doingMultiSort = (multiSort || this.gos.get("alwaysMultiSort")) && !this.gos.get("suppressMultiSort");
      const updatedColumns = [];
      if (!doingMultiSort) {
        const clearedColumns = this.clearSortBarTheseColumns(columnsToUpdate, source);
        updatedColumns.push(...clearedColumns);
      }
      this.updateSortIndex(column);
      updatedColumns.push(...columnsToUpdate);
      this.dispatchSortChangedEvents(source, updatedColumns);
    }
    updateSortIndex(lastColToChange) {
      const isCoupled = this.gos.isColumnsSortingCoupledToGroup();
      const groupParent = this.columnModel.getGroupDisplayColumnForGroup(lastColToChange.getId());
      const lastSortIndexCol = isCoupled ? groupParent || lastColToChange : lastColToChange;
      const allSortedCols = this.getColumnsWithSortingOrdered();
      this.columnModel.getPrimaryAndSecondaryAndAutoColumns().forEach((col) => col.setSortIndex(null));
      const allSortedColsWithoutChangesOrGroups = allSortedCols.filter((col) => {
        if (isCoupled && col.getColDef().showRowGroup) {
          return false;
        }
        return col !== lastSortIndexCol;
      });
      const sortedColsWithIndices = !!lastSortIndexCol.getSort() ? [...allSortedColsWithoutChangesOrGroups, lastSortIndexCol] : allSortedColsWithoutChangesOrGroups;
      sortedColsWithIndices.forEach((col, idx) => {
        col.setSortIndex(idx);
      });
    }
    // gets called by API, so if data changes, use can call this, which will end up
    // working out the sort order again of the rows.
    onSortChanged(source, columns) {
      this.dispatchSortChangedEvents(source, columns);
    }
    isSortActive() {
      const allCols = this.columnModel.getPrimaryAndSecondaryAndAutoColumns();
      const sortedCols = allCols.filter((column) => !!column.getSort());
      return sortedCols && sortedCols.length > 0;
    }
    dispatchSortChangedEvents(source, columns) {
      const event = {
        type: Events.EVENT_SORT_CHANGED,
        source
      };
      if (columns) {
        event.columns = columns;
      }
      this.eventService.dispatchEvent(event);
    }
    clearSortBarTheseColumns(columnsToSkip, source) {
      const clearedColumns = [];
      this.columnModel.getPrimaryAndSecondaryAndAutoColumns().forEach((columnToClear) => {
        if (!columnsToSkip.includes(columnToClear)) {
          if (!!columnToClear.getSort()) {
            clearedColumns.push(columnToClear);
          }
          columnToClear.setSort(void 0, source);
        }
      });
      return clearedColumns;
    }
    getNextSortDirection(column) {
      let sortingOrder;
      if (column.getColDef().sortingOrder) {
        sortingOrder = column.getColDef().sortingOrder;
      } else if (this.gos.get("sortingOrder")) {
        sortingOrder = this.gos.get("sortingOrder");
      } else {
        sortingOrder = SortController.DEFAULT_SORTING_ORDER;
      }
      if (!Array.isArray(sortingOrder) || sortingOrder.length <= 0) {
        console.warn(`AG Grid: sortingOrder must be an array with at least one element, currently it's ${sortingOrder}`);
        return null;
      }
      const currentIndex = sortingOrder.indexOf(column.getSort());
      const notInArray = currentIndex < 0;
      const lastItemInArray = currentIndex == sortingOrder.length - 1;
      let result;
      if (notInArray || lastItemInArray) {
        result = sortingOrder[0];
      } else {
        result = sortingOrder[currentIndex + 1];
      }
      if (SortController.DEFAULT_SORTING_ORDER.indexOf(result) < 0) {
        console.warn("AG Grid: invalid sort type " + result);
        return null;
      }
      return result;
    }
    /**
     * @returns a map of sort indexes for every sorted column, if groups sort primaries then they will have equivalent indices
     */
    getIndexedSortMap() {
      let allSortedCols = this.columnModel.getPrimaryAndSecondaryAndAutoColumns().filter((col) => !!col.getSort());
      if (this.columnModel.isPivotMode()) {
        const isSortingLinked = this.gos.isColumnsSortingCoupledToGroup();
        allSortedCols = allSortedCols.filter((col) => {
          const isAggregated = !!col.getAggFunc();
          const isSecondary = !col.isPrimary();
          const isGroup = isSortingLinked ? this.columnModel.getGroupDisplayColumnForGroup(col.getId()) : col.getColDef().showRowGroup;
          return isAggregated || isSecondary || isGroup;
        });
      }
      const sortedRowGroupCols = this.columnModel.getRowGroupColumns().filter((col) => !!col.getSort());
      const allColsIndexes = {};
      allSortedCols.forEach((col, index) => allColsIndexes[col.getId()] = index);
      allSortedCols.sort((a, b) => {
        const iA = a.getSortIndex();
        const iB = b.getSortIndex();
        if (iA != null && iB != null) {
          return iA - iB;
        } else if (iA == null && iB == null) {
          const posA = allColsIndexes[a.getId()];
          const posB = allColsIndexes[b.getId()];
          return posA > posB ? 1 : -1;
        } else if (iB == null) {
          return -1;
        } else {
          return 1;
        }
      });
      const isSortLinked = this.gos.isColumnsSortingCoupledToGroup() && !!sortedRowGroupCols.length;
      if (isSortLinked) {
        allSortedCols = [
          ...new Set(
            // if linked sorting, replace all columns with the display group column for index purposes, and ensure uniqueness
            allSortedCols.map((col) => {
              var _a;
              return (_a = this.columnModel.getGroupDisplayColumnForGroup(col.getId())) != null ? _a : col;
            })
          )
        ];
      }
      const indexMap = /* @__PURE__ */ new Map();
      allSortedCols.forEach((col, idx) => indexMap.set(col, idx));
      if (isSortLinked) {
        sortedRowGroupCols.forEach((col) => {
          const groupDisplayCol = this.columnModel.getGroupDisplayColumnForGroup(col.getId());
          indexMap.set(col, indexMap.get(groupDisplayCol));
        });
      }
      return indexMap;
    }
    getColumnsWithSortingOrdered() {
      return [...this.getIndexedSortMap().entries()].sort(([col1, idx1], [col2, idx2]) => idx1 - idx2).map(([col]) => col);
    }
    // used by server side row models, to sent sort to server
    getSortModel() {
      return this.getColumnsWithSortingOrdered().filter((column) => column.getSort()).map((column) => ({
        sort: column.getSort(),
        colId: column.getId()
      }));
    }
    getSortOptions() {
      return this.getColumnsWithSortingOrdered().filter((column) => column.getSort()).map((column) => ({
        sort: column.getSort(),
        column
      }));
    }
    canColumnDisplayMixedSort(column) {
      const isColumnSortCouplingActive = this.gos.isColumnsSortingCoupledToGroup();
      const isGroupDisplayColumn = !!column.getColDef().showRowGroup;
      return isColumnSortCouplingActive && isGroupDisplayColumn;
    }
    getDisplaySortForColumn(column) {
      const linkedColumns = this.columnModel.getSourceColumnsForGroupColumn(column);
      if (!this.canColumnDisplayMixedSort(column) || !(linkedColumns == null ? void 0 : linkedColumns.length)) {
        return column.getSort();
      }
      const columnHasUniqueData = column.getColDef().field != null || !!column.getColDef().valueGetter;
      const sortableColumns = columnHasUniqueData ? [column, ...linkedColumns] : linkedColumns;
      const firstSort = sortableColumns[0].getSort();
      const allMatch = sortableColumns.every((col) => col.getSort() == firstSort);
      if (!allMatch) {
        return "mixed";
      }
      return firstSort;
    }
    getDisplaySortIndexForColumn(column) {
      return this.getIndexedSortMap().get(column);
    }
  };
  SortController.DEFAULT_SORTING_ORDER = ["asc", "desc", null];
  __decorateClass([
    Autowired("columnModel")
  ], SortController.prototype, "columnModel", 2);
  SortController = __decorateClass([
    Bean("sortController")
  ], SortController);
  var FocusService = class extends BeanStub {
    static addKeyboardModeEvents(doc2) {
      if (this.instanceCount > 0) {
        return;
      }
      doc2.addEventListener("keydown", FocusService.toggleKeyboardMode);
      doc2.addEventListener("mousedown", FocusService.toggleKeyboardMode);
    }
    static removeKeyboardModeEvents(doc2) {
      if (this.instanceCount > 0)
        return;
      doc2.addEventListener("keydown", FocusService.toggleKeyboardMode);
      doc2.addEventListener("mousedown", FocusService.toggleKeyboardMode);
    }
    static toggleKeyboardMode(event) {
      const isKeyboardActive = FocusService.keyboardModeActive;
      const isKeyboardEvent2 = event.type === "keydown";
      if (isKeyboardEvent2) {
        if (event.ctrlKey || event.metaKey || event.altKey) {
          return;
        }
      }
      if (isKeyboardActive === isKeyboardEvent2) {
        return;
      }
      FocusService.keyboardModeActive = isKeyboardEvent2;
    }
    static unregisterGridCompController(doc2) {
      FocusService.removeKeyboardModeEvents(doc2);
    }
    init() {
      const clearFocusedCellListener = this.clearFocusedCell.bind(this);
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, clearFocusedCellListener);
      this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverythingChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_GROUP_OPENED, clearFocusedCellListener);
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, clearFocusedCellListener);
      this.registerKeyboardFocusEvents();
      this.ctrlsService.whenReady((p2) => {
        this.gridCtrl = p2.gridCtrl;
      });
    }
    registerKeyboardFocusEvents() {
      const eDocument = this.gos.getDocument();
      FocusService.addKeyboardModeEvents(eDocument);
      FocusService.instanceCount++;
      this.addDestroyFunc(() => {
        FocusService.instanceCount--;
        FocusService.unregisterGridCompController(eDocument);
      });
    }
    onColumnEverythingChanged() {
      if (!this.focusedCellPosition) {
        return;
      }
      const col = this.focusedCellPosition.column;
      const colFromColumnModel = this.columnModel.getGridColumn(col.getId());
      if (col !== colFromColumnModel) {
        this.clearFocusedCell();
      }
    }
    isKeyboardMode() {
      return FocusService.keyboardModeActive;
    }
    // we check if the browser is focusing something, and if it is, and
    // it's the cell we think is focused, then return the cell. so this
    // methods returns the cell if a) we think it has focus and b) the
    // browser thinks it has focus. this then returns nothing if we
    // first focus a cell, then second click outside the grid, as then the
    // grid cell will still be focused as far as the grid is concerned,
    // however the browser focus will have moved somewhere else.
    getFocusCellToUseAfterRefresh() {
      if (this.gos.get("suppressFocusAfterRefresh") || !this.focusedCellPosition) {
        return null;
      }
      if (this.isDomDataMissingInHierarchy(this.gos.getActiveDomElement(), RowCtrl.DOM_DATA_KEY_ROW_CTRL)) {
        return null;
      }
      return this.focusedCellPosition;
    }
    getFocusHeaderToUseAfterRefresh() {
      if (this.gos.get("suppressFocusAfterRefresh") || !this.focusedHeaderPosition) {
        return null;
      }
      if (this.isDomDataMissingInHierarchy(this.gos.getActiveDomElement(), AbstractHeaderCellCtrl.DOM_DATA_KEY_HEADER_CTRL)) {
        return null;
      }
      return this.focusedHeaderPosition;
    }
    isDomDataMissingInHierarchy(eBrowserCell, key) {
      let ePointer = eBrowserCell;
      while (ePointer) {
        const data = this.gos.getDomData(ePointer, key);
        if (data) {
          return false;
        }
        ePointer = ePointer.parentNode;
      }
      return true;
    }
    getFocusedCell() {
      return this.focusedCellPosition;
    }
    shouldRestoreFocus(cell) {
      if (this.isCellRestoreFocused(cell)) {
        setTimeout(() => {
          this.restoredFocusedCellPosition = null;
        }, 0);
        return true;
      }
      return false;
    }
    isCellRestoreFocused(cellPosition) {
      if (this.restoredFocusedCellPosition == null) {
        return false;
      }
      return this.cellPositionUtils.equals(cellPosition, this.restoredFocusedCellPosition);
    }
    setRestoreFocusedCell(cellPosition) {
      if (this.getFrameworkOverrides().renderingEngine === "react") {
        this.restoredFocusedCellPosition = cellPosition;
      }
    }
    getFocusEventParams() {
      const { rowIndex, rowPinned, column } = this.focusedCellPosition;
      const params = {
        rowIndex,
        rowPinned,
        column,
        isFullWidthCell: false
      };
      const rowCtrl = this.rowRenderer.getRowByPosition({ rowIndex, rowPinned });
      if (rowCtrl) {
        params.isFullWidthCell = rowCtrl.isFullWidth();
      }
      return params;
    }
    clearFocusedCell() {
      this.restoredFocusedCellPosition = null;
      if (this.focusedCellPosition == null) {
        return;
      }
      const event = __spreadValues({
        type: Events.EVENT_CELL_FOCUS_CLEARED
      }, this.getFocusEventParams());
      this.focusedCellPosition = null;
      this.eventService.dispatchEvent(event);
    }
    setFocusedCell(params) {
      const {
        column,
        rowIndex,
        rowPinned,
        forceBrowserFocus = false,
        preventScrollOnBrowserFocus = false
      } = params;
      const gridColumn = this.columnModel.getGridColumn(column);
      if (!gridColumn) {
        this.focusedCellPosition = null;
        return;
      }
      this.focusedCellPosition = gridColumn ? {
        rowIndex,
        rowPinned: makeNull(rowPinned),
        column: gridColumn
      } : null;
      const event = __spreadProps(__spreadValues({
        type: Events.EVENT_CELL_FOCUSED
      }, this.getFocusEventParams()), {
        forceBrowserFocus,
        preventScrollOnBrowserFocus,
        floating: null
      });
      this.eventService.dispatchEvent(event);
    }
    isCellFocused(cellPosition) {
      if (this.focusedCellPosition == null) {
        return false;
      }
      return this.cellPositionUtils.equals(cellPosition, this.focusedCellPosition);
    }
    isRowNodeFocused(rowNode) {
      return this.isRowFocused(rowNode.rowIndex, rowNode.rowPinned);
    }
    isHeaderWrapperFocused(headerCtrl) {
      if (this.focusedHeaderPosition == null) {
        return false;
      }
      const column = headerCtrl.getColumnGroupChild();
      const headerRowIndex = headerCtrl.getRowIndex();
      const pinned = headerCtrl.getPinned();
      const { column: focusedColumn, headerRowIndex: focusedHeaderRowIndex } = this.focusedHeaderPosition;
      return column === focusedColumn && headerRowIndex === focusedHeaderRowIndex && pinned == focusedColumn.getPinned();
    }
    clearFocusedHeader() {
      this.focusedHeaderPosition = null;
    }
    getFocusedHeader() {
      return this.focusedHeaderPosition;
    }
    setFocusedHeader(headerRowIndex, column) {
      this.focusedHeaderPosition = { headerRowIndex, column };
    }
    focusHeaderPosition(params) {
      if (this.gos.get("suppressHeaderFocus")) {
        return false;
      }
      const { direction, fromTab, allowUserOverride, event, fromCell, rowWithoutSpanValue } = params;
      let { headerPosition } = params;
      if (fromCell && this.filterManager.isAdvancedFilterHeaderActive()) {
        return this.focusAdvancedFilter(headerPosition);
      }
      if (allowUserOverride) {
        const currentPosition = this.getFocusedHeader();
        const headerRowCount = this.headerNavigationService.getHeaderRowCount();
        if (fromTab) {
          const userFunc = this.gos.getCallback("tabToNextHeader");
          if (userFunc) {
            headerPosition = this.getHeaderPositionFromUserFunc({
              userFunc,
              direction,
              currentPosition,
              headerPosition,
              headerRowCount
            });
          }
        } else {
          const userFunc = this.gos.getCallback("navigateToNextHeader");
          if (userFunc && event) {
            const params2 = {
              key: event.key,
              previousHeaderPosition: currentPosition,
              nextHeaderPosition: headerPosition,
              headerRowCount,
              event
            };
            headerPosition = userFunc(params2);
          }
        }
      }
      if (!headerPosition) {
        return false;
      }
      return this.focusProvidedHeaderPosition({
        headerPosition,
        direction,
        event,
        fromCell,
        rowWithoutSpanValue
      });
    }
    focusHeaderPositionFromUserFunc(params) {
      if (this.gos.get("suppressHeaderFocus")) {
        return false;
      }
      const { userFunc, headerPosition, direction, event } = params;
      const currentPosition = this.getFocusedHeader();
      const headerRowCount = this.headerNavigationService.getHeaderRowCount();
      const newHeaderPosition = this.getHeaderPositionFromUserFunc({
        userFunc,
        direction,
        currentPosition,
        headerPosition,
        headerRowCount
      });
      return !!newHeaderPosition && this.focusProvidedHeaderPosition({
        headerPosition: newHeaderPosition,
        direction,
        event
      });
    }
    getHeaderPositionFromUserFunc(params) {
      const { userFunc, direction, currentPosition, headerPosition, headerRowCount } = params;
      const userFuncParams = {
        backwards: direction === "Before",
        previousHeaderPosition: currentPosition,
        nextHeaderPosition: headerPosition,
        headerRowCount
      };
      const userResult = userFunc(userFuncParams);
      if (userResult === true || userResult === null) {
        if (userResult === null) {
          warnOnce("Returning `null` from tabToNextHeader is deprecated. Return `true` to stay on the current header, or `false` to let the browser handle the tab behaviour.");
        }
        return currentPosition;
      }
      if (userResult === false) {
        return null;
      }
      return userResult;
    }
    focusProvidedHeaderPosition(params) {
      const { headerPosition, direction, fromCell, rowWithoutSpanValue, event } = params;
      if (headerPosition.headerRowIndex === -1) {
        if (this.filterManager.isAdvancedFilterHeaderActive()) {
          return this.focusAdvancedFilter(headerPosition);
        }
        return this.focusGridView(headerPosition.column);
      }
      this.headerNavigationService.scrollToColumn(headerPosition.column, direction);
      const headerRowContainerCtrl = this.ctrlsService.getHeaderRowContainerCtrl(headerPosition.column.getPinned());
      const focusSuccess = headerRowContainerCtrl.focusHeader(headerPosition.headerRowIndex, headerPosition.column, event);
      if (focusSuccess && (rowWithoutSpanValue != null || fromCell)) {
        this.headerNavigationService.setCurrentHeaderRowWithoutSpan(rowWithoutSpanValue != null ? rowWithoutSpanValue : -1);
      }
      return focusSuccess;
    }
    focusFirstHeader() {
      let firstColumn = this.columnModel.getAllDisplayedColumns()[0];
      if (!firstColumn) {
        return false;
      }
      if (firstColumn.getParent()) {
        firstColumn = this.columnModel.getColumnGroupAtLevel(firstColumn, 0);
      }
      const headerPosition = this.headerPositionUtils.getHeaderIndexToFocus(firstColumn, 0);
      return this.focusHeaderPosition({
        headerPosition,
        rowWithoutSpanValue: 0
      });
    }
    focusLastHeader(event) {
      const headerRowIndex = this.headerNavigationService.getHeaderRowCount() - 1;
      const column = last(this.columnModel.getAllDisplayedColumns());
      return this.focusHeaderPosition({
        headerPosition: { headerRowIndex, column },
        rowWithoutSpanValue: -1,
        event
      });
    }
    focusPreviousFromFirstCell(event) {
      if (this.filterManager.isAdvancedFilterHeaderActive()) {
        return this.focusAdvancedFilter(null);
      }
      return this.focusLastHeader(event);
    }
    isAnyCellFocused() {
      return !!this.focusedCellPosition;
    }
    isRowFocused(rowIndex, floating) {
      if (this.focusedCellPosition == null) {
        return false;
      }
      return this.focusedCellPosition.rowIndex === rowIndex && this.focusedCellPosition.rowPinned === makeNull(floating);
    }
    findFocusableElements(rootNode, exclude, onlyUnmanaged = false) {
      const focusableString = FOCUSABLE_SELECTOR;
      let excludeString = FOCUSABLE_EXCLUDE;
      if (exclude) {
        excludeString += ", " + exclude;
      }
      if (onlyUnmanaged) {
        excludeString += ', [tabindex="-1"]';
      }
      const nodes = Array.prototype.slice.apply(rootNode.querySelectorAll(focusableString)).filter((node) => {
        return isVisible(node);
      });
      const excludeNodes = Array.prototype.slice.apply(rootNode.querySelectorAll(excludeString));
      if (!excludeNodes.length) {
        return nodes;
      }
      const diff = (a, b) => a.filter((element) => b.indexOf(element) === -1);
      return diff(nodes, excludeNodes);
    }
    focusInto(rootNode, up = false, onlyUnmanaged = false) {
      const focusableElements = this.findFocusableElements(rootNode, null, onlyUnmanaged);
      const toFocus = up ? last(focusableElements) : focusableElements[0];
      if (toFocus) {
        toFocus.focus({ preventScroll: true });
        return true;
      }
      return false;
    }
    findFocusableElementBeforeTabGuard(rootNode, referenceElement) {
      if (!referenceElement) {
        return null;
      }
      const focusableElements = this.findFocusableElements(rootNode);
      const referenceIndex = focusableElements.indexOf(referenceElement);
      if (referenceIndex === -1) {
        return null;
      }
      let lastTabGuardIndex = -1;
      for (let i = referenceIndex - 1; i >= 0; i--) {
        if (focusableElements[i].classList.contains(
          "ag-tab-guard-top"
          /* TAB_GUARD_TOP */
        )) {
          lastTabGuardIndex = i;
          break;
        }
      }
      if (lastTabGuardIndex <= 0) {
        return null;
      }
      return focusableElements[lastTabGuardIndex - 1];
    }
    findNextFocusableElement(rootNode = this.eGridDiv, onlyManaged, backwards) {
      const focusable = this.findFocusableElements(rootNode, onlyManaged ? ':not([tabindex="-1"])' : null);
      const activeEl = this.gos.getActiveDomElement();
      let currentIndex;
      if (onlyManaged) {
        currentIndex = focusable.findIndex((el) => el.contains(activeEl));
      } else {
        currentIndex = focusable.indexOf(activeEl);
      }
      const nextIndex = currentIndex + (backwards ? -1 : 1);
      if (nextIndex < 0 || nextIndex >= focusable.length) {
        return null;
      }
      return focusable[nextIndex];
    }
    isTargetUnderManagedComponent(rootNode, target) {
      if (!target) {
        return false;
      }
      const managedContainers = rootNode.querySelectorAll(`.${ManagedFocusFeature.FOCUS_MANAGED_CLASS}`);
      if (!managedContainers.length) {
        return false;
      }
      for (let i = 0; i < managedContainers.length; i++) {
        if (managedContainers[i].contains(target)) {
          return true;
        }
      }
      return false;
    }
    findTabbableParent(node, limit = 5) {
      let counter = 0;
      while (node && getTabIndex(node) === null && ++counter <= limit) {
        node = node.parentElement;
      }
      if (getTabIndex(node) === null) {
        return null;
      }
      return node;
    }
    focusGridView(column, backwards) {
      var _a;
      if (this.gos.get("suppressCellFocus")) {
        if (backwards) {
          if (!this.gos.get("suppressHeaderFocus")) {
            return this.focusLastHeader();
          }
          return this.focusNextGridCoreContainer(true, true);
        }
        return this.focusNextGridCoreContainer(false);
      }
      const nextRow = backwards ? this.rowPositionUtils.getLastRow() : this.rowPositionUtils.getFirstRow();
      if (!nextRow) {
        return false;
      }
      const { rowIndex, rowPinned } = nextRow;
      const focusedHeader = this.getFocusedHeader();
      if (!column && focusedHeader) {
        column = focusedHeader.column;
      }
      if (rowIndex == null || !column) {
        return false;
      }
      this.navigationService.ensureCellVisible({ rowIndex, column, rowPinned });
      this.setFocusedCell({
        rowIndex,
        column,
        rowPinned: makeNull(rowPinned),
        forceBrowserFocus: true
      });
      (_a = this.rangeService) == null ? void 0 : _a.setRangeToCell({ rowIndex, rowPinned, column });
      return true;
    }
    focusNextGridCoreContainer(backwards, forceOut = false) {
      if (!forceOut && this.gridCtrl.focusNextInnerContainer(backwards)) {
        return true;
      }
      if (forceOut || !backwards && !this.gridCtrl.isDetailGrid()) {
        this.gridCtrl.forceFocusOutOfContainer(backwards);
      }
      return false;
    }
    focusAdvancedFilter(position) {
      var _a, _b;
      this.advancedFilterFocusColumn = position == null ? void 0 : position.column;
      return (_b = (_a = this.advancedFilterService) == null ? void 0 : _a.getCtrl().focusHeaderComp()) != null ? _b : false;
    }
    focusNextFromAdvancedFilter(backwards, forceFirstColumn) {
      var _a, _b;
      const column = (_b = forceFirstColumn ? void 0 : this.advancedFilterFocusColumn) != null ? _b : (_a = this.columnModel.getAllDisplayedColumns()) == null ? void 0 : _a[0];
      if (backwards) {
        return this.focusHeaderPosition({
          headerPosition: {
            column,
            headerRowIndex: this.headerNavigationService.getHeaderRowCount() - 1
          }
        });
      } else {
        return this.focusGridView(column);
      }
    }
    clearAdvancedFilterColumn() {
      this.advancedFilterFocusColumn = void 0;
    }
  };
  FocusService.keyboardModeActive = false;
  FocusService.instanceCount = 0;
  __decorateClass([
    Autowired("eGridDiv")
  ], FocusService.prototype, "eGridDiv", 2);
  __decorateClass([
    Autowired("columnModel")
  ], FocusService.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("headerNavigationService")
  ], FocusService.prototype, "headerNavigationService", 2);
  __decorateClass([
    Autowired("headerPositionUtils")
  ], FocusService.prototype, "headerPositionUtils", 2);
  __decorateClass([
    Autowired("rowRenderer")
  ], FocusService.prototype, "rowRenderer", 2);
  __decorateClass([
    Autowired("rowPositionUtils")
  ], FocusService.prototype, "rowPositionUtils", 2);
  __decorateClass([
    Autowired("cellPositionUtils")
  ], FocusService.prototype, "cellPositionUtils", 2);
  __decorateClass([
    Autowired("navigationService")
  ], FocusService.prototype, "navigationService", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], FocusService.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("filterManager")
  ], FocusService.prototype, "filterManager", 2);
  __decorateClass([
    Optional("rangeService")
  ], FocusService.prototype, "rangeService", 2);
  __decorateClass([
    Optional("advancedFilterService")
  ], FocusService.prototype, "advancedFilterService", 2);
  __decorateClass([
    PostConstruct
  ], FocusService.prototype, "init", 1);
  FocusService = __decorateClass([
    Bean("focusService")
  ], FocusService);
  var ColumnHoverService = class extends BeanStub {
    setMouseOver(columns) {
      this.selectedColumns = columns;
      const event = {
        type: Events.EVENT_COLUMN_HOVER_CHANGED
      };
      this.eventService.dispatchEvent(event);
    }
    clearMouseOver() {
      this.selectedColumns = null;
      const event = {
        type: Events.EVENT_COLUMN_HOVER_CHANGED
      };
      this.eventService.dispatchEvent(event);
    }
    isHovered(column) {
      return !!this.selectedColumns && this.selectedColumns.indexOf(column) >= 0;
    }
  };
  ColumnHoverService = __decorateClass([
    Bean("columnHoverService")
  ], ColumnHoverService);
  var ColumnAnimationService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.executeNextFuncs = [];
      this.executeLaterFuncs = [];
      this.active = false;
      this.suppressAnimation = false;
      this.animationThreadCount = 0;
    }
    postConstruct() {
      this.ctrlsService.whenReady((p2) => this.gridBodyCtrl = p2.gridBodyCtrl);
    }
    isActive() {
      return this.active && !this.suppressAnimation;
    }
    setSuppressAnimation(suppress) {
      this.suppressAnimation = suppress;
    }
    start() {
      if (this.active) {
        return;
      }
      if (this.gos.get("suppressColumnMoveAnimation")) {
        return;
      }
      if (this.gos.get("enableRtl")) {
        return;
      }
      this.ensureAnimationCssClassPresent();
      this.active = true;
    }
    finish() {
      if (!this.active) {
        return;
      }
      this.flush(() => {
        this.active = false;
      });
    }
    executeNextVMTurn(func) {
      if (this.active) {
        this.executeNextFuncs.push(func);
      } else {
        func();
      }
    }
    executeLaterVMTurn(func) {
      if (this.active) {
        this.executeLaterFuncs.push(func);
      } else {
        func();
      }
    }
    ensureAnimationCssClassPresent() {
      this.animationThreadCount++;
      const animationThreadCountCopy = this.animationThreadCount;
      this.gridBodyCtrl.setColumnMovingCss(true);
      this.executeLaterFuncs.push(() => {
        if (this.animationThreadCount === animationThreadCountCopy) {
          this.gridBodyCtrl.setColumnMovingCss(false);
        }
      });
    }
    flush(callback) {
      if (this.executeNextFuncs.length === 0 && this.executeLaterFuncs.length === 0) {
        callback();
        return;
      }
      const runFuncs = (queue2) => {
        while (queue2.length) {
          const func = queue2.pop();
          if (func) {
            func();
          }
        }
      };
      this.getFrameworkOverrides().wrapIncoming(() => {
        window.setTimeout(() => runFuncs(this.executeNextFuncs), 0);
        window.setTimeout(() => {
          callback();
          runFuncs(this.executeLaterFuncs);
        }, 200);
      });
    }
  };
  __decorateClass([
    Autowired("ctrlsService")
  ], ColumnAnimationService.prototype, "ctrlsService", 2);
  __decorateClass([
    PostConstruct
  ], ColumnAnimationService.prototype, "postConstruct", 1);
  ColumnAnimationService = __decorateClass([
    Bean("columnAnimationService")
  ], ColumnAnimationService);
  var PaginationAutoPageSizeService = class extends BeanStub {
    postConstruct() {
      this.ctrlsService.whenReady((p2) => {
        this.centerRowsCtrl = p2.center;
        this.addManagedListener(this.eventService, Events.EVENT_BODY_HEIGHT_CHANGED, this.checkPageSize.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_SCROLL_VISIBILITY_CHANGED, this.checkPageSize.bind(this));
        this.addManagedPropertyListener("paginationAutoPageSize", this.onPaginationAutoSizeChanged.bind(this));
        this.checkPageSize();
      });
    }
    notActive() {
      return !this.gos.get("paginationAutoPageSize") || this.centerRowsCtrl == null;
    }
    onPaginationAutoSizeChanged() {
      if (this.notActive()) {
        this.paginationProxy.unsetAutoCalculatedPageSize();
      } else {
        this.checkPageSize();
      }
    }
    checkPageSize() {
      if (this.notActive()) {
        return;
      }
      const bodyHeight = this.centerRowsCtrl.getViewportSizeFeature().getBodyHeight();
      if (bodyHeight > 0) {
        const update = () => {
          const rowHeight = this.gos.getRowHeightAsNumber();
          const newPageSize = Math.floor(bodyHeight / rowHeight);
          this.paginationProxy.setPageSize(newPageSize, "autoCalculated");
        };
        if (!this.isBodyRendered) {
          update();
          this.isBodyRendered = true;
        } else {
          debounce2(() => update(), 50)();
        }
      } else {
        this.isBodyRendered = false;
      }
    }
  };
  __decorateClass([
    Autowired("ctrlsService")
  ], PaginationAutoPageSizeService.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("paginationProxy")
  ], PaginationAutoPageSizeService.prototype, "paginationProxy", 2);
  __decorateClass([
    PostConstruct
  ], PaginationAutoPageSizeService.prototype, "postConstruct", 1);
  PaginationAutoPageSizeService = __decorateClass([
    Bean("paginationAutoPageSizeService")
  ], PaginationAutoPageSizeService);
  var ValueCache = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.cacheVersion = 0;
    }
    init() {
      this.active = this.gos.get("valueCache");
      this.neverExpires = this.gos.get("valueCacheNeverExpires");
    }
    onDataChanged() {
      if (this.neverExpires) {
        return;
      }
      this.expire();
    }
    expire() {
      this.cacheVersion++;
    }
    setValue(rowNode, colId, value) {
      if (this.active) {
        if (rowNode.__cacheVersion !== this.cacheVersion) {
          rowNode.__cacheVersion = this.cacheVersion;
          rowNode.__cacheData = {};
        }
        rowNode.__cacheData[colId] = value;
      }
    }
    getValue(rowNode, colId) {
      if (!this.active || rowNode.__cacheVersion !== this.cacheVersion) {
        return void 0;
      }
      return rowNode.__cacheData[colId];
    }
  };
  __decorateClass([
    PostConstruct
  ], ValueCache.prototype, "init", 1);
  ValueCache = __decorateClass([
    Bean("valueCache")
  ], ValueCache);
  var SOURCE_PASTE = "paste";
  var ChangeDetectionService = class extends BeanStub {
    init() {
      if (this.rowModel.getType() === "clientSide") {
        this.clientSideRowModel = this.rowModel;
      }
      this.addManagedListener(this.eventService, Events.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged.bind(this));
    }
    onCellValueChanged(event) {
      if (event.source === SOURCE_PASTE) {
        return;
      }
      this.doChangeDetection(event.node, event.column);
    }
    doChangeDetection(rowNode, column) {
      if (this.gos.get("suppressChangeDetection")) {
        return;
      }
      const nodesToRefresh = [rowNode];
      if (this.clientSideRowModel && !rowNode.isRowPinned()) {
        const onlyChangedColumns = this.gos.get("aggregateOnlyChangedColumns");
        const changedPath = new ChangedPath(onlyChangedColumns, this.clientSideRowModel.getRootNode());
        changedPath.addParentNode(rowNode.parent, [column]);
        this.clientSideRowModel.doAggregate(changedPath);
        changedPath.forEachChangedNodeDepthFirst((rowNode2) => {
          nodesToRefresh.push(rowNode2);
        });
      }
      this.rowRenderer.refreshCells({ rowNodes: nodesToRefresh });
    }
  };
  __decorateClass([
    Autowired("rowModel")
  ], ChangeDetectionService.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("rowRenderer")
  ], ChangeDetectionService.prototype, "rowRenderer", 2);
  __decorateClass([
    PostConstruct
  ], ChangeDetectionService.prototype, "init", 1);
  ChangeDetectionService = __decorateClass([
    Bean("changeDetectionService")
  ], ChangeDetectionService);
  var AgComponentUtils = class extends BeanStub {
    adaptFunction(propertyName, jsCompFunc) {
      const metadata = this.componentMetadataProvider.retrieve(propertyName);
      if (metadata && metadata.functionAdapter) {
        return metadata.functionAdapter(jsCompFunc);
      }
      return null;
    }
    adaptCellRendererFunction(callback) {
      class Adapter {
        refresh(params) {
          return false;
        }
        getGui() {
          return this.eGui;
        }
        init(params) {
          const callbackResult = callback(params);
          const type = typeof callbackResult;
          if (type === "string" || type === "number" || type === "boolean") {
            this.eGui = loadTemplate("<span>" + callbackResult + "</span>");
            return;
          }
          if (callbackResult == null) {
            this.eGui = loadTemplate("<span></span>");
            return;
          }
          this.eGui = callbackResult;
        }
      }
      return Adapter;
    }
    doesImplementIComponent(candidate) {
      if (!candidate) {
        return false;
      }
      return candidate.prototype && "getGui" in candidate.prototype;
    }
  };
  __decorateClass([
    Autowired("componentMetadataProvider")
  ], AgComponentUtils.prototype, "componentMetadataProvider", 2);
  AgComponentUtils = __decorateClass([
    Bean("agComponentUtils")
  ], AgComponentUtils);
  var ComponentMetadataProvider = class extends BeanStub {
    postConstruct() {
      this.componentMetaData = {
        dateComponent: {
          mandatoryMethodList: ["getDate", "setDate"],
          optionalMethodList: ["afterGuiAttached", "setInputPlaceholder", "setInputAriaLabel", "setDisabled", "onParamsUpdated", "refresh"]
        },
        detailCellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        headerComponent: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh"]
        },
        headerGroupComponent: {
          mandatoryMethodList: [],
          optionalMethodList: []
        },
        loadingCellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: [],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        loadingOverlayComponent: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh"]
        },
        noRowsOverlayComponent: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh"]
        },
        floatingFilterComponent: {
          mandatoryMethodList: ["onParentModelChanged"],
          optionalMethodList: ["afterGuiAttached", "onParamsUpdated", "refresh"]
        },
        cellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh", "afterGuiAttached"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        cellEditor: {
          mandatoryMethodList: ["getValue"],
          optionalMethodList: ["isPopup", "isCancelBeforeStart", "isCancelAfterEnd", "getPopupPosition", "focusIn", "focusOut", "afterGuiAttached", "refresh"]
        },
        innerRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["afterGuiAttached"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        fullWidthCellRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh", "afterGuiAttached"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        groupRowRenderer: {
          mandatoryMethodList: [],
          optionalMethodList: ["afterGuiAttached"],
          functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
        },
        filter: {
          mandatoryMethodList: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
          optionalMethodList: ["afterGuiAttached", "afterGuiDetached", "onNewRowsLoaded", "getModelAsString", "onFloatingFilterChanged", "onAnyFilterChanged", "refresh"]
        },
        statusPanel: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh"]
        },
        toolPanel: {
          mandatoryMethodList: [],
          optionalMethodList: ["refresh", "getState"]
        },
        tooltipComponent: {
          mandatoryMethodList: [],
          optionalMethodList: []
        },
        menuItem: {
          mandatoryMethodList: [],
          optionalMethodList: ["setActive", "select", "setExpanded", "configureDefaults"]
        }
      };
    }
    retrieve(name) {
      return this.componentMetaData[name];
    }
  };
  __decorateClass([
    Autowired("agComponentUtils")
  ], ComponentMetadataProvider.prototype, "agComponentUtils", 2);
  __decorateClass([
    PostConstruct
  ], ComponentMetadataProvider.prototype, "postConstruct", 1);
  ComponentMetadataProvider = __decorateClass([
    Bean("componentMetadataProvider")
  ], ComponentMetadataProvider);
  var DEFAULT_ROW_HEIGHT = 25;
  var MIN_COL_WIDTH = 10;
  var MAT_GRID_SIZE = 8;
  var BASE_GRID_SIZE = 4;
  var BALHAM_GRID_SIZE = 4;
  var ALPINE_GRID_SIZE = 6;
  var QUARTZ_ICON_SIZE = 16;
  var QUARTZ_FONT_SIZE = 14;
  var QUARTZ_GRID_SIZE = 8;
  var HARD_CODED_SIZES = {
    // this item is required for custom themes
    "ag-theme-custom": {
      headerHeight: 25,
      headerCellMinWidth: 24,
      listItemHeight: BASE_GRID_SIZE * 5,
      rowHeight: 25,
      chartMenuPanelWidth: 220
    },
    "ag-theme-material": {
      headerHeight: MAT_GRID_SIZE * 7,
      headerCellMinWidth: 48,
      listItemHeight: MAT_GRID_SIZE * 4,
      rowHeight: MAT_GRID_SIZE * 6,
      chartMenuPanelWidth: 240
    },
    "ag-theme-balham": {
      headerHeight: BALHAM_GRID_SIZE * 8,
      headerCellMinWidth: 24,
      listItemHeight: BALHAM_GRID_SIZE * 6,
      rowHeight: BALHAM_GRID_SIZE * 7,
      chartMenuPanelWidth: 220
    },
    "ag-theme-alpine": {
      headerHeight: ALPINE_GRID_SIZE * 8,
      headerCellMinWidth: 36,
      listItemHeight: ALPINE_GRID_SIZE * 4,
      rowHeight: ALPINE_GRID_SIZE * 7,
      chartMenuPanelWidth: 240
    },
    "ag-theme-quartz": {
      headerHeight: QUARTZ_FONT_SIZE + QUARTZ_GRID_SIZE * 4.25,
      headerCellMinWidth: 36,
      listItemHeight: QUARTZ_ICON_SIZE + QUARTZ_GRID_SIZE,
      rowHeight: QUARTZ_FONT_SIZE + QUARTZ_GRID_SIZE * 3.5,
      chartMenuPanelWidth: 260
    }
  };
  var SASS_PROPERTY_BUILDER = {
    headerHeight: ["ag-header-row"],
    headerCellMinWidth: ["ag-header-cell"],
    listItemHeight: ["ag-virtual-list-item"],
    rowHeight: ["ag-row"],
    chartMenuPanelWidth: ["ag-chart-docked-container"]
  };
  var Environment = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.calculatedSizes = {};
      this.calculatedTheme = null;
    }
    postConstruct() {
      var _a;
      const el = (_a = this.getTheme().el) != null ? _a : this.eGridDiv;
      this.addManagedPropertyListener("rowHeight", () => this.refreshRowHeightVariable());
      this.mutationObserver = new MutationObserver(() => {
        this.calculatedSizes = {};
        this.calculatedTheme = null;
        this.calculatedTheme = this.getTheme();
        this.fireGridStylesChangedEvent();
      });
      this.mutationObserver.observe(el || this.eGridDiv, {
        attributes: true,
        attributeFilter: ["class"]
      });
    }
    fireGridStylesChangedEvent() {
      const event = {
        type: Events.EVENT_GRID_STYLES_CHANGED
      };
      this.eventService.dispatchEvent(event);
    }
    getSassVariable(key) {
      const { themeFamily, el } = this.getTheme();
      if (!themeFamily || themeFamily.indexOf("ag-theme") !== 0) {
        return;
      }
      if (!this.calculatedSizes) {
        this.calculatedSizes = {};
      }
      if (!this.calculatedSizes[themeFamily]) {
        this.calculatedSizes[themeFamily] = {};
      }
      const size2 = this.calculatedSizes[themeFamily][key];
      if (size2 != null) {
        return size2;
      }
      this.calculatedSizes[themeFamily][key] = this.calculateValueForSassProperty(key, themeFamily, el);
      return this.calculatedSizes[themeFamily][key];
    }
    calculateValueForSassProperty(property, theme, themeElement) {
      const useTheme = "ag-theme-" + (theme.match("material") ? "material" : theme.match("balham") ? "balham" : theme.match("alpine") ? "alpine" : "custom");
      const defaultValue = HARD_CODED_SIZES[useTheme][property];
      const eDocument = this.gos.getDocument();
      if (!themeElement) {
        themeElement = this.eGridDiv;
      }
      if (!SASS_PROPERTY_BUILDER[property]) {
        return defaultValue;
      }
      const classList = SASS_PROPERTY_BUILDER[property];
      const div = eDocument.createElement("div");
      const classesFromThemeElement = Array.from(themeElement.classList);
      div.classList.add(theme, ...classesFromThemeElement);
      div.style.position = "absolute";
      const el = classList.reduce((prevEl, currentClass) => {
        const currentDiv = eDocument.createElement("div");
        currentDiv.style.position = "static";
        currentDiv.classList.add(currentClass);
        prevEl.appendChild(currentDiv);
        return currentDiv;
      }, div);
      let calculatedValue = 0;
      if (eDocument.body) {
        eDocument.body.appendChild(div);
        const sizeName = property.toLowerCase().indexOf("height") !== -1 ? "height" : "width";
        calculatedValue = parseInt(window.getComputedStyle(el)[sizeName], 10);
        eDocument.body.removeChild(div);
      }
      return calculatedValue || defaultValue;
    }
    isThemeDark() {
      const { theme } = this.getTheme();
      return !!theme && theme.indexOf("dark") >= 0;
    }
    chartMenuPanelWidth() {
      return this.getSassVariable("chartMenuPanelWidth");
    }
    getTheme() {
      if (this.calculatedTheme) {
        return this.calculatedTheme;
      }
      const reg = /\bag-(material|(?:theme-([\w\-]*)))\b/g;
      let el = this.eGridDiv;
      let themeMatch = null;
      let allThemes = [];
      while (el) {
        themeMatch = reg.exec(el.className);
        if (!themeMatch) {
          el = el.parentElement || void 0;
        } else {
          const matched = el.className.match(reg);
          if (matched) {
            allThemes = matched;
          }
          break;
        }
      }
      if (!themeMatch) {
        return { allThemes };
      }
      const theme = themeMatch[0];
      this.calculatedTheme = { theme, el, themeFamily: theme.replace(/-dark$/, ""), allThemes };
      return this.calculatedTheme;
    }
    getFromTheme(defaultValue, sassVariableName) {
      var _a;
      return (_a = this.getSassVariable(sassVariableName)) != null ? _a : defaultValue;
    }
    getDefaultRowHeight() {
      return this.getFromTheme(DEFAULT_ROW_HEIGHT, "rowHeight");
    }
    getListItemHeight() {
      return this.getFromTheme(20, "listItemHeight");
    }
    refreshRowHeightVariable() {
      const oldRowHeight = this.eGridDiv.style.getPropertyValue("--ag-line-height").trim();
      const height = this.gos.get("rowHeight");
      if (height == null || isNaN(height) || !isFinite(height)) {
        if (oldRowHeight !== null) {
          this.eGridDiv.style.setProperty("--ag-line-height", null);
        }
        return -1;
      }
      const newRowHeight = `${height}px`;
      if (oldRowHeight != newRowHeight) {
        this.eGridDiv.style.setProperty("--ag-line-height", newRowHeight);
        return height;
      }
      return oldRowHeight != "" ? parseFloat(oldRowHeight) : -1;
    }
    getMinColWidth() {
      const measuredMin = this.getFromTheme(null, "headerCellMinWidth");
      return exists(measuredMin) ? Math.max(measuredMin, MIN_COL_WIDTH) : MIN_COL_WIDTH;
    }
    destroy() {
      this.calculatedSizes = null;
      if (this.mutationObserver) {
        this.mutationObserver.disconnect();
      }
      super.destroy();
    }
  };
  __decorateClass([
    Autowired("eGridDiv")
  ], Environment.prototype, "eGridDiv", 2);
  __decorateClass([
    PostConstruct
  ], Environment.prototype, "postConstruct", 1);
  Environment = __decorateClass([
    Bean("environment")
  ], Environment);
  var RowContainerHeightService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.scrollY = 0;
      this.uiBodyHeight = 0;
    }
    agWire(loggerFactory) {
      this.logger = loggerFactory.create("RowContainerHeightService");
    }
    postConstruct() {
      this.addManagedListener(this.eventService, Events.EVENT_BODY_HEIGHT_CHANGED, this.updateOffset.bind(this));
      this.maxDivHeight = getMaxDivHeight();
      this.logger.log("maxDivHeight = " + this.maxDivHeight);
    }
    isStretching() {
      return this.stretching;
    }
    getDivStretchOffset() {
      return this.divStretchOffset;
    }
    updateOffset() {
      if (!this.stretching) {
        return;
      }
      const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
      const newScrollY = gridBodyCon.getScrollFeature().getVScrollPosition().top;
      const newBodyHeight = this.getUiBodyHeight();
      const atLeastOneChanged = newScrollY !== this.scrollY || newBodyHeight !== this.uiBodyHeight;
      if (atLeastOneChanged) {
        this.scrollY = newScrollY;
        this.uiBodyHeight = newBodyHeight;
        this.calculateOffset();
      }
    }
    calculateOffset() {
      this.setUiContainerHeight(this.maxDivHeight);
      this.pixelsToShave = this.modelHeight - this.uiContainerHeight;
      this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
      const scrollPercent = this.scrollY / this.maxScrollY;
      const divStretchOffset = scrollPercent * this.pixelsToShave;
      this.logger.log(`Div Stretch Offset = ${divStretchOffset} (${this.pixelsToShave} * ${scrollPercent})`);
      this.setDivStretchOffset(divStretchOffset);
    }
    setUiContainerHeight(height) {
      if (height !== this.uiContainerHeight) {
        this.uiContainerHeight = height;
        this.eventService.dispatchEvent({ type: Events.EVENT_ROW_CONTAINER_HEIGHT_CHANGED });
      }
    }
    clearOffset() {
      this.setUiContainerHeight(this.modelHeight);
      this.pixelsToShave = 0;
      this.setDivStretchOffset(0);
    }
    setDivStretchOffset(newOffset) {
      const newOffsetFloor = typeof newOffset === "number" ? Math.floor(newOffset) : null;
      if (this.divStretchOffset === newOffsetFloor) {
        return;
      }
      this.divStretchOffset = newOffsetFloor;
      this.eventService.dispatchEvent({ type: Events.EVENT_HEIGHT_SCALE_CHANGED });
    }
    setModelHeight(modelHeight) {
      this.modelHeight = modelHeight;
      this.stretching = modelHeight != null && this.maxDivHeight > 0 && modelHeight > this.maxDivHeight;
      if (this.stretching) {
        this.calculateOffset();
      } else {
        this.clearOffset();
      }
    }
    getUiContainerHeight() {
      return this.uiContainerHeight;
    }
    getRealPixelPosition(modelPixel) {
      return modelPixel - this.divStretchOffset;
    }
    getUiBodyHeight() {
      const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
      const pos = gridBodyCon.getScrollFeature().getVScrollPosition();
      return pos.bottom - pos.top;
    }
    getScrollPositionForPixel(rowTop) {
      if (this.pixelsToShave <= 0) {
        return rowTop;
      }
      const modelMaxScroll = this.modelHeight - this.getUiBodyHeight();
      const scrollPercent = rowTop / modelMaxScroll;
      const scrollPixel = this.maxScrollY * scrollPercent;
      return scrollPixel;
    }
  };
  __decorateClass([
    Autowired("ctrlsService")
  ], RowContainerHeightService.prototype, "ctrlsService", 2);
  __decorateClass([
    __decorateParam(0, Qualifier("loggerFactory"))
  ], RowContainerHeightService.prototype, "agWire", 1);
  __decorateClass([
    PostConstruct
  ], RowContainerHeightService.prototype, "postConstruct", 1);
  RowContainerHeightService = __decorateClass([
    Bean("rowContainerHeightService")
  ], RowContainerHeightService);
  var SelectableService = class extends BeanStub {
    init() {
      this.addManagedPropertyListener("isRowSelectable", () => this.updateSelectable());
    }
    /**
     * Used by CSRM only, to update selectable state after group state changes.
     */
    updateSelectableAfterGrouping() {
      this.updateSelectable(true);
    }
    updateSelectable(skipLeafNodes = false) {
      const isRowSelecting = !!this.gos.get("rowSelection");
      const isRowSelectable = this.gos.get("isRowSelectable");
      if (!isRowSelecting || !isRowSelectable) {
        return;
      }
      const isGroupSelectsChildren = this.gos.get("groupSelectsChildren");
      const isCsrmGroupSelectsChildren = this.rowModel.getType() === "clientSide" && isGroupSelectsChildren;
      const nodesToDeselect = [];
      const nodeCallback = (node) => {
        if (skipLeafNodes && !node.group) {
          return;
        }
        if (isCsrmGroupSelectsChildren && node.group) {
          const hasSelectableChild = node.childrenAfterGroup.some((rowNode) => rowNode.selectable === true);
          node.setRowSelectable(hasSelectableChild, true);
          return;
        }
        const rowSelectable = isRowSelectable ? isRowSelectable(node) : true;
        node.setRowSelectable(rowSelectable, true);
        if (!rowSelectable && node.isSelected()) {
          nodesToDeselect.push(node);
        }
      };
      if (isCsrmGroupSelectsChildren) {
        const csrm = this.rowModel;
        const changedPath = new ChangedPath(false, csrm.getRootNode());
        changedPath.forEachChangedNodeDepthFirst(nodeCallback, true, true);
      } else {
        this.rowModel.forEachNode(nodeCallback);
      }
      if (nodesToDeselect.length) {
        this.selectionService.setNodesSelected({ nodes: nodesToDeselect, newValue: false, source: "selectableChanged" });
      }
      if (isCsrmGroupSelectsChildren && this.selectionService instanceof SelectionService) {
        this.selectionService.updateGroupsFromChildrenSelections("selectableChanged");
      }
    }
  };
  __decorateClass([
    Autowired("rowModel")
  ], SelectableService.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("selectionService")
  ], SelectableService.prototype, "selectionService", 2);
  __decorateClass([
    PostConstruct
  ], SelectableService.prototype, "init", 1);
  SelectableService = __decorateClass([
    Bean("selectableService")
  ], SelectableService);
  var PaginationComp = class extends Component {
    constructor() {
      super();
      this.previousAndFirstButtonsDisabled = false;
      this.nextButtonDisabled = false;
      this.lastButtonDisabled = false;
      this.areListenersSetup = false;
    }
    postConstruct() {
      const isRtl = this.gos.get("enableRtl");
      this.setTemplate(this.getTemplate());
      const { btFirst, btPrevious, btNext, btLast, pageSizeComp } = this;
      this.activateTabIndex([btFirst, btPrevious, btNext, btLast]);
      btFirst.insertAdjacentElement("afterbegin", createIconNoSpan(isRtl ? "last" : "first", this.gos));
      btPrevious.insertAdjacentElement("afterbegin", createIconNoSpan(isRtl ? "next" : "previous", this.gos));
      btNext.insertAdjacentElement("afterbegin", createIconNoSpan(isRtl ? "previous" : "next", this.gos));
      btLast.insertAdjacentElement("afterbegin", createIconNoSpan(isRtl ? "first" : "last", this.gos));
      this.addManagedPropertyListener("pagination", this.onPaginationChanged.bind(this));
      this.addManagedPropertyListener("suppressPaginationPanel", this.onPaginationChanged.bind(this));
      this.addManagedPropertyListeners(
        ["paginationPageSizeSelector", "paginationAutoPageSize", "suppressPaginationPanel"],
        () => this.onPageSizeRelatedOptionsChange()
      );
      this.pageSizeComp.toggleSelectDisplay(
        this.pageSizeComp.shouldShowPageSizeSelector()
      );
      this.onPaginationChanged();
    }
    onPaginationChanged() {
      const isPaging = this.gos.get("pagination");
      const paginationPanelEnabled = isPaging && !this.gos.get("suppressPaginationPanel");
      this.setDisplayed(paginationPanelEnabled);
      if (!paginationPanelEnabled) {
        return;
      }
      this.setupListeners();
      this.enableOrDisableButtons();
      this.updateRowLabels();
      this.setCurrentPageLabel();
      this.setTotalLabels();
      this.onPageSizeRelatedOptionsChange();
    }
    onPageSizeRelatedOptionsChange() {
      this.pageSizeComp.toggleSelectDisplay(
        this.pageSizeComp.shouldShowPageSizeSelector()
      );
    }
    setupListeners() {
      if (!this.areListenersSetup) {
        this.addManagedListener(this.eventService, Events.EVENT_PAGINATION_CHANGED, this.onPaginationChanged.bind(this));
        [
          { el: this.btFirst, fn: this.onBtFirst.bind(this) },
          { el: this.btPrevious, fn: this.onBtPrevious.bind(this) },
          { el: this.btNext, fn: this.onBtNext.bind(this) },
          { el: this.btLast, fn: this.onBtLast.bind(this) }
        ].forEach((item) => {
          const { el, fn } = item;
          this.addManagedListener(el, "click", fn);
          this.addManagedListener(el, "keydown", (e) => {
            if (e.key === KeyCode.ENTER || e.key === KeyCode.SPACE) {
              e.preventDefault();
              fn();
            }
          });
        });
        this.areListenersSetup = true;
      }
    }
    onBtFirst() {
      if (!this.previousAndFirstButtonsDisabled) {
        this.paginationProxy.goToFirstPage();
      }
    }
    setCurrentPageLabel() {
      const pagesExist = this.paginationProxy.getTotalPages() > 0;
      const currentPage = this.paginationProxy.getCurrentPage();
      const toDisplay = pagesExist ? currentPage + 1 : 0;
      this.lbCurrent.textContent = this.formatNumber(toDisplay);
    }
    formatNumber(value) {
      const userFunc = this.gos.getCallback("paginationNumberFormatter");
      if (userFunc) {
        const params = { value };
        return userFunc(params);
      }
      const localeTextFunc = this.localeService.getLocaleTextFunc();
      const thousandSeparator = localeTextFunc("thousandSeparator", ",");
      const decimalSeparator = localeTextFunc("decimalSeparator", ".");
      return formatNumberCommas(value, thousandSeparator, decimalSeparator);
    }
    getTemplate() {
      const localeTextFunc = this.localeService.getLocaleTextFunc();
      const strPage = localeTextFunc("page", "Page");
      const strTo = localeTextFunc("to", "to");
      const strOf = localeTextFunc("of", "of");
      const strFirst = localeTextFunc("firstPage", "First Page");
      const strPrevious = localeTextFunc("previousPage", "Previous Page");
      const strNext = localeTextFunc("nextPage", "Next Page");
      const strLast = localeTextFunc("lastPage", "Last Page");
      const compId = this.getCompId();
      return (
        /* html */
        `<div class="ag-paging-panel ag-unselectable" id="ag-${compId}">
                <ag-page-size-selector ref="pageSizeComp"></ag-page-size-selector>
                <span class="ag-paging-row-summary-panel" role="status">
                    <span id="ag-${compId}-first-row" ref="lbFirstRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${compId}-to">${strTo}</span>
                    <span id="ag-${compId}-last-row" ref="lbLastRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${compId}-of">${strOf}</span>
                    <span id="ag-${compId}-row-count" ref="lbRecordCount" class="ag-paging-row-summary-panel-number"></span>
                </span>
                <span class="ag-paging-page-summary-panel" role="presentation">
                    <div ref="btFirst" class="ag-button ag-paging-button" role="button" aria-label="${strFirst}"></div>
                    <div ref="btPrevious" class="ag-button ag-paging-button" role="button" aria-label="${strPrevious}"></div>
                    <span class="ag-paging-description" role="status">
                        <span id="ag-${compId}-start-page">${strPage}</span>
                        <span id="ag-${compId}-start-page-number" ref="lbCurrent" class="ag-paging-number"></span>
                        <span id="ag-${compId}-of-page">${strOf}</span>
                        <span id="ag-${compId}-of-page-number" ref="lbTotal" class="ag-paging-number"></span>
                    </span>
                    <div ref="btNext" class="ag-button ag-paging-button" role="button" aria-label="${strNext}"></div>
                    <div ref="btLast" class="ag-button ag-paging-button" role="button" aria-label="${strLast}"></div>
                </span>
            </div>`
      );
    }
    onBtNext() {
      if (!this.nextButtonDisabled) {
        this.paginationProxy.goToNextPage();
      }
    }
    onBtPrevious() {
      if (!this.previousAndFirstButtonsDisabled) {
        this.paginationProxy.goToPreviousPage();
      }
    }
    onBtLast() {
      if (!this.lastButtonDisabled) {
        this.paginationProxy.goToLastPage();
      }
    }
    enableOrDisableButtons() {
      const currentPage = this.paginationProxy.getCurrentPage();
      const maxRowFound = this.paginationProxy.isLastPageFound();
      const totalPages = this.paginationProxy.getTotalPages();
      this.previousAndFirstButtonsDisabled = currentPage === 0;
      this.toggleButtonDisabled(this.btFirst, this.previousAndFirstButtonsDisabled);
      this.toggleButtonDisabled(this.btPrevious, this.previousAndFirstButtonsDisabled);
      const zeroPagesToDisplay = this.isZeroPagesToDisplay();
      const onLastPage = currentPage === totalPages - 1;
      this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;
      this.lastButtonDisabled = !maxRowFound || zeroPagesToDisplay || currentPage === totalPages - 1;
      this.toggleButtonDisabled(this.btNext, this.nextButtonDisabled);
      this.toggleButtonDisabled(this.btLast, this.lastButtonDisabled);
    }
    toggleButtonDisabled(button, disabled) {
      setAriaDisabled(button, disabled);
      button.classList.toggle("ag-disabled", disabled);
    }
    updateRowLabels() {
      const currentPage = this.paginationProxy.getCurrentPage();
      const pageSize = this.paginationProxy.getPageSize();
      const maxRowFound = this.paginationProxy.isLastPageFound();
      const rowCount = this.paginationProxy.isLastPageFound() ? this.paginationProxy.getMasterRowCount() : null;
      let startRow;
      let endRow;
      if (this.isZeroPagesToDisplay()) {
        startRow = endRow = 0;
      } else {
        startRow = pageSize * currentPage + 1;
        endRow = startRow + pageSize - 1;
        if (maxRowFound && endRow > rowCount) {
          endRow = rowCount;
        }
      }
      this.lbFirstRowOnPage.textContent = this.formatNumber(startRow);
      if (this.rowNodeBlockLoader.isLoading()) {
        const translate = this.localeService.getLocaleTextFunc();
        this.lbLastRowOnPage.innerHTML = translate("pageLastRowUnknown", "?");
      } else {
        this.lbLastRowOnPage.textContent = this.formatNumber(endRow);
      }
    }
    isZeroPagesToDisplay() {
      const maxRowFound = this.paginationProxy.isLastPageFound();
      const totalPages = this.paginationProxy.getTotalPages();
      return maxRowFound && totalPages === 0;
    }
    setTotalLabels() {
      const lastPageFound = this.paginationProxy.isLastPageFound();
      const totalPages = this.paginationProxy.getTotalPages();
      const rowCount = lastPageFound ? this.paginationProxy.getMasterRowCount() : null;
      if (rowCount === 1) {
        const firstRow = this.paginationProxy.getRow(0);
        const hiddenGroupRow = firstRow && firstRow.group && !(firstRow.groupData || firstRow.aggData);
        if (hiddenGroupRow) {
          this.setTotalLabelsToZero();
          return;
        }
      }
      if (lastPageFound) {
        this.lbTotal.textContent = this.formatNumber(totalPages);
        this.lbRecordCount.textContent = this.formatNumber(rowCount);
      } else {
        const moreText = this.localeService.getLocaleTextFunc()("more", "more");
        this.lbTotal.innerHTML = moreText;
        this.lbRecordCount.innerHTML = moreText;
      }
    }
    setTotalLabelsToZero() {
      this.lbFirstRowOnPage.textContent = this.formatNumber(0);
      this.lbCurrent.textContent = this.formatNumber(0);
      this.lbLastRowOnPage.textContent = this.formatNumber(0);
      this.lbTotal.textContent = this.formatNumber(0);
      this.lbRecordCount.textContent = this.formatNumber(0);
    }
  };
  __decorateClass([
    Autowired("paginationProxy")
  ], PaginationComp.prototype, "paginationProxy", 2);
  __decorateClass([
    Autowired("rowNodeBlockLoader")
  ], PaginationComp.prototype, "rowNodeBlockLoader", 2);
  __decorateClass([
    RefSelector("btFirst")
  ], PaginationComp.prototype, "btFirst", 2);
  __decorateClass([
    RefSelector("btPrevious")
  ], PaginationComp.prototype, "btPrevious", 2);
  __decorateClass([
    RefSelector("btNext")
  ], PaginationComp.prototype, "btNext", 2);
  __decorateClass([
    RefSelector("btLast")
  ], PaginationComp.prototype, "btLast", 2);
  __decorateClass([
    RefSelector("lbRecordCount")
  ], PaginationComp.prototype, "lbRecordCount", 2);
  __decorateClass([
    RefSelector("lbFirstRowOnPage")
  ], PaginationComp.prototype, "lbFirstRowOnPage", 2);
  __decorateClass([
    RefSelector("lbLastRowOnPage")
  ], PaginationComp.prototype, "lbLastRowOnPage", 2);
  __decorateClass([
    RefSelector("lbCurrent")
  ], PaginationComp.prototype, "lbCurrent", 2);
  __decorateClass([
    RefSelector("lbTotal")
  ], PaginationComp.prototype, "lbTotal", 2);
  __decorateClass([
    RefSelector("pageSizeComp")
  ], PaginationComp.prototype, "pageSizeComp", 2);
  __decorateClass([
    PostConstruct
  ], PaginationComp.prototype, "postConstruct", 1);
  var _OverlayWrapperComponent = class _OverlayWrapperComponent2 extends Component {
    constructor() {
      super(_OverlayWrapperComponent2.TEMPLATE);
      this.inProgress = false;
      this.destroyRequested = false;
    }
    updateLayoutClasses(cssClass, params) {
      const overlayWrapperClassList = this.eOverlayWrapper.classList;
      overlayWrapperClassList.toggle("ag-layout-auto-height", params.autoHeight);
      overlayWrapperClassList.toggle("ag-layout-normal", params.normal);
      overlayWrapperClassList.toggle("ag-layout-print", params.print);
    }
    postConstruct() {
      this.createManagedBean(new LayoutFeature(this));
      this.setDisplayed(false, { skipAriaHidden: true });
      this.overlayService.registerOverlayWrapperComp(this);
    }
    setWrapperTypeClass(overlayWrapperCssClass) {
      const overlayWrapperClassList = this.eOverlayWrapper.classList;
      if (this.activeOverlayWrapperCssClass) {
        overlayWrapperClassList.toggle(this.activeOverlayWrapperCssClass, false);
      }
      this.activeOverlayWrapperCssClass = overlayWrapperCssClass;
      overlayWrapperClassList.toggle(overlayWrapperCssClass, true);
    }
    showOverlay(overlayComp, overlayWrapperCssClass, updateListenerDestroyFunc) {
      if (this.inProgress) {
        return;
      }
      this.setWrapperTypeClass(overlayWrapperCssClass);
      this.destroyActiveOverlay();
      this.inProgress = true;
      if (overlayComp) {
        overlayComp.then((comp) => {
          this.inProgress = false;
          this.eOverlayWrapper.appendChild(comp.getGui());
          this.activeOverlay = comp;
          this.updateListenerDestroyFunc = updateListenerDestroyFunc;
          if (this.destroyRequested) {
            this.destroyRequested = false;
            this.destroyActiveOverlay();
          }
        });
      }
      this.setDisplayed(true, { skipAriaHidden: true });
    }
    destroyActiveOverlay() {
      var _a;
      if (this.inProgress) {
        this.destroyRequested = true;
        return;
      }
      if (!this.activeOverlay) {
        return;
      }
      this.activeOverlay = this.getContext().destroyBean(this.activeOverlay);
      (_a = this.updateListenerDestroyFunc) == null ? void 0 : _a.call(this);
      clearElement(this.eOverlayWrapper);
    }
    hideOverlay() {
      this.destroyActiveOverlay();
      this.setDisplayed(false, { skipAriaHidden: true });
    }
    destroy() {
      this.destroyActiveOverlay();
      super.destroy();
    }
  };
  _OverlayWrapperComponent.TEMPLATE = /* html */
  `
        <div class="ag-overlay" role="presentation">
            <div class="ag-overlay-panel" role="presentation">
                <div class="ag-overlay-wrapper" ref="eOverlayWrapper" role="presentation"></div>
            </div>
        </div>`;
  __decorateClass([
    Autowired("overlayService")
  ], _OverlayWrapperComponent.prototype, "overlayService", 2);
  __decorateClass([
    RefSelector("eOverlayWrapper")
  ], _OverlayWrapperComponent.prototype, "eOverlayWrapper", 2);
  __decorateClass([
    PostConstruct
  ], _OverlayWrapperComponent.prototype, "postConstruct", 1);
  var OverlayWrapperComponent = _OverlayWrapperComponent;
  var RowPositionUtils = class extends BeanStub {
    getFirstRow() {
      let rowIndex = 0;
      let rowPinned;
      if (this.pinnedRowModel.getPinnedTopRowCount()) {
        rowPinned = "top";
      } else if (this.rowModel.getRowCount()) {
        rowPinned = null;
        rowIndex = this.paginationProxy.getPageFirstRow();
      } else if (this.pinnedRowModel.getPinnedBottomRowCount()) {
        rowPinned = "bottom";
      }
      return rowPinned === void 0 ? null : { rowIndex, rowPinned };
    }
    getLastRow() {
      let rowIndex;
      let rowPinned = null;
      const pinnedBottomCount = this.pinnedRowModel.getPinnedBottomRowCount();
      const pinnedTopCount = this.pinnedRowModel.getPinnedTopRowCount();
      if (pinnedBottomCount) {
        rowPinned = "bottom";
        rowIndex = pinnedBottomCount - 1;
      } else if (this.rowModel.getRowCount()) {
        rowPinned = null;
        rowIndex = this.paginationProxy.getPageLastRow();
      } else if (pinnedTopCount) {
        rowPinned = "top";
        rowIndex = pinnedTopCount - 1;
      }
      return rowIndex === void 0 ? null : { rowIndex, rowPinned };
    }
    getRowNode(gridRow) {
      switch (gridRow.rowPinned) {
        case "top":
          return this.pinnedRowModel.getPinnedTopRowData()[gridRow.rowIndex];
        case "bottom":
          return this.pinnedRowModel.getPinnedBottomRowData()[gridRow.rowIndex];
        default:
          return this.rowModel.getRow(gridRow.rowIndex);
      }
    }
    sameRow(rowA, rowB) {
      if (!rowA && !rowB) {
        return true;
      }
      if (rowA && !rowB || !rowA && rowB) {
        return false;
      }
      return rowA.rowIndex === rowB.rowIndex && rowA.rowPinned == rowB.rowPinned;
    }
    // tests if this row selection is before the other row selection
    before(rowA, rowB) {
      switch (rowA.rowPinned) {
        case "top":
          if (rowB.rowPinned !== "top") {
            return true;
          }
          break;
        case "bottom":
          if (rowB.rowPinned !== "bottom") {
            return false;
          }
          break;
        default:
          if (exists(rowB.rowPinned)) {
            return rowB.rowPinned !== "top";
          }
          break;
      }
      return rowA.rowIndex < rowB.rowIndex;
    }
  };
  __decorateClass([
    Autowired("rowModel")
  ], RowPositionUtils.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("pinnedRowModel")
  ], RowPositionUtils.prototype, "pinnedRowModel", 2);
  __decorateClass([
    Autowired("paginationProxy")
  ], RowPositionUtils.prototype, "paginationProxy", 2);
  RowPositionUtils = __decorateClass([
    Bean("rowPositionUtils")
  ], RowPositionUtils);
  var CellPositionUtils = class extends BeanStub {
    createId(cellPosition) {
      const { rowIndex, rowPinned, column } = cellPosition;
      return this.createIdFromValues({ rowIndex, column, rowPinned });
    }
    createIdFromValues(cellPosition) {
      const { rowIndex, rowPinned, column } = cellPosition;
      return `${rowIndex}.${rowPinned == null ? "null" : rowPinned}.${column.getId()}`;
    }
    equals(cellA, cellB) {
      const colsMatch = cellA.column === cellB.column;
      const floatingMatch = cellA.rowPinned === cellB.rowPinned;
      const indexMatch = cellA.rowIndex === cellB.rowIndex;
      return colsMatch && floatingMatch && indexMatch;
    }
  };
  CellPositionUtils = __decorateClass([
    Bean("cellPositionUtils")
  ], CellPositionUtils);
  var UndoRedoAction = class {
    constructor(cellValueChanges) {
      this.cellValueChanges = cellValueChanges;
    }
  };
  var RangeUndoRedoAction = class extends UndoRedoAction {
    constructor(cellValueChanges, initialRange, finalRange, ranges) {
      super(cellValueChanges);
      this.initialRange = initialRange;
      this.finalRange = finalRange;
      this.ranges = ranges;
    }
  };
  var _UndoRedoStack = class _UndoRedoStack2 {
    constructor(maxStackSize) {
      this.actionStack = [];
      this.maxStackSize = maxStackSize ? maxStackSize : _UndoRedoStack2.DEFAULT_STACK_SIZE;
      this.actionStack = new Array(this.maxStackSize);
    }
    pop() {
      return this.actionStack.pop();
    }
    push(item) {
      const shouldAddActions = item.cellValueChanges && item.cellValueChanges.length > 0;
      if (!shouldAddActions) {
        return;
      }
      if (this.actionStack.length === this.maxStackSize) {
        this.actionStack.shift();
      }
      this.actionStack.push(item);
    }
    clear() {
      this.actionStack = [];
    }
    getCurrentStackSize() {
      return this.actionStack.length;
    }
  };
  _UndoRedoStack.DEFAULT_STACK_SIZE = 10;
  var UndoRedoStack = _UndoRedoStack;
  var UndoRedoService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.cellValueChanges = [];
      this.activeCellEdit = null;
      this.activeRowEdit = null;
      this.isPasting = false;
      this.isRangeInAction = false;
      this.onCellValueChanged = (event) => {
        const eventCell = { column: event.column, rowIndex: event.rowIndex, rowPinned: event.rowPinned };
        const isCellEditing = this.activeCellEdit !== null && this.cellPositionUtils.equals(this.activeCellEdit, eventCell);
        const isRowEditing = this.activeRowEdit !== null && this.rowPositionUtils.sameRow(this.activeRowEdit, eventCell);
        const shouldCaptureAction = isCellEditing || isRowEditing || this.isPasting || this.isRangeInAction;
        if (!shouldCaptureAction) {
          return;
        }
        const { rowPinned, rowIndex, column, oldValue, value } = event;
        const cellValueChange = {
          rowPinned,
          rowIndex,
          columnId: column.getColId(),
          newValue: value,
          oldValue
        };
        this.cellValueChanges.push(cellValueChange);
      };
      this.clearStacks = () => {
        this.undoStack.clear();
        this.redoStack.clear();
      };
    }
    init() {
      if (!this.gos.get("undoRedoCellEditing")) {
        return;
      }
      const undoRedoLimit = this.gos.get("undoRedoCellEditingLimit");
      if (undoRedoLimit <= 0) {
        return;
      }
      this.undoStack = new UndoRedoStack(undoRedoLimit);
      this.redoStack = new UndoRedoStack(undoRedoLimit);
      this.addRowEditingListeners();
      this.addCellEditingListeners();
      this.addPasteListeners();
      this.addFillListeners();
      this.addCellKeyListeners();
      this.addManagedListener(this.eventService, Events.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged);
      this.addManagedListener(this.eventService, Events.EVENT_MODEL_UPDATED, (e) => {
        if (!e.keepUndoRedoStack) {
          this.clearStacks();
        }
      });
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.clearStacks);
      this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.clearStacks);
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_GROUP_OPENED, this.clearStacks);
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.clearStacks);
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, this.clearStacks);
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PINNED, this.clearStacks);
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, this.clearStacks);
      this.addManagedListener(this.eventService, Events.EVENT_ROW_DRAG_END, this.clearStacks);
      this.ctrlsService.whenReady((p2) => {
        this.gridBodyCtrl = p2.gridBodyCtrl;
      });
    }
    getCurrentUndoStackSize() {
      return this.undoStack ? this.undoStack.getCurrentStackSize() : 0;
    }
    getCurrentRedoStackSize() {
      return this.redoStack ? this.redoStack.getCurrentStackSize() : 0;
    }
    undo(source) {
      const startEvent = {
        type: Events.EVENT_UNDO_STARTED,
        source
      };
      this.eventService.dispatchEvent(startEvent);
      const operationPerformed = this.undoRedo(this.undoStack, this.redoStack, "initialRange", "oldValue", "undo");
      const endEvent = {
        type: Events.EVENT_UNDO_ENDED,
        source,
        operationPerformed
      };
      this.eventService.dispatchEvent(endEvent);
    }
    redo(source) {
      const startEvent = {
        type: Events.EVENT_REDO_STARTED,
        source
      };
      this.eventService.dispatchEvent(startEvent);
      const operationPerformed = this.undoRedo(this.redoStack, this.undoStack, "finalRange", "newValue", "redo");
      const endEvent = {
        type: Events.EVENT_REDO_ENDED,
        source,
        operationPerformed
      };
      this.eventService.dispatchEvent(endEvent);
    }
    undoRedo(undoRedoStack, opposingUndoRedoStack, rangeProperty, cellValueChangeProperty, source) {
      if (!undoRedoStack) {
        return false;
      }
      const undoRedoAction = undoRedoStack.pop();
      if (!undoRedoAction || !undoRedoAction.cellValueChanges) {
        return false;
      }
      this.processAction(undoRedoAction, (cellValueChange) => cellValueChange[cellValueChangeProperty], source);
      if (undoRedoAction instanceof RangeUndoRedoAction) {
        this.processRange(this.rangeService, undoRedoAction.ranges || [undoRedoAction[rangeProperty]]);
      } else {
        this.processCell(undoRedoAction.cellValueChanges);
      }
      opposingUndoRedoStack.push(undoRedoAction);
      return true;
    }
    processAction(action, valueExtractor, source) {
      action.cellValueChanges.forEach((cellValueChange) => {
        const { rowIndex, rowPinned, columnId } = cellValueChange;
        const rowPosition = { rowIndex, rowPinned };
        const currentRow = this.rowPositionUtils.getRowNode(rowPosition);
        if (!currentRow.displayed) {
          return;
        }
        currentRow.setDataValue(columnId, valueExtractor(cellValueChange), source);
      });
    }
    processRange(rangeService, ranges) {
      let lastFocusedCell;
      rangeService.removeAllCellRanges(true);
      ranges.forEach((range2, idx) => {
        if (!range2) {
          return;
        }
        const startRow = range2.startRow;
        const endRow = range2.endRow;
        if (idx === ranges.length - 1) {
          lastFocusedCell = {
            rowPinned: startRow.rowPinned,
            rowIndex: startRow.rowIndex,
            columnId: range2.startColumn.getColId()
          };
          this.setLastFocusedCell(lastFocusedCell);
        }
        const cellRangeParams = {
          rowStartIndex: startRow.rowIndex,
          rowStartPinned: startRow.rowPinned,
          rowEndIndex: endRow.rowIndex,
          rowEndPinned: endRow.rowPinned,
          columnStart: range2.startColumn,
          columns: range2.columns
        };
        rangeService.addCellRange(cellRangeParams);
      });
    }
    processCell(cellValueChanges) {
      const cellValueChange = cellValueChanges[0];
      const { rowIndex, rowPinned } = cellValueChange;
      const rowPosition = { rowIndex, rowPinned };
      const row = this.rowPositionUtils.getRowNode(rowPosition);
      const lastFocusedCell = {
        rowPinned: cellValueChange.rowPinned,
        rowIndex: row.rowIndex,
        columnId: cellValueChange.columnId
      };
      this.setLastFocusedCell(lastFocusedCell, this.rangeService);
    }
    setLastFocusedCell(lastFocusedCell, rangeService) {
      const { rowIndex, columnId, rowPinned } = lastFocusedCell;
      const scrollFeature = this.gridBodyCtrl.getScrollFeature();
      const column = this.columnModel.getGridColumn(columnId);
      if (!column) {
        return;
      }
      scrollFeature.ensureIndexVisible(rowIndex);
      scrollFeature.ensureColumnVisible(column);
      const cellPosition = { rowIndex, column, rowPinned };
      this.focusService.setFocusedCell(__spreadProps(__spreadValues({}, cellPosition), { forceBrowserFocus: true }));
      rangeService == null ? void 0 : rangeService.setRangeToCell(cellPosition);
    }
    addRowEditingListeners() {
      this.addManagedListener(this.eventService, Events.EVENT_ROW_EDITING_STARTED, (e) => {
        this.activeRowEdit = { rowIndex: e.rowIndex, rowPinned: e.rowPinned };
      });
      this.addManagedListener(this.eventService, Events.EVENT_ROW_EDITING_STOPPED, () => {
        const action = new UndoRedoAction(this.cellValueChanges);
        this.pushActionsToUndoStack(action);
        this.activeRowEdit = null;
      });
    }
    addCellEditingListeners() {
      this.addManagedListener(this.eventService, Events.EVENT_CELL_EDITING_STARTED, (e) => {
        this.activeCellEdit = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned };
      });
      this.addManagedListener(this.eventService, Events.EVENT_CELL_EDITING_STOPPED, (e) => {
        this.activeCellEdit = null;
        const shouldPushAction = e.valueChanged && !this.activeRowEdit && !this.isPasting && !this.isRangeInAction;
        if (shouldPushAction) {
          const action = new UndoRedoAction(this.cellValueChanges);
          this.pushActionsToUndoStack(action);
        }
      });
    }
    addPasteListeners() {
      this.addManagedListener(this.eventService, Events.EVENT_PASTE_START, () => {
        this.isPasting = true;
      });
      this.addManagedListener(this.eventService, Events.EVENT_PASTE_END, () => {
        const action = new UndoRedoAction(this.cellValueChanges);
        this.pushActionsToUndoStack(action);
        this.isPasting = false;
      });
    }
    addFillListeners() {
      this.addManagedListener(this.eventService, Events.EVENT_FILL_START, () => {
        this.isRangeInAction = true;
      });
      this.addManagedListener(this.eventService, Events.EVENT_FILL_END, (event) => {
        const action = new RangeUndoRedoAction(this.cellValueChanges, event.initialRange, event.finalRange);
        this.pushActionsToUndoStack(action);
        this.isRangeInAction = false;
      });
    }
    addCellKeyListeners() {
      this.addManagedListener(this.eventService, Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_START, () => {
        this.isRangeInAction = true;
      });
      this.addManagedListener(this.eventService, Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_END, () => {
        let action;
        if (this.rangeService && this.gos.get("enableRangeSelection")) {
          action = new RangeUndoRedoAction(this.cellValueChanges, void 0, void 0, [...this.rangeService.getCellRanges()]);
        } else {
          action = new UndoRedoAction(this.cellValueChanges);
        }
        this.pushActionsToUndoStack(action);
        this.isRangeInAction = false;
      });
    }
    pushActionsToUndoStack(action) {
      this.undoStack.push(action);
      this.cellValueChanges = [];
      this.redoStack.clear();
    }
  };
  __decorateClass([
    Autowired("focusService")
  ], UndoRedoService.prototype, "focusService", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], UndoRedoService.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("cellPositionUtils")
  ], UndoRedoService.prototype, "cellPositionUtils", 2);
  __decorateClass([
    Autowired("rowPositionUtils")
  ], UndoRedoService.prototype, "rowPositionUtils", 2);
  __decorateClass([
    Autowired("columnModel")
  ], UndoRedoService.prototype, "columnModel", 2);
  __decorateClass([
    Optional("rangeService")
  ], UndoRedoService.prototype, "rangeService", 2);
  __decorateClass([
    PostConstruct
  ], UndoRedoService.prototype, "init", 1);
  UndoRedoService = __decorateClass([
    Bean("undoRedoService")
  ], UndoRedoService);
  var HeaderPositionUtils = class extends BeanStub {
    findHeader(focusedHeader, direction) {
      let nextColumn;
      let getColMethod;
      if (focusedHeader.column instanceof ColumnGroup) {
        nextColumn = this.columnModel.getDisplayedGroupAtDirection(focusedHeader.column, direction);
      } else {
        getColMethod = `getDisplayedCol${direction}`;
        nextColumn = this.columnModel[getColMethod](focusedHeader.column);
      }
      if (!nextColumn) {
        return;
      }
      let { headerRowIndex } = focusedHeader;
      if (this.getHeaderRowType(headerRowIndex) !== "filter") {
        const columnsInPath = [nextColumn];
        while (nextColumn.getParent()) {
          nextColumn = nextColumn.getParent();
          columnsInPath.push(nextColumn);
        }
        nextColumn = columnsInPath[columnsInPath.length - 1 - headerRowIndex];
      }
      const { column, headerRowIndex: indexToFocus } = this.getHeaderIndexToFocus(nextColumn, headerRowIndex);
      return {
        column,
        headerRowIndex: indexToFocus
      };
    }
    getHeaderIndexToFocus(column, currentIndex) {
      let nextColumn;
      if (column instanceof ColumnGroup && this.isAnyChildSpanningHeaderHeight(column) && column.isPadding()) {
        const targetColumn = column;
        nextColumn = targetColumn.getLeafColumns()[0];
        let col = nextColumn;
        while (col !== targetColumn) {
          currentIndex++;
          col = col.getParent();
        }
      }
      return {
        column: nextColumn || column,
        headerRowIndex: currentIndex
      };
    }
    isAnyChildSpanningHeaderHeight(columnGroup) {
      if (!columnGroup) {
        return false;
      }
      return columnGroup.getLeafColumns().some((col) => col.isSpanHeaderHeight());
    }
    getColumnVisibleParent(currentColumn, currentIndex) {
      const currentRowType = this.getHeaderRowType(currentIndex);
      const isFloatingFilter = currentRowType === "filter";
      const isColumn = currentRowType === "column";
      let nextFocusColumn = isFloatingFilter ? currentColumn : currentColumn.getParent();
      let nextRow = currentIndex - 1;
      let headerRowIndexWithoutSpan = nextRow;
      if (isColumn && this.isAnyChildSpanningHeaderHeight(currentColumn.getParent())) {
        while (nextFocusColumn && nextFocusColumn.isPadding()) {
          nextFocusColumn = nextFocusColumn.getParent();
          nextRow--;
        }
        headerRowIndexWithoutSpan = nextRow;
        if (nextRow < 0) {
          nextFocusColumn = currentColumn;
          nextRow = currentIndex;
          headerRowIndexWithoutSpan = void 0;
        }
      }
      return { column: nextFocusColumn, headerRowIndex: nextRow, headerRowIndexWithoutSpan };
    }
    getColumnVisibleChild(column, currentIndex, direction = "After") {
      const currentRowType = this.getHeaderRowType(currentIndex);
      let nextFocusColumn = column;
      let nextRow = currentIndex + 1;
      let headerRowIndexWithoutSpan = nextRow;
      if (currentRowType === "group") {
        const leafColumns = column.getDisplayedLeafColumns();
        const leafColumn = direction === "After" ? leafColumns[0] : last(leafColumns);
        const columnsInTheWay = [];
        let currentColumn = leafColumn;
        while (currentColumn.getParent() !== column) {
          currentColumn = currentColumn.getParent();
          columnsInTheWay.push(currentColumn);
        }
        nextFocusColumn = leafColumn;
        if (leafColumn.isSpanHeaderHeight()) {
          for (let i = columnsInTheWay.length - 1; i >= 0; i--) {
            const colToFocus = columnsInTheWay[i];
            if (!colToFocus.isPadding()) {
              nextFocusColumn = colToFocus;
              break;
            }
            nextRow++;
          }
        } else {
          nextFocusColumn = last(columnsInTheWay);
          if (!nextFocusColumn) {
            nextFocusColumn = leafColumn;
          }
        }
      }
      return { column: nextFocusColumn, headerRowIndex: nextRow, headerRowIndexWithoutSpan };
    }
    getHeaderRowType(rowIndex) {
      const centerHeaderContainer = this.ctrlsService.getHeaderRowContainerCtrl();
      if (centerHeaderContainer) {
        return centerHeaderContainer.getRowType(rowIndex);
      }
    }
    findColAtEdgeForHeaderRow(level, position) {
      const displayedColumns = this.columnModel.getAllDisplayedColumns();
      const column = displayedColumns[position === "start" ? 0 : displayedColumns.length - 1];
      if (!column) {
        return;
      }
      const childContainer = this.ctrlsService.getHeaderRowContainerCtrl(column.getPinned());
      const type = childContainer.getRowType(level);
      if (type == "group") {
        const columnGroup = this.columnModel.getColumnGroupAtLevel(column, level);
        return {
          headerRowIndex: level,
          column: columnGroup
        };
      }
      return {
        // if type==null, means the header level didn't exist
        headerRowIndex: type == null ? -1 : level,
        column
      };
    }
  };
  __decorateClass([
    Autowired("columnModel")
  ], HeaderPositionUtils.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], HeaderPositionUtils.prototype, "ctrlsService", 2);
  HeaderPositionUtils = __decorateClass([
    Bean("headerPositionUtils")
  ], HeaderPositionUtils);
  var ColumnDefFactory = class {
    buildColumnDefs(cols, rowGroupColumns, pivotColumns) {
      const res = [];
      const colGroupDefs = {};
      cols.forEach((col) => {
        const colDef = this.createDefFromColumn(col, rowGroupColumns, pivotColumns);
        let addToResult = true;
        let childDef = colDef;
        let pointer = col.getOriginalParent();
        let lastPointer = null;
        while (pointer) {
          let parentDef = null;
          if (pointer.isPadding()) {
            pointer = pointer.getOriginalParent();
            continue;
          }
          const existingParentDef = colGroupDefs[pointer.getGroupId()];
          if (existingParentDef) {
            existingParentDef.children.push(childDef);
            addToResult = false;
            break;
          }
          parentDef = this.createDefFromGroup(pointer);
          if (parentDef) {
            parentDef.children = [childDef];
            colGroupDefs[parentDef.groupId] = parentDef;
            childDef = parentDef;
            pointer = pointer.getOriginalParent();
          }
          if (pointer != null && lastPointer === pointer) {
            addToResult = false;
            break;
          }
          lastPointer = pointer;
        }
        if (addToResult) {
          res.push(childDef);
        }
      });
      return res;
    }
    createDefFromGroup(group) {
      const defCloned = deepCloneDefinition(group.getColGroupDef(), ["children"]);
      if (defCloned) {
        defCloned.groupId = group.getGroupId();
      }
      return defCloned;
    }
    createDefFromColumn(col, rowGroupColumns, pivotColumns) {
      const colDefCloned = deepCloneDefinition(col.getColDef());
      colDefCloned.colId = col.getColId();
      colDefCloned.width = col.getActualWidth();
      colDefCloned.rowGroup = col.isRowGroupActive();
      colDefCloned.rowGroupIndex = col.isRowGroupActive() ? rowGroupColumns.indexOf(col) : null;
      colDefCloned.pivot = col.isPivotActive();
      colDefCloned.pivotIndex = col.isPivotActive() ? pivotColumns.indexOf(col) : null;
      colDefCloned.aggFunc = col.isValueActive() ? col.getAggFunc() : null;
      colDefCloned.hide = col.isVisible() ? void 0 : true;
      colDefCloned.pinned = col.isPinned() ? col.getPinned() : null;
      colDefCloned.sort = col.getSort() ? col.getSort() : null;
      colDefCloned.sortIndex = col.getSortIndex() != null ? col.getSortIndex() : null;
      return colDefCloned;
    }
  };
  ColumnDefFactory = __decorateClass([
    Bean("columnDefFactory")
  ], ColumnDefFactory);
  var RowCssClassCalculator = class {
    getInitialRowClasses(params) {
      const classes = [];
      if (exists(params.extraCssClass)) {
        classes.push(params.extraCssClass);
      }
      classes.push("ag-row");
      classes.push(params.rowFocused ? "ag-row-focus" : "ag-row-no-focus");
      if (params.fadeRowIn) {
        classes.push("ag-opacity-zero");
      }
      classes.push(params.rowIsEven ? "ag-row-even" : "ag-row-odd");
      if (params.rowNode.isRowPinned()) {
        classes.push("ag-row-pinned");
      }
      if (params.rowNode.isSelected()) {
        classes.push("ag-row-selected");
      }
      if (params.rowNode.footer) {
        classes.push("ag-row-footer");
      }
      classes.push("ag-row-level-" + params.rowLevel);
      if (params.rowNode.stub) {
        classes.push("ag-row-loading");
      }
      if (params.fullWidthRow) {
        classes.push("ag-full-width-row");
      }
      if (params.expandable) {
        classes.push("ag-row-group");
        classes.push(params.rowNode.expanded ? "ag-row-group-expanded" : "ag-row-group-contracted");
      }
      if (params.rowNode.dragging) {
        classes.push("ag-row-dragging");
      }
      pushAll(classes, this.processClassesFromGridOptions(params.rowNode));
      pushAll(classes, this.preProcessRowClassRules(params.rowNode));
      classes.push(params.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute");
      if (params.firstRowOnPage) {
        classes.push("ag-row-first");
      }
      if (params.lastRowOnPage) {
        classes.push("ag-row-last");
      }
      if (params.fullWidthRow) {
        if (params.pinned === "left") {
          classes.push("ag-cell-last-left-pinned");
        }
        if (params.pinned === "right") {
          classes.push("ag-cell-first-right-pinned");
        }
      }
      return classes;
    }
    processClassesFromGridOptions(rowNode) {
      const res = [];
      const process2 = (rowCls) => {
        if (typeof rowCls === "string") {
          res.push(rowCls);
        } else if (Array.isArray(rowCls)) {
          rowCls.forEach((e) => res.push(e));
        }
      };
      const rowClass = this.gos.get("rowClass");
      if (rowClass) {
        if (typeof rowClass === "function") {
          console.warn("AG Grid: rowClass should not be a function, please use getRowClass instead");
          return [];
        }
        process2(rowClass);
      }
      const rowClassFunc = this.gos.getCallback("getRowClass");
      if (rowClassFunc) {
        const params = {
          data: rowNode.data,
          node: rowNode,
          rowIndex: rowNode.rowIndex
        };
        const rowClassFuncResult = rowClassFunc(params);
        process2(rowClassFuncResult);
      }
      return res;
    }
    preProcessRowClassRules(rowNode) {
      const res = [];
      this.processRowClassRules(
        rowNode,
        (className) => {
          res.push(className);
        },
        (className) => {
        }
      );
      return res;
    }
    processRowClassRules(rowNode, onApplicableClass, onNotApplicableClass) {
      const rowClassParams = this.gos.addGridCommonParams({
        data: rowNode.data,
        node: rowNode,
        rowIndex: rowNode.rowIndex
      });
      this.stylingService.processClassRules(
        void 0,
        this.gos.get("rowClassRules"),
        rowClassParams,
        onApplicableClass,
        onNotApplicableClass
      );
    }
    calculateRowLevel(rowNode) {
      if (rowNode.group) {
        return rowNode.level;
      }
      return rowNode.parent ? rowNode.parent.level + 1 : 0;
    }
  };
  __decorateClass([
    Autowired("stylingService")
  ], RowCssClassCalculator.prototype, "stylingService", 2);
  __decorateClass([
    Autowired("gridOptionsService")
  ], RowCssClassCalculator.prototype, "gos", 2);
  RowCssClassCalculator = __decorateClass([
    Bean("rowCssClassCalculator")
  ], RowCssClassCalculator);
  var RowNodeSorter = class extends BeanStub {
    init() {
      this.isAccentedSort = this.gos.get("accentedSort");
      this.primaryColumnsSortGroups = this.gos.isColumnsSortingCoupledToGroup();
      this.addManagedPropertyListener("accentedSort", (propChange) => this.isAccentedSort = propChange.currentValue);
      this.addManagedPropertyListener("autoGroupColumnDef", () => this.primaryColumnsSortGroups = this.gos.isColumnsSortingCoupledToGroup());
    }
    doFullSort(rowNodes, sortOptions) {
      const mapper = (rowNode, pos) => ({ currentPos: pos, rowNode });
      const sortedRowNodes = rowNodes.map(mapper);
      sortedRowNodes.sort(this.compareRowNodes.bind(this, sortOptions));
      return sortedRowNodes.map((item) => item.rowNode);
    }
    compareRowNodes(sortOptions, sortedNodeA, sortedNodeB) {
      const nodeA = sortedNodeA.rowNode;
      const nodeB = sortedNodeB.rowNode;
      for (let i = 0, len = sortOptions.length; i < len; i++) {
        const sortOption = sortOptions[i];
        const isDescending = sortOption.sort === "desc";
        const valueA = this.getValue(nodeA, sortOption.column);
        const valueB = this.getValue(nodeB, sortOption.column);
        let comparatorResult;
        const providedComparator = this.getComparator(sortOption, nodeA);
        if (providedComparator) {
          comparatorResult = providedComparator(valueA, valueB, nodeA, nodeB, isDescending);
        } else {
          comparatorResult = _.defaultComparator(valueA, valueB, this.isAccentedSort);
        }
        const validResult = !isNaN(comparatorResult);
        if (validResult && comparatorResult !== 0) {
          return sortOption.sort === "asc" ? comparatorResult : comparatorResult * -1;
        }
      }
      return sortedNodeA.currentPos - sortedNodeB.currentPos;
    }
    getComparator(sortOption, rowNode) {
      const column = sortOption.column;
      const comparatorOnCol = column.getColDef().comparator;
      if (comparatorOnCol != null) {
        return comparatorOnCol;
      }
      if (!column.getColDef().showRowGroup) {
        return;
      }
      const groupLeafField = !rowNode.group && column.getColDef().field;
      if (!groupLeafField) {
        return;
      }
      const primaryColumn = this.columnModel.getPrimaryColumn(groupLeafField);
      if (!primaryColumn) {
        return;
      }
      return primaryColumn.getColDef().comparator;
    }
    getValue(node, column) {
      var _a, _b;
      if (!this.primaryColumnsSortGroups) {
        return this.valueService.getValue(column, node, false, false);
      }
      const isNodeGroupedAtLevel = node.rowGroupColumn === column;
      if (isNodeGroupedAtLevel) {
        const isGroupRows = this.gos.isGroupUseEntireRow(this.columnModel.isPivotActive());
        if (isGroupRows) {
          const leafChild = (_a = node.allLeafChildren) == null ? void 0 : _a[0];
          if (leafChild) {
            return this.valueService.getValue(column, leafChild, false, false);
          }
          return void 0;
        }
        const displayCol = this.columnModel.getGroupDisplayColumnForGroup(column.getId());
        if (!displayCol) {
          return void 0;
        }
        return (_b = node.groupData) == null ? void 0 : _b[displayCol.getId()];
      }
      if (node.group && column.getColDef().showRowGroup) {
        return void 0;
      }
      return this.valueService.getValue(column, node, false, false);
    }
  };
  __decorateClass([
    Autowired("valueService")
  ], RowNodeSorter.prototype, "valueService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], RowNodeSorter.prototype, "columnModel", 2);
  __decorateClass([
    PostConstruct
  ], RowNodeSorter.prototype, "init", 1);
  RowNodeSorter = __decorateClass([
    Bean("rowNodeSorter")
  ], RowNodeSorter);
  var CtrlsService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.params = {};
      this.ready = false;
      this.readyCallbacks = [];
    }
    checkReady() {
      const params = this.params;
      this.ready = params.gridCtrl != null && params.gridBodyCtrl != null && params.center != null && params.left != null && params.right != null && params.bottomCenter != null && params.bottomLeft != null && params.bottomRight != null && params.topCenter != null && params.topLeft != null && params.topRight != null && params.stickyTopCenter != null && params.stickyTopLeft != null && params.stickyTopRight != null && params.stickyBottomCenter != null && params.stickyBottomLeft != null && params.stickyBottomRight != null && params.centerHeader != null && params.leftHeader != null && params.rightHeader != null && params.fakeHScrollComp != null && params.fakeVScrollComp != null && params.gridHeaderCtrl != null;
      if (this.ready) {
        this.readyCallbacks.forEach((c) => c(params));
        this.readyCallbacks.length = 0;
      }
    }
    whenReady(callback) {
      if (this.ready) {
        callback(this.params);
      } else {
        this.readyCallbacks.push(callback);
      }
    }
    register(ctrlType, ctrl) {
      this.params[ctrlType] = ctrl;
      this.checkReady();
    }
    registerHeaderContainer(ctrl, pinned) {
      switch (pinned) {
        case "left":
          this.params.leftHeader = ctrl;
          break;
        case "right":
          this.params.rightHeader = ctrl;
          break;
        default:
          this.params.centerHeader = ctrl;
          break;
      }
      this.checkReady();
    }
    get(ctrlType) {
      return this.params[ctrlType];
    }
    getParams() {
      return this.params;
    }
    getGridBodyCtrl() {
      return this.params.gridBodyCtrl;
    }
    getHeaderRowContainerCtrls() {
      return [this.params.leftHeader, this.params.rightHeader, this.params.centerHeader];
    }
    getHeaderRowContainerCtrl(pinned) {
      switch (pinned) {
        case "left":
          return this.params.leftHeader;
        case "right":
          return this.params.rightHeader;
        default:
          return this.params.centerHeader;
      }
    }
  };
  CtrlsService.NAME = "ctrlsService";
  CtrlsService = __decorateClass([
    Bean(CtrlsService.NAME)
  ], CtrlsService);
  var CtrlsFactory = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.registry = {};
    }
    register(meta) {
      this.registry[meta.controllerName] = meta.controllerClass;
    }
    getInstance(name) {
      const ControllerClass = this.registry[name];
      if (ControllerClass == null) {
        return void 0;
      }
      return new ControllerClass();
    }
  };
  CtrlsFactory = __decorateClass([
    Bean("ctrlsFactory")
  ], CtrlsFactory);
  var AbstractFakeScrollComp = class extends Component {
    constructor(template, direction) {
      super(template);
      this.direction = direction;
      this.hideTimeout = null;
    }
    postConstruct() {
      this.addManagedListener(this.eventService, Events.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this));
      this.onScrollVisibilityChanged();
      this.addOrRemoveCssClass("ag-apple-scrollbar", isMacOsUserAgent() || isIOSUserAgent());
    }
    initialiseInvisibleScrollbar() {
      if (this.invisibleScrollbar !== void 0) {
        return;
      }
      this.invisibleScrollbar = isInvisibleScrollbar();
      if (this.invisibleScrollbar) {
        this.hideAndShowInvisibleScrollAsNeeded();
        this.addActiveListenerToggles();
      }
    }
    addActiveListenerToggles() {
      const activateEvents = ["mouseenter", "mousedown", "touchstart"];
      const deactivateEvents = ["mouseleave", "touchend"];
      const eGui = this.getGui();
      activateEvents.forEach(
        (eventName) => this.addManagedListener(
          eGui,
          eventName,
          () => this.addOrRemoveCssClass("ag-scrollbar-active", true)
        )
      );
      deactivateEvents.forEach(
        (eventName) => this.addManagedListener(
          eGui,
          eventName,
          () => this.addOrRemoveCssClass("ag-scrollbar-active", false)
        )
      );
    }
    onScrollVisibilityChanged() {
      if (this.invisibleScrollbar === void 0) {
        this.initialiseInvisibleScrollbar();
      }
      this.animationFrameService.requestAnimationFrame(() => this.setScrollVisible());
    }
    hideAndShowInvisibleScrollAsNeeded() {
      this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL, (params) => {
        if (params.direction === this.direction) {
          if (this.hideTimeout !== null) {
            window.clearTimeout(this.hideTimeout);
            this.hideTimeout = null;
          }
          this.addOrRemoveCssClass("ag-scrollbar-scrolling", true);
        }
      });
      this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL_END, () => {
        this.hideTimeout = window.setTimeout(() => {
          this.addOrRemoveCssClass("ag-scrollbar-scrolling", false);
          this.hideTimeout = null;
        }, 400);
      });
    }
    attemptSettingScrollPosition(value) {
      const viewport = this.getViewport();
      waitUntil(() => isVisible(viewport), () => this.setScrollPosition(value), 100);
    }
    getViewport() {
      return this.eViewport;
    }
    getContainer() {
      return this.eContainer;
    }
    onScrollCallback(fn) {
      this.addManagedListener(this.getViewport(), "scroll", fn);
    }
  };
  __decorateClass([
    RefSelector("eViewport")
  ], AbstractFakeScrollComp.prototype, "eViewport", 2);
  __decorateClass([
    RefSelector("eContainer")
  ], AbstractFakeScrollComp.prototype, "eContainer", 2);
  __decorateClass([
    Autowired("scrollVisibleService")
  ], AbstractFakeScrollComp.prototype, "scrollVisibleService", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], AbstractFakeScrollComp.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("animationFrameService")
  ], AbstractFakeScrollComp.prototype, "animationFrameService", 2);
  var _FakeHScrollComp = class _FakeHScrollComp2 extends AbstractFakeScrollComp {
    constructor() {
      super(_FakeHScrollComp2.TEMPLATE, "horizontal");
    }
    postConstruct() {
      super.postConstruct();
      const spacerWidthsListener = this.setFakeHScrollSpacerWidths.bind(this);
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, spacerWidthsListener);
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, spacerWidthsListener);
      this.addManagedListener(this.eventService, Events.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this));
      this.addManagedPropertyListener("domLayout", spacerWidthsListener);
      this.ctrlsService.register("fakeHScrollComp", this);
      this.createManagedBean(new CenterWidthFeature((width) => this.eContainer.style.width = `${width}px`));
      this.addManagedPropertyListeners(["suppressHorizontalScroll"], this.onScrollVisibilityChanged.bind(this));
    }
    initialiseInvisibleScrollbar() {
      if (this.invisibleScrollbar !== void 0) {
        return;
      }
      this.enableRtl = this.gos.get("enableRtl");
      super.initialiseInvisibleScrollbar();
      if (this.invisibleScrollbar) {
        this.refreshCompBottom();
      }
    }
    onPinnedRowDataChanged() {
      this.refreshCompBottom();
    }
    refreshCompBottom() {
      if (!this.invisibleScrollbar) {
        return;
      }
      const bottomPinnedHeight = this.pinnedRowModel.getPinnedBottomTotalHeight();
      this.getGui().style.bottom = `${bottomPinnedHeight}px`;
    }
    onScrollVisibilityChanged() {
      super.onScrollVisibilityChanged();
      this.setFakeHScrollSpacerWidths();
    }
    setFakeHScrollSpacerWidths() {
      const vScrollShowing = this.scrollVisibleService.isVerticalScrollShowing();
      let rightSpacing = this.columnModel.getDisplayedColumnsRightWidth();
      const scrollOnRight = !this.enableRtl && vScrollShowing;
      const scrollbarWidth = this.gos.getScrollbarWidth();
      if (scrollOnRight) {
        rightSpacing += scrollbarWidth;
      }
      setFixedWidth(this.eRightSpacer, rightSpacing);
      this.eRightSpacer.classList.toggle("ag-scroller-corner", rightSpacing <= scrollbarWidth);
      let leftSpacing = this.columnModel.getDisplayedColumnsLeftWidth();
      const scrollOnLeft = this.enableRtl && vScrollShowing;
      if (scrollOnLeft) {
        leftSpacing += scrollbarWidth;
      }
      setFixedWidth(this.eLeftSpacer, leftSpacing);
      this.eLeftSpacer.classList.toggle("ag-scroller-corner", leftSpacing <= scrollbarWidth);
    }
    setScrollVisible() {
      const hScrollShowing = this.scrollVisibleService.isHorizontalScrollShowing();
      const invisibleScrollbar2 = this.invisibleScrollbar;
      const isSuppressHorizontalScroll = this.gos.get("suppressHorizontalScroll");
      const scrollbarWidth = hScrollShowing ? this.gos.getScrollbarWidth() || 0 : 0;
      const adjustedScrollbarWidth = scrollbarWidth === 0 && invisibleScrollbar2 ? 16 : scrollbarWidth;
      const scrollContainerSize = !isSuppressHorizontalScroll ? adjustedScrollbarWidth : 0;
      this.addOrRemoveCssClass("ag-scrollbar-invisible", invisibleScrollbar2);
      setFixedHeight(this.getGui(), scrollContainerSize);
      setFixedHeight(this.eViewport, scrollContainerSize);
      setFixedHeight(this.eContainer, scrollContainerSize);
      this.setDisplayed(hScrollShowing, { skipAriaHidden: true });
    }
    getScrollPosition() {
      return getScrollLeft(this.getViewport(), this.enableRtl);
    }
    setScrollPosition(value) {
      if (!isVisible(this.getViewport())) {
        this.attemptSettingScrollPosition(value);
      }
      setScrollLeft(this.getViewport(), value, this.enableRtl);
    }
  };
  _FakeHScrollComp.TEMPLATE = /* html */
  `<div class="ag-body-horizontal-scroll" aria-hidden="true">
            <div class="ag-horizontal-left-spacer" ref="eLeftSpacer"></div>
            <div class="ag-body-horizontal-scroll-viewport" ref="eViewport">
                <div class="ag-body-horizontal-scroll-container" ref="eContainer"></div>
            </div>
            <div class="ag-horizontal-right-spacer" ref="eRightSpacer"></div>
        </div>`;
  __decorateClass([
    RefSelector("eLeftSpacer")
  ], _FakeHScrollComp.prototype, "eLeftSpacer", 2);
  __decorateClass([
    RefSelector("eRightSpacer")
  ], _FakeHScrollComp.prototype, "eRightSpacer", 2);
  __decorateClass([
    Autowired("columnModel")
  ], _FakeHScrollComp.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("pinnedRowModel")
  ], _FakeHScrollComp.prototype, "pinnedRowModel", 2);
  __decorateClass([
    PostConstruct
  ], _FakeHScrollComp.prototype, "postConstruct", 1);
  var FakeHScrollComp = _FakeHScrollComp;
  var PinnedWidthService = class extends BeanStub {
    postConstruct() {
      const listener = this.checkContainerWidths.bind(this);
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, listener);
      this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, listener);
      this.addManagedPropertyListener("domLayout", listener);
    }
    checkContainerWidths() {
      const printLayout = this.gos.isDomLayout("print");
      const newLeftWidth = printLayout ? 0 : this.columnModel.getDisplayedColumnsLeftWidth();
      const newRightWidth = printLayout ? 0 : this.columnModel.getDisplayedColumnsRightWidth();
      if (newLeftWidth != this.leftWidth) {
        this.leftWidth = newLeftWidth;
        this.eventService.dispatchEvent({ type: Events.EVENT_LEFT_PINNED_WIDTH_CHANGED });
      }
      if (newRightWidth != this.rightWidth) {
        this.rightWidth = newRightWidth;
        this.eventService.dispatchEvent({ type: Events.EVENT_RIGHT_PINNED_WIDTH_CHANGED });
      }
    }
    getPinnedRightWidth() {
      return this.rightWidth;
    }
    getPinnedLeftWidth() {
      return this.leftWidth;
    }
  };
  __decorateClass([
    Autowired("columnModel")
  ], PinnedWidthService.prototype, "columnModel", 2);
  __decorateClass([
    PostConstruct
  ], PinnedWidthService.prototype, "postConstruct", 1);
  PinnedWidthService = __decorateClass([
    Bean("pinnedWidthService")
  ], PinnedWidthService);
  var RowNodeEventThrottle = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.events = [];
    }
    postConstruct() {
      if (this.rowModel.getType() == "clientSide") {
        this.clientSideRowModel = this.rowModel;
      }
    }
    // because the user can call rowNode.setExpanded() many times in one VM turn,
    // we throttle the calls to ClientSideRowModel using animationFrameService. this means for 100
    // row nodes getting expanded, we only update the CSRM once, and then we fire all events after
    // CSRM has updated.
    //
    // if we did not do this, then the user could call setExpanded on 100+ rows, causing the grid
    // to re-render 100+ times, which would be a performance lag.
    //
    // we use animationFrameService
    // rather than _.debounce() so this will get done if anyone flushes the animationFrameService
    // (eg user calls api.ensureRowVisible(), which in turn flushes ).
    dispatchExpanded(event, forceSync) {
      if (this.clientSideRowModel == null) {
        this.eventService.dispatchEvent(event);
        return;
      }
      this.events.push(event);
      const func = () => {
        if (this.clientSideRowModel) {
          this.clientSideRowModel.onRowGroupOpened();
        }
        this.events.forEach((e) => this.eventService.dispatchEvent(e));
        this.events = [];
      };
      if (forceSync) {
        func();
      } else {
        if (this.dispatchExpandedDebounced == null) {
          this.dispatchExpandedDebounced = this.animationFrameService.debounce(func);
        }
        this.dispatchExpandedDebounced();
      }
    }
  };
  __decorateClass([
    Autowired("animationFrameService")
  ], RowNodeEventThrottle.prototype, "animationFrameService", 2);
  __decorateClass([
    Autowired("rowModel")
  ], RowNodeEventThrottle.prototype, "rowModel", 2);
  __decorateClass([
    PostConstruct
  ], RowNodeEventThrottle.prototype, "postConstruct", 1);
  RowNodeEventThrottle = __decorateClass([
    Bean("rowNodeEventThrottle")
  ], RowNodeEventThrottle);
  var COLUMN_DEFINITION_DEPRECATIONS = {
    columnsMenuParams: { version: "31.1", message: "Use `columnChooserParams` instead." },
    suppressMenu: { version: "31.1", message: "Use `suppressHeaderMenuButton` instead." },
    suppressCellFlash: { version: "31.2", message: "Use `enableCellChangeFlash={false}` in the ColDef" },
    dndSource: { version: "31.2", message: "This feature has been replaced by `Row Dragging to an External DropZone`." },
    dndSourceOnRowDrag: { version: "31.2", message: "This feature has been replaced by `Row Dragging to an External DropZone`." }
  };
  var CSRM_REQUIRES_ROW_GROUP_MODULE = (_options, gridOptions) => {
    var _a;
    if (((_a = gridOptions.rowModelType) != null ? _a : "clientSide") === "clientSide") {
      return {
        module: "@ag-grid-enterprise/row-grouping"
        /* RowGroupingModule */
      };
    }
    return null;
  };
  var COLUMN_DEFINITION_VALIDATIONS = {
    // supported on all row models, but need module for client side.
    enableRowGroup: CSRM_REQUIRES_ROW_GROUP_MODULE,
    rowGroup: CSRM_REQUIRES_ROW_GROUP_MODULE,
    rowGroupIndex: CSRM_REQUIRES_ROW_GROUP_MODULE,
    enablePivot: CSRM_REQUIRES_ROW_GROUP_MODULE,
    enableValue: CSRM_REQUIRES_ROW_GROUP_MODULE,
    pivot: CSRM_REQUIRES_ROW_GROUP_MODULE,
    pivotIndex: CSRM_REQUIRES_ROW_GROUP_MODULE,
    aggFunc: CSRM_REQUIRES_ROW_GROUP_MODULE,
    cellEditor: (options) => {
      if (options.cellEditor === "agRichSelect" || options.cellEditor === "agRichSelectCellEditor") {
        return {
          module: "@ag-grid-enterprise/rich-select"
          /* RichSelectModule */
        };
      }
      return null;
    },
    menuTabs: (options) => {
      var _a;
      const enterpriseMenuTabs = ["columnsMenuTab", "generalMenuTab"];
      if ((_a = options.menuTabs) == null ? void 0 : _a.some((tab) => enterpriseMenuTabs.includes(tab))) {
        return {
          module: "@ag-grid-enterprise/menu"
          /* MenuModule */
        };
      }
      return null;
    },
    columnsMenuParams: {
      module: [
        "@ag-grid-enterprise/menu",
        "@ag-grid-enterprise/column-tool-panel"
        /* ColumnsToolPanelModule */
      ]
    },
    columnChooserParams: {
      module: [
        "@ag-grid-enterprise/menu",
        "@ag-grid-enterprise/column-tool-panel"
        /* ColumnsToolPanelModule */
      ]
    },
    headerCheckboxSelection: {
      supportedRowModels: ["clientSide", "serverSide"],
      dependencies: (_options, { rowSelection }) => rowSelection === "multiple" ? null : "headerCheckboxSelection is only supported with rowSelection=multiple"
    },
    headerCheckboxSelectionFilteredOnly: {
      supportedRowModels: ["clientSide"],
      dependencies: (_options, { rowSelection }) => rowSelection === "multiple" ? null : "headerCheckboxSelectionFilteredOnly is only supported with rowSelection=multiple"
    },
    headerCheckboxSelectionCurrentPageOnly: {
      supportedRowModels: ["clientSide"],
      dependencies: (_options, { rowSelection }) => rowSelection === "multiple" ? null : "headerCheckboxSelectionCurrentPageOnly is only supported with rowSelection=multiple"
    },
    children: () => COL_DEF_VALIDATORS
  };
  var colDefPropertyMap = {
    headerName: void 0,
    columnGroupShow: void 0,
    headerClass: void 0,
    toolPanelClass: void 0,
    headerValueGetter: void 0,
    pivotKeys: void 0,
    groupId: void 0,
    colId: void 0,
    sort: void 0,
    initialSort: void 0,
    field: void 0,
    type: void 0,
    cellDataType: void 0,
    tooltipComponent: void 0,
    tooltipField: void 0,
    headerTooltip: void 0,
    cellClass: void 0,
    showRowGroup: void 0,
    filter: void 0,
    initialAggFunc: void 0,
    defaultAggFunc: void 0,
    aggFunc: void 0,
    pinned: void 0,
    initialPinned: void 0,
    chartDataType: void 0,
    cellAriaRole: void 0,
    cellEditorPopupPosition: void 0,
    headerGroupComponent: void 0,
    headerGroupComponentParams: void 0,
    cellStyle: void 0,
    cellRenderer: void 0,
    cellRendererParams: void 0,
    cellEditor: void 0,
    cellEditorParams: void 0,
    filterParams: void 0,
    pivotValueColumn: void 0,
    headerComponent: void 0,
    headerComponentParams: void 0,
    floatingFilterComponent: void 0,
    floatingFilterComponentParams: void 0,
    tooltipComponentParams: void 0,
    refData: void 0,
    columnsMenuParams: void 0,
    columnChooserParams: void 0,
    children: void 0,
    sortingOrder: void 0,
    allowedAggFuncs: void 0,
    menuTabs: void 0,
    pivotTotalColumnIds: void 0,
    cellClassRules: void 0,
    icons: void 0,
    sortIndex: void 0,
    initialSortIndex: void 0,
    flex: void 0,
    initialFlex: void 0,
    width: void 0,
    initialWidth: void 0,
    minWidth: void 0,
    maxWidth: void 0,
    rowGroupIndex: void 0,
    initialRowGroupIndex: void 0,
    pivotIndex: void 0,
    initialPivotIndex: void 0,
    suppressCellFlash: void 0,
    suppressColumnsToolPanel: void 0,
    suppressFiltersToolPanel: void 0,
    openByDefault: void 0,
    marryChildren: void 0,
    suppressStickyLabel: void 0,
    hide: void 0,
    initialHide: void 0,
    rowGroup: void 0,
    initialRowGroup: void 0,
    pivot: void 0,
    initialPivot: void 0,
    checkboxSelection: void 0,
    showDisabledCheckboxes: void 0,
    headerCheckboxSelection: void 0,
    headerCheckboxSelectionFilteredOnly: void 0,
    headerCheckboxSelectionCurrentPageOnly: void 0,
    suppressMenu: void 0,
    suppressHeaderMenuButton: void 0,
    suppressMovable: void 0,
    lockPosition: void 0,
    lockVisible: void 0,
    lockPinned: void 0,
    unSortIcon: void 0,
    suppressSizeToFit: void 0,
    suppressAutoSize: void 0,
    enableRowGroup: void 0,
    enablePivot: void 0,
    enableValue: void 0,
    editable: void 0,
    suppressPaste: void 0,
    suppressNavigable: void 0,
    enableCellChangeFlash: void 0,
    rowDrag: void 0,
    dndSource: void 0,
    autoHeight: void 0,
    wrapText: void 0,
    sortable: void 0,
    resizable: void 0,
    singleClickEdit: void 0,
    floatingFilter: void 0,
    cellEditorPopup: void 0,
    suppressFillHandle: void 0,
    wrapHeaderText: void 0,
    autoHeaderHeight: void 0,
    dndSourceOnRowDrag: void 0,
    valueGetter: void 0,
    valueSetter: void 0,
    filterValueGetter: void 0,
    keyCreator: void 0,
    valueFormatter: void 0,
    valueParser: void 0,
    comparator: void 0,
    equals: void 0,
    pivotComparator: void 0,
    suppressKeyboardEvent: void 0,
    suppressHeaderKeyboardEvent: void 0,
    colSpan: void 0,
    rowSpan: void 0,
    getQuickFilterText: void 0,
    onCellValueChanged: void 0,
    onCellClicked: void 0,
    onCellDoubleClicked: void 0,
    onCellContextMenu: void 0,
    rowDragText: void 0,
    tooltipValueGetter: void 0,
    cellRendererSelector: void 0,
    cellEditorSelector: void 0,
    suppressSpanHeaderHeight: void 0,
    useValueFormatterForExport: void 0,
    useValueParserForImport: void 0,
    mainMenuItems: void 0,
    contextMenuItems: void 0,
    suppressFloatingFilterButton: void 0,
    suppressHeaderFilterButton: void 0,
    suppressHeaderContextMenu: void 0,
    loadingCellRenderer: void 0,
    loadingCellRendererParams: void 0,
    loadingCellRendererSelector: void 0
  };
  var ALL_PROPERTIES = Object.keys(colDefPropertyMap);
  var COL_DEF_VALIDATORS = {
    objectName: "colDef",
    allProperties: ALL_PROPERTIES,
    docsUrl: "column-properties/",
    deprecations: COLUMN_DEFINITION_DEPRECATIONS,
    validations: COLUMN_DEFINITION_VALIDATIONS
  };
  var GRID_OPTION_DEPRECATIONS = {
    enableChartToolPanelsButton: { version: "29" },
    functionsPassive: { version: "29.2" },
    onColumnRowGroupChangeRequest: { version: "29.2" },
    onColumnPivotChangeRequest: { version: "29.2" },
    onColumnValueChangeRequest: { version: "29.2" },
    onColumnAggFuncChangeRequest: { version: "29.2" },
    serverSideFilterAllLevels: { version: "30", message: "All server-side group levels are now filtered by default. This can be toggled using `serverSideOnlyRefreshFilteredGroups`." },
    suppressAggAtRootLevel: { version: "30", message: "The root level aggregation is now suppressed by default. This can be toggled using  `alwaysAggregateAtRootLevel`." },
    excludeHiddenColumnsFromQuickFilter: { version: "30", message: "Hidden columns are now excluded from the Quick Filter by default. This can be toggled using `includeHiddenColumnsInQuickFilter`." },
    enterMovesDown: { version: "30", renamed: "enterNavigatesVertically" },
    enterMovesDownAfterEdit: { version: "30", renamed: "enterNavigatesVerticallyAfterEdit" },
    suppressParentsInRowNodes: { version: "30.2", message: "Using suppressParentsInRowNodes is no longer recommended. To serialize nodes it is now recommended to instead remove the parent node reference before serialization." },
    advancedFilterModel: { version: "31", message: "Use `initialState.filter.advancedFilterModel` instead." },
    suppressAsyncEvents: { version: "31", message: "Events should be handled asynchronously." },
    cellFadeDelay: { version: "31.1", renamed: "cellFadeDuration" },
    cellFlashDelay: { version: "31.1", renamed: "cellFlashDuration" },
    suppressServerSideInfiniteScroll: { version: "31.1" },
    serverSideSortOnServer: { version: "31.1" },
    serverSideFilterOnServer: { version: "31.1" },
    enableCellChangeFlash: { version: "31.2", message: "Use `enableCellChangeFlash` in the `ColDef` or `defaultColDef` for all columns." },
    groupIncludeFooter: { version: "31.3", message: "Use `groupTotalRow` instead." },
    groupIncludeTotalFooter: { version: "31.3", message: "Use `grandTotalRow` instead." }
  };
  var GRID_OPTION_DEFAULTS = {
    suppressContextMenu: false,
    preventDefaultOnContextMenu: false,
    allowContextMenuWithControlKey: false,
    suppressMenuHide: false,
    enableBrowserTooltips: false,
    tooltipTrigger: "hover",
    tooltipShowDelay: 2e3,
    tooltipHideDelay: 1e4,
    tooltipMouseTrack: false,
    tooltipShowMode: "standard",
    tooltipInteraction: false,
    copyHeadersToClipboard: false,
    copyGroupHeadersToClipboard: false,
    clipboardDelimiter: "	",
    suppressCopyRowsToClipboard: false,
    suppressCopySingleCellRanges: false,
    suppressLastEmptyLineOnPaste: false,
    suppressClipboardPaste: false,
    suppressClipboardApi: false,
    suppressCutToClipboard: false,
    maintainColumnOrder: false,
    suppressFieldDotNotation: false,
    allowDragFromColumnsToolPanel: false,
    suppressMovableColumns: false,
    suppressColumnMoveAnimation: false,
    suppressDragLeaveHidesColumns: false,
    suppressRowGroupHidesColumns: false,
    suppressAutoSize: false,
    autoSizePadding: 20,
    skipHeaderOnAutoSize: false,
    singleClickEdit: false,
    suppressClickEdit: false,
    readOnlyEdit: false,
    stopEditingWhenCellsLoseFocus: false,
    enterNavigatesVertically: false,
    enterNavigatesVerticallyAfterEdit: false,
    enableCellEditingOnBackspace: false,
    undoRedoCellEditing: false,
    undoRedoCellEditingLimit: 10,
    suppressCsvExport: false,
    suppressExcelExport: false,
    cacheQuickFilter: false,
    includeHiddenColumnsInQuickFilter: false,
    excludeChildrenWhenTreeDataFiltering: false,
    enableAdvancedFilter: false,
    includeHiddenColumnsInAdvancedFilter: false,
    enableCharts: false,
    suppressChartToolPanelsButton: false,
    masterDetail: false,
    keepDetailRows: false,
    keepDetailRowsCount: 10,
    detailRowAutoHeight: false,
    tabIndex: 0,
    rowBuffer: 10,
    valueCache: false,
    valueCacheNeverExpires: false,
    enableCellExpressions: false,
    suppressTouch: false,
    suppressFocusAfterRefresh: false,
    suppressAsyncEvents: false,
    suppressBrowserResizeObserver: false,
    suppressPropertyNamesCheck: false,
    suppressChangeDetection: false,
    debug: false,
    suppressLoadingOverlay: false,
    suppressNoRowsOverlay: false,
    pagination: false,
    paginationPageSize: 100,
    paginationPageSizeSelector: true,
    paginationAutoPageSize: false,
    paginateChildRows: false,
    suppressPaginationPanel: false,
    pivotMode: false,
    pivotPanelShow: "never",
    pivotDefaultExpanded: 0,
    pivotSuppressAutoColumn: false,
    suppressExpandablePivotGroups: false,
    functionsReadOnly: false,
    suppressAggFuncInHeader: false,
    alwaysAggregateAtRootLevel: false,
    aggregateOnlyChangedColumns: false,
    suppressAggFilteredOnly: false,
    removePivotHeaderRowWhenSingleValueColumn: false,
    animateRows: true,
    enableCellChangeFlash: false,
    cellFlashDelay: 500,
    cellFlashDuration: 500,
    cellFadeDelay: 1e3,
    cellFadeDuration: 1e3,
    allowShowChangeAfterFilter: false,
    domLayout: "normal",
    ensureDomOrder: false,
    enableRtl: false,
    suppressColumnVirtualisation: false,
    suppressMaxRenderedRowRestriction: false,
    suppressRowVirtualisation: false,
    rowDragManaged: false,
    suppressRowDrag: false,
    suppressMoveWhenRowDragging: false,
    rowDragEntireRow: false,
    rowDragMultiRow: false,
    embedFullWidthRows: false,
    groupDisplayType: "singleColumn",
    groupDefaultExpanded: 0,
    groupMaintainOrder: false,
    groupSelectsChildren: false,
    groupIncludeTotalFooter: false,
    groupSuppressBlankHeader: false,
    groupSelectsFiltered: false,
    showOpenedGroup: false,
    groupRemoveSingleChildren: false,
    groupRemoveLowestSingleChildren: false,
    groupHideOpenParents: false,
    groupAllowUnbalanced: false,
    rowGroupPanelShow: "never",
    suppressMakeColumnVisibleAfterUnGroup: false,
    treeData: false,
    rowGroupPanelSuppressSort: false,
    suppressGroupRowsSticky: false,
    rowModelType: "clientSide",
    asyncTransactionWaitMillis: 50,
    suppressModelUpdateAfterUpdateTransaction: false,
    cacheOverflowSize: 1,
    infiniteInitialRowCount: 1,
    serverSideInitialRowCount: 1,
    suppressServerSideInfiniteScroll: false,
    cacheBlockSize: 100,
    maxBlocksInCache: -1,
    maxConcurrentDatasourceRequests: 2,
    blockLoadDebounceMillis: 0,
    purgeClosedRowNodes: false,
    serverSideSortAllLevels: false,
    serverSideOnlyRefreshFilteredGroups: false,
    serverSideSortOnServer: false,
    serverSideFilterOnServer: false,
    serverSidePivotResultFieldSeparator: "_",
    viewportRowModelPageSize: 5,
    viewportRowModelBufferSize: 5,
    alwaysShowHorizontalScroll: false,
    alwaysShowVerticalScroll: false,
    debounceVerticalScrollbar: false,
    suppressHorizontalScroll: false,
    suppressScrollOnNewData: false,
    suppressScrollWhenPopupsAreOpen: false,
    suppressAnimationFrame: false,
    suppressMiddleClickScrolls: false,
    suppressPreventDefaultOnMouseWheel: false,
    rowMultiSelectWithClick: false,
    suppressRowDeselection: false,
    suppressRowClickSelection: false,
    suppressCellFocus: false,
    suppressHeaderFocus: false,
    suppressMultiRangeSelection: false,
    enableCellTextSelection: false,
    enableRangeSelection: false,
    enableRangeHandle: false,
    enableFillHandle: false,
    fillHandleDirection: "xy",
    suppressClearOnFillReduction: false,
    accentedSort: false,
    unSortIcon: false,
    suppressMultiSort: false,
    alwaysMultiSort: false,
    suppressMaintainUnsortedOrder: false,
    suppressRowHoverHighlight: false,
    suppressRowTransform: false,
    columnHoverHighlight: false,
    deltaSort: false,
    enableGroupEdit: false,
    suppressGroupMaintainValueType: false,
    functionsPassive: false,
    groupLockGroupColumns: 0,
    serverSideEnableClientSideSort: false,
    suppressServerSideFullWidthLoadingRow: false,
    pivotMaxGeneratedColumns: -1
  };
  var GRID_OPTION_VALIDATIONS = {
    sideBar: {
      module: "@ag-grid-enterprise/side-bar"
      /* SideBarModule */
    },
    statusBar: {
      module: "@ag-grid-enterprise/status-bar"
      /* StatusBarModule */
    },
    enableCharts: {
      module: "@ag-grid-enterprise/charts"
      /* GridChartsModule */
    },
    getMainMenuItems: {
      module: "@ag-grid-enterprise/menu"
      /* MenuModule */
    },
    getContextMenuItems: {
      module: "@ag-grid-enterprise/menu"
      /* MenuModule */
    },
    allowContextMenuWithControlKey: {
      module: "@ag-grid-enterprise/menu"
      /* MenuModule */
    },
    enableAdvancedFilter: {
      module: "@ag-grid-enterprise/advanced-filter"
      /* AdvancedFilterModule */
    },
    treeData: {
      supportedRowModels: ["clientSide", "serverSide"],
      module: "@ag-grid-enterprise/row-grouping",
      dependencies: (options) => {
        var _a;
        const rowModel = (_a = options.rowModelType) != null ? _a : "clientSide";
        switch (rowModel) {
          case "clientSide":
            const csrmWarning = `treeData requires 'getDataPath' in the ${rowModel} row model.`;
            return options.getDataPath ? null : csrmWarning;
          case "serverSide":
            const ssrmWarning = `treeData requires 'isServerSideGroup' and 'getServerSideGroupKey' in the ${rowModel} row model.`;
            return options.isServerSideGroup && options.getServerSideGroupKey ? null : ssrmWarning;
        }
        return null;
      }
    },
    masterDetail: {
      module: "@ag-grid-enterprise/master-detail"
      /* MasterDetailModule */
    },
    enableRangeSelection: {
      module: "@ag-grid-enterprise/range-selection"
      /* RangeSelectionModule */
    },
    enableRangeHandle: {
      dependencies: {
        enableRangeSelection: [true]
      }
    },
    enableFillHandle: {
      dependencies: {
        enableRangeSelection: [true]
      }
    },
    groupDefaultExpanded: {
      supportedRowModels: ["clientSide"]
    },
    groupIncludeFooter: {
      supportedRowModels: ["clientSide", "serverSide"],
      dependencies: (options) => {
        var _a;
        const rowModel = (_a = options.rowModelType) != null ? _a : "clientSide";
        switch (rowModel) {
          case "clientSide":
            return null;
          case "serverSide":
            const warning = "groupIncludeFooter is not supported alongside suppressServerSideInfiniteScroll";
            return options.suppressServerSideInfiniteScroll ? warning : null;
        }
        return null;
      }
    },
    groupIncludeTotalFooter: {
      supportedRowModels: ["clientSide"]
    },
    groupRemoveSingleChildren: {
      dependencies: {
        groupHideOpenParents: [void 0, false],
        groupRemoveLowestSingleChildren: [void 0, false]
      }
    },
    groupRemoveLowestSingleChildren: {
      dependencies: {
        groupHideOpenParents: [void 0, false],
        groupRemoveSingleChildren: [void 0, false]
      }
    },
    groupSelectsChildren: {
      dependencies: {
        rowSelection: ["multiple"]
      }
    },
    suppressParentsInRowNodes: {
      dependencies: {
        groupSelectsChildren: [void 0, false]
      }
    },
    viewportDatasource: {
      supportedRowModels: ["viewport"],
      module: "@ag-grid-enterprise/viewport-row-model"
      /* ViewportRowModelModule */
    },
    serverSideDatasource: {
      supportedRowModels: ["serverSide"],
      module: "@ag-grid-enterprise/server-side-row-model"
      /* ServerSideRowModelModule */
    },
    cacheBlockSize: {
      supportedRowModels: ["serverSide", "infinite"]
    },
    datasource: {
      supportedRowModels: ["infinite"],
      module: "@ag-grid-community/infinite-row-model"
      /* InfiniteRowModelModule */
    },
    rowData: {
      supportedRowModels: ["clientSide"],
      module: "@ag-grid-community/client-side-row-model"
      /* ClientSideRowModelModule */
    },
    columnDefs: () => COL_DEF_VALIDATORS,
    defaultColDef: () => COL_DEF_VALIDATORS,
    defaultColGroupDef: () => COL_DEF_VALIDATORS,
    autoGroupColumnDef: () => COL_DEF_VALIDATORS
  };
  var GRID_OPTIONS_VALIDATORS = {
    objectName: "gridOptions",
    allProperties: [
      ...PropertyKeys.ALL_PROPERTIES,
      ...ComponentUtil.EVENT_CALLBACKS
    ],
    propertyExceptions: ["api", "columnApi"],
    docsUrl: "grid-options/",
    deprecations: GRID_OPTION_DEPRECATIONS,
    validations: GRID_OPTION_VALIDATIONS
  };
  var GridOptionsService = class {
    constructor() {
      this.destroyed = false;
      this.domDataKey = "__AG_" + Math.random().toString();
      this.propertyEventService = new EventService();
      this.globalEventHandlerFactory = (restrictToSyncOnly) => {
        return (eventName, event) => {
          if (this.destroyed) {
            return;
          }
          const alwaysSync = ALWAYS_SYNC_GLOBAL_EVENTS.has(eventName);
          if (alwaysSync && !restrictToSyncOnly || !alwaysSync && restrictToSyncOnly) {
            return;
          }
          const eventHandlerName = ComponentUtil.getCallbackForEvent(eventName);
          const eventHandler = this.gridOptions[eventHandlerName];
          if (typeof eventHandler === "function") {
            this.frameworkOverrides.wrapOutgoing(() => {
              eventHandler(event);
            });
          }
        };
      };
    }
    // This is quicker then having code call gridOptionsService.get('context')
    get context() {
      return this.gridOptions["context"];
    }
    init() {
      this.columnApi = new ColumnApi(this.api);
      const async = !this.get("suppressAsyncEvents");
      this.eventService.addGlobalListener(this.globalEventHandlerFactory().bind(this), async);
      this.eventService.addGlobalListener(this.globalEventHandlerFactory(true).bind(this), false);
      this.propertyEventService.setFrameworkOverrides(this.frameworkOverrides);
      this.getScrollbarWidth();
    }
    destroy() {
      this.destroyed = true;
      this.columnApi = void 0;
    }
    /**
     * Get the raw value of the GridOptions property provided.
     * @param property
     */
    get(property) {
      var _a;
      return (_a = this.gridOptions[property]) != null ? _a : GRID_OPTION_DEFAULTS[property];
    }
    /**
     * Get the GridOption callback but wrapped so that the common params of api,columnApi and context are automatically applied to the params.
     * @param property GridOption callback properties based on the fact that this property has a callback with params extending AgGridCommon
     */
    getCallback(property) {
      return this.mergeGridCommonParams(this.gridOptions[property]);
    }
    /**
     * Returns `true` if a value has been specified for this GridOption.
     * @param property GridOption property
     */
    exists(property) {
      return exists(this.gridOptions[property]);
    }
    /**
    * Wrap the user callback and attach the api, columnApi and context to the params object on the way through.
    * @param callback User provided callback
    * @returns Wrapped callback where the params object not require api, columnApi and context
    */
    mergeGridCommonParams(callback) {
      if (callback) {
        const wrapped = (callbackParams) => {
          const mergedParams = callbackParams;
          mergedParams.api = this.api;
          mergedParams.columnApi = this.columnApi;
          mergedParams.context = this.context;
          return callback(mergedParams);
        };
        return wrapped;
      }
      return callback;
    }
    static toBoolean(value) {
      if (typeof value === "boolean") {
        return value;
      }
      if (typeof value === "string") {
        return value.toUpperCase() === "TRUE" || value == "";
      }
      return false;
    }
    static toNumber(value) {
      if (typeof value === "number") {
        return value;
      }
      if (typeof value === "string") {
        const parsed = parseInt(value);
        if (isNaN(parsed)) {
          return void 0;
        }
        return parsed;
      }
      return void 0;
    }
    static toConstrainedNum(min, max) {
      return (value) => {
        const num = GridOptionsService.toNumber(value);
        if (num == null || num < min || num > max) {
          return void 0;
        }
        return num;
      };
    }
    static getCoercedValue(key, value) {
      const coerceFunc = GridOptionsService.PROPERTY_COERCIONS.get(key);
      if (!coerceFunc) {
        return value;
      }
      return coerceFunc(value);
    }
    static getCoercedGridOptions(gridOptions) {
      const newGo = {};
      Object.entries(gridOptions).forEach(([key, value]) => {
        const coercedValue = GridOptionsService.getCoercedValue(key, value);
        newGo[key] = coercedValue;
      });
      return newGo;
    }
    updateGridOptions({ options, force, source = "api" }) {
      const changeSet = { id: GridOptionsService.changeSetId++, properties: [] };
      const events = [];
      Object.entries(options).forEach(([key, value]) => {
        if (source === "api" && INITIAL_GRID_OPTION_KEYS[key]) {
          warnOnce(`${key} is an initial property and cannot be updated.`);
        }
        const coercedValue = GridOptionsService.getCoercedValue(key, value);
        const shouldForce = force || typeof coercedValue === "object" && source === "api";
        const previousValue = this.gridOptions[key];
        if (shouldForce || previousValue !== coercedValue) {
          this.gridOptions[key] = coercedValue;
          const event = {
            type: key,
            currentValue: coercedValue,
            previousValue,
            changeSet,
            source
          };
          events.push(event);
        }
      });
      this.validationService.processGridOptions(this.gridOptions);
      changeSet.properties = events.map((event) => event.type);
      events.forEach((event) => {
        if (this.gridOptions.debug) {
          console.log(`AG Grid: Updated property ${event.type} from `, event.previousValue, " to  ", event.currentValue);
        }
        this.propertyEventService.dispatchEvent(event);
      });
    }
    addEventListener(key, listener) {
      this.propertyEventService.addEventListener(key, listener);
    }
    removeEventListener(key, listener) {
      this.propertyEventService.removeEventListener(key, listener);
    }
    // *************** Helper methods ************************** //
    // Methods to share common GridOptions related logic that goes above accessing a single property
    // the user might be using some non-standard scrollbar, eg a scrollbar that has zero
    // width and overlays (like the Safari scrollbar, but presented in Chrome). so we
    // allow the user to provide the scroll width before we work it out.
    getScrollbarWidth() {
      if (this.scrollbarWidth == null) {
        const useGridOptions = typeof this.gridOptions.scrollbarWidth === "number" && this.gridOptions.scrollbarWidth >= 0;
        const scrollbarWidth = useGridOptions ? this.gridOptions.scrollbarWidth : getScrollbarWidth();
        if (scrollbarWidth != null) {
          this.scrollbarWidth = scrollbarWidth;
          this.eventService.dispatchEvent({
            type: Events.EVENT_SCROLLBAR_WIDTH_CHANGED
          });
        }
      }
      return this.scrollbarWidth;
    }
    isRowModelType(rowModelType) {
      return this.gridOptions.rowModelType === rowModelType || rowModelType === "clientSide" && missing(this.gridOptions.rowModelType);
    }
    isDomLayout(domLayout) {
      var _a;
      const gridLayout = (_a = this.gridOptions.domLayout) != null ? _a : "normal";
      return gridLayout === domLayout;
    }
    isRowSelection() {
      return this.gridOptions.rowSelection === "single" || this.gridOptions.rowSelection === "multiple";
    }
    useAsyncEvents() {
      return !this.get("suppressAsyncEvents");
    }
    isGetRowHeightFunction() {
      return typeof this.gridOptions.getRowHeight === "function";
    }
    getRowHeightForNode(rowNode, allowEstimate = false, defaultRowHeight) {
      if (defaultRowHeight == null) {
        defaultRowHeight = this.environment.getDefaultRowHeight();
      }
      if (this.isGetRowHeightFunction()) {
        if (allowEstimate) {
          return { height: defaultRowHeight, estimated: true };
        }
        const params = {
          node: rowNode,
          data: rowNode.data
        };
        const height = this.getCallback("getRowHeight")(params);
        if (this.isNumeric(height)) {
          if (height === 0) {
            warnOnce("The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead.");
          }
          return { height: Math.max(1, height), estimated: false };
        }
      }
      if (rowNode.detail && this.get("masterDetail")) {
        return this.getMasterDetailRowHeight();
      }
      const rowHeight = this.gridOptions.rowHeight && this.isNumeric(this.gridOptions.rowHeight) ? this.gridOptions.rowHeight : defaultRowHeight;
      return { height: rowHeight, estimated: false };
    }
    getMasterDetailRowHeight() {
      if (this.get("detailRowAutoHeight")) {
        return { height: 1, estimated: false };
      }
      if (this.isNumeric(this.gridOptions.detailRowHeight)) {
        return { height: this.gridOptions.detailRowHeight, estimated: false };
      }
      return { height: 300, estimated: false };
    }
    // we don't allow dynamic row height for virtual paging
    getRowHeightAsNumber() {
      if (!this.gridOptions.rowHeight || missing(this.gridOptions.rowHeight)) {
        return this.environment.getDefaultRowHeight();
      }
      const rowHeight = this.environment.refreshRowHeightVariable();
      if (rowHeight !== -1) {
        return rowHeight;
      }
      console.warn("AG Grid row height must be a number if not using standard row model");
      return this.environment.getDefaultRowHeight();
    }
    isNumeric(value) {
      return !isNaN(value) && typeof value === "number" && isFinite(value);
    }
    getDomDataKey() {
      return this.domDataKey;
    }
    // returns the dom data, or undefined if not found
    getDomData(element, key) {
      const domData = element[this.getDomDataKey()];
      return domData ? domData[key] : void 0;
    }
    setDomData(element, key, value) {
      const domDataKey = this.getDomDataKey();
      let domData = element[domDataKey];
      if (missing(domData)) {
        domData = {};
        element[domDataKey] = domData;
      }
      domData[key] = value;
    }
    getDocument() {
      let result = null;
      if (this.gridOptions.getDocument && exists(this.gridOptions.getDocument)) {
        result = this.gridOptions.getDocument();
      } else if (this.eGridDiv) {
        result = this.eGridDiv.ownerDocument;
      }
      if (result && exists(result)) {
        return result;
      }
      return document;
    }
    getWindow() {
      const eDocument = this.getDocument();
      return eDocument.defaultView || window;
    }
    getRootNode() {
      return this.eGridDiv.getRootNode();
    }
    getActiveDomElement() {
      return this.getRootNode().activeElement;
    }
    getAsyncTransactionWaitMillis() {
      return exists(this.gridOptions.asyncTransactionWaitMillis) ? this.gridOptions.asyncTransactionWaitMillis : 50;
    }
    isAnimateRows() {
      if (this.get("ensureDomOrder")) {
        return false;
      }
      return this.get("animateRows");
    }
    isGroupRowsSticky() {
      if (this.get("paginateChildRows") || this.get("groupHideOpenParents") || this.isDomLayout("print")) {
        return false;
      }
      return true;
    }
    isColumnsSortingCoupledToGroup() {
      const autoGroupColumnDef = this.gridOptions.autoGroupColumnDef;
      return !(autoGroupColumnDef == null ? void 0 : autoGroupColumnDef.comparator) && !this.get("treeData");
    }
    getGroupAggFiltering() {
      const userValue = this.gridOptions.groupAggFiltering;
      if (typeof userValue === "function") {
        return this.getCallback("groupAggFiltering");
      }
      if (userValue === true) {
        return () => true;
      }
      return void 0;
    }
    getGrandTotalRow() {
      const userValue = this.gridOptions.grandTotalRow;
      if (userValue) {
        return userValue;
      }
      const legacyValue = this.gridOptions.groupIncludeTotalFooter;
      if (legacyValue) {
        return "bottom";
      }
      return void 0;
    }
    getGroupTotalRowCallback() {
      const userValue = this.get("groupTotalRow");
      if (typeof userValue === "function") {
        return this.getCallback("groupTotalRow");
      }
      if (userValue) {
        return () => userValue;
      }
      const legacyValue = this.get("groupIncludeFooter");
      if (typeof legacyValue === "function") {
        const legacyCallback = this.getCallback("groupIncludeFooter");
        return (p2) => {
          return legacyCallback(p2) ? "bottom" : void 0;
        };
      }
      return () => legacyValue ? "bottom" : void 0;
    }
    isGroupMultiAutoColumn() {
      if (this.gridOptions.groupDisplayType) {
        return this.gridOptions.groupDisplayType === "multipleColumns";
      }
      return this.get("groupHideOpenParents");
    }
    isGroupUseEntireRow(pivotMode) {
      if (pivotMode) {
        return false;
      }
      return this.gridOptions.groupDisplayType === "groupRows";
    }
    getGridCommonParams() {
      return {
        api: this.api,
        columnApi: this.columnApi,
        context: this.context
      };
    }
    addGridCommonParams(params) {
      const updatedParams = params;
      updatedParams.api = this.api;
      updatedParams.columnApi = this.columnApi;
      updatedParams.context = this.context;
      return updatedParams;
    }
  };
  GridOptionsService.PROPERTY_COERCIONS = new Map([
    ...PropertyKeys.BOOLEAN_PROPERTIES.map((key) => [key, GridOptionsService.toBoolean]),
    ...PropertyKeys.NUMBER_PROPERTIES.map((key) => [key, GridOptionsService.toNumber]),
    ["groupAggFiltering", (val) => typeof val === "function" ? val : GridOptionsService.toBoolean(val)],
    ["pageSize", GridOptionsService.toConstrainedNum(1, Number.MAX_VALUE)],
    ["autoSizePadding", GridOptionsService.toConstrainedNum(0, Number.MAX_VALUE)],
    ["keepDetailRowsCount", GridOptionsService.toConstrainedNum(1, Number.MAX_VALUE)],
    ["rowBuffer", GridOptionsService.toConstrainedNum(0, Number.MAX_VALUE)],
    ["infiniteInitialRowCount", GridOptionsService.toConstrainedNum(1, Number.MAX_VALUE)],
    ["cacheOverflowSize", GridOptionsService.toConstrainedNum(1, Number.MAX_VALUE)],
    ["cacheBlockSize", GridOptionsService.toConstrainedNum(1, Number.MAX_VALUE)],
    ["serverSideInitialRowCount", GridOptionsService.toConstrainedNum(1, Number.MAX_VALUE)],
    ["viewportRowModelPageSize", GridOptionsService.toConstrainedNum(1, Number.MAX_VALUE)],
    ["viewportRowModelBufferSize", GridOptionsService.toConstrainedNum(0, Number.MAX_VALUE)]
  ]);
  GridOptionsService.changeSetId = 0;
  __decorateClass([
    Autowired("gridOptions")
  ], GridOptionsService.prototype, "gridOptions", 2);
  __decorateClass([
    Autowired("eventService")
  ], GridOptionsService.prototype, "eventService", 2);
  __decorateClass([
    Autowired("environment")
  ], GridOptionsService.prototype, "environment", 2);
  __decorateClass([
    Autowired("frameworkOverrides")
  ], GridOptionsService.prototype, "frameworkOverrides", 2);
  __decorateClass([
    Autowired("eGridDiv")
  ], GridOptionsService.prototype, "eGridDiv", 2);
  __decorateClass([
    Autowired("validationService")
  ], GridOptionsService.prototype, "validationService", 2);
  __decorateClass([
    Autowired("gridApi")
  ], GridOptionsService.prototype, "api", 2);
  __decorateClass([
    PostConstruct
  ], GridOptionsService.prototype, "init", 1);
  __decorateClass([
    PreDestroy
  ], GridOptionsService.prototype, "destroy", 1);
  GridOptionsService = __decorateClass([
    Bean("gridOptionsService")
  ], GridOptionsService);
  var LocaleService = class extends BeanStub {
    getLocaleTextFunc() {
      const getLocaleText = this.gos.getCallback("getLocaleText");
      if (getLocaleText) {
        return (key, defaultValue, variableValues) => {
          const params = {
            key,
            defaultValue,
            variableValues
          };
          return getLocaleText(params);
        };
      }
      const localeText = this.gos.get("localeText");
      return (key, defaultValue, variableValues) => {
        let localisedText = localeText && localeText[key];
        if (localisedText && variableValues && variableValues.length) {
          let found = 0;
          while (true) {
            if (found >= variableValues.length) {
              break;
            }
            const idx = localisedText.indexOf("${variable}");
            if (idx === -1) {
              break;
            }
            localisedText = localisedText.replace("${variable}", variableValues[found++]);
          }
        }
        return localisedText != null ? localisedText : defaultValue;
      };
    }
  };
  LocaleService = __decorateClass([
    Bean("localeService")
  ], LocaleService);
  var _FakeVScrollComp = class _FakeVScrollComp2 extends AbstractFakeScrollComp {
    constructor() {
      super(_FakeVScrollComp2.TEMPLATE, "vertical");
    }
    postConstruct() {
      super.postConstruct();
      this.createManagedBean(new SetHeightFeature(this.eContainer));
      this.ctrlsService.register("fakeVScrollComp", this);
      this.addManagedListener(this.eventService, Events.EVENT_ROW_CONTAINER_HEIGHT_CHANGED, this.onRowContainerHeightChanged.bind(this));
    }
    setScrollVisible() {
      const vScrollShowing = this.scrollVisibleService.isVerticalScrollShowing();
      const invisibleScrollbar2 = this.invisibleScrollbar;
      const scrollbarWidth = vScrollShowing ? this.gos.getScrollbarWidth() || 0 : 0;
      const adjustedScrollbarWidth = scrollbarWidth === 0 && invisibleScrollbar2 ? 16 : scrollbarWidth;
      this.addOrRemoveCssClass("ag-scrollbar-invisible", invisibleScrollbar2);
      setFixedWidth(this.getGui(), adjustedScrollbarWidth);
      setFixedWidth(this.eViewport, adjustedScrollbarWidth);
      setFixedWidth(this.eContainer, adjustedScrollbarWidth);
      this.setDisplayed(vScrollShowing, { skipAriaHidden: true });
    }
    onRowContainerHeightChanged() {
      const { ctrlsService } = this;
      const gridBodyCtrl = ctrlsService.getGridBodyCtrl();
      const gridBodyViewportEl = gridBodyCtrl.getBodyViewportElement();
      const eViewportScrollTop = this.getScrollPosition();
      const gridBodyViewportScrollTop = gridBodyViewportEl.scrollTop;
      if (eViewportScrollTop != gridBodyViewportScrollTop) {
        this.setScrollPosition(gridBodyViewportScrollTop, true);
      }
    }
    getScrollPosition() {
      return this.getViewport().scrollTop;
    }
    setScrollPosition(value, force) {
      if (!force && !isVisible(this.getViewport())) {
        this.attemptSettingScrollPosition(value);
      }
      this.getViewport().scrollTop = value;
    }
  };
  _FakeVScrollComp.TEMPLATE = /* html */
  `<div class="ag-body-vertical-scroll" aria-hidden="true">
            <div class="ag-body-vertical-scroll-viewport" ref="eViewport">
                <div class="ag-body-vertical-scroll-container" ref="eContainer"></div>
            </div>
        </div>`;
  __decorateClass([
    PostConstruct
  ], _FakeVScrollComp.prototype, "postConstruct", 1);
  var FakeVScrollComp = _FakeVScrollComp;
  var MONTH_LOCALE_TEXT = {
    january: "January",
    february: "February",
    march: "March",
    april: "April",
    may: "May",
    june: "June",
    july: "July",
    august: "August",
    september: "September",
    october: "October",
    november: "November",
    december: "December"
  };
  var MONTH_KEYS = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
  var DataTypeService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.dataTypeDefinitions = {};
      this.isWaitingForRowData = false;
      this.isColumnTypeOverrideInDataTypeDefinitions = false;
      this.columnStateUpdatesPendingInference = {};
      this.columnStateUpdateListenerDestroyFuncs = [];
    }
    init() {
      this.groupHideOpenParents = this.gos.get("groupHideOpenParents");
      this.addManagedPropertyListener("groupHideOpenParents", () => {
        this.groupHideOpenParents = this.gos.get("groupHideOpenParents");
      });
      this.processDataTypeDefinitions();
      this.addManagedPropertyListener("dataTypeDefinitions", (event) => {
        this.processDataTypeDefinitions();
        this.columnModel.recreateColumnDefs(convertSourceType(event.source));
      });
    }
    processDataTypeDefinitions() {
      var _a;
      const defaultDataTypes = this.getDefaultDataTypes();
      this.dataTypeDefinitions = {};
      Object.entries(defaultDataTypes).forEach(([cellDataType, dataTypeDefinition]) => {
        this.dataTypeDefinitions[cellDataType] = __spreadProps(__spreadValues({}, dataTypeDefinition), {
          groupSafeValueFormatter: this.createGroupSafeValueFormatter(dataTypeDefinition)
        });
      });
      const dataTypeDefinitions = (_a = this.gos.get("dataTypeDefinitions")) != null ? _a : {};
      this.dataTypeMatchers = {};
      Object.entries(dataTypeDefinitions).forEach(([cellDataType, dataTypeDefinition]) => {
        const mergedDataTypeDefinition = this.processDataTypeDefinition(dataTypeDefinition, dataTypeDefinitions, [cellDataType], defaultDataTypes);
        if (mergedDataTypeDefinition) {
          this.dataTypeDefinitions[cellDataType] = mergedDataTypeDefinition;
          if (dataTypeDefinition.dataTypeMatcher) {
            this.dataTypeMatchers[cellDataType] = dataTypeDefinition.dataTypeMatcher;
          }
        }
      });
      this.checkObjectValueHandlers(defaultDataTypes);
      ["dateString", "text", "number", "boolean", "date"].forEach((cellDataType) => {
        const overriddenDataTypeMatcher = this.dataTypeMatchers[cellDataType];
        if (overriddenDataTypeMatcher) {
          delete this.dataTypeMatchers[cellDataType];
        }
        this.dataTypeMatchers[cellDataType] = overriddenDataTypeMatcher != null ? overriddenDataTypeMatcher : defaultDataTypes[cellDataType].dataTypeMatcher;
      });
    }
    mergeDataTypeDefinitions(parentDataTypeDefinition, childDataTypeDefinition) {
      const mergedDataTypeDefinition = __spreadValues(__spreadValues({}, parentDataTypeDefinition), childDataTypeDefinition);
      if (parentDataTypeDefinition.columnTypes && childDataTypeDefinition.columnTypes && childDataTypeDefinition.appendColumnTypes) {
        mergedDataTypeDefinition.columnTypes = [
          ...this.convertColumnTypes(parentDataTypeDefinition.columnTypes),
          ...this.convertColumnTypes(childDataTypeDefinition.columnTypes)
        ];
      }
      return mergedDataTypeDefinition;
    }
    processDataTypeDefinition(dataTypeDefinition, dataTypeDefinitions, alreadyProcessedDataTypes, defaultDataTypes) {
      let mergedDataTypeDefinition;
      const extendsCellDataType = dataTypeDefinition.extendsDataType;
      if (dataTypeDefinition.columnTypes) {
        this.isColumnTypeOverrideInDataTypeDefinitions = true;
      }
      if (dataTypeDefinition.extendsDataType === dataTypeDefinition.baseDataType) {
        let baseDataTypeDefinition = defaultDataTypes[extendsCellDataType];
        const overriddenBaseDataTypeDefinition = dataTypeDefinitions[extendsCellDataType];
        if (baseDataTypeDefinition && overriddenBaseDataTypeDefinition) {
          baseDataTypeDefinition = overriddenBaseDataTypeDefinition;
        }
        if (!this.validateDataTypeDefinition(dataTypeDefinition, baseDataTypeDefinition, extendsCellDataType)) {
          return void 0;
        }
        mergedDataTypeDefinition = this.mergeDataTypeDefinitions(
          baseDataTypeDefinition,
          dataTypeDefinition
        );
      } else {
        if (alreadyProcessedDataTypes.includes(extendsCellDataType)) {
          warnOnce('Data type definition hierarchies (via the "extendsDataType" property) cannot contain circular references.');
          return void 0;
        }
        const extendedDataTypeDefinition = dataTypeDefinitions[extendsCellDataType];
        if (!this.validateDataTypeDefinition(dataTypeDefinition, extendedDataTypeDefinition, extendsCellDataType)) {
          return void 0;
        }
        const mergedExtendedDataTypeDefinition = this.processDataTypeDefinition(
          extendedDataTypeDefinition,
          dataTypeDefinitions,
          [...alreadyProcessedDataTypes, extendsCellDataType],
          defaultDataTypes
        );
        if (!mergedExtendedDataTypeDefinition) {
          return void 0;
        }
        mergedDataTypeDefinition = this.mergeDataTypeDefinitions(
          mergedExtendedDataTypeDefinition,
          dataTypeDefinition
        );
      }
      return __spreadProps(__spreadValues({}, mergedDataTypeDefinition), {
        groupSafeValueFormatter: this.createGroupSafeValueFormatter(mergedDataTypeDefinition)
      });
    }
    validateDataTypeDefinition(dataTypeDefinition, parentDataTypeDefinition, parentCellDataType) {
      if (!parentDataTypeDefinition) {
        warnOnce(`The data type definition ${parentCellDataType} does not exist.`);
        return false;
      }
      if (parentDataTypeDefinition.baseDataType !== dataTypeDefinition.baseDataType) {
        warnOnce('The "baseDataType" property of a data type definition must match that of its parent.');
        return false;
      }
      return true;
    }
    createGroupSafeValueFormatter(dataTypeDefinition) {
      if (!dataTypeDefinition.valueFormatter) {
        return void 0;
      }
      return (params) => {
        var _a, _b;
        if ((_a = params.node) == null ? void 0 : _a.group) {
          const aggFunc = params.column.getAggFunc();
          if (aggFunc) {
            if (aggFunc === "first" || aggFunc === "last") {
              return dataTypeDefinition.valueFormatter(params);
            }
            if (dataTypeDefinition.baseDataType === "number" && aggFunc !== "count") {
              if (typeof params.value === "number") {
                return dataTypeDefinition.valueFormatter(params);
              }
              if (typeof params.value === "object") {
                if (!params.value) {
                  return void 0;
                }
                if ("toNumber" in params.value) {
                  return dataTypeDefinition.valueFormatter(__spreadProps(__spreadValues({}, params), {
                    value: params.value.toNumber()
                  }));
                }
                if ("value" in params.value) {
                  return dataTypeDefinition.valueFormatter(__spreadProps(__spreadValues({}, params), {
                    value: params.value.value
                  }));
                }
              }
            }
          }
          if (!this.gos.get("suppressGroupMaintainValueType")) {
            return void 0;
          }
        } else if (this.groupHideOpenParents && params.column.isRowGroupActive()) {
          if (typeof params.value !== "string" || ((_b = dataTypeDefinition.dataTypeMatcher) == null ? void 0 : _b.call(dataTypeDefinition, params.value))) {
            return dataTypeDefinition.valueFormatter(params);
          }
          if (!this.gos.get("suppressGroupMaintainValueType")) {
            return void 0;
          }
        }
        return dataTypeDefinition.valueFormatter(params);
      };
    }
    updateColDefAndGetDataTypeDefinitionColumnType(colDef, userColDef, colId) {
      let { cellDataType } = userColDef;
      const { field } = userColDef;
      if (cellDataType === void 0) {
        cellDataType = colDef.cellDataType;
      }
      if (cellDataType == null || cellDataType === true) {
        cellDataType = this.canInferCellDataType(colDef, userColDef) ? this.inferCellDataType(field, colId) : false;
      }
      if (!cellDataType) {
        colDef.cellDataType = false;
        return void 0;
      }
      const dataTypeDefinition = this.dataTypeDefinitions[cellDataType];
      if (!dataTypeDefinition) {
        warnOnce(`Missing data type definition - "${cellDataType}"`);
        return void 0;
      }
      colDef.cellDataType = cellDataType;
      if (dataTypeDefinition.groupSafeValueFormatter) {
        colDef.valueFormatter = dataTypeDefinition.groupSafeValueFormatter;
      }
      if (dataTypeDefinition.valueParser) {
        colDef.valueParser = dataTypeDefinition.valueParser;
      }
      if (!dataTypeDefinition.suppressDefaultProperties) {
        this.setColDefPropertiesForBaseDataType(colDef, dataTypeDefinition, colId);
      }
      return dataTypeDefinition.columnTypes;
    }
    updateColDefAndGetColumnType(colDef, userColDef, colId) {
      var _a, _b;
      const dataTypeDefinitionColumnType = this.updateColDefAndGetDataTypeDefinitionColumnType(colDef, userColDef, colId);
      const columnTypes = (_b = (_a = userColDef.type) != null ? _a : dataTypeDefinitionColumnType) != null ? _b : colDef.type;
      colDef.type = columnTypes;
      return columnTypes ? this.convertColumnTypes(columnTypes) : void 0;
    }
    addColumnListeners(column) {
      if (!this.isWaitingForRowData) {
        return;
      }
      const columnStateUpdates = this.columnStateUpdatesPendingInference[column.getColId()];
      if (!columnStateUpdates) {
        return;
      }
      const columnListener = (event) => {
        columnStateUpdates.add(event.key);
      };
      column.addEventListener(Column.EVENT_STATE_UPDATED, columnListener);
      this.columnStateUpdateListenerDestroyFuncs.push(() => column.removeEventListener(Column.EVENT_STATE_UPDATED, columnListener));
    }
    canInferCellDataType(colDef, userColDef) {
      var _a;
      if (this.rowModel.getType() !== "clientSide") {
        return false;
      }
      const propsToCheckForInference = { cellRenderer: true, valueGetter: true, valueParser: true, refData: true };
      if (this.doColDefPropsPreventInference(userColDef, propsToCheckForInference)) {
        return false;
      }
      const columnTypes = userColDef.type === null ? colDef.type : userColDef.type;
      if (columnTypes) {
        const columnTypeDefs = (_a = this.gos.get("columnTypes")) != null ? _a : {};
        const hasPropsPreventingInference = this.convertColumnTypes(columnTypes).some((columnType) => {
          const columnTypeDef = columnTypeDefs[columnType.trim()];
          return columnTypeDef && this.doColDefPropsPreventInference(columnTypeDef, propsToCheckForInference);
        });
        if (hasPropsPreventingInference) {
          return false;
        }
      }
      return !this.doColDefPropsPreventInference(colDef, propsToCheckForInference);
    }
    doColDefPropsPreventInference(colDef, propsToCheckForInference) {
      return [
        ["cellRenderer", "agSparklineCellRenderer"],
        ["valueGetter", void 0],
        ["valueParser", void 0],
        ["refData", void 0]
      ].some(([prop, comparisonValue]) => this.doesColDefPropPreventInference(colDef, propsToCheckForInference, prop, comparisonValue));
    }
    doesColDefPropPreventInference(colDef, checkProps, prop, comparisonValue) {
      if (!checkProps[prop]) {
        return false;
      }
      const value = colDef[prop];
      if (value === null) {
        checkProps[prop] = false;
        return false;
      } else {
        return comparisonValue === void 0 ? !!value : value === comparisonValue;
      }
    }
    inferCellDataType(field, colId) {
      var _a;
      if (!field) {
        return void 0;
      }
      let value;
      const initialData = this.getInitialData();
      if (initialData) {
        const fieldContainsDots = field.indexOf(".") >= 0 && !this.gos.get("suppressFieldDotNotation");
        value = getValueUsingField(initialData, field, fieldContainsDots);
      } else {
        this.initWaitForRowData(colId);
      }
      if (value == null) {
        return void 0;
      }
      const [cellDataType] = (_a = Object.entries(this.dataTypeMatchers).find(([_cellDataType, dataTypeMatcher]) => dataTypeMatcher(value))) != null ? _a : ["object"];
      return cellDataType;
    }
    getInitialData() {
      const rowData = this.gos.get("rowData");
      if (rowData == null ? void 0 : rowData.length) {
        return rowData[0];
      } else if (this.initialData) {
        return this.initialData;
      } else {
        const rowNodes = this.rowModel.getRootNode().allLeafChildren;
        if (rowNodes == null ? void 0 : rowNodes.length) {
          return rowNodes[0].data;
        }
      }
      return null;
    }
    initWaitForRowData(colId) {
      this.columnStateUpdatesPendingInference[colId] = /* @__PURE__ */ new Set();
      if (this.isWaitingForRowData) {
        return;
      }
      this.isWaitingForRowData = true;
      const columnTypeOverridesExist = this.isColumnTypeOverrideInDataTypeDefinitions;
      if (columnTypeOverridesExist) {
        this.columnModel.queueResizeOperations();
      }
      const destroyFunc = this.addManagedListener(this.eventService, Events.EVENT_ROW_DATA_UPDATE_STARTED, (event) => {
        const { firstRowData } = event;
        if (!firstRowData) {
          return;
        }
        destroyFunc == null ? void 0 : destroyFunc();
        this.isWaitingForRowData = false;
        this.processColumnsPendingInference(firstRowData, columnTypeOverridesExist);
        this.columnStateUpdatesPendingInference = {};
        if (columnTypeOverridesExist) {
          this.columnModel.processResizeOperations();
        }
        const dataTypesInferredEvent = {
          type: Events.EVENT_DATA_TYPES_INFERRED
        };
        this.eventService.dispatchEvent(dataTypesInferredEvent);
      });
    }
    isPendingInference() {
      return this.isWaitingForRowData;
    }
    processColumnsPendingInference(firstRowData, columnTypeOverridesExist) {
      this.initialData = firstRowData;
      const state = [];
      this.columnStateUpdateListenerDestroyFuncs.forEach((destroyFunc) => destroyFunc());
      this.columnStateUpdateListenerDestroyFuncs = [];
      const newRowGroupColumnStateWithoutIndex = {};
      const newPivotColumnStateWithoutIndex = {};
      Object.entries(this.columnStateUpdatesPendingInference).forEach(([colId, columnStateUpdates]) => {
        const column = this.columnModel.getGridColumn(colId);
        if (!column) {
          return;
        }
        const oldColDef = column.getColDef();
        if (!this.columnModel.resetColumnDefIntoColumn(column, "cellDataTypeInferred")) {
          return;
        }
        const newColDef = column.getColDef();
        if (columnTypeOverridesExist && newColDef.type && newColDef.type !== oldColDef.type) {
          const updatedColumnState = this.getUpdatedColumnState(column, columnStateUpdates);
          if (updatedColumnState.rowGroup && updatedColumnState.rowGroupIndex == null) {
            newRowGroupColumnStateWithoutIndex[colId] = updatedColumnState;
          }
          if (updatedColumnState.pivot && updatedColumnState.pivotIndex == null) {
            newPivotColumnStateWithoutIndex[colId] = updatedColumnState;
          }
          state.push(updatedColumnState);
        }
      });
      if (columnTypeOverridesExist) {
        state.push(...this.columnModel.generateColumnStateForRowGroupAndPivotIndexes(newRowGroupColumnStateWithoutIndex, newPivotColumnStateWithoutIndex));
      }
      if (state.length) {
        this.columnModel.applyColumnState({ state }, "cellDataTypeInferred");
      }
      this.initialData = null;
    }
    getUpdatedColumnState(column, columnStateUpdates) {
      const columnState = this.columnModel.getColumnStateFromColDef(column);
      columnStateUpdates.forEach((key) => {
        delete columnState[key];
        if (key === "rowGroup") {
          delete columnState.rowGroupIndex;
        } else if (key === "pivot") {
          delete columnState.pivotIndex;
        }
      });
      return columnState;
    }
    checkObjectValueHandlers(defaultDataTypes) {
      const resolvedObjectDataTypeDefinition = this.dataTypeDefinitions.object;
      const defaultObjectDataTypeDefinition = defaultDataTypes.object;
      this.hasObjectValueParser = resolvedObjectDataTypeDefinition.valueParser !== defaultObjectDataTypeDefinition.valueParser;
      this.hasObjectValueFormatter = resolvedObjectDataTypeDefinition.valueFormatter !== defaultObjectDataTypeDefinition.valueFormatter;
    }
    convertColumnTypes(type) {
      let typeKeys = [];
      if (type instanceof Array) {
        const invalidArray = type.some((a) => typeof a !== "string");
        if (invalidArray) {
          console.warn("if colDef.type is supplied an array it should be of type 'string[]'");
        } else {
          typeKeys = type;
        }
      } else if (typeof type === "string") {
        typeKeys = type.split(",");
      } else {
        console.warn("colDef.type should be of type 'string' | 'string[]'");
      }
      return typeKeys;
    }
    getDateStringTypeDefinition(column) {
      var _a;
      if (!column) {
        return this.dataTypeDefinitions.dateString;
      }
      return (_a = this.getDataTypeDefinition(column)) != null ? _a : this.dataTypeDefinitions.dateString;
    }
    getDateParserFunction(column) {
      return this.getDateStringTypeDefinition(column).dateParser;
    }
    getDateFormatterFunction(column) {
      return this.getDateStringTypeDefinition(column).dateFormatter;
    }
    getDataTypeDefinition(column) {
      const colDef = column.getColDef();
      if (!colDef.cellDataType) {
        return void 0;
      }
      return this.dataTypeDefinitions[colDef.cellDataType];
    }
    getBaseDataType(column) {
      var _a;
      return (_a = this.getDataTypeDefinition(column)) == null ? void 0 : _a.baseDataType;
    }
    checkType(column, value) {
      var _a;
      if (value == null) {
        return true;
      }
      const dataTypeMatcher = (_a = this.getDataTypeDefinition(column)) == null ? void 0 : _a.dataTypeMatcher;
      if (!dataTypeMatcher) {
        return true;
      }
      return dataTypeMatcher(value);
    }
    validateColDef(colDef) {
      if (colDef.cellDataType === "object") {
        if (colDef.valueFormatter === this.dataTypeDefinitions.object.groupSafeValueFormatter && !this.hasObjectValueFormatter) {
          warnOnce('Cell data type is "object" but no value formatter has been provided. Please either provide an object data type definition with a value formatter, or set "colDef.valueFormatter"');
        }
        if (colDef.editable && colDef.valueParser === this.dataTypeDefinitions.object.valueParser && !this.hasObjectValueParser) {
          warnOnce('Cell data type is "object" but no value parser has been provided. Please either provide an object data type definition with a value parser, or set "colDef.valueParser"');
        }
      }
    }
    setColDefPropertiesForBaseDataType(colDef, dataTypeDefinition, colId) {
      const formatValue = (column, node, value) => {
        let valueFormatter = column.getColDef().valueFormatter;
        if (valueFormatter === dataTypeDefinition.groupSafeValueFormatter) {
          valueFormatter = dataTypeDefinition.valueFormatter;
        }
        return this.valueService.formatValue(column, node, value, valueFormatter);
      };
      const usingSetFilter = ModuleRegistry.__isRegistered("@ag-grid-enterprise/set-filter", this.context.getGridId());
      const translate = this.localeService.getLocaleTextFunc();
      const mergeFilterParams = (params) => {
        const { filterParams } = colDef;
        colDef.filterParams = typeof filterParams === "object" ? __spreadValues(__spreadValues({}, filterParams), params) : params;
      };
      switch (dataTypeDefinition.baseDataType) {
        case "number": {
          colDef.cellEditor = "agNumberCellEditor";
          if (usingSetFilter) {
            mergeFilterParams({
              comparator: (a, b) => {
                const valA = a == null ? 0 : parseInt(a);
                const valB = b == null ? 0 : parseInt(b);
                if (valA === valB)
                  return 0;
                return valA > valB ? 1 : -1;
              }
            });
          }
          break;
        }
        case "boolean": {
          colDef.cellEditor = "agCheckboxCellEditor";
          colDef.cellRenderer = "agCheckboxCellRenderer";
          colDef.suppressKeyboardEvent = (params) => !!params.colDef.editable && params.event.key === KeyCode.SPACE;
          if (usingSetFilter) {
            mergeFilterParams({
              valueFormatter: (params) => {
                if (!exists(params.value)) {
                  return translate("blanks", "(Blanks)");
                }
                return translate(String(params.value), params.value ? "True" : "False");
              }
            });
          } else {
            mergeFilterParams({
              maxNumConditions: 1,
              debounceMs: 0,
              filterOptions: [
                "empty",
                {
                  displayKey: "true",
                  displayName: "True",
                  predicate: (_filterValues, cellValue) => cellValue,
                  numberOfInputs: 0
                },
                {
                  displayKey: "false",
                  displayName: "False",
                  predicate: (_filterValues, cellValue) => cellValue === false,
                  numberOfInputs: 0
                }
              ]
            });
          }
          break;
        }
        case "date": {
          colDef.cellEditor = "agDateCellEditor";
          colDef.keyCreator = (params) => formatValue(params.column, params.node, params.value);
          if (usingSetFilter) {
            mergeFilterParams({
              valueFormatter: (params) => {
                const valueFormatted = formatValue(params.column, params.node, params.value);
                return exists(valueFormatted) ? valueFormatted : translate("blanks", "(Blanks)");
              },
              treeList: true,
              treeListFormatter: (pathKey, level) => {
                if (level === 1 && pathKey != null) {
                  const monthKey = MONTH_KEYS[Number(pathKey) - 1];
                  return translate(monthKey, MONTH_LOCALE_TEXT[monthKey]);
                }
                return pathKey != null ? pathKey : translate("blanks", "(Blanks)");
              }
            });
          }
          break;
        }
        case "dateString": {
          colDef.cellEditor = "agDateStringCellEditor";
          colDef.keyCreator = (params) => formatValue(params.column, params.node, params.value);
          const convertToDate = dataTypeDefinition.dateParser;
          if (usingSetFilter) {
            mergeFilterParams({
              valueFormatter: (params) => {
                const valueFormatted = formatValue(params.column, params.node, params.value);
                return exists(valueFormatted) ? valueFormatted : translate("blanks", "(Blanks)");
              },
              treeList: true,
              treeListPathGetter: (value) => {
                const date = convertToDate(value != null ? value : void 0);
                return date ? [String(date.getFullYear()), String(date.getMonth() + 1), String(date.getDate())] : null;
              },
              treeListFormatter: (pathKey, level) => {
                if (level === 1 && pathKey != null) {
                  const monthKey = MONTH_KEYS[Number(pathKey) - 1];
                  return translate(monthKey, MONTH_LOCALE_TEXT[monthKey]);
                }
                return pathKey != null ? pathKey : translate("blanks", "(Blanks)");
              }
            });
          } else {
            mergeFilterParams({
              comparator: (filterDate, cellValue) => {
                const cellAsDate = convertToDate(cellValue);
                if (cellValue == null || cellAsDate < filterDate) {
                  return -1;
                }
                if (cellAsDate > filterDate) {
                  return 1;
                }
                return 0;
              }
            });
          }
          break;
        }
        case "object": {
          colDef.cellEditorParams = {
            useFormatter: true
          };
          colDef.comparator = (a, b) => {
            const column = this.columnModel.getPrimaryColumn(colId);
            const colDef2 = column == null ? void 0 : column.getColDef();
            if (!column || !colDef2) {
              return 0;
            }
            const valA = a == null ? "" : formatValue(column, null, a);
            const valB = b == null ? "" : formatValue(column, null, b);
            if (valA === valB)
              return 0;
            return valA > valB ? 1 : -1;
          };
          colDef.keyCreator = (params) => formatValue(params.column, params.node, params.value);
          if (usingSetFilter) {
            mergeFilterParams({
              valueFormatter: (params) => {
                const valueFormatted = formatValue(params.column, params.node, params.value);
                return exists(valueFormatted) ? valueFormatted : translate("blanks", "(Blanks)");
              }
            });
          } else {
            colDef.filterValueGetter = (params) => formatValue(
              params.column,
              params.node,
              this.valueService.getValue(params.column, params.node)
            );
          }
          break;
        }
      }
    }
    getDefaultDataTypes() {
      const defaultDateFormatMatcher = (value) => !!value.match("^\\d{4}-\\d{2}-\\d{2}$");
      const translate = this.localeService.getLocaleTextFunc();
      return {
        number: {
          baseDataType: "number",
          // can be empty space with legacy copy
          valueParser: (params) => {
            var _a, _b;
            return ((_b = (_a = params.newValue) == null ? void 0 : _a.trim) == null ? void 0 : _b.call(_a)) === "" ? null : Number(params.newValue);
          },
          valueFormatter: (params) => {
            if (params.value == null) {
              return "";
            }
            if (typeof params.value !== "number" || isNaN(params.value)) {
              return translate("invalidNumber", "Invalid Number");
            }
            return String(params.value);
          },
          dataTypeMatcher: (value) => typeof value === "number"
        },
        text: {
          baseDataType: "text",
          valueParser: (params) => params.newValue === "" ? null : toStringOrNull(params.newValue),
          dataTypeMatcher: (value) => typeof value === "string"
        },
        boolean: {
          baseDataType: "boolean",
          valueParser: (params) => {
            var _a, _b;
            if (params.newValue == null) {
              return params.newValue;
            }
            return ((_b = (_a = params.newValue) == null ? void 0 : _a.trim) == null ? void 0 : _b.call(_a)) === "" ? null : String(params.newValue).toLowerCase() === "true";
          },
          valueFormatter: (params) => params.value == null ? "" : String(params.value),
          dataTypeMatcher: (value) => typeof value === "boolean"
        },
        date: {
          baseDataType: "date",
          valueParser: (params) => parseDateTimeFromString(params.newValue == null ? null : String(params.newValue)),
          valueFormatter: (params) => {
            var _a;
            if (params.value == null) {
              return "";
            }
            if (!(params.value instanceof Date) || isNaN(params.value.getTime())) {
              return translate("invalidDate", "Invalid Date");
            }
            return (_a = serialiseDate(params.value, false)) != null ? _a : "";
          },
          dataTypeMatcher: (value) => value instanceof Date
        },
        dateString: {
          baseDataType: "dateString",
          dateParser: (value) => {
            var _a;
            return (_a = parseDateTimeFromString(value)) != null ? _a : void 0;
          },
          dateFormatter: (value) => {
            var _a;
            return (_a = serialiseDate(value != null ? value : null, false)) != null ? _a : void 0;
          },
          valueParser: (params) => defaultDateFormatMatcher(String(params.newValue)) ? params.newValue : null,
          valueFormatter: (params) => defaultDateFormatMatcher(String(params.value)) ? params.value : "",
          dataTypeMatcher: (value) => typeof value === "string" && defaultDateFormatMatcher(value)
        },
        object: {
          baseDataType: "object",
          valueParser: () => null,
          valueFormatter: (params) => {
            var _a;
            return (_a = toStringOrNull(params.value)) != null ? _a : "";
          }
        }
      };
    }
  };
  __decorateClass([
    Autowired("rowModel")
  ], DataTypeService.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("columnModel")
  ], DataTypeService.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("valueService")
  ], DataTypeService.prototype, "valueService", 2);
  __decorateClass([
    PostConstruct
  ], DataTypeService.prototype, "init", 1);
  DataTypeService = __decorateClass([
    Bean("dataTypeService")
  ], DataTypeService);
  var SyncService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.waitingForColumns = false;
    }
    postConstruct() {
      this.addManagedPropertyListener("columnDefs", (event) => this.setColumnDefs(event));
    }
    start() {
      this.ctrlsService.whenReady(() => {
        const columnDefs = this.gos.get("columnDefs");
        if (columnDefs) {
          this.setColumnsAndData(columnDefs);
        } else {
          this.waitingForColumns = true;
        }
        this.gridReady();
      });
    }
    setColumnsAndData(columnDefs) {
      this.columnModel.setColumnDefs(columnDefs != null ? columnDefs : [], "gridInitializing");
      this.rowModel.start();
    }
    gridReady() {
      this.dispatchGridReadyEvent();
      const isEnterprise = ModuleRegistry.__isRegistered("@ag-grid-enterprise/core", this.context.getGridId());
      const logger = new Logger("AG Grid", () => this.gos.get("debug"));
      logger.log(`initialised successfully, enterprise = ${isEnterprise}`);
    }
    dispatchGridReadyEvent() {
      const readyEvent = {
        type: Events.EVENT_GRID_READY
      };
      this.eventService.dispatchEvent(readyEvent);
    }
    setColumnDefs(event) {
      const columnDefs = this.gos.get("columnDefs");
      if (!columnDefs) {
        return;
      }
      if (this.waitingForColumns) {
        this.waitingForColumns = false;
        this.setColumnsAndData(columnDefs);
        return;
      }
      this.columnModel.setColumnDefs(columnDefs, convertSourceType(event.source));
    }
  };
  __decorateClass([
    Autowired("ctrlsService")
  ], SyncService.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], SyncService.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("rowModel")
  ], SyncService.prototype, "rowModel", 2);
  __decorateClass([
    PostConstruct
  ], SyncService.prototype, "postConstruct", 1);
  SyncService = __decorateClass([
    Bean("syncService")
  ], SyncService);
  var OverlayService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.manuallyDisplayed = false;
    }
    postConstruct() {
      this.addManagedListener(this.eventService, Events.EVENT_ROW_DATA_UPDATED, () => this.onRowDataUpdated());
      this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, () => this.onNewColumnsLoaded());
    }
    registerOverlayWrapperComp(overlayWrapperComp) {
      this.overlayWrapperComp = overlayWrapperComp;
      if (!this.gos.get("columnDefs") || this.gos.isRowModelType("clientSide") && !this.gos.get("rowData")) {
        this.showLoadingOverlay();
      }
    }
    showLoadingOverlay() {
      if (this.gos.get("suppressLoadingOverlay")) {
        return;
      }
      const params = {};
      const compDetails = this.userComponentFactory.getLoadingOverlayCompDetails(params);
      this.showOverlay(compDetails, "ag-overlay-loading-wrapper", "loadingOverlayComponentParams");
    }
    showNoRowsOverlay() {
      if (this.gos.get("suppressNoRowsOverlay")) {
        return;
      }
      const params = {};
      const compDetails = this.userComponentFactory.getNoRowsOverlayCompDetails(params);
      this.showOverlay(compDetails, "ag-overlay-no-rows-wrapper", "noRowsOverlayComponentParams");
    }
    showOverlay(compDetails, wrapperCssClass, gridOption) {
      const promise = compDetails.newAgStackInstance();
      const listenerDestroyFunc = this.addManagedPropertyListener(gridOption, ({ currentValue }) => {
        promise.then((comp) => {
          if (comp.refresh) {
            comp.refresh(this.gos.addGridCommonParams(__spreadValues({}, currentValue != null ? currentValue : {})));
          }
        });
      });
      this.manuallyDisplayed = this.columnModel.isReady() && !this.paginationProxy.isEmpty();
      this.overlayWrapperComp.showOverlay(promise, wrapperCssClass, listenerDestroyFunc);
    }
    hideOverlay() {
      this.manuallyDisplayed = false;
      this.overlayWrapperComp.hideOverlay();
    }
    showOrHideOverlay() {
      const isEmpty = this.paginationProxy.isEmpty();
      const isSuppressNoRowsOverlay = this.gos.get("suppressNoRowsOverlay");
      if (isEmpty && !isSuppressNoRowsOverlay) {
        this.showNoRowsOverlay();
      } else {
        this.hideOverlay();
      }
    }
    onRowDataUpdated() {
      this.showOrHideOverlay();
    }
    onNewColumnsLoaded() {
      if (this.columnModel.isReady() && !this.paginationProxy.isEmpty() && !this.manuallyDisplayed) {
        this.hideOverlay();
      }
    }
  };
  __decorateClass([
    Autowired("userComponentFactory")
  ], OverlayService.prototype, "userComponentFactory", 2);
  __decorateClass([
    Autowired("paginationProxy")
  ], OverlayService.prototype, "paginationProxy", 2);
  __decorateClass([
    Autowired("columnModel")
  ], OverlayService.prototype, "columnModel", 2);
  __decorateClass([
    PostConstruct
  ], OverlayService.prototype, "postConstruct", 1);
  OverlayService = __decorateClass([
    Bean("overlayService")
  ], OverlayService);
  var StateService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.suppressEvents = true;
      this.queuedUpdateSources = /* @__PURE__ */ new Set();
      this.dispatchStateUpdateEventDebounced = debounce2(() => this.dispatchQueuedStateUpdateEvents(), 0);
      this.onRowGroupOpenedDebounced = debounce2(() => this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()), 0);
      this.onRowSelectedDebounced = debounce2(() => {
        this.staleStateKeys.delete("rowSelection");
        this.updateCachedState("rowSelection", this.getRowSelectionState());
      }, 0);
      this.staleStateKeys = /* @__PURE__ */ new Set();
    }
    postConstruct() {
      var _a;
      this.isClientSideRowModel = this.rowModel.getType() === "clientSide";
      this.cachedState = (_a = this.gos.get("initialState")) != null ? _a : {};
      this.ctrlsService.whenReady(() => this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnGridReady()));
      const newColumnsLoadedDestroyFunc = this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, ({ source }) => {
        if (source === "gridInitializing") {
          newColumnsLoadedDestroyFunc == null ? void 0 : newColumnsLoadedDestroyFunc();
          this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnColumnsInitialised());
        }
      });
      const rowCountReadyDestroyFunc = this.addManagedListener(this.eventService, Events.EVENT_ROW_COUNT_READY, () => {
        rowCountReadyDestroyFunc == null ? void 0 : rowCountReadyDestroyFunc();
        this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnRowCountReady());
      });
      const firstDataRenderedDestroyFunc = this.addManagedListener(this.eventService, Events.EVENT_FIRST_DATA_RENDERED, () => {
        firstDataRenderedDestroyFunc == null ? void 0 : firstDataRenderedDestroyFunc();
        this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnFirstDataRendered());
      });
    }
    getState() {
      if (this.staleStateKeys.size) {
        this.refreshStaleState();
      }
      return this.cachedState;
    }
    setupStateOnGridReady() {
      this.updateCachedState("sideBar", this.getSideBarState());
      this.addManagedListener(this.eventService, Events.EVENT_TOOL_PANEL_VISIBLE_CHANGED, () => this.updateCachedState("sideBar", this.getSideBarState()));
      this.addManagedListener(this.eventService, Events.EVENT_SIDE_BAR_UPDATED, () => this.updateCachedState("sideBar", this.getSideBarState()));
    }
    setupStateOnColumnsInitialised() {
      var _a;
      const initialState = (_a = this.gos.get("initialState")) != null ? _a : {};
      this.setColumnState(initialState);
      this.setColumnGroupState(initialState);
      this.updateColumnState([
        "aggregation",
        "columnOrder",
        "columnPinning",
        "columnSizing",
        "columnVisibility",
        "pivot",
        "pivot",
        "rowGroup",
        "sort"
      ]);
      this.updateCachedState("columnGroup", this.getColumnGroupState());
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, () => this.updateColumnState(["aggregation"]));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, () => this.updateColumnState(["columnOrder"]));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PINNED, () => this.updateColumnState(["columnPinning"]));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_RESIZED, () => this.updateColumnState(["columnSizing"]));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, () => this.updateColumnState(["columnVisibility"]));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, () => this.updateColumnState(["pivot"]));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, () => this.updateColumnState(["pivot"]));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.updateColumnState(["rowGroup"]));
      this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, () => this.updateColumnState(["sort"]));
      this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, () => this.updateColumnState([
        "aggregation",
        "columnOrder",
        "columnPinning",
        "columnSizing",
        "columnVisibility",
        "pivot",
        "pivot",
        "rowGroup",
        "sort"
      ]));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_GROUP_OPENED, () => this.updateCachedState("columnGroup", this.getColumnGroupState()));
    }
    setupStateOnRowCountReady() {
      var _a;
      const {
        filter: filterState,
        rowGroupExpansion: rowGroupExpansionState,
        rowSelection: rowSelectionState,
        pagination: paginationState
      } = (_a = this.gos.get("initialState")) != null ? _a : {};
      const advancedFilterModel = this.gos.get("advancedFilterModel");
      if (filterState || advancedFilterModel) {
        this.setFilterState(filterState, advancedFilterModel);
      }
      if (rowGroupExpansionState) {
        this.setRowGroupExpansionState(rowGroupExpansionState);
      }
      if (rowSelectionState) {
        this.setRowSelectionState(rowSelectionState);
      }
      if (paginationState) {
        this.setPaginationState(paginationState);
      }
      this.updateCachedState("filter", this.getFilterState());
      this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState());
      this.updateCachedState("rowSelection", this.getRowSelectionState());
      this.updateCachedState("pagination", this.getPaginationState());
      this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, () => this.updateCachedState("filter", this.getFilterState()));
      this.addManagedListener(this.eventService, Events.EVENT_ROW_GROUP_OPENED, () => this.onRowGroupOpenedDebounced());
      this.addManagedListener(this.eventService, Events.EVENT_EXPAND_COLLAPSE_ALL, () => this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()));
      this.addManagedListener(this.eventService, Events.EVENT_SELECTION_CHANGED, () => {
        this.staleStateKeys.add("rowSelection");
        this.onRowSelectedDebounced();
      });
      this.addManagedListener(this.eventService, Events.EVENT_PAGINATION_CHANGED, (event) => {
        if (event.newPage || event.newPageSize) {
          this.updateCachedState("pagination", this.getPaginationState());
        }
      });
    }
    setupStateOnFirstDataRendered() {
      var _a;
      const {
        scroll: scrollState,
        rangeSelection: rangeSelectionState,
        focusedCell: focusedCellState,
        columnOrder: columnOrderState
      } = (_a = this.gos.get("initialState")) != null ? _a : {};
      if (focusedCellState) {
        this.setFocusedCellState(focusedCellState);
      }
      if (rangeSelectionState) {
        this.setRangeSelectionState(rangeSelectionState);
      }
      if (scrollState) {
        this.setScrollState(scrollState);
      }
      this.setColumnPivotState(!!(columnOrderState == null ? void 0 : columnOrderState.orderedColIds));
      this.updateCachedState("sideBar", this.getSideBarState());
      this.updateCachedState("focusedCell", this.getFocusedCellState());
      this.updateCachedState("rangeSelection", this.getRangeSelectionState());
      this.updateCachedState("scroll", this.getScrollState());
      this.addManagedListener(this.eventService, Events.EVENT_CELL_FOCUSED, () => this.updateCachedState("focusedCell", this.getFocusedCellState()));
      this.addManagedListener(this.eventService, Events.EVENT_RANGE_SELECTION_CHANGED, (event) => {
        if (event.finished) {
          this.updateCachedState("rangeSelection", this.getRangeSelectionState());
        }
      });
      this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL_END, () => this.updateCachedState("scroll", this.getScrollState()));
    }
    getColumnState() {
      const pivotMode = this.columnModel.isPivotMode();
      const sortColumns = [];
      const groupColIds = [];
      const aggregationColumns = [];
      const pivotColIds = [];
      const leftColIds = [];
      const rightColIds = [];
      const hiddenColIds = [];
      const columnSizes = [];
      const columns = [];
      const columnState = this.columnModel.getColumnState();
      for (let i = 0; i < columnState.length; i++) {
        const {
          colId,
          sort,
          sortIndex,
          rowGroup,
          rowGroupIndex,
          aggFunc,
          pivot,
          pivotIndex,
          pinned,
          hide,
          width,
          flex
        } = columnState[i];
        columns.push(colId);
        if (sort) {
          sortColumns[sortIndex != null ? sortIndex : 0] = { colId, sort };
        }
        if (rowGroup) {
          groupColIds[rowGroupIndex != null ? rowGroupIndex : 0] = colId;
        }
        if (typeof aggFunc === "string") {
          aggregationColumns.push({ colId, aggFunc });
        }
        if (pivot) {
          pivotColIds[pivotIndex != null ? pivotIndex : 0] = colId;
        }
        if (pinned) {
          (pinned === "right" ? rightColIds : leftColIds).push(colId);
        }
        if (hide) {
          hiddenColIds.push(colId);
        }
        if (flex || width) {
          columnSizes.push({ colId, flex: flex != null ? flex : void 0, width });
        }
      }
      return {
        sort: sortColumns.length ? { sortModel: sortColumns } : void 0,
        rowGroup: groupColIds.length ? { groupColIds } : void 0,
        aggregation: aggregationColumns.length ? { aggregationModel: aggregationColumns } : void 0,
        pivot: pivotColIds.length || pivotMode ? { pivotMode, pivotColIds } : void 0,
        columnPinning: leftColIds.length || rightColIds.length ? { leftColIds, rightColIds } : void 0,
        columnVisibility: hiddenColIds.length ? { hiddenColIds } : void 0,
        columnSizing: columnSizes.length ? { columnSizingModel: columnSizes } : void 0,
        columnOrder: columns.length ? { orderedColIds: columns } : void 0
      };
    }
    setColumnState(initialState) {
      const {
        sort: sortState,
        rowGroup: groupState,
        aggregation: aggregationState,
        pivot: pivotState,
        columnPinning: columnPinningState,
        columnVisibility: columnVisibilityState,
        columnSizing: columnSizingState,
        columnOrder: columnOrderState
      } = initialState;
      const columnStateMap = {};
      const getColumnState = (colId) => {
        let columnState = columnStateMap[colId];
        if (columnState) {
          return columnState;
        }
        columnState = { colId };
        columnStateMap[colId] = columnState;
        return columnState;
      };
      if (sortState) {
        sortState.sortModel.forEach(({ colId, sort }, sortIndex) => {
          const columnState = getColumnState(colId);
          columnState.sort = sort;
          columnState.sortIndex = sortIndex;
        });
      }
      if (groupState) {
        groupState.groupColIds.forEach((colId, rowGroupIndex) => {
          const columnState = getColumnState(colId);
          columnState.rowGroup = true;
          columnState.rowGroupIndex = rowGroupIndex;
        });
      }
      if (aggregationState) {
        aggregationState.aggregationModel.forEach(({ colId, aggFunc }) => {
          getColumnState(colId).aggFunc = aggFunc;
        });
      }
      if (pivotState) {
        pivotState.pivotColIds.forEach((colId, pivotIndex) => {
          const columnState = getColumnState(colId);
          columnState.pivot = true;
          columnState.pivotIndex = pivotIndex;
        });
        this.gos.updateGridOptions({ options: { pivotMode: pivotState.pivotMode }, source: "gridInitializing" });
      }
      if (columnPinningState) {
        columnPinningState.leftColIds.forEach((colId) => {
          getColumnState(colId).pinned = "left";
        });
        columnPinningState.rightColIds.forEach((colId) => {
          getColumnState(colId).pinned = "right";
        });
      }
      if (columnVisibilityState) {
        columnVisibilityState.hiddenColIds.forEach((colId) => {
          getColumnState(colId).hide = true;
        });
      }
      if (columnSizingState) {
        columnSizingState.columnSizingModel.forEach(({ colId, flex, width }) => {
          const columnState = getColumnState(colId);
          columnState.flex = flex != null ? flex : null;
          columnState.width = width;
        });
      }
      const columns = columnOrderState == null ? void 0 : columnOrderState.orderedColIds;
      const applyOrder = !!(columns == null ? void 0 : columns.length);
      const columnStates = applyOrder ? columns.map((colId) => getColumnState(colId)) : Object.values(columnStateMap);
      if (columnStates.length) {
        this.columnStates = columnStates;
        const defaultState = {
          sort: null,
          sortIndex: null,
          rowGroup: null,
          rowGroupIndex: null,
          aggFunc: null,
          pivot: null,
          pivotIndex: null,
          pinned: null,
          hide: null,
          flex: null
        };
        this.columnModel.applyColumnState({
          state: columnStates,
          applyOrder,
          defaultState
        }, "gridInitializing");
      }
    }
    setColumnPivotState(applyOrder) {
      const columnStates = this.columnStates;
      this.columnStates = void 0;
      const columnGroupStates = this.columnGroupStates;
      this.columnGroupStates = void 0;
      if (!this.columnModel.isSecondaryColumnsPresent()) {
        return;
      }
      if (columnStates) {
        let secondaryColumnStates = [];
        for (const columnState of columnStates) {
          if (this.columnModel.getSecondaryColumn(columnState.colId)) {
            secondaryColumnStates.push(columnState);
          }
        }
        this.columnModel.applyColumnState({
          state: secondaryColumnStates,
          applyOrder
        }, "gridInitializing");
      }
      if (columnGroupStates) {
        this.columnModel.setColumnGroupState(columnGroupStates, "gridInitializing");
      }
    }
    getColumnGroupState() {
      const columnGroupState = this.columnModel.getColumnGroupState();
      const openColumnGroups = [];
      columnGroupState.forEach(({ groupId, open }) => {
        if (open) {
          openColumnGroups.push(groupId);
        }
      });
      return openColumnGroups.length ? { openColumnGroupIds: openColumnGroups } : void 0;
    }
    setColumnGroupState(initialState) {
      var _a;
      if (!initialState.hasOwnProperty("columnGroup")) {
        return;
      }
      const openColumnGroups = new Set((_a = initialState.columnGroup) == null ? void 0 : _a.openColumnGroupIds);
      const existingColumnGroupState = this.columnModel.getColumnGroupState();
      const stateItems = existingColumnGroupState.map(({ groupId }) => {
        const open = openColumnGroups.has(groupId);
        if (open) {
          openColumnGroups.delete(groupId);
        }
        return {
          groupId,
          open
        };
      });
      openColumnGroups.forEach((groupId) => {
        stateItems.push({
          groupId,
          open: true
        });
      });
      if (stateItems.length) {
        this.columnGroupStates = stateItems;
      }
      this.columnModel.setColumnGroupState(stateItems, "gridInitializing");
    }
    getFilterState() {
      var _a;
      let filterModel = this.filterManager.getFilterModel();
      if (filterModel && Object.keys(filterModel).length === 0) {
        filterModel = void 0;
      }
      const advancedFilterModel = (_a = this.filterManager.getAdvancedFilterModel()) != null ? _a : void 0;
      return filterModel || advancedFilterModel ? { filterModel, advancedFilterModel } : void 0;
    }
    setFilterState(filterState, gridOptionAdvancedFilterModel) {
      const { filterModel, advancedFilterModel } = filterState != null ? filterState : { advancedFilterModel: gridOptionAdvancedFilterModel };
      if (filterModel) {
        this.filterManager.setFilterModel(filterModel, "columnFilter");
      }
      if (advancedFilterModel) {
        this.filterManager.setAdvancedFilterModel(advancedFilterModel);
      }
    }
    getRangeSelectionState() {
      var _a;
      const cellRanges = (_a = this.rangeService) == null ? void 0 : _a.getCellRanges().map((cellRange) => {
        const { id, type, startRow, endRow, columns, startColumn } = cellRange;
        return {
          id,
          type,
          startRow,
          endRow,
          colIds: columns.map((column) => column.getColId()),
          startColId: startColumn.getColId()
        };
      });
      return (cellRanges == null ? void 0 : cellRanges.length) ? { cellRanges } : void 0;
    }
    setRangeSelectionState(rangeSelectionState) {
      if (!this.gos.get("enableRangeSelection") || !this.rangeService) {
        return;
      }
      const cellRanges = [];
      rangeSelectionState.cellRanges.forEach((cellRange) => {
        const columns = [];
        cellRange.colIds.forEach((colId) => {
          const column = this.columnModel.getGridColumn(colId);
          if (column) {
            columns.push(column);
          }
        });
        if (!columns.length) {
          return;
        }
        let startColumn = this.columnModel.getGridColumn(cellRange.startColId);
        if (!startColumn) {
          const allColumns = this.columnModel.getAllDisplayedColumns();
          const columnSet = new Set(columns);
          startColumn = allColumns.find((column) => columnSet.has(column));
        }
        cellRanges.push(__spreadProps(__spreadValues({}, cellRange), {
          columns,
          startColumn
        }));
      });
      this.rangeService.setCellRanges(cellRanges);
    }
    getScrollState() {
      var _a, _b, _c;
      if (!this.isClientSideRowModel) {
        return void 0;
      }
      const scrollFeature = (_a = this.ctrlsService.getGridBodyCtrl()) == null ? void 0 : _a.getScrollFeature();
      const { left } = (_b = scrollFeature == null ? void 0 : scrollFeature.getHScrollPosition()) != null ? _b : { left: 0 };
      const { top } = (_c = scrollFeature == null ? void 0 : scrollFeature.getVScrollPosition()) != null ? _c : { top: 0 };
      return top || left ? {
        top,
        left
      } : void 0;
    }
    setScrollState(scrollState) {
      var _a;
      if (!this.isClientSideRowModel) {
        return;
      }
      const { top, left } = scrollState;
      (_a = this.ctrlsService.getGridBodyCtrl()) == null ? void 0 : _a.getScrollFeature().setScrollPosition(top, left);
    }
    getSideBarState() {
      var _a, _b;
      return (_b = (_a = this.sideBarService) == null ? void 0 : _a.getSideBarComp()) == null ? void 0 : _b.getState();
    }
    getFocusedCellState() {
      if (!this.isClientSideRowModel) {
        return void 0;
      }
      const focusedCell = this.focusService.getFocusedCell();
      if (focusedCell) {
        const { column, rowIndex, rowPinned } = focusedCell;
        return {
          colId: column.getColId(),
          rowIndex,
          rowPinned
        };
      }
      return void 0;
    }
    setFocusedCellState(focusedCellState) {
      if (!this.isClientSideRowModel) {
        return;
      }
      const { colId, rowIndex, rowPinned } = focusedCellState;
      this.focusService.setFocusedCell({
        column: this.columnModel.getGridColumn(colId),
        rowIndex,
        rowPinned,
        forceBrowserFocus: true,
        preventScrollOnBrowserFocus: true
      });
    }
    getPaginationState() {
      const page = this.paginationProxy.getCurrentPage();
      const pageSize = !this.gos.get("paginationAutoPageSize") ? this.paginationProxy.getPageSize() : void 0;
      if (!page && !pageSize) {
        return;
      }
      return { page, pageSize };
    }
    setPaginationState(paginationState) {
      if (paginationState.pageSize && !this.gos.get("paginationAutoPageSize")) {
        this.paginationProxy.setPageSize(paginationState.pageSize, "initialState");
      }
      if (typeof paginationState.page === "number") {
        this.paginationProxy.setPage(paginationState.page);
      }
    }
    getRowSelectionState() {
      var _a;
      const selectionState = this.selectionService.getSelectionState();
      const noSelections = !selectionState || !Array.isArray(selectionState) && (selectionState.selectAll === false || selectionState.selectAllChildren === false) && !((_a = selectionState == null ? void 0 : selectionState.toggledNodes) == null ? void 0 : _a.length);
      return noSelections ? void 0 : selectionState;
    }
    setRowSelectionState(rowSelectionState) {
      this.selectionService.setSelectionState(rowSelectionState, "gridInitializing");
    }
    getRowGroupExpansionState() {
      const expandedRowGroups = this.expansionService.getExpandedRows();
      return expandedRowGroups.length ? {
        expandedRowGroupIds: expandedRowGroups
      } : void 0;
    }
    setRowGroupExpansionState(rowGroupExpansionState) {
      this.expansionService.expandRows(rowGroupExpansionState.expandedRowGroupIds);
    }
    updateColumnState(features) {
      const newColumnState = this.getColumnState();
      let hasChanged2 = false;
      Object.entries(newColumnState).forEach(([key, value]) => {
        if (!jsonEquals(value, this.cachedState[key])) {
          hasChanged2 = true;
        }
      });
      this.cachedState = __spreadValues(__spreadValues({}, this.cachedState), newColumnState);
      if (hasChanged2) {
        this.dispatchStateUpdateEvent(features);
      }
    }
    updateCachedState(key, value) {
      const existingValue = this.cachedState[key];
      this.setCachedStateValue(key, value);
      if (!jsonEquals(value, existingValue)) {
        this.dispatchStateUpdateEvent([key]);
      }
    }
    setCachedStateValue(key, value) {
      this.cachedState = __spreadProps(__spreadValues({}, this.cachedState), {
        [key]: value
      });
    }
    refreshStaleState() {
      this.staleStateKeys.forEach((key) => {
        switch (key) {
          case "rowSelection":
            this.setCachedStateValue(key, this.getRowSelectionState());
            break;
        }
      });
      this.staleStateKeys.clear();
    }
    dispatchStateUpdateEvent(sources) {
      if (this.suppressEvents) {
        return;
      }
      sources.forEach((source) => this.queuedUpdateSources.add(source));
      this.dispatchStateUpdateEventDebounced();
    }
    dispatchQueuedStateUpdateEvents() {
      const sources = Array.from(this.queuedUpdateSources);
      this.queuedUpdateSources.clear();
      const event = {
        type: Events.EVENT_STATE_UPDATED,
        sources,
        state: this.cachedState
      };
      this.eventService.dispatchEvent(event);
    }
    suppressEventsAndDispatchInitEvent(updateFunc) {
      this.suppressEvents = true;
      this.columnAnimationService.setSuppressAnimation(true);
      updateFunc();
      setTimeout(() => {
        this.suppressEvents = false;
        this.queuedUpdateSources.clear();
        if (!this.isAlive()) {
          return;
        }
        this.columnAnimationService.setSuppressAnimation(false);
        this.dispatchStateUpdateEvent(["gridInitializing"]);
      });
    }
  };
  __decorateClass([
    Autowired("filterManager")
  ], StateService.prototype, "filterManager", 2);
  __decorateClass([
    Autowired("ctrlsService")
  ], StateService.prototype, "ctrlsService", 2);
  __decorateClass([
    Autowired("focusService")
  ], StateService.prototype, "focusService", 2);
  __decorateClass([
    Autowired("columnModel")
  ], StateService.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("paginationProxy")
  ], StateService.prototype, "paginationProxy", 2);
  __decorateClass([
    Autowired("rowModel")
  ], StateService.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("selectionService")
  ], StateService.prototype, "selectionService", 2);
  __decorateClass([
    Autowired("expansionService")
  ], StateService.prototype, "expansionService", 2);
  __decorateClass([
    Autowired("columnAnimationService")
  ], StateService.prototype, "columnAnimationService", 2);
  __decorateClass([
    Optional("sideBarService")
  ], StateService.prototype, "sideBarService", 2);
  __decorateClass([
    Optional("rangeService")
  ], StateService.prototype, "rangeService", 2);
  __decorateClass([
    PostConstruct
  ], StateService.prototype, "postConstruct", 1);
  StateService = __decorateClass([
    Bean("stateService")
  ], StateService);
  var ValidationService = class extends BeanStub {
    init() {
      this.processGridOptions(this.gridOptions);
    }
    processGridOptions(options) {
      this.processOptions(options, GRID_OPTIONS_VALIDATORS);
    }
    processColumnDefs(options) {
      this.processOptions(options, COL_DEF_VALIDATORS);
    }
    processOptions(options, validator) {
      const { validations, deprecations, allProperties, propertyExceptions, objectName, docsUrl } = validator;
      if (allProperties && this.gridOptions.suppressPropertyNamesCheck !== true) {
        this.checkProperties(
          options,
          [...propertyExceptions != null ? propertyExceptions : [], ...Object.keys(deprecations)],
          allProperties,
          objectName,
          docsUrl
        );
      }
      const warnings = /* @__PURE__ */ new Set();
      const optionKeys = Object.keys(options);
      optionKeys.forEach((key) => {
        var _a;
        const deprecation = deprecations[key];
        if (deprecation) {
          if ("renamed" in deprecation) {
            const { renamed, version: version2 } = deprecation;
            warnings.add(`As of v${version2}, ${String(key)} is deprecated. Please use ${String(renamed)} instead.`);
            options[renamed] = options[key];
          } else {
            const { message, version: version2 } = deprecation;
            warnings.add(`As of v${version2}, ${String(key)} is deprecated. ${message != null ? message : ""}`);
          }
        }
        const value = options[key];
        if (value == null || value === false) {
          return;
        }
        const rulesOrGetter = validations[key];
        let rules;
        if (!rulesOrGetter) {
          return;
        } else if (typeof rulesOrGetter === "function") {
          const fromGetter = rulesOrGetter(options, this.gridOptions);
          if (!fromGetter) {
            return;
          }
          if ("objectName" in fromGetter) {
            const value2 = options[key];
            if (Array.isArray(value2)) {
              value2.forEach((item) => {
                this.processOptions(item, fromGetter);
              });
              return;
            }
            this.processOptions(options[key], fromGetter);
            return;
          }
          rules = fromGetter;
        } else {
          rules = rulesOrGetter;
        }
        const { module, dependencies, supportedRowModels } = rules;
        if (supportedRowModels) {
          const rowModel = (_a = this.gridOptions.rowModelType) != null ? _a : "clientSide";
          if (!supportedRowModels.includes(rowModel)) {
            warnings.add(`${String(key)} is not supported with the '${rowModel}' row model.`);
            return;
          }
        }
        if (module) {
          const modules = Array.isArray(module) ? module : [module];
          let allRegistered = true;
          modules.forEach((m) => {
            if (!ModuleRegistry.__assertRegistered(m, String(key), this.context.getGridId())) {
              allRegistered = false;
              warnings.add(`${String(key)} is only available when ${m} is loaded.`);
            }
          });
          if (!allRegistered) {
            return;
          }
        }
        if (dependencies) {
          const warning = this.checkForWarning(key, dependencies, options);
          if (warning) {
            warnings.add(warning);
            return;
          }
        }
      });
      if (warnings.size > 0) {
        warnings.forEach((warning) => {
          warnOnce(warning);
        });
      }
    }
    checkForWarning(key, validator, options) {
      if (typeof validator === "function") {
        return validator(options, this.gridOptions);
      }
      const optionEntries = Object.entries(validator);
      const failed = optionEntries.find(([key2, value]) => {
        const gridOptionValue = options[key2];
        return !value.includes(gridOptionValue);
      });
      if (!failed) {
        return null;
      }
      const [failedKey, possibleOptions] = failed;
      if (possibleOptions.length > 1) {
        return `'${String(key)}' requires '${failedKey}' to be one of [${possibleOptions.join(", ")}].`;
      }
      return `'${String(key)}' requires '${failedKey}' to be ${possibleOptions[0]}.`;
    }
    checkProperties(object, exceptions, validProperties, containerName, docsUrl) {
      const VUE_FRAMEWORK_PROPS = ["__ob__", "__v_skip", "__metadata__"];
      const invalidProperties = fuzzyCheckStrings(
        Object.getOwnPropertyNames(object),
        [...VUE_FRAMEWORK_PROPS, ...exceptions, ...validProperties],
        validProperties
      );
      iterateObject(invalidProperties, (key, value) => {
        warnOnce(`invalid ${containerName} property '${key}' did you mean any of these: ${value.slice(0, 8).join(", ")}`);
      });
      if (Object.keys(invalidProperties).length > 0 && docsUrl) {
        const url = this.getFrameworkOverrides().getDocLink(docsUrl);
        warnOnce(`to see all the valid ${containerName} properties please check: ${url}`);
      }
    }
  };
  __decorateClass([
    Autowired("gridOptions")
  ], ValidationService.prototype, "gridOptions", 2);
  __decorateClass([
    PostConstruct
  ], ValidationService.prototype, "init", 1);
  ValidationService = __decorateClass([
    Bean("validationService")
  ], ValidationService);
  var ApiEventService = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.syncEventListeners = /* @__PURE__ */ new Map();
      this.asyncEventListeners = /* @__PURE__ */ new Map();
      this.syncGlobalEventListeners = /* @__PURE__ */ new Set();
      this.globalEventListenerPairs = /* @__PURE__ */ new Map();
    }
    postConstruct() {
      this.frameworkEventWrappingService = new FrameworkEventListenerService(this.getFrameworkOverrides());
    }
    addEventListener(eventType, userListener) {
      const listener = this.frameworkEventWrappingService.wrap(userListener);
      const async = this.gos.useAsyncEvents() && !ALWAYS_SYNC_GLOBAL_EVENTS.has(eventType);
      ;
      const listeners = async ? this.asyncEventListeners : this.syncEventListeners;
      if (!listeners.has(eventType)) {
        listeners.set(eventType, /* @__PURE__ */ new Set());
      }
      listeners.get(eventType).add(listener);
      this.eventService.addEventListener(eventType, listener, async);
    }
    removeEventListener(eventType, userListener) {
      var _a;
      const listener = this.frameworkEventWrappingService.unwrap(userListener);
      const asyncListeners = this.asyncEventListeners.get(eventType);
      const hasAsync = !!(asyncListeners == null ? void 0 : asyncListeners.delete(listener));
      if (!hasAsync) {
        (_a = this.syncEventListeners.get(eventType)) == null ? void 0 : _a.delete(listener);
      }
      this.eventService.removeEventListener(eventType, listener, hasAsync);
    }
    addGlobalListener(userListener) {
      const listener = this.frameworkEventWrappingService.wrapGlobal(userListener);
      const async = this.gos.useAsyncEvents();
      if (async) {
        const syncListener = (eventType, event) => {
          if (ALWAYS_SYNC_GLOBAL_EVENTS.has(eventType)) {
            listener(eventType, event);
          }
        };
        const asyncListener = (eventType, event) => {
          if (!ALWAYS_SYNC_GLOBAL_EVENTS.has(eventType)) {
            listener(eventType, event);
          }
        };
        this.globalEventListenerPairs.set(userListener, { syncListener, asyncListener });
        this.eventService.addGlobalListener(syncListener, false);
        this.eventService.addGlobalListener(asyncListener, true);
      } else {
        this.syncGlobalEventListeners.add(listener);
        this.eventService.addGlobalListener(listener, false);
      }
    }
    removeGlobalListener(userListener) {
      const listener = this.frameworkEventWrappingService.unwrapGlobal(userListener);
      const hasAsync = this.globalEventListenerPairs.has(listener);
      if (hasAsync) {
        const { syncListener, asyncListener } = this.globalEventListenerPairs.get(listener);
        this.eventService.removeGlobalListener(syncListener, false);
        this.eventService.removeGlobalListener(asyncListener, true);
        this.globalEventListenerPairs.delete(userListener);
      } else {
        this.syncGlobalEventListeners.delete(listener);
        this.eventService.removeGlobalListener(listener, false);
      }
    }
    destroyEventListeners(map2, async) {
      map2.forEach((listeners, eventType) => {
        listeners.forEach((listener) => this.eventService.removeEventListener(eventType, listener, async));
        listeners.clear();
      });
      map2.clear();
    }
    destroyGlobalListeners(set2, async) {
      set2.forEach((listener) => this.eventService.removeGlobalListener(listener, async));
      set2.clear();
    }
    destroy() {
      super.destroy();
      this.destroyEventListeners(this.syncEventListeners, false);
      this.destroyEventListeners(this.asyncEventListeners, true);
      this.destroyGlobalListeners(this.syncGlobalEventListeners, false);
      this.globalEventListenerPairs.forEach(({ syncListener, asyncListener }) => {
        this.eventService.removeGlobalListener(syncListener, false);
        this.eventService.removeGlobalListener(asyncListener, true);
      });
      this.globalEventListenerPairs.clear();
    }
  };
  __decorateClass([
    PostConstruct
  ], ApiEventService.prototype, "postConstruct", 1);
  ApiEventService = __decorateClass([
    Bean("apiEventService")
  ], ApiEventService);
  var PageSizeSelectorComp = class extends Component {
    constructor() {
      super(
        /* html */
        `<span class="ag-paging-page-size"></span>`
      );
      this.hasEmptyOption = false;
      this.handlePageSizeItemSelected = () => {
        if (!this.selectPageSizeComp) {
          return;
        }
        const newValue = this.selectPageSizeComp.getValue();
        if (!newValue) {
          return;
        }
        const paginationPageSize = Number(newValue);
        if (isNaN(paginationPageSize) || paginationPageSize < 1 || paginationPageSize === this.paginationProxy.getPageSize()) {
          return;
        }
        this.paginationProxy.setPageSize(paginationPageSize, "pageSizeSelector");
        if (this.hasEmptyOption) {
          this.toggleSelectDisplay(true);
        }
        this.selectPageSizeComp.getFocusableElement().focus();
      };
    }
    init() {
      this.addManagedPropertyListener("paginationPageSizeSelector", () => {
        this.onPageSizeSelectorValuesChange();
      });
      this.addManagedListener(
        this.eventService,
        Events.EVENT_PAGINATION_CHANGED,
        (event) => this.handlePaginationChanged(event)
      );
    }
    handlePaginationChanged(paginationChangedEvent) {
      if (!this.selectPageSizeComp || !(paginationChangedEvent == null ? void 0 : paginationChangedEvent.newPageSize)) {
        return;
      }
      const paginationPageSize = this.paginationProxy.getPageSize();
      if (this.getPageSizeSelectorValues().includes(paginationPageSize)) {
        this.selectPageSizeComp.setValue(paginationPageSize.toString());
      } else {
        if (this.hasEmptyOption) {
          this.selectPageSizeComp.setValue("");
        } else {
          this.toggleSelectDisplay(true);
        }
      }
    }
    toggleSelectDisplay(show) {
      if (this.selectPageSizeComp) {
        this.reset();
      }
      if (!show) {
        return;
      }
      this.reloadPageSizesSelector();
      if (!this.selectPageSizeComp) {
        return;
      }
      this.appendChild(this.selectPageSizeComp);
    }
    reset() {
      clearElement(this.getGui());
      if (!this.selectPageSizeComp) {
        return;
      }
      this.destroyBean(this.selectPageSizeComp);
      this.selectPageSizeComp = void 0;
    }
    onPageSizeSelectorValuesChange() {
      if (!this.selectPageSizeComp) {
        return;
      }
      if (this.shouldShowPageSizeSelector()) {
        this.reloadPageSizesSelector();
      }
    }
    shouldShowPageSizeSelector() {
      return this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel") && !this.gos.get("paginationAutoPageSize") && this.gos.get("paginationPageSizeSelector") !== false;
    }
    reloadPageSizesSelector() {
      const pageSizeOptions = this.getPageSizeSelectorValues();
      const paginationPageSizeOption = this.paginationProxy.getPageSize();
      const shouldAddAndSelectEmptyOption = !paginationPageSizeOption || !pageSizeOptions.includes(paginationPageSizeOption);
      if (shouldAddAndSelectEmptyOption) {
        pageSizeOptions.unshift("");
        warnOnce(
          `The paginationPageSize grid option is set to a value that is not in the list of page size options.
                Please make sure that the paginationPageSize grid option is set to one of the values in the 
                paginationPageSizeSelector array, or set the paginationPageSizeSelector to false to hide the page size selector.`
        );
      }
      if (this.selectPageSizeComp) {
        this.destroyBean(this.selectPageSizeComp);
        this.selectPageSizeComp = void 0;
      }
      const localeTextFunc = this.localeService.getLocaleTextFunc();
      const localisedLabel = localeTextFunc("pageSizeSelectorLabel", "Page Size:");
      const options = pageSizeOptions.map((value) => ({
        value: String(value),
        text: String(value)
      }));
      const localisedAriaLabel = localeTextFunc("ariaPageSizeSelectorLabel", "Page Size");
      this.selectPageSizeComp = this.createManagedBean(new AgSelect()).addOptions(options).setValue(String(shouldAddAndSelectEmptyOption ? "" : paginationPageSizeOption)).setAriaLabel(localisedAriaLabel).setLabel(localisedLabel).onValueChange(() => this.handlePageSizeItemSelected());
      this.hasEmptyOption = shouldAddAndSelectEmptyOption;
    }
    getPageSizeSelectorValues() {
      const defaultValues = [20, 50, 100];
      const paginationPageSizeSelectorValues = this.gos.get("paginationPageSizeSelector");
      if (!Array.isArray(paginationPageSizeSelectorValues) || !this.validateValues(paginationPageSizeSelectorValues)) {
        return defaultValues;
      }
      return [...paginationPageSizeSelectorValues].sort((a, b) => a - b);
    }
    validateValues(values2) {
      if (!values2.length) {
        warnOnce(
          `The paginationPageSizeSelector grid option is an empty array. This is most likely a mistake.
                If you want to hide the page size selector, please set the paginationPageSizeSelector to false.`
        );
        return false;
      }
      for (let i = 0; i < values2.length; i++) {
        const value = values2[i];
        const isNumber = typeof value === "number";
        const isPositive = value > 0;
        if (!isNumber) {
          warnOnce(
            `The paginationPageSizeSelector grid option contains a non-numeric value.
                    Please make sure that all values in the paginationPageSizeSelector array are numbers.`
          );
          return false;
        }
        if (!isPositive) {
          warnOnce(
            `The paginationPageSizeSelector grid option contains a negative number or zero.
                    Please make sure that all values in the paginationPageSizeSelector array are positive.`
          );
          return false;
        }
      }
      return true;
    }
    destroy() {
      this.toggleSelectDisplay(false);
      super.destroy();
    }
  };
  __decorateClass([
    Autowired("paginationProxy")
  ], PageSizeSelectorComp.prototype, "paginationProxy", 2);
  __decorateClass([
    PostConstruct
  ], PageSizeSelectorComp.prototype, "init", 1);
  var AriaAnnouncementService = class extends BeanStub {
    constructor() {
      super();
      this.descriptionContainer = null;
      this.announceValue = debounce2(this.announceValue.bind(this), 200);
    }
    postConstruct() {
      const eDocument = this.gos.getDocument();
      const div = this.descriptionContainer = eDocument.createElement("div");
      div.classList.add("ag-aria-description-container");
      setAriaLive(div, "polite");
      setAriaRelevant(div, "additions text");
      setAriaAtomic(div, true);
      this.eGridDiv.appendChild(div);
    }
    announceValue(value) {
      if (!this.descriptionContainer) {
        return;
      }
      this.descriptionContainer.textContent = "";
      setTimeout(() => {
        if (this.isAlive() && this.descriptionContainer) {
          this.descriptionContainer.textContent = value;
        }
      }, 50);
    }
    destroy() {
      super.destroy();
      const { descriptionContainer } = this;
      if (descriptionContainer) {
        clearElement(descriptionContainer);
        if (descriptionContainer.parentElement) {
          descriptionContainer.parentElement.removeChild(descriptionContainer);
        }
      }
      this.descriptionContainer = null;
      this.eGridDiv = null;
    }
  };
  __decorateClass([
    Autowired("eGridDiv")
  ], AriaAnnouncementService.prototype, "eGridDiv", 2);
  __decorateClass([
    PostConstruct
  ], AriaAnnouncementService.prototype, "postConstruct", 1);
  AriaAnnouncementService = __decorateClass([
    Bean("ariaAnnouncementService")
  ], AriaAnnouncementService);
  var GlobalGridOptions = class {
  };
  GlobalGridOptions.gridOptions = void 0;
  function provideGlobalGridOptions(gridOptions) {
    GlobalGridOptions.gridOptions = gridOptions;
  }
  function createGrid(eGridDiv, gridOptions, params) {
    if (!gridOptions) {
      errorOnce("No gridOptions provided to createGrid");
      return {};
    }
    const api = new GridCoreCreator().create(eGridDiv, gridOptions, (context) => {
      const gridComp = new GridComp(eGridDiv);
      context.createBean(gridComp);
    }, void 0, params);
    if (!Object.isFrozen(gridOptions) && !(params == null ? void 0 : params.frameworkOverrides)) {
      const apiUrl = "https://ag-grid.com/javascript-data-grid/grid-interface/#grid-api";
      Object.defineProperty(gridOptions, "api", {
        get: () => {
          errorOnce(`gridOptions.api is no longer supported. See ${apiUrl}.`);
          return void 0;
        },
        configurable: true
      });
      Object.defineProperty(gridOptions, "columnApi", {
        get: () => {
          errorOnce(`gridOptions.columnApi is no longer supported and all methods moved to the grid api. See ${apiUrl}.`);
          return void 0;
        },
        configurable: true
      });
    }
    return api;
  }
  var Grid = class {
    // Not typed to enable setting api / columnApi for backwards compatibility
    constructor(eGridDiv, gridOptions, params) {
      warnOnce("Since v31 new Grid(...) is deprecated. Use createGrid instead: `const gridApi = createGrid(...)`. The grid api is returned from createGrid and will not be available on gridOptions.");
      if (!gridOptions) {
        errorOnce("No gridOptions provided to the grid");
        return;
      }
      this.gridOptions = gridOptions;
      const api = new GridCoreCreator().create(
        eGridDiv,
        gridOptions,
        (context) => {
          const gridComp = new GridComp(eGridDiv);
          const bean = context.createBean(gridComp);
          bean.addDestroyFunc(() => {
            this.destroy();
          });
        },
        void 0,
        params
      );
      this.gridOptions.api = api;
      this.gridOptions.columnApi = new ColumnApi(api);
    }
    destroy() {
      var _a;
      if (this.gridOptions) {
        (_a = this.gridOptions.api) == null ? void 0 : _a.destroy();
        delete this.gridOptions.api;
        delete this.gridOptions.columnApi;
      }
    }
  };
  var nextGridId = 1;
  var GridCoreCreator = class {
    create(eGridDiv, providedOptions, createUi, acceptChanges, params) {
      var _a;
      let mergedGridOps = {};
      if (GlobalGridOptions.gridOptions) {
        mergeDeep(mergedGridOps, GlobalGridOptions.gridOptions, true, true);
        mergedGridOps = __spreadValues(__spreadValues({}, mergedGridOps), providedOptions);
      } else {
        mergedGridOps = providedOptions;
      }
      const gridOptions = GridOptionsService.getCoercedGridOptions(mergedGridOps);
      const debug = !!gridOptions.debug;
      const gridId = (_a = gridOptions.gridId) != null ? _a : String(nextGridId++);
      const registeredModules = this.getRegisteredModules(params, gridId);
      const beanClasses = this.createBeansList(gridOptions.rowModelType, registeredModules, gridId);
      const providedBeanInstances = this.createProvidedBeans(eGridDiv, gridOptions, params);
      if (!beanClasses) {
        errorOnce("Failed to create grid.");
        return void 0;
      }
      const contextParams = {
        providedBeanInstances,
        beanClasses,
        debug,
        gridId
      };
      const contextLogger = new Logger("Context", () => contextParams.debug);
      const context = new Context2(contextParams, contextLogger);
      const beans = context.getBean("beans");
      this.registerModuleUserComponents(beans, registeredModules);
      this.registerStackComponents(beans, registeredModules);
      this.registerControllers(beans, registeredModules);
      createUi(context);
      beans.syncService.start();
      if (acceptChanges) {
        acceptChanges(context);
      }
      const gridApi = context.getBean("gridApi");
      return gridApi;
    }
    registerControllers(beans, registeredModules) {
      registeredModules.forEach((module) => {
        if (module.controllers) {
          module.controllers.forEach((meta) => beans.ctrlsFactory.register(meta));
        }
      });
    }
    registerStackComponents(beans, registeredModules) {
      const agStackComponents = this.createAgStackComponentsList(registeredModules);
      beans.agStackComponentsRegistry.setupComponents(agStackComponents);
    }
    getRegisteredModules(params, gridId) {
      const passedViaConstructor = params ? params.modules : null;
      const registered = ModuleRegistry.__getRegisteredModules(gridId);
      const allModules = [];
      const mapNames = {};
      const addModule = (moduleBased, mod, gridId2) => {
        const addIndividualModule = (currentModule) => {
          if (!mapNames[currentModule.moduleName]) {
            mapNames[currentModule.moduleName] = true;
            allModules.push(currentModule);
            ModuleRegistry.__register(currentModule, moduleBased, gridId2);
          }
        };
        addIndividualModule(mod);
        if (mod.dependantModules) {
          mod.dependantModules.forEach((m) => addModule(moduleBased, m, gridId2));
        }
      };
      if (passedViaConstructor) {
        passedViaConstructor.forEach((m) => addModule(true, m, gridId));
      }
      if (registered) {
        registered.forEach((m) => addModule(!ModuleRegistry.__isPackageBased(), m, void 0));
      }
      return allModules;
    }
    registerModuleUserComponents(beans, registeredModules) {
      const moduleUserComps = this.extractModuleEntity(
        registeredModules,
        (module) => module.userComponents ? module.userComponents : []
      );
      moduleUserComps.forEach((compMeta) => {
        beans.userComponentRegistry.registerDefaultComponent(compMeta.componentName, compMeta.componentClass);
      });
    }
    createProvidedBeans(eGridDiv, gridOptions, params) {
      let frameworkOverrides = params ? params.frameworkOverrides : null;
      if (missing(frameworkOverrides)) {
        frameworkOverrides = new VanillaFrameworkOverrides();
      }
      const seed = {
        gridOptions,
        eGridDiv,
        globalEventListener: params ? params.globalEventListener : null,
        globalSyncEventListener: params ? params.globalSyncEventListener : null,
        frameworkOverrides
      };
      if (params && params.providedBeanInstances) {
        Object.assign(seed, params.providedBeanInstances);
      }
      return seed;
    }
    createAgStackComponentsList(registeredModules) {
      let components = [
        { componentName: "AgCheckbox", componentClass: AgCheckbox },
        { componentName: "AgRadioButton", componentClass: AgRadioButton },
        { componentName: "AgToggleButton", componentClass: AgToggleButton },
        { componentName: "AgInputTextField", componentClass: AgInputTextField },
        { componentName: "AgInputTextArea", componentClass: AgInputTextArea },
        { componentName: "AgInputNumberField", componentClass: AgInputNumberField },
        { componentName: "AgInputDateField", componentClass: AgInputDateField },
        { componentName: "AgInputRange", componentClass: AgInputRange },
        { componentName: "AgRichSelect", componentClass: AgRichSelect },
        { componentName: "AgSelect", componentClass: AgSelect },
        { componentName: "AgSlider", componentClass: AgSlider },
        { componentName: "AgGridBody", componentClass: GridBodyComp },
        { componentName: "AgHeaderRoot", componentClass: GridHeaderComp },
        { componentName: "AgSortIndicator", componentClass: SortIndicatorComp },
        { componentName: "AgPagination", componentClass: PaginationComp },
        { componentName: "AgPageSizeSelector", componentClass: PageSizeSelectorComp },
        { componentName: "AgOverlayWrapper", componentClass: OverlayWrapperComponent },
        { componentName: "AgGroupComponent", componentClass: AgGroupComponent },
        { componentName: "AgRowContainer", componentClass: RowContainerComp },
        { componentName: "AgFakeHorizontalScroll", componentClass: FakeHScrollComp },
        { componentName: "AgFakeVerticalScroll", componentClass: FakeVScrollComp },
        { componentName: "AgAutocomplete", componentClass: AgAutocomplete }
      ];
      const moduleAgStackComps = this.extractModuleEntity(
        registeredModules,
        (module) => module.agStackComponents ? module.agStackComponents : []
      );
      components = components.concat(moduleAgStackComps);
      return components;
    }
    createBeansList(rowModelType = "clientSide", registeredModules, gridId) {
      const rowModelModules = registeredModules.filter((module) => !module.rowModel || module.rowModel === rowModelType);
      const rowModelModuleNames = {
        clientSide: "@ag-grid-community/client-side-row-model",
        infinite: "@ag-grid-community/infinite-row-model",
        serverSide: "@ag-grid-enterprise/server-side-row-model",
        viewport: "@ag-grid-enterprise/viewport-row-model"
        /* ViewportRowModelModule */
      };
      if (!rowModelModuleNames[rowModelType]) {
        errorOnce("Could not find row model for rowModelType = " + rowModelType);
        return;
      }
      if (!ModuleRegistry.__assertRegistered(rowModelModuleNames[rowModelType], `rowModelType = '${rowModelType}'`, gridId)) {
        return;
      }
      const beans = [
        Beans,
        RowPositionUtils,
        CellPositionUtils,
        HeaderPositionUtils,
        PaginationAutoPageSizeService,
        GridApi,
        UserComponentRegistry,
        AgComponentUtils,
        ComponentMetadataProvider,
        ResizeObserverService,
        UserComponentFactory,
        RowContainerHeightService,
        HorizontalResizeService,
        LocaleService,
        ValidationService,
        PinnedRowModel,
        DragService,
        DisplayedGroupCreator,
        EventService,
        GridOptionsService,
        PopupService,
        SelectionService,
        FilterManager,
        ColumnModel,
        HeaderNavigationService,
        PaginationProxy,
        RowRenderer,
        ExpressionService,
        ColumnFactory,
        AlignedGridsService,
        NavigationService,
        ValueCache,
        ValueService,
        LoggerFactory,
        AutoWidthCalculator,
        StandardMenuFactory,
        DragAndDropService,
        ColumnApi,
        FocusService,
        MouseEventService,
        Environment,
        CellNavigationService,
        StylingService,
        ScrollVisibleService,
        SortController,
        ColumnHoverService,
        ColumnAnimationService,
        SelectableService,
        AutoGroupColService,
        ChangeDetectionService,
        AnimationFrameService,
        UndoRedoService,
        AgStackComponentsRegistry,
        ColumnDefFactory,
        RowCssClassCalculator,
        RowNodeBlockLoader,
        RowNodeSorter,
        CtrlsService,
        PinnedWidthService,
        RowNodeEventThrottle,
        CtrlsFactory,
        DataTypeService,
        QuickFilterService,
        SyncService,
        OverlayService,
        StateService,
        ExpansionService,
        ApiEventService,
        AriaAnnouncementService,
        MenuService
      ];
      const moduleBeans = this.extractModuleEntity(rowModelModules, (module) => module.beans ? module.beans : []);
      beans.push(...moduleBeans);
      const beansNoDuplicates = [];
      beans.forEach((bean) => {
        if (beansNoDuplicates.indexOf(bean) < 0) {
          beansNoDuplicates.push(bean);
        }
      });
      return beansNoDuplicates;
    }
    extractModuleEntity(moduleEntities, extractor) {
      return [].concat(...moduleEntities.map(extractor));
    }
  };
  var BaseComponentWrapper = class {
    wrap(OriginalConstructor, mandatoryMethodList, optionalMethodList = [], componentType) {
      const wrapper = this.createWrapper(OriginalConstructor, componentType);
      mandatoryMethodList.forEach((methodName) => {
        this.createMethod(wrapper, methodName, true);
      });
      optionalMethodList.forEach((methodName) => {
        this.createMethod(wrapper, methodName, false);
      });
      return wrapper;
    }
    unwrap(comp) {
      return comp;
    }
    createMethod(wrapper, methodName, mandatory) {
      wrapper.addMethod(methodName, this.createMethodProxy(wrapper, methodName, mandatory));
    }
    createMethodProxy(wrapper, methodName, mandatory) {
      return function() {
        if (wrapper.hasMethod(methodName)) {
          return wrapper.callMethod(methodName, arguments);
        }
        if (mandatory) {
          console.warn("AG Grid: Framework component is missing the method " + methodName + "()");
        }
        return null;
      };
    }
  };
  var ChartMappings = class {
  };
  ChartMappings.CHART_TYPE_TO_SERIES_TYPE = {
    column: "bar",
    groupedColumn: "bar",
    stackedColumn: "bar",
    normalizedColumn: "bar",
    bar: "bar",
    groupedBar: "bar",
    stackedBar: "bar",
    normalizedBar: "bar",
    line: "line",
    scatter: "scatter",
    bubble: "bubble",
    pie: "pie",
    donut: "donut",
    doughnut: "donut",
    area: "area",
    stackedArea: "area",
    normalizedArea: "area",
    histogram: "histogram",
    radarLine: "radar-line",
    radarArea: "radar-area",
    nightingale: "nightingale",
    radialColumn: "radial-column",
    radialBar: "radial-bar",
    sunburst: "sunburst",
    rangeBar: "range-bar",
    rangeArea: "range-area",
    boxPlot: "box-plot",
    treemap: "treemap",
    heatmap: "heatmap",
    waterfall: "waterfall"
  };
  ChartMappings.COMBO_CHART_TYPES = ["columnLineCombo", "areaColumnCombo", "customCombo"];
  ChartMappings.SERIES_GROUP_TYPES = ["grouped", "stacked", "normalized"];
  var BarColumnLabelPlacement = /* @__PURE__ */ ((BarColumnLabelPlacement2) => {
    BarColumnLabelPlacement2["InsideBase"] = "insideBase";
    BarColumnLabelPlacement2["InsideEnd"] = "insideEnd";
    BarColumnLabelPlacement2["Center"] = "center";
    BarColumnLabelPlacement2["OutsideEnd"] = "outsideEnd";
    return BarColumnLabelPlacement2;
  })(BarColumnLabelPlacement || {});
  var globalObj = typeof global === "undefined" ? {} : global;
  globalObj.HTMLElement = typeof HTMLElement === "undefined" ? {} : HTMLElement;
  globalObj.HTMLButtonElement = typeof HTMLButtonElement === "undefined" ? {} : HTMLButtonElement;
  globalObj.HTMLSelectElement = typeof HTMLSelectElement === "undefined" ? {} : HTMLSelectElement;
  globalObj.HTMLInputElement = typeof HTMLInputElement === "undefined" ? {} : HTMLInputElement;
  globalObj.Node = typeof Node === "undefined" ? {} : Node;
  globalObj.MouseEvent = typeof MouseEvent === "undefined" ? {} : MouseEvent;
  var _ClientSideNodeManager = class _ClientSideNodeManager2 {
    constructor(rootNode, gos, eventService, columnModel, selectionService, beans) {
      this.nextId = 0;
      this.rowCountReady = false;
      this.allNodesMap = {};
      this.rootNode = rootNode;
      this.gos = gos;
      this.eventService = eventService;
      this.columnModel = columnModel;
      this.beans = beans;
      this.selectionService = selectionService;
      this.rootNode.group = true;
      this.rootNode.level = -1;
      this.rootNode.id = _ClientSideNodeManager2.ROOT_NODE_ID;
      this.rootNode.allLeafChildren = [];
      this.rootNode.childrenAfterGroup = [];
      this.rootNode.childrenAfterSort = [];
      this.rootNode.childrenAfterAggFilter = [];
      this.rootNode.childrenAfterFilter = [];
    }
    getCopyOfNodesMap() {
      return _.cloneObject(this.allNodesMap);
    }
    getRowNode(id) {
      return this.allNodesMap[id];
    }
    setRowData(rowData) {
      if (typeof rowData === "string") {
        console.warn("AG Grid: rowData must be an array.");
        return;
      }
      this.rowCountReady = true;
      this.dispatchRowDataUpdateStartedEvent(rowData);
      const rootNode = this.rootNode;
      const sibling = this.rootNode.sibling;
      rootNode.childrenAfterFilter = null;
      rootNode.childrenAfterGroup = null;
      rootNode.childrenAfterAggFilter = null;
      rootNode.childrenAfterSort = null;
      rootNode.childrenMapped = null;
      rootNode.updateHasChildren();
      this.nextId = 0;
      this.allNodesMap = {};
      if (rowData) {
        rootNode.allLeafChildren = rowData.map((dataItem) => this.createNode(dataItem, this.rootNode, _ClientSideNodeManager2.TOP_LEVEL));
      } else {
        rootNode.allLeafChildren = [];
        rootNode.childrenAfterGroup = [];
      }
      if (sibling) {
        sibling.childrenAfterFilter = rootNode.childrenAfterFilter;
        sibling.childrenAfterGroup = rootNode.childrenAfterGroup;
        sibling.childrenAfterAggFilter = rootNode.childrenAfterAggFilter;
        sibling.childrenAfterSort = rootNode.childrenAfterSort;
        sibling.childrenMapped = rootNode.childrenMapped;
        sibling.allLeafChildren = rootNode.allLeafChildren;
      }
    }
    updateRowData(rowDataTran, rowNodeOrder) {
      this.rowCountReady = true;
      this.dispatchRowDataUpdateStartedEvent(rowDataTran.add);
      const rowNodeTransaction = {
        remove: [],
        update: [],
        add: []
      };
      const nodesToUnselect = [];
      this.executeRemove(rowDataTran, rowNodeTransaction, nodesToUnselect);
      this.executeUpdate(rowDataTran, rowNodeTransaction, nodesToUnselect);
      this.executeAdd(rowDataTran, rowNodeTransaction);
      this.updateSelection(nodesToUnselect, "rowDataChanged");
      if (rowNodeOrder) {
        _.sortRowNodesByOrder(this.rootNode.allLeafChildren, rowNodeOrder);
      }
      return rowNodeTransaction;
    }
    isRowCountReady() {
      return this.rowCountReady;
    }
    dispatchRowDataUpdateStartedEvent(rowData) {
      const event = {
        type: Events.EVENT_ROW_DATA_UPDATE_STARTED,
        firstRowData: (rowData == null ? void 0 : rowData.length) ? rowData[0] : null
      };
      this.eventService.dispatchEvent(event);
    }
    updateSelection(nodesToUnselect, source) {
      const selectionChanged = nodesToUnselect.length > 0;
      if (selectionChanged) {
        this.selectionService.setNodesSelected({
          newValue: false,
          nodes: nodesToUnselect,
          suppressFinishActions: true,
          source
        });
      }
      this.selectionService.updateGroupsFromChildrenSelections(source);
      if (selectionChanged) {
        const event = {
          type: Events.EVENT_SELECTION_CHANGED,
          source
        };
        this.eventService.dispatchEvent(event);
      }
    }
    executeAdd(rowDataTran, rowNodeTransaction) {
      var _a;
      const { add: add3, addIndex } = rowDataTran;
      if (_.missingOrEmpty(add3)) {
        return;
      }
      const newNodes = add3.map((item) => this.createNode(item, this.rootNode, _ClientSideNodeManager2.TOP_LEVEL));
      if (typeof addIndex === "number" && addIndex >= 0) {
        const { allLeafChildren } = this.rootNode;
        const len = allLeafChildren.length;
        let normalisedAddIndex = addIndex;
        const isTreeData = this.gos.get("treeData");
        if (isTreeData && addIndex > 0 && len > 0) {
          for (let i = 0; i < len; i++) {
            if (((_a = allLeafChildren[i]) == null ? void 0 : _a.rowIndex) == addIndex - 1) {
              normalisedAddIndex = i + 1;
              break;
            }
          }
        }
        const nodesBeforeIndex = allLeafChildren.slice(0, normalisedAddIndex);
        const nodesAfterIndex = allLeafChildren.slice(normalisedAddIndex, allLeafChildren.length);
        this.rootNode.allLeafChildren = [...nodesBeforeIndex, ...newNodes, ...nodesAfterIndex];
      } else {
        this.rootNode.allLeafChildren = [...this.rootNode.allLeafChildren, ...newNodes];
      }
      if (this.rootNode.sibling) {
        this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren;
      }
      rowNodeTransaction.add = newNodes;
    }
    executeRemove(rowDataTran, rowNodeTransaction, nodesToUnselect) {
      const { remove: remove2 } = rowDataTran;
      if (_.missingOrEmpty(remove2)) {
        return;
      }
      const rowIdsRemoved = {};
      remove2.forEach((item) => {
        const rowNode = this.lookupRowNode(item);
        if (!rowNode) {
          return;
        }
        if (rowNode.isSelected()) {
          nodesToUnselect.push(rowNode);
        }
        rowNode.clearRowTopAndRowIndex();
        rowIdsRemoved[rowNode.id] = true;
        delete this.allNodesMap[rowNode.id];
        rowNodeTransaction.remove.push(rowNode);
      });
      this.rootNode.allLeafChildren = this.rootNode.allLeafChildren.filter((rowNode) => !rowIdsRemoved[rowNode.id]);
      if (this.rootNode.sibling) {
        this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren;
      }
    }
    executeUpdate(rowDataTran, rowNodeTransaction, nodesToUnselect) {
      const { update } = rowDataTran;
      if (_.missingOrEmpty(update)) {
        return;
      }
      update.forEach((item) => {
        const rowNode = this.lookupRowNode(item);
        if (!rowNode) {
          return;
        }
        rowNode.updateData(item);
        if (!rowNode.selectable && rowNode.isSelected()) {
          nodesToUnselect.push(rowNode);
        }
        this.setMasterForRow(rowNode, item, _ClientSideNodeManager2.TOP_LEVEL, false);
        rowNodeTransaction.update.push(rowNode);
      });
    }
    lookupRowNode(data) {
      const getRowIdFunc = this.gos.getCallback("getRowId");
      let rowNode;
      if (getRowIdFunc) {
        const id = getRowIdFunc({ data, level: 0 });
        rowNode = this.allNodesMap[id];
        if (!rowNode) {
          console.error(`AG Grid: could not find row id=${id}, data item was not found for this id`);
          return null;
        }
      } else {
        rowNode = this.rootNode.allLeafChildren.find((node) => node.data === data);
        if (!rowNode) {
          console.error(`AG Grid: could not find data item as object was not found`, data);
          console.error(`Consider using getRowId to help the Grid find matching row data`);
          return null;
        }
      }
      return rowNode || null;
    }
    createNode(dataItem, parent, level) {
      const node = new RowNode(this.beans);
      node.group = false;
      this.setMasterForRow(node, dataItem, level, true);
      const suppressParentsInRowNodes = this.gos.get("suppressParentsInRowNodes");
      if (parent && !suppressParentsInRowNodes) {
        node.parent = parent;
      }
      node.level = level;
      node.setDataAndId(dataItem, this.nextId.toString());
      if (this.allNodesMap[node.id]) {
        console.warn(`AG Grid: duplicate node id '${node.id}' detected from getRowId callback, this could cause issues in your grid.`);
      }
      this.allNodesMap[node.id] = node;
      this.nextId++;
      return node;
    }
    setMasterForRow(rowNode, data, level, setExpanded) {
      const isTreeData = this.gos.get("treeData");
      if (isTreeData) {
        rowNode.setMaster(false);
        if (setExpanded) {
          rowNode.expanded = false;
        }
      } else {
        const masterDetail = this.gos.get("masterDetail");
        if (masterDetail) {
          const isRowMasterFunc = this.gos.get("isRowMaster");
          if (isRowMasterFunc) {
            rowNode.setMaster(isRowMasterFunc(data));
          } else {
            rowNode.setMaster(true);
          }
        } else {
          rowNode.setMaster(false);
        }
        if (setExpanded) {
          const rowGroupColumns = this.columnModel.getRowGroupColumns();
          const numRowGroupColumns = rowGroupColumns ? rowGroupColumns.length : 0;
          const masterRowLevel = level + numRowGroupColumns;
          rowNode.expanded = rowNode.master ? this.isExpanded(masterRowLevel) : false;
        }
      }
    }
    isExpanded(level) {
      const expandByDefault = this.gos.get("groupDefaultExpanded");
      if (expandByDefault === -1) {
        return true;
      }
      return level < expandByDefault;
    }
  };
  _ClientSideNodeManager.TOP_LEVEL = 0;
  _ClientSideNodeManager.ROOT_NODE_ID = "ROOT_NODE_ID";
  var ClientSideNodeManager = _ClientSideNodeManager;
  var ClientSideRowModel = class extends BeanStub {
    constructor() {
      super(...arguments);
      this.onRowHeightChanged_debounced = _.debounce(this.onRowHeightChanged.bind(this), 100);
      this.rowsToDisplay = [];
      this.hasStarted = false;
      this.shouldSkipSettingDataOnStart = false;
      this.isRefreshingModel = false;
      this.rowCountReady = false;
    }
    init() {
      const refreshEverythingFunc = this.refreshModel.bind(this, {
        step: "group"
        /* EVERYTHING */
      });
      const animate = !this.gos.get("suppressAnimationFrame");
      const refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, {
        step: "group",
        // after cols change, row grouping (the first stage) could of changed
        afterColumnsChanged: true,
        keepRenderedRows: true,
        // we want animations cos sorting or filtering could be applied
        animate
      });
      this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, refreshEverythingAfterColsChangedFunc);
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, refreshEverythingFunc);
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, {
        step: "pivot"
        /* PIVOT */
      }));
      this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, refreshEverythingFunc);
      this.addManagedListener(this.eventService, Events.EVENT_GRID_STYLES_CHANGED, this.onGridStylesChanges.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_GRID_READY, () => this.onGridReady());
      this.addPropertyListeners();
      this.rootNode = new RowNode(this.beans);
      this.nodeManager = new ClientSideNodeManager(
        this.rootNode,
        this.gos,
        this.eventService,
        this.columnModel,
        this.selectionService,
        this.beans
      );
    }
    addPropertyListeners() {
      const resetProps = /* @__PURE__ */ new Set([
        "treeData",
        "masterDetail"
      ]);
      const groupStageRefreshProps = /* @__PURE__ */ new Set([
        "suppressParentsInRowNodes",
        "groupDefaultExpanded",
        "groupAllowUnbalanced",
        "initialGroupOrderComparator",
        "groupHideOpenParents",
        "groupDisplayType"
      ]);
      const filterStageRefreshProps = /* @__PURE__ */ new Set([
        "excludeChildrenWhenTreeDataFiltering"
      ]);
      const pivotStageRefreshProps = /* @__PURE__ */ new Set([
        "removePivotHeaderRowWhenSingleValueColumn",
        "pivotRowTotals",
        "pivotColumnGroupTotals",
        "suppressExpandablePivotGroups"
      ]);
      const aggregateStageRefreshProps = /* @__PURE__ */ new Set([
        "getGroupRowAgg",
        "alwaysAggregateAtRootLevel",
        "groupIncludeTotalFooter",
        "suppressAggFilteredOnly",
        "grandTotalRow"
      ]);
      const sortStageRefreshProps = /* @__PURE__ */ new Set([
        "postSortRows",
        "groupDisplayType",
        "accentedSort"
      ]);
      const filterAggStageRefreshProps = /* @__PURE__ */ new Set([]);
      const flattenStageRefreshProps = /* @__PURE__ */ new Set([
        "groupRemoveSingleChildren",
        "groupRemoveLowestSingleChildren",
        "groupIncludeFooter",
        "groupTotalRow"
      ]);
      const allProps = [
        ...resetProps,
        ...groupStageRefreshProps,
        ...filterStageRefreshProps,
        ...pivotStageRefreshProps,
        ...pivotStageRefreshProps,
        ...aggregateStageRefreshProps,
        ...sortStageRefreshProps,
        ...filterAggStageRefreshProps,
        ...flattenStageRefreshProps
      ];
      this.addManagedPropertyListeners(allProps, (params) => {
        var _a;
        const properties = (_a = params.changeSet) == null ? void 0 : _a.properties;
        if (!properties) {
          return;
        }
        ;
        const arePropertiesImpacted = (propSet) => properties.some((prop) => propSet.has(prop));
        if (arePropertiesImpacted(resetProps)) {
          this.setRowData(this.rootNode.allLeafChildren.map((child) => child.data));
          return;
        }
        if (arePropertiesImpacted(groupStageRefreshProps)) {
          this.refreshModel({
            step: "group"
            /* EVERYTHING */
          });
          return;
        }
        if (arePropertiesImpacted(filterStageRefreshProps)) {
          this.refreshModel({
            step: "filter"
            /* FILTER */
          });
          return;
        }
        if (arePropertiesImpacted(pivotStageRefreshProps)) {
          this.refreshModel({
            step: "pivot"
            /* PIVOT */
          });
          return;
        }
        if (arePropertiesImpacted(aggregateStageRefreshProps)) {
          this.refreshModel({
            step: "aggregate"
            /* AGGREGATE */
          });
          return;
        }
        if (arePropertiesImpacted(sortStageRefreshProps)) {
          this.refreshModel({
            step: "sort"
            /* SORT */
          });
          return;
        }
        if (arePropertiesImpacted(filterAggStageRefreshProps)) {
          this.refreshModel({
            step: "filter_aggregates"
            /* FILTER_AGGREGATES */
          });
          return;
        }
        if (arePropertiesImpacted(flattenStageRefreshProps)) {
          this.refreshModel({
            step: "map"
            /* MAP */
          });
        }
      });
      this.addManagedPropertyListener("rowHeight", () => this.resetRowHeights());
    }
    start() {
      this.hasStarted = true;
      if (this.shouldSkipSettingDataOnStart) {
        this.dispatchUpdateEventsAndRefresh();
      } else {
        this.setInitialData();
      }
    }
    setInitialData() {
      const rowData = this.gos.get("rowData");
      if (rowData) {
        this.shouldSkipSettingDataOnStart = true;
        this.setRowData(rowData);
      }
    }
    ensureRowHeightsValid(startPixel, endPixel, startLimitIndex, endLimitIndex) {
      let atLeastOneChange;
      let res = false;
      do {
        atLeastOneChange = false;
        const rowAtStartPixel = this.getRowIndexAtPixel(startPixel);
        const rowAtEndPixel = this.getRowIndexAtPixel(endPixel);
        const firstRow = Math.max(rowAtStartPixel, startLimitIndex);
        const lastRow = Math.min(rowAtEndPixel, endLimitIndex);
        for (let rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {
          const rowNode = this.getRow(rowIndex);
          if (rowNode.rowHeightEstimated) {
            const rowHeight = this.gos.getRowHeightForNode(rowNode);
            rowNode.setRowHeight(rowHeight.height);
            atLeastOneChange = true;
            res = true;
          }
        }
        if (atLeastOneChange) {
          this.setRowTopAndRowIndex();
        }
      } while (atLeastOneChange);
      return res;
    }
    setRowTopAndRowIndex() {
      const defaultRowHeight = this.environment.getDefaultRowHeight();
      let nextRowTop = 0;
      const displayedRowsMapped = /* @__PURE__ */ new Set();
      const allowEstimate = this.gos.isDomLayout("normal");
      for (let i = 0; i < this.rowsToDisplay.length; i++) {
        const rowNode = this.rowsToDisplay[i];
        if (rowNode.id != null) {
          displayedRowsMapped.add(rowNode.id);
        }
        if (rowNode.rowHeight == null) {
          const rowHeight = this.gos.getRowHeightForNode(rowNode, allowEstimate, defaultRowHeight);
          rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);
        }
        rowNode.setRowTop(nextRowTop);
        rowNode.setRowIndex(i);
        nextRowTop += rowNode.rowHeight;
      }
      return displayedRowsMapped;
    }
    clearRowTopAndRowIndex(changedPath, displayedRowsMapped) {
      const changedPathActive = changedPath.isActive();
      const clearIfNotDisplayed = (rowNode) => {
        if (rowNode && rowNode.id != null && !displayedRowsMapped.has(rowNode.id)) {
          rowNode.clearRowTopAndRowIndex();
        }
      };
      const recurse = (rowNode) => {
        clearIfNotDisplayed(rowNode);
        clearIfNotDisplayed(rowNode.detailNode);
        clearIfNotDisplayed(rowNode.sibling);
        if (rowNode.hasChildren()) {
          if (rowNode.childrenAfterGroup) {
            const isRootNode = rowNode.level == -1;
            const skipChildren = changedPathActive && !isRootNode && !rowNode.expanded;
            if (!skipChildren) {
              rowNode.childrenAfterGroup.forEach(recurse);
            }
          }
        }
      };
      recurse(this.rootNode);
    }
    // returns false if row was moved, otherwise true
    ensureRowsAtPixel(rowNodes, pixel, increment = 0) {
      const indexAtPixelNow = this.getRowIndexAtPixel(pixel);
      const rowNodeAtPixelNow = this.getRow(indexAtPixelNow);
      const animate = !this.gos.get("suppressAnimationFrame");
      if (rowNodeAtPixelNow === rowNodes[0]) {
        return false;
      }
      rowNodes.forEach((rowNode) => {
        _.removeFromArray(this.rootNode.allLeafChildren, rowNode);
      });
      rowNodes.forEach((rowNode, idx) => {
        _.insertIntoArray(this.rootNode.allLeafChildren, rowNode, Math.max(indexAtPixelNow + increment, 0) + idx);
      });
      this.refreshModel({
        step: "group",
        keepRenderedRows: true,
        keepEditingRows: true,
        animate
      });
      return true;
    }
    highlightRowAtPixel(rowNode, pixel) {
      const indexAtPixelNow = pixel != null ? this.getRowIndexAtPixel(pixel) : null;
      const rowNodeAtPixelNow = indexAtPixelNow != null ? this.getRow(indexAtPixelNow) : null;
      if (!rowNodeAtPixelNow || !rowNode || rowNodeAtPixelNow === rowNode || pixel == null) {
        if (this.lastHighlightedRow) {
          this.lastHighlightedRow.setHighlighted(null);
          this.lastHighlightedRow = null;
        }
        return;
      }
      const highlight = this.getHighlightPosition(pixel, rowNodeAtPixelNow);
      if (this.lastHighlightedRow && this.lastHighlightedRow !== rowNodeAtPixelNow) {
        this.lastHighlightedRow.setHighlighted(null);
        this.lastHighlightedRow = null;
      }
      rowNodeAtPixelNow.setHighlighted(highlight);
      this.lastHighlightedRow = rowNodeAtPixelNow;
    }
    getHighlightPosition(pixel, rowNode) {
      if (!rowNode) {
        const index = this.getRowIndexAtPixel(pixel);
        rowNode = this.getRow(index || 0);
        if (!rowNode) {
          return 1;
        }
      }
      const { rowTop, rowHeight } = rowNode;
      return pixel - rowTop < rowHeight / 2 ? 0 : 1;
    }
    getLastHighlightedRowNode() {
      return this.lastHighlightedRow;
    }
    isLastRowIndexKnown() {
      return true;
    }
    getRowCount() {
      if (this.rowsToDisplay) {
        return this.rowsToDisplay.length;
      }
      return 0;
    }
    getTopLevelRowCount() {
      const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;
      if (showingRootNode) {
        return 1;
      }
      const filteredChildren = this.rootNode.childrenAfterAggFilter;
      return filteredChildren ? filteredChildren.length : 0;
    }
    getTopLevelRowDisplayedIndex(topLevelIndex) {
      const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;
      if (showingRootNode) {
        return topLevelIndex;
      }
      let rowNode = this.rootNode.childrenAfterSort[topLevelIndex];
      if (this.gos.get("groupHideOpenParents")) {
        while (rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0) {
          rowNode = rowNode.childrenAfterSort[0];
        }
      }
      return rowNode.rowIndex;
    }
    getRowBounds(index) {
      if (_.missing(this.rowsToDisplay)) {
        return null;
      }
      const rowNode = this.rowsToDisplay[index];
      if (rowNode) {
        return {
          rowTop: rowNode.rowTop,
          rowHeight: rowNode.rowHeight
        };
      }
      return null;
    }
    onRowGroupOpened() {
      const animate = this.gos.isAnimateRows();
      this.refreshModel({ step: "map", keepRenderedRows: true, animate });
    }
    onFilterChanged(event) {
      if (event.afterDataChange) {
        return;
      }
      const animate = this.gos.isAnimateRows();
      const primaryOrQuickFilterChanged = event.columns.length === 0 || event.columns.some((col) => col.isPrimary());
      const step = primaryOrQuickFilterChanged ? "filter" : "filter_aggregates";
      this.refreshModel({ step, keepRenderedRows: true, animate });
    }
    onSortChanged() {
      const animate = this.gos.isAnimateRows();
      this.refreshModel({ step: "sort", keepRenderedRows: true, animate, keepEditingRows: true });
    }
    getType() {
      return "clientSide";
    }
    onValueChanged() {
      if (this.columnModel.isPivotActive()) {
        this.refreshModel({
          step: "pivot"
          /* PIVOT */
        });
      } else {
        this.refreshModel({
          step: "aggregate"
          /* AGGREGATE */
        });
      }
    }
    createChangePath(rowNodeTransactions) {
      const noTransactions = _.missingOrEmpty(rowNodeTransactions);
      const changedPath = new ChangedPath(false, this.rootNode);
      if (noTransactions || this.gos.get("treeData")) {
        changedPath.setInactive();
      }
      return changedPath;
    }
    isSuppressModelUpdateAfterUpdateTransaction(params) {
      if (!this.gos.get("suppressModelUpdateAfterUpdateTransaction")) {
        return false;
      }
      if (params.rowNodeTransactions == null) {
        return false;
      }
      const transWithAddsOrDeletes = params.rowNodeTransactions.filter(
        (tx) => tx.add != null && tx.add.length > 0 || tx.remove != null && tx.remove.length > 0
      );
      const transactionsContainUpdatesOnly = transWithAddsOrDeletes == null || transWithAddsOrDeletes.length == 0;
      return transactionsContainUpdatesOnly;
    }
    buildRefreshModelParams(step) {
      let paramsStep = "group";
      const stepsMapped = {
        everything: "group",
        group: "group",
        filter: "filter",
        map: "map",
        aggregate: "aggregate",
        sort: "sort",
        pivot: "pivot"
        /* PIVOT */
      };
      if (_.exists(step)) {
        paramsStep = stepsMapped[step];
      }
      if (_.missing(paramsStep)) {
        console.error(`AG Grid: invalid step ${step}, available steps are ${Object.keys(stepsMapped).join(", ")}`);
        return void 0;
      }
      const animate = !this.gos.get("suppressAnimationFrame");
      const modelParams = {
        step: paramsStep,
        keepRenderedRows: true,
        keepEditingRows: true,
        animate
      };
      return modelParams;
    }
    refreshModel(paramsOrStep) {
      if (!this.hasStarted || this.isRefreshingModel || this.columnModel.shouldRowModelIgnoreRefresh()) {
        return;
      }
      let params = typeof paramsOrStep === "object" && "step" in paramsOrStep ? paramsOrStep : this.buildRefreshModelParams(paramsOrStep);
      if (!params) {
        return;
      }
      if (this.isSuppressModelUpdateAfterUpdateTransaction(params)) {
        return;
      }
      const changedPath = this.createChangePath(params.rowNodeTransactions);
      this.isRefreshingModel = true;
      switch (params.step) {
        case "group":
          this.doRowGrouping(
            params.rowNodeTransactions,
            params.rowNodeOrder,
            changedPath,
            !!params.afterColumnsChanged
          );
        case "filter":
          this.doFilter(changedPath);
        case "pivot":
          this.doPivot(changedPath);
        case "aggregate":
          this.doAggregate(changedPath);
        case "filter_aggregates":
          this.doFilterAggregates(changedPath);
        case "sort":
          this.doSort(params.rowNodeTransactions, changedPath);
        case "map":
          this.doRowsToDisplay();
      }
      const displayedNodesMapped = this.setRowTopAndRowIndex();
      this.clearRowTopAndRowIndex(changedPath, displayedNodesMapped);
      this.isRefreshingModel = false;
      const event = {
        type: Events.EVENT_MODEL_UPDATED,
        animate: params.animate,
        keepRenderedRows: params.keepRenderedRows,
        newData: params.newData,
        newPage: false,
        keepUndoRedoStack: params.keepUndoRedoStack
      };
      this.eventService.dispatchEvent(event);
    }
    isEmpty() {
      const rowsMissing = _.missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;
      return _.missing(this.rootNode) || rowsMissing || !this.columnModel.isReady();
    }
    isRowsToRender() {
      return _.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;
    }
    getNodesInRangeForSelection(firstInRange, lastInRange) {
      let started = !lastInRange;
      let finished = false;
      const result = [];
      const groupsSelectChildren = this.gos.get("groupSelectsChildren");
      this.forEachNodeAfterFilterAndSort((rowNode) => {
        if (finished) {
          return;
        }
        if (started) {
          if (rowNode === lastInRange || rowNode === firstInRange) {
            finished = true;
            if (rowNode.group && groupsSelectChildren) {
              result.push(...rowNode.allLeafChildren);
              return;
            }
          }
        }
        if (!started) {
          if (rowNode !== lastInRange && rowNode !== firstInRange) {
            return;
          }
          started = true;
        }
        const includeThisNode = !rowNode.group || !groupsSelectChildren;
        if (includeThisNode) {
          result.push(rowNode);
          return;
        }
      });
      return result;
    }
    setDatasource(datasource) {
      console.error("AG Grid: should never call setDatasource on clientSideRowController");
    }
    getTopLevelNodes() {
      return this.rootNode ? this.rootNode.childrenAfterGroup : null;
    }
    getRootNode() {
      return this.rootNode;
    }
    getRow(index) {
      return this.rowsToDisplay[index];
    }
    isRowPresent(rowNode) {
      return this.rowsToDisplay.indexOf(rowNode) >= 0;
    }
    getRowIndexAtPixel(pixelToMatch) {
      if (this.isEmpty() || this.rowsToDisplay.length === 0) {
        return -1;
      }
      let bottomPointer = 0;
      let topPointer = this.rowsToDisplay.length - 1;
      if (pixelToMatch <= 0) {
        return 0;
      }
      const lastNode = _.last(this.rowsToDisplay);
      if (lastNode.rowTop <= pixelToMatch) {
        return this.rowsToDisplay.length - 1;
      }
      let oldBottomPointer = -1;
      let oldTopPointer = -1;
      while (true) {
        const midPointer = Math.floor((bottomPointer + topPointer) / 2);
        const currentRowNode = this.rowsToDisplay[midPointer];
        if (this.isRowInPixel(currentRowNode, pixelToMatch)) {
          return midPointer;
        }
        if (currentRowNode.rowTop < pixelToMatch) {
          bottomPointer = midPointer + 1;
        } else if (currentRowNode.rowTop > pixelToMatch) {
          topPointer = midPointer - 1;
        }
        const caughtInInfiniteLoop = oldBottomPointer === bottomPointer && oldTopPointer === topPointer;
        if (caughtInInfiniteLoop) {
          return midPointer;
        }
        oldBottomPointer = bottomPointer;
        oldTopPointer = topPointer;
      }
    }
    isRowInPixel(rowNode, pixelToMatch) {
      const topPixel = rowNode.rowTop;
      const bottomPixel = rowNode.rowTop + rowNode.rowHeight;
      const pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;
      return pixelInRow;
    }
    forEachLeafNode(callback) {
      if (this.rootNode.allLeafChildren) {
        this.rootNode.allLeafChildren.forEach((rowNode, index) => callback(rowNode, index));
      }
    }
    forEachNode(callback, includeFooterNodes = false) {
      this.recursivelyWalkNodesAndCallback({
        nodes: [...this.rootNode.childrenAfterGroup || []],
        callback,
        recursionType: 0,
        index: 0,
        includeFooterNodes
      });
    }
    forEachNodeAfterFilter(callback, includeFooterNodes = false) {
      this.recursivelyWalkNodesAndCallback({
        nodes: [...this.rootNode.childrenAfterAggFilter || []],
        callback,
        recursionType: 1,
        index: 0,
        includeFooterNodes
      });
    }
    forEachNodeAfterFilterAndSort(callback, includeFooterNodes = false) {
      this.recursivelyWalkNodesAndCallback({
        nodes: [...this.rootNode.childrenAfterSort || []],
        callback,
        recursionType: 2,
        index: 0,
        includeFooterNodes
      });
    }
    forEachPivotNode(callback, includeFooterNodes = false) {
      this.recursivelyWalkNodesAndCallback({
        nodes: [this.rootNode],
        callback,
        recursionType: 3,
        index: 0,
        includeFooterNodes
      });
    }
    // iterates through each item in memory, and calls the callback function
    // nodes - the rowNodes to traverse
    // callback - the user provided callback
    // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc
    // index - works similar to the index in forEach in javascript's array function
    recursivelyWalkNodesAndCallback(params) {
      const { nodes, callback, recursionType, includeFooterNodes } = params;
      let { index } = params;
      const addFooters = (position) => {
        var _a;
        const parentNode = (_a = nodes[0]) == null ? void 0 : _a.parent;
        if (!parentNode)
          return;
        const grandTotal = includeFooterNodes && this.gos.getGrandTotalRow();
        const isGroupIncludeFooter = this.gos.getGroupTotalRowCallback();
        const groupTotal = includeFooterNodes && isGroupIncludeFooter({ node: parentNode });
        const isRootNode = parentNode === this.rootNode;
        if (isRootNode) {
          if (grandTotal === position) {
            parentNode.createFooter();
            callback(parentNode.sibling, index++);
          }
          return;
        }
        if (groupTotal === position) {
          parentNode.createFooter();
          callback(parentNode.sibling, index++);
        }
      };
      addFooters("top");
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        callback(node, index++);
        if (node.hasChildren() && !node.footer) {
          let nodeChildren = null;
          switch (recursionType) {
            case 0:
              nodeChildren = node.childrenAfterGroup;
              break;
            case 1:
              nodeChildren = node.childrenAfterAggFilter;
              break;
            case 2:
              nodeChildren = node.childrenAfterSort;
              break;
            case 3:
              nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;
              break;
          }
          if (nodeChildren) {
            index = this.recursivelyWalkNodesAndCallback({
              nodes: [...nodeChildren],
              callback,
              recursionType,
              index,
              includeFooterNodes
            });
          }
        }
      }
      addFooters("bottom");
      return index;
    }
    // it's possible to recompute the aggregate without doing the other parts
    // + api.refreshClientSideRowModel('aggregate')
    doAggregate(changedPath) {
      var _a;
      (_a = this.aggregationStage) == null ? void 0 : _a.execute({ rowNode: this.rootNode, changedPath });
    }
    doFilterAggregates(changedPath) {
      if (this.filterAggregatesStage) {
        this.filterAggregatesStage.execute({ rowNode: this.rootNode, changedPath });
      } else {
        this.rootNode.childrenAfterAggFilter = this.rootNode.childrenAfterFilter;
      }
    }
    // + gridApi.expandAll()
    // + gridApi.collapseAll()
    expandOrCollapseAll(expand) {
      const usingTreeData = this.gos.get("treeData");
      const usingPivotMode = this.columnModel.isPivotActive();
      const recursiveExpandOrCollapse = (rowNodes) => {
        if (!rowNodes) {
          return;
        }
        rowNodes.forEach((rowNode) => {
          const actionRow = () => {
            rowNode.expanded = expand;
            recursiveExpandOrCollapse(rowNode.childrenAfterGroup);
          };
          if (usingTreeData) {
            const hasChildren = _.exists(rowNode.childrenAfterGroup);
            if (hasChildren) {
              actionRow();
            }
            return;
          }
          if (usingPivotMode) {
            const notLeafGroup = !rowNode.leafGroup;
            if (notLeafGroup) {
              actionRow();
            }
            return;
          }
          const isRowGroup = rowNode.group;
          if (isRowGroup) {
            actionRow();
          }
        });
      };
      if (this.rootNode) {
        recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);
      }
      this.refreshModel({
        step: "map"
        /* MAP */
      });
      const eventSource = expand ? "expandAll" : "collapseAll";
      const event = {
        type: Events.EVENT_EXPAND_COLLAPSE_ALL,
        source: eventSource
      };
      this.eventService.dispatchEvent(event);
    }
    doSort(rowNodeTransactions, changedPath) {
      this.sortStage.execute({
        rowNode: this.rootNode,
        rowNodeTransactions,
        changedPath
      });
    }
    doRowGrouping(rowNodeTransactions, rowNodeOrder, changedPath, afterColumnsChanged) {
      if (this.groupStage) {
        if (rowNodeTransactions) {
          this.groupStage.execute({
            rowNode: this.rootNode,
            rowNodeTransactions,
            rowNodeOrder,
            changedPath
          });
        } else {
          this.groupStage.execute({
            rowNode: this.rootNode,
            changedPath,
            afterColumnsChanged
          });
        }
        if (this.gos.get("groupSelectsChildren")) {
          const selectionChanged = this.selectionService.updateGroupsFromChildrenSelections("rowGroupChanged", changedPath);
          if (selectionChanged) {
            const event = {
              type: Events.EVENT_SELECTION_CHANGED,
              source: "rowGroupChanged"
            };
            this.eventService.dispatchEvent(event);
          }
        }
      } else {
        this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;
        if (this.rootNode.sibling) {
          this.rootNode.sibling.childrenAfterGroup = this.rootNode.childrenAfterGroup;
        }
        this.rootNode.updateHasChildren();
      }
      if (this.nodeManager.isRowCountReady()) {
        this.rowCountReady = true;
        this.eventService.dispatchEventOnce({
          type: Events.EVENT_ROW_COUNT_READY
        });
      }
    }
    doFilter(changedPath) {
      this.filterStage.execute({ rowNode: this.rootNode, changedPath });
    }
    doPivot(changedPath) {
      var _a;
      (_a = this.pivotStage) == null ? void 0 : _a.execute({ rowNode: this.rootNode, changedPath });
    }
    getCopyOfNodesMap() {
      return this.nodeManager.getCopyOfNodesMap();
    }
    getRowNode(id) {
      const idIsGroup = typeof id == "string" && id.indexOf(RowNode.ID_PREFIX_ROW_GROUP) == 0;
      if (idIsGroup) {
        let res = void 0;
        this.forEachNode((node) => {
          if (node.id === id) {
            res = node;
          }
        });
        return res;
      }
      return this.nodeManager.getRowNode(id);
    }
    // rows: the rows to put into the model
    setRowData(rowData) {
      this.selectionService.reset("rowDataChanged");
      this.nodeManager.setRowData(rowData);
      if (this.hasStarted) {
        this.dispatchUpdateEventsAndRefresh();
      }
    }
    dispatchUpdateEventsAndRefresh() {
      const rowDataUpdatedEvent = {
        type: Events.EVENT_ROW_DATA_UPDATED
      };
      this.eventService.dispatchEvent(rowDataUpdatedEvent);
      this.refreshModel({
        step: "group",
        newData: true
      });
    }
    batchUpdateRowData(rowDataTransaction, callback) {
      if (this.applyAsyncTransactionsTimeout == null) {
        this.rowDataTransactionBatch = [];
        const waitMillis = this.gos.getAsyncTransactionWaitMillis();
        this.applyAsyncTransactionsTimeout = window.setTimeout(() => {
          this.executeBatchUpdateRowData();
        }, waitMillis);
      }
      this.rowDataTransactionBatch.push({ rowDataTransaction, callback });
    }
    flushAsyncTransactions() {
      if (this.applyAsyncTransactionsTimeout != null) {
        clearTimeout(this.applyAsyncTransactionsTimeout);
        this.executeBatchUpdateRowData();
      }
    }
    executeBatchUpdateRowData() {
      this.valueCache.onDataChanged();
      const callbackFuncsBound = [];
      const rowNodeTrans = [];
      let forceRowNodeOrder = false;
      if (this.rowDataTransactionBatch) {
        this.rowDataTransactionBatch.forEach((tranItem) => {
          const rowNodeTran = this.nodeManager.updateRowData(tranItem.rowDataTransaction, void 0);
          rowNodeTrans.push(rowNodeTran);
          if (tranItem.callback) {
            callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTran));
          }
          if (typeof tranItem.rowDataTransaction.addIndex === "number") {
            forceRowNodeOrder = true;
          }
        });
      }
      this.commonUpdateRowData(rowNodeTrans, void 0, forceRowNodeOrder);
      if (callbackFuncsBound.length > 0) {
        window.setTimeout(() => {
          callbackFuncsBound.forEach((func) => func());
        }, 0);
      }
      if (rowNodeTrans.length > 0) {
        const event = {
          type: Events.EVENT_ASYNC_TRANSACTIONS_FLUSHED,
          results: rowNodeTrans
        };
        this.eventService.dispatchEvent(event);
      }
      this.rowDataTransactionBatch = null;
      this.applyAsyncTransactionsTimeout = void 0;
    }
    updateRowData(rowDataTran, rowNodeOrder) {
      this.valueCache.onDataChanged();
      const rowNodeTran = this.nodeManager.updateRowData(rowDataTran, rowNodeOrder);
      const forceRowNodeOrder = typeof rowDataTran.addIndex === "number";
      this.commonUpdateRowData([rowNodeTran], rowNodeOrder, forceRowNodeOrder);
      return rowNodeTran;
    }
    createRowNodeOrder() {
      const suppressSortOrder = this.gos.get("suppressMaintainUnsortedOrder");
      if (suppressSortOrder) {
        return;
      }
      const orderMap = {};
      if (this.rootNode && this.rootNode.allLeafChildren) {
        for (let index = 0; index < this.rootNode.allLeafChildren.length; index++) {
          const node = this.rootNode.allLeafChildren[index];
          orderMap[node.id] = index;
        }
      }
      return orderMap;
    }
    // common to updateRowData and batchUpdateRowData
    commonUpdateRowData(rowNodeTrans, rowNodeOrder, forceRowNodeOrder) {
      if (!this.hasStarted) {
        return;
      }
      const animate = !this.gos.get("suppressAnimationFrame");
      if (forceRowNodeOrder) {
        rowNodeOrder = this.createRowNodeOrder();
      }
      const event = {
        type: Events.EVENT_ROW_DATA_UPDATED
      };
      this.eventService.dispatchEvent(event);
      this.refreshModel({
        step: "group",
        rowNodeTransactions: rowNodeTrans,
        rowNodeOrder,
        keepRenderedRows: true,
        keepEditingRows: true,
        animate
      });
    }
    doRowsToDisplay() {
      this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode });
    }
    onRowHeightChanged() {
      this.refreshModel({ step: "map", keepRenderedRows: true, keepEditingRows: true, keepUndoRedoStack: true });
    }
    /** This method is debounced. It is used for row auto-height. If we don't debounce,
     * then the Row Models will end up recalculating each row position
     * for each row height change and result in the Row Renderer laying out rows.
     * This is particularly bad if using print layout, and showing eg 1,000 rows,
     * each row will change it's height, causing Row Model to update 1,000 times.
     */
    onRowHeightChangedDebounced() {
      this.onRowHeightChanged_debounced();
    }
    resetRowHeights() {
      const atLeastOne = this.resetRowHeightsForAllRowNodes();
      this.rootNode.setRowHeight(this.rootNode.rowHeight, true);
      if (this.rootNode.sibling) {
        this.rootNode.sibling.setRowHeight(this.rootNode.sibling.rowHeight, true);
      }
      if (atLeastOne) {
        this.onRowHeightChanged();
      }
    }
    resetRowHeightsForAllRowNodes() {
      let atLeastOne = false;
      this.forEachNode((rowNode) => {
        rowNode.setRowHeight(rowNode.rowHeight, true);
        const detailNode = rowNode.detailNode;
        if (detailNode) {
          detailNode.setRowHeight(detailNode.rowHeight, true);
        }
        if (rowNode.sibling) {
          rowNode.sibling.setRowHeight(rowNode.sibling.rowHeight, true);
        }
        atLeastOne = true;
      });
      return atLeastOne;
    }
    onGridStylesChanges() {
      if (this.columnModel.isAutoRowHeightActive()) {
        return;
      }
      this.resetRowHeights();
    }
    onGridReady() {
      if (this.hasStarted) {
        return;
      }
      this.setInitialData();
    }
    isRowDataLoaded() {
      return this.rowCountReady;
    }
  };
  __decorateClass([
    Autowired("columnModel")
  ], ClientSideRowModel.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("selectionService")
  ], ClientSideRowModel.prototype, "selectionService", 2);
  __decorateClass([
    Autowired("valueCache")
  ], ClientSideRowModel.prototype, "valueCache", 2);
  __decorateClass([
    Autowired("beans")
  ], ClientSideRowModel.prototype, "beans", 2);
  __decorateClass([
    Autowired("filterStage")
  ], ClientSideRowModel.prototype, "filterStage", 2);
  __decorateClass([
    Autowired("sortStage")
  ], ClientSideRowModel.prototype, "sortStage", 2);
  __decorateClass([
    Autowired("flattenStage")
  ], ClientSideRowModel.prototype, "flattenStage", 2);
  __decorateClass([
    Optional("groupStage")
  ], ClientSideRowModel.prototype, "groupStage", 2);
  __decorateClass([
    Optional("aggregationStage")
  ], ClientSideRowModel.prototype, "aggregationStage", 2);
  __decorateClass([
    Optional("pivotStage")
  ], ClientSideRowModel.prototype, "pivotStage", 2);
  __decorateClass([
    Optional("filterAggregatesStage")
  ], ClientSideRowModel.prototype, "filterAggregatesStage", 2);
  __decorateClass([
    PostConstruct
  ], ClientSideRowModel.prototype, "init", 1);
  ClientSideRowModel = __decorateClass([
    Bean("rowModel")
  ], ClientSideRowModel);
  var FilterStage = class extends BeanStub {
    execute(params) {
      const { changedPath } = params;
      this.filterService.filter(changedPath);
    }
  };
  __decorateClass([
    Autowired("filterService")
  ], FilterStage.prototype, "filterService", 2);
  FilterStage = __decorateClass([
    Bean("filterStage")
  ], FilterStage);
  var SortStage = class extends BeanStub {
    execute(params) {
      const sortOptions = this.sortController.getSortOptions();
      const sortActive = _.exists(sortOptions) && sortOptions.length > 0;
      const deltaSort = sortActive && _.exists(params.rowNodeTransactions) && this.gos.get("deltaSort");
      const sortContainsGroupColumns = sortOptions.some((opt) => {
        const isSortingCoupled = this.gos.isColumnsSortingCoupledToGroup();
        if (isSortingCoupled) {
          return opt.column.isPrimary() && opt.column.isRowGroupActive();
        }
        return !!opt.column.getColDef().showRowGroup;
      });
      this.sortService.sort(sortOptions, sortActive, deltaSort, params.rowNodeTransactions, params.changedPath, sortContainsGroupColumns);
    }
  };
  __decorateClass([
    Autowired("sortService")
  ], SortStage.prototype, "sortService", 2);
  __decorateClass([
    Autowired("sortController")
  ], SortStage.prototype, "sortController", 2);
  SortStage = __decorateClass([
    Bean("sortStage")
  ], SortStage);
  var FlattenStage = class extends BeanStub {
    execute(params) {
      const rootNode = params.rowNode;
      const result = [];
      const skipLeafNodes = this.beans.columnModel.isPivotMode();
      const showRootNode = skipLeafNodes && rootNode.leafGroup;
      const topList = showRootNode ? [rootNode] : rootNode.childrenAfterSort;
      const details = this.getFlattenDetails();
      this.recursivelyAddToRowsToDisplay(details, topList, result, skipLeafNodes, 0);
      const atLeastOneRowPresent = result.length > 0;
      const includeGrandTotalRow = !showRootNode && atLeastOneRowPresent && details.grandTotalRow;
      if (includeGrandTotalRow) {
        rootNode.createFooter();
        const addToTop = details.grandTotalRow === "top";
        this.addRowNodeToRowsToDisplay(details, rootNode.sibling, result, 0, addToTop);
      }
      return result;
    }
    getFlattenDetails() {
      const groupRemoveSingleChildren = this.gos.get("groupRemoveSingleChildren");
      const groupRemoveLowestSingleChildren = !groupRemoveSingleChildren && this.gos.get("groupRemoveLowestSingleChildren");
      return {
        groupRemoveLowestSingleChildren,
        groupRemoveSingleChildren,
        isGroupMultiAutoColumn: this.gos.isGroupMultiAutoColumn(),
        hideOpenParents: this.gos.get("groupHideOpenParents"),
        grandTotalRow: this.gos.getGrandTotalRow(),
        groupTotalRow: this.gos.getGroupTotalRowCallback()
      };
    }
    recursivelyAddToRowsToDisplay(details, rowsToFlatten, result, skipLeafNodes, uiLevel) {
      if (_.missingOrEmpty(rowsToFlatten)) {
        return;
      }
      for (let i = 0; i < rowsToFlatten.length; i++) {
        const rowNode = rowsToFlatten[i];
        const isParent = rowNode.hasChildren();
        const isSkippedLeafNode = skipLeafNodes && !isParent;
        const isRemovedSingleChildrenGroup = details.groupRemoveSingleChildren && isParent && rowNode.childrenAfterGroup.length === 1;
        const isRemovedLowestSingleChildrenGroup = details.groupRemoveLowestSingleChildren && isParent && rowNode.leafGroup && rowNode.childrenAfterGroup.length === 1;
        const neverAllowToExpand = skipLeafNodes && rowNode.leafGroup;
        const isHiddenOpenParent = details.hideOpenParents && rowNode.expanded && !rowNode.master && !neverAllowToExpand;
        const thisRowShouldBeRendered = !isSkippedLeafNode && !isHiddenOpenParent && !isRemovedSingleChildrenGroup && !isRemovedLowestSingleChildrenGroup;
        if (thisRowShouldBeRendered) {
          this.addRowNodeToRowsToDisplay(details, rowNode, result, uiLevel);
        }
        if (skipLeafNodes && rowNode.leafGroup) {
          continue;
        }
        if (isParent) {
          const excludedParent = isRemovedSingleChildrenGroup || isRemovedLowestSingleChildrenGroup;
          if (rowNode.expanded || excludedParent) {
            const doesRowShowFooter = details.groupTotalRow({ node: rowNode });
            if (!doesRowShowFooter) {
              rowNode.destroyFooter();
            }
            const uiLevelForChildren = excludedParent ? uiLevel : uiLevel + 1;
            if (doesRowShowFooter === "top") {
              rowNode.createFooter();
              this.addRowNodeToRowsToDisplay(details, rowNode.sibling, result, uiLevelForChildren);
            }
            this.recursivelyAddToRowsToDisplay(
              details,
              rowNode.childrenAfterSort,
              result,
              skipLeafNodes,
              uiLevelForChildren
            );
            if (doesRowShowFooter === "bottom") {
              rowNode.createFooter();
              this.addRowNodeToRowsToDisplay(details, rowNode.sibling, result, uiLevelForChildren);
            }
          }
        } else if (rowNode.master && rowNode.expanded) {
          const detailNode = this.createDetailNode(rowNode);
          this.addRowNodeToRowsToDisplay(details, detailNode, result, uiLevel);
        }
      }
    }
    // duplicated method, it's also in floatingRowModel
    addRowNodeToRowsToDisplay(details, rowNode, result, uiLevel, addToTop) {
      if (addToTop) {
        result.unshift(rowNode);
      } else {
        result.push(rowNode);
      }
      rowNode.setUiLevel(details.isGroupMultiAutoColumn ? 0 : uiLevel);
    }
    createDetailNode(masterNode) {
      if (_.exists(masterNode.detailNode)) {
        return masterNode.detailNode;
      }
      const detailNode = new RowNode(this.beans);
      detailNode.detail = true;
      detailNode.selectable = false;
      detailNode.parent = masterNode;
      if (_.exists(masterNode.id)) {
        detailNode.id = "detail_" + masterNode.id;
      }
      detailNode.data = masterNode.data;
      detailNode.level = masterNode.level + 1;
      masterNode.detailNode = detailNode;
      return detailNode;
    }
  };
  __decorateClass([
    Autowired("beans")
  ], FlattenStage.prototype, "beans", 2);
  FlattenStage = __decorateClass([
    Bean("flattenStage")
  ], FlattenStage);
  var SortService = class extends BeanStub {
    sort(sortOptions, sortActive, useDeltaSort, rowNodeTransactions, changedPath, sortContainsGroupColumns) {
      const groupMaintainOrder = this.gos.get("groupMaintainOrder");
      const groupColumnsPresent = this.columnModel.getAllGridColumns().some((c) => c.isRowGroupActive());
      let allDirtyNodes = {};
      if (useDeltaSort && rowNodeTransactions) {
        allDirtyNodes = this.calculateDirtyNodes(rowNodeTransactions);
      }
      const isPivotMode = this.columnModel.isPivotMode();
      const postSortFunc = this.gos.getCallback("postSortRows");
      const callback = (rowNode) => {
        var _a;
        this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterAggFilter, true);
        const skipSortingPivotLeafs = isPivotMode && rowNode.leafGroup;
        let skipSortingGroups = groupMaintainOrder && groupColumnsPresent && !rowNode.leafGroup && !sortContainsGroupColumns;
        if (skipSortingGroups) {
          const nextGroup = (_a = this.columnModel.getRowGroupColumns()) == null ? void 0 : _a[rowNode.level + 1];
          const wasSortExplicitlyRemoved = (nextGroup == null ? void 0 : nextGroup.getSort()) === null;
          const childrenToBeSorted = rowNode.childrenAfterAggFilter.slice(0);
          if (rowNode.childrenAfterSort && !wasSortExplicitlyRemoved) {
            const indexedOrders = {};
            rowNode.childrenAfterSort.forEach((node, idx) => {
              indexedOrders[node.id] = idx;
            });
            childrenToBeSorted.sort((row1, row2) => {
              var _a2, _b;
              return ((_a2 = indexedOrders[row1.id]) != null ? _a2 : 0) - ((_b = indexedOrders[row2.id]) != null ? _b : 0);
            });
          }
          rowNode.childrenAfterSort = childrenToBeSorted;
        } else if (!sortActive || skipSortingPivotLeafs) {
          rowNode.childrenAfterSort = rowNode.childrenAfterAggFilter.slice(0);
        } else if (useDeltaSort) {
          rowNode.childrenAfterSort = this.doDeltaSort(rowNode, allDirtyNodes, changedPath, sortOptions);
        } else {
          rowNode.childrenAfterSort = this.rowNodeSorter.doFullSort(rowNode.childrenAfterAggFilter, sortOptions);
        }
        if (rowNode.sibling) {
          rowNode.sibling.childrenAfterSort = rowNode.childrenAfterSort;
        }
        this.updateChildIndexes(rowNode);
        if (postSortFunc) {
          const params = { nodes: rowNode.childrenAfterSort };
          postSortFunc(params);
        }
      };
      if (changedPath) {
        changedPath.forEachChangedNodeDepthFirst(callback);
      }
      this.updateGroupDataForHideOpenParents(changedPath);
    }
    calculateDirtyNodes(rowNodeTransactions) {
      const dirtyNodes = {};
      const addNodesFunc = (rowNodes) => {
        if (rowNodes) {
          rowNodes.forEach((rowNode) => dirtyNodes[rowNode.id] = true);
        }
      };
      if (rowNodeTransactions) {
        rowNodeTransactions.forEach((tran) => {
          addNodesFunc(tran.add);
          addNodesFunc(tran.update);
          addNodesFunc(tran.remove);
        });
      }
      return dirtyNodes;
    }
    doDeltaSort(rowNode, allTouchedNodes, changedPath, sortOptions) {
      const unsortedRows = rowNode.childrenAfterAggFilter;
      const oldSortedRows = rowNode.childrenAfterSort;
      if (!oldSortedRows) {
        return this.rowNodeSorter.doFullSort(unsortedRows, sortOptions);
      }
      const untouchedRowsMap = {};
      const touchedRows = [];
      unsortedRows.forEach((row) => {
        if (allTouchedNodes[row.id] || !changedPath.canSkip(row)) {
          touchedRows.push(row);
        } else {
          untouchedRowsMap[row.id] = true;
        }
      });
      const sortedUntouchedRows = oldSortedRows.filter((child) => untouchedRowsMap[child.id]);
      const mapNodeToSortedNode = (rowNode2, pos) => ({ currentPos: pos, rowNode: rowNode2 });
      const sortedChangedRows = touchedRows.map(mapNodeToSortedNode).sort((a, b) => this.rowNodeSorter.compareRowNodes(sortOptions, a, b));
      return this.mergeSortedArrays(
        sortOptions,
        sortedChangedRows,
        sortedUntouchedRows.map(mapNodeToSortedNode)
      ).map(({ rowNode: rowNode2 }) => rowNode2);
    }
    // Merge two sorted arrays into each other
    mergeSortedArrays(sortOptions, arr1, arr2) {
      const res = [];
      let i = 0;
      let j = 0;
      while (i < arr1.length && j < arr2.length) {
        const compareResult = this.rowNodeSorter.compareRowNodes(sortOptions, arr1[i], arr2[j]);
        if (compareResult < 0) {
          res.push(arr1[i++]);
        } else {
          res.push(arr2[j++]);
        }
      }
      while (i < arr1.length) {
        res.push(arr1[i++]);
      }
      while (j < arr2.length) {
        res.push(arr2[j++]);
      }
      return res;
    }
    updateChildIndexes(rowNode) {
      if (_.missing(rowNode.childrenAfterSort)) {
        return;
      }
      const listToSort = rowNode.childrenAfterSort;
      for (let i = 0; i < listToSort.length; i++) {
        const child = listToSort[i];
        const firstChild = i === 0;
        const lastChild = i === rowNode.childrenAfterSort.length - 1;
        child.setFirstChild(firstChild);
        child.setLastChild(lastChild);
        child.setChildIndex(i);
      }
    }
    updateGroupDataForHideOpenParents(changedPath) {
      if (!this.gos.get("groupHideOpenParents")) {
        return;
      }
      if (this.gos.get("treeData")) {
        _.warnOnce(`The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them.`);
        return false;
      }
      const callback = (rowNode) => {
        this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterSort, false);
        rowNode.childrenAfterSort.forEach((child) => {
          if (child.hasChildren()) {
            callback(child);
          }
        });
      };
      if (changedPath) {
        changedPath.executeFromRootNode((rowNode) => callback(rowNode));
      }
    }
    pullDownGroupDataForHideOpenParents(rowNodes, clearOperation) {
      if (!this.gos.get("groupHideOpenParents") || _.missing(rowNodes)) {
        return;
      }
      rowNodes.forEach((childRowNode) => {
        const groupDisplayCols = this.columnModel.getGroupDisplayColumns();
        groupDisplayCols.forEach((groupDisplayCol) => {
          const showRowGroup = groupDisplayCol.getColDef().showRowGroup;
          if (typeof showRowGroup !== "string") {
            console.error("AG Grid: groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup");
            return;
          }
          const displayingGroupKey = showRowGroup;
          const rowGroupColumn = this.columnModel.getPrimaryColumn(displayingGroupKey);
          const thisRowNodeMatches = rowGroupColumn === childRowNode.rowGroupColumn;
          if (thisRowNodeMatches) {
            return;
          }
          if (clearOperation) {
            childRowNode.setGroupValue(groupDisplayCol.getId(), void 0);
          } else {
            const parentToStealFrom = childRowNode.getFirstChildOfFirstChild(rowGroupColumn);
            if (parentToStealFrom) {
              childRowNode.setGroupValue(groupDisplayCol.getId(), parentToStealFrom.key);
            }
          }
        });
      });
    }
  };
  __decorateClass([
    Autowired("columnModel")
  ], SortService.prototype, "columnModel", 2);
  __decorateClass([
    Autowired("rowNodeSorter")
  ], SortService.prototype, "rowNodeSorter", 2);
  SortService = __decorateClass([
    Bean("sortService")
  ], SortService);
  var FilterService = class extends BeanStub {
    filter(changedPath) {
      const filterActive = this.filterManager.isChildFilterPresent();
      this.filterNodes(filterActive, changedPath);
    }
    filterNodes(filterActive, changedPath) {
      const filterCallback = (rowNode, includeChildNodes) => {
        if (rowNode.hasChildren()) {
          if (filterActive && !includeChildNodes) {
            rowNode.childrenAfterFilter = rowNode.childrenAfterGroup.filter((childNode) => {
              const passBecauseChildren = childNode.childrenAfterFilter && childNode.childrenAfterFilter.length > 0;
              const passBecauseDataPasses = childNode.data && this.filterManager.doesRowPassFilter({ rowNode: childNode });
              return passBecauseChildren || passBecauseDataPasses;
            });
          } else {
            rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
          }
        } else {
          rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
        }
        if (rowNode.sibling) {
          rowNode.sibling.childrenAfterFilter = rowNode.childrenAfterFilter;
        }
      };
      if (this.doingTreeDataFiltering()) {
        const treeDataDepthFirstFilter = (rowNode, alreadyFoundInParent) => {
          if (rowNode.childrenAfterGroup) {
            for (let i = 0; i < rowNode.childrenAfterGroup.length; i++) {
              const childNode = rowNode.childrenAfterGroup[i];
              const foundInParent = alreadyFoundInParent || this.filterManager.doesRowPassFilter({ rowNode: childNode });
              if (childNode.childrenAfterGroup) {
                treeDataDepthFirstFilter(rowNode.childrenAfterGroup[i], foundInParent);
              } else {
                filterCallback(childNode, foundInParent);
              }
            }
          }
          filterCallback(rowNode, alreadyFoundInParent);
        };
        const treeDataFilterCallback = (rowNode) => treeDataDepthFirstFilter(rowNode, false);
        changedPath.executeFromRootNode(treeDataFilterCallback);
      } else {
        const defaultFilterCallback = (rowNode) => filterCallback(rowNode, false);
        changedPath.forEachChangedNodeDepthFirst(defaultFilterCallback, true);
      }
    }
    doingTreeDataFiltering() {
      return this.gos.get("treeData") && !this.gos.get("excludeChildrenWhenTreeDataFiltering");
    }
  };
  __decorateClass([
    Autowired("filterManager")
  ], FilterService.prototype, "filterManager", 2);
  FilterService = __decorateClass([
    Bean("filterService")
  ], FilterService);
  var ImmutableService = class extends BeanStub {
    postConstruct() {
      if (this.rowModel.getType() === "clientSide") {
        this.clientSideRowModel = this.rowModel;
        this.addManagedPropertyListener("rowData", () => this.onRowDataUpdated());
      }
    }
    isActive() {
      const getRowIdProvided = this.gos.exists("getRowId");
      const resetRowDataOnUpdate = this.gos.get("resetRowDataOnUpdate");
      if (resetRowDataOnUpdate) {
        return false;
      }
      return getRowIdProvided;
    }
    setRowData(rowData) {
      const transactionAndMap = this.createTransactionForRowData(rowData);
      if (!transactionAndMap) {
        return;
      }
      const [transaction, orderIdMap] = transactionAndMap;
      this.clientSideRowModel.updateRowData(transaction, orderIdMap);
    }
    // converts the setRowData() command to a transaction
    createTransactionForRowData(rowData) {
      if (_.missing(this.clientSideRowModel)) {
        console.error("AG Grid: ImmutableService only works with ClientSideRowModel");
        return;
      }
      const getRowIdFunc = this.gos.getCallback("getRowId");
      if (getRowIdFunc == null) {
        console.error("AG Grid: ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!");
        return;
      }
      const transaction = {
        remove: [],
        update: [],
        add: []
      };
      const existingNodesMap = this.clientSideRowModel.getCopyOfNodesMap();
      const suppressSortOrder = this.gos.get("suppressMaintainUnsortedOrder");
      const orderMap = suppressSortOrder ? void 0 : {};
      if (_.exists(rowData)) {
        rowData.forEach((data, index) => {
          const id = getRowIdFunc({ data, level: 0 });
          const existingNode = existingNodesMap[id];
          if (orderMap) {
            orderMap[id] = index;
          }
          if (existingNode) {
            const dataHasChanged = existingNode.data !== data;
            if (dataHasChanged) {
              transaction.update.push(data);
            }
            existingNodesMap[id] = void 0;
          } else {
            transaction.add.push(data);
          }
        });
      }
      _.iterateObject(existingNodesMap, (id, rowNode) => {
        if (rowNode) {
          transaction.remove.push(rowNode.data);
        }
      });
      return [transaction, orderMap];
    }
    onRowDataUpdated() {
      const rowData = this.gos.get("rowData");
      if (!rowData) {
        return;
      }
      if (this.isActive()) {
        this.setRowData(rowData);
      } else {
        this.selectionService.reset("rowDataChanged");
        this.clientSideRowModel.setRowData(rowData);
      }
    }
  };
  __decorateClass([
    Autowired("rowModel")
  ], ImmutableService.prototype, "rowModel", 2);
  __decorateClass([
    Autowired("rowRenderer")
  ], ImmutableService.prototype, "rowRenderer", 2);
  __decorateClass([
    Autowired("selectionService")
  ], ImmutableService.prototype, "selectionService", 2);
  __decorateClass([
    PostConstruct
  ], ImmutableService.prototype, "postConstruct", 1);
  ImmutableService = __decorateClass([
    Bean("immutableService")
  ], ImmutableService);
  var VERSION = "31.3.2";
  var ClientSideRowModelModule = {
    version: VERSION,
    moduleName: "@ag-grid-community/client-side-row-model",
    rowModel: "clientSide",
    beans: [ClientSideRowModel, FilterStage, SortStage, FlattenStage, SortService, FilterService, ImmutableService]
  };
  var __defProp22 = Object.defineProperty;
  var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
  var __decorateClass2 = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc22(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp22(target, key, result);
    return result;
  };
  var __decorateParam2 = (index, decorator) => (target, key) => decorator(target, key, index);
  var InfiniteBlock = class extends RowNodeBlock {
    constructor(id, parentCache, params) {
      super(id);
      this.parentCache = parentCache;
      this.params = params;
      this.startRow = id * params.blockSize;
      this.endRow = this.startRow + params.blockSize;
    }
    postConstruct() {
      this.createRowNodes();
    }
    getBlockStateJson() {
      return {
        id: "" + this.getId(),
        state: {
          blockNumber: this.getId(),
          startRow: this.getStartRow(),
          endRow: this.getEndRow(),
          pageStatus: this.getState()
        }
      };
    }
    setDataAndId(rowNode, data, index) {
      if (_.exists(data)) {
        rowNode.setDataAndId(data, index.toString());
      } else {
        rowNode.setDataAndId(void 0, void 0);
      }
    }
    loadFromDatasource() {
      const params = this.createLoadParams();
      if (_.missing(this.params.datasource.getRows)) {
        console.warn(`AG Grid: datasource is missing getRows method`);
        return;
      }
      window.setTimeout(() => {
        this.params.datasource.getRows(params);
      }, 0);
    }
    processServerFail() {
    }
    createLoadParams() {
      const params = {
        startRow: this.getStartRow(),
        endRow: this.getEndRow(),
        successCallback: this.pageLoaded.bind(this, this.getVersion()),
        failCallback: this.pageLoadFailed.bind(this, this.getVersion()),
        sortModel: this.params.sortModel,
        filterModel: this.params.filterModel,
        context: this.gos.getGridCommonParams().context
      };
      return params;
    }
    forEachNode(callback, sequence, rowCount) {
      this.rowNodes.forEach((rowNode, index) => {
        const rowIndex = this.startRow + index;
        if (rowIndex < rowCount) {
          callback(rowNode, sequence.next());
        }
      });
    }
    getLastAccessed() {
      return this.lastAccessed;
    }
    getRow(rowIndex, dontTouchLastAccessed = false) {
      if (!dontTouchLastAccessed) {
        this.lastAccessed = this.params.lastAccessedSequence.next();
      }
      const localIndex = rowIndex - this.startRow;
      return this.rowNodes[localIndex];
    }
    getStartRow() {
      return this.startRow;
    }
    getEndRow() {
      return this.endRow;
    }
    // creates empty row nodes, data is missing as not loaded yet
    createRowNodes() {
      this.rowNodes = [];
      for (let i = 0; i < this.params.blockSize; i++) {
        const rowIndex = this.startRow + i;
        const rowNode = new RowNode(this.beans);
        rowNode.setRowHeight(this.params.rowHeight);
        rowNode.uiLevel = 0;
        rowNode.setRowIndex(rowIndex);
        rowNode.setRowTop(this.params.rowHeight * rowIndex);
        this.rowNodes.push(rowNode);
      }
    }
    processServerResult(params) {
      this.rowNodes.forEach((rowNode, index) => {
        const data = params.rowData ? params.rowData[index] : void 0;
        if (!rowNode.id && rowNode.alreadyRendered && data) {
          this.rowNodes[index] = new RowNode(this.beans);
          this.rowNodes[index].setRowIndex(rowNode.rowIndex);
          this.rowNodes[index].setRowTop(rowNode.rowTop);
          this.rowNodes[index].setRowHeight(rowNode.rowHeight);
          rowNode.clearRowTopAndRowIndex();
        }
        this.setDataAndId(this.rowNodes[index], data, this.startRow + index);
      });
      const finalRowCount = params.rowCount != null && params.rowCount >= 0 ? params.rowCount : void 0;
      this.parentCache.pageLoaded(this, finalRowCount);
    }
    destroyRowNodes() {
      this.rowNodes.forEach((rowNode) => {
        rowNode.clearRowTopAndRowIndex();
      });
    }
  };
  __decorateClass2([
    Autowired("beans")
  ], InfiniteBlock.prototype, "beans", 2);
  __decorateClass2([
    PostConstruct
  ], InfiniteBlock.prototype, "postConstruct", 1);
  __decorateClass2([
    PreDestroy
  ], InfiniteBlock.prototype, "destroyRowNodes", 1);
  var _InfiniteCache = class _InfiniteCache2 extends BeanStub {
    constructor(params) {
      super();
      this.lastRowIndexKnown = false;
      this.blocks = {};
      this.blockCount = 0;
      this.rowCount = params.initialRowCount;
      this.params = params;
    }
    setBeans(loggerFactory) {
      this.logger = loggerFactory.create("InfiniteCache");
    }
    // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,
    // it will want new pages in the cache as it asks for rows. only when we are inserting /
    // removing rows via the api is dontCreatePage set, where we move rows between the pages.
    getRow(rowIndex, dontCreatePage = false) {
      const blockId = Math.floor(rowIndex / this.params.blockSize);
      let block = this.blocks[blockId];
      if (!block) {
        if (dontCreatePage) {
          return void 0;
        }
        block = this.createBlock(blockId);
      }
      return block.getRow(rowIndex);
    }
    createBlock(blockNumber) {
      const newBlock = this.createBean(new InfiniteBlock(blockNumber, this, this.params));
      this.blocks[newBlock.getId()] = newBlock;
      this.blockCount++;
      this.purgeBlocksIfNeeded(newBlock);
      this.params.rowNodeBlockLoader.addBlock(newBlock);
      return newBlock;
    }
    // we have this on infinite row model only, not server side row model,
    // because for server side, it would leave the children in inconsistent
    // state - eg if a node had children, but after the refresh it had data
    // for a different row, then the children would be with the wrong row node.
    refreshCache() {
      const nothingToRefresh = this.blockCount == 0;
      if (nothingToRefresh) {
        this.purgeCache();
        return;
      }
      this.getBlocksInOrder().forEach((block) => block.setStateWaitingToLoad());
      this.params.rowNodeBlockLoader.checkBlockToLoad();
    }
    destroyAllBlocks() {
      this.getBlocksInOrder().forEach((block) => this.destroyBlock(block));
    }
    getRowCount() {
      return this.rowCount;
    }
    isLastRowIndexKnown() {
      return this.lastRowIndexKnown;
    }
    // block calls this, when page loaded
    pageLoaded(block, lastRow) {
      if (!this.isAlive()) {
        return;
      }
      this.logger.log(`onPageLoaded: page = ${block.getId()}, lastRow = ${lastRow}`);
      this.checkRowCount(block, lastRow);
      this.onCacheUpdated();
    }
    purgeBlocksIfNeeded(blockToExclude) {
      const blocksForPurging = this.getBlocksInOrder().filter((b) => b != blockToExclude);
      const lastAccessedComparator = (a, b) => b.getLastAccessed() - a.getLastAccessed();
      blocksForPurging.sort(lastAccessedComparator);
      const maxBlocksProvided = this.params.maxBlocksInCache > 0;
      const blocksToKeep = maxBlocksProvided ? this.params.maxBlocksInCache - 1 : null;
      const emptyBlocksToKeep = _InfiniteCache2.MAX_EMPTY_BLOCKS_TO_KEEP - 1;
      blocksForPurging.forEach((block, index) => {
        const purgeBecauseBlockEmpty = block.getState() === InfiniteBlock.STATE_WAITING_TO_LOAD && index >= emptyBlocksToKeep;
        const purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep : false;
        if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {
          if (this.isBlockCurrentlyDisplayed(block)) {
            return;
          }
          if (this.isBlockFocused(block)) {
            return;
          }
          this.removeBlockFromCache(block);
        }
      });
    }
    isBlockFocused(block) {
      const focusedCell = this.focusService.getFocusCellToUseAfterRefresh();
      if (!focusedCell) {
        return false;
      }
      if (focusedCell.rowPinned != null) {
        return false;
      }
      const blockIndexStart = block.getStartRow();
      const blockIndexEnd = block.getEndRow();
      const hasFocus = focusedCell.rowIndex >= blockIndexStart && focusedCell.rowIndex < blockIndexEnd;
      return hasFocus;
    }
    isBlockCurrentlyDisplayed(block) {
      const startIndex = block.getStartRow();
      const endIndex = block.getEndRow() - 1;
      return this.rowRenderer.isRangeInRenderedViewport(startIndex, endIndex);
    }
    removeBlockFromCache(blockToRemove) {
      if (!blockToRemove) {
        return;
      }
      this.destroyBlock(blockToRemove);
    }
    checkRowCount(block, lastRow) {
      if (typeof lastRow === "number" && lastRow >= 0) {
        this.rowCount = lastRow;
        this.lastRowIndexKnown = true;
      } else if (!this.lastRowIndexKnown) {
        const lastRowIndex = (block.getId() + 1) * this.params.blockSize;
        const lastRowIndexPlusOverflow = lastRowIndex + this.params.overflowSize;
        if (this.rowCount < lastRowIndexPlusOverflow) {
          this.rowCount = lastRowIndexPlusOverflow;
        }
      }
    }
    setRowCount(rowCount, lastRowIndexKnown) {
      this.rowCount = rowCount;
      if (_.exists(lastRowIndexKnown)) {
        this.lastRowIndexKnown = lastRowIndexKnown;
      }
      if (!this.lastRowIndexKnown) {
        if (this.rowCount % this.params.blockSize === 0) {
          this.rowCount++;
        }
      }
      this.onCacheUpdated();
    }
    forEachNodeDeep(callback) {
      const sequence = new NumberSequence();
      this.getBlocksInOrder().forEach((block) => block.forEachNode(callback, sequence, this.rowCount));
    }
    getBlocksInOrder() {
      const blockComparator = (a, b) => a.getId() - b.getId();
      const blocks = _.getAllValuesInObject(this.blocks).sort(blockComparator);
      return blocks;
    }
    destroyBlock(block) {
      delete this.blocks[block.getId()];
      this.destroyBean(block);
      this.blockCount--;
      this.params.rowNodeBlockLoader.removeBlock(block);
    }
    // gets called 1) row count changed 2) cache purged 3) items inserted
    onCacheUpdated() {
      if (this.isAlive()) {
        this.destroyAllBlocksPastVirtualRowCount();
        const event = {
          type: Events.EVENT_STORE_UPDATED
        };
        this.eventService.dispatchEvent(event);
      }
    }
    destroyAllBlocksPastVirtualRowCount() {
      const blocksToDestroy = [];
      this.getBlocksInOrder().forEach((block) => {
        const startRow = block.getId() * this.params.blockSize;
        if (startRow >= this.rowCount) {
          blocksToDestroy.push(block);
        }
      });
      if (blocksToDestroy.length > 0) {
        blocksToDestroy.forEach((block) => this.destroyBlock(block));
      }
    }
    purgeCache() {
      this.getBlocksInOrder().forEach((block) => this.removeBlockFromCache(block));
      this.lastRowIndexKnown = false;
      if (this.rowCount === 0) {
        this.rowCount = this.params.initialRowCount;
      }
      this.onCacheUpdated();
    }
    getRowNodesInRange(firstInRange, lastInRange) {
      const result = [];
      let lastBlockId = -1;
      let inActiveRange = false;
      const numberSequence = new NumberSequence();
      if (_.missing(firstInRange)) {
        inActiveRange = true;
      }
      let foundGapInSelection = false;
      this.getBlocksInOrder().forEach((block) => {
        if (foundGapInSelection) {
          return;
        }
        if (inActiveRange && lastBlockId + 1 !== block.getId()) {
          foundGapInSelection = true;
          return;
        }
        lastBlockId = block.getId();
        block.forEachNode((rowNode) => {
          const hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;
          if (inActiveRange || hitFirstOrLast) {
            result.push(rowNode);
          }
          if (hitFirstOrLast) {
            inActiveRange = !inActiveRange;
          }
        }, numberSequence, this.rowCount);
      });
      const invalidRange = foundGapInSelection || inActiveRange;
      return invalidRange ? [] : result;
    }
  };
  _InfiniteCache.MAX_EMPTY_BLOCKS_TO_KEEP = 2;
  __decorateClass2([
    Autowired("rowRenderer")
  ], _InfiniteCache.prototype, "rowRenderer", 2);
  __decorateClass2([
    Autowired("focusService")
  ], _InfiniteCache.prototype, "focusService", 2);
  __decorateClass2([
    __decorateParam2(0, Qualifier("loggerFactory"))
  ], _InfiniteCache.prototype, "setBeans", 1);
  __decorateClass2([
    PreDestroy
  ], _InfiniteCache.prototype, "destroyAllBlocks", 1);
  var InfiniteCache = _InfiniteCache;
  var InfiniteRowModel = class extends BeanStub {
    getRowBounds(index) {
      return {
        rowHeight: this.rowHeight,
        rowTop: this.rowHeight * index
      };
    }
    // we don't implement as lazy row heights is not supported in this row model
    ensureRowHeightsValid(startPixel, endPixel, startLimitIndex, endLimitIndex) {
      return false;
    }
    init() {
      if (!this.gos.isRowModelType("infinite")) {
        return;
      }
      this.rowHeight = this.gos.getRowHeightAsNumber();
      this.addEventListeners();
      this.addDestroyFunc(() => this.destroyCache());
      this.verifyProps();
    }
    verifyProps() {
      if (this.gos.exists("initialGroupOrderComparator")) {
        _.warnOnce("initialGroupOrderComparator cannot be used with Infinite Row Model as sorting is done on the server side");
      }
    }
    start() {
      this.setDatasource(this.gos.get("datasource"));
    }
    destroyDatasource() {
      if (this.datasource) {
        this.getContext().destroyBean(this.datasource);
        this.rowRenderer.datasourceChanged();
        this.datasource = null;
      }
    }
    addEventListeners() {
      this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverything.bind(this));
      this.addManagedListener(this.eventService, Events.EVENT_STORE_UPDATED, this.onCacheUpdated.bind(this));
      this.addManagedPropertyListener("datasource", () => this.setDatasource(this.gos.get("datasource")));
      this.addManagedPropertyListener("cacheBlockSize", () => this.resetCache());
      this.addManagedPropertyListener("rowHeight", () => {
        this.rowHeight = this.gos.getRowHeightAsNumber();
        this.cacheParams.rowHeight = this.rowHeight;
        this.updateRowHeights();
      });
    }
    onFilterChanged() {
      this.reset();
    }
    onSortChanged() {
      this.reset();
    }
    onColumnEverything() {
      let resetRequired;
      if (this.cacheParams) {
        resetRequired = this.isSortModelDifferent();
      } else {
        resetRequired = true;
      }
      if (resetRequired) {
        this.reset();
      }
    }
    isSortModelDifferent() {
      return !_.jsonEquals(this.cacheParams.sortModel, this.sortController.getSortModel());
    }
    getType() {
      return "infinite";
    }
    setDatasource(datasource) {
      this.destroyDatasource();
      this.datasource = datasource;
      if (datasource) {
        this.reset();
      }
    }
    isEmpty() {
      return !this.infiniteCache;
    }
    isRowsToRender() {
      return !!this.infiniteCache;
    }
    getNodesInRangeForSelection(firstInRange, lastInRange) {
      return this.infiniteCache ? this.infiniteCache.getRowNodesInRange(firstInRange, lastInRange) : [];
    }
    reset() {
      if (!this.datasource) {
        return;
      }
      const getRowIdFunc = this.gos.getCallback("getRowId");
      const userGeneratingIds = getRowIdFunc != null;
      if (!userGeneratingIds) {
        this.selectionService.reset("rowDataChanged");
      }
      this.resetCache();
    }
    createModelUpdatedEvent() {
      return {
        type: Events.EVENT_MODEL_UPDATED,
        // not sure if these should all be false - noticed if after implementing,
        // maybe they should be true?
        newPage: false,
        newPageSize: false,
        newData: false,
        keepRenderedRows: true,
        animate: false
      };
    }
    resetCache() {
      this.destroyCache();
      this.cacheParams = {
        // the user provided datasource
        datasource: this.datasource,
        // sort and filter model
        filterModel: this.filterManager.getFilterModel(),
        sortModel: this.sortController.getSortModel(),
        rowNodeBlockLoader: this.rowNodeBlockLoader,
        // properties - this way we take a snapshot of them, so if user changes any, they will be
        // used next time we create a new cache, which is generally after a filter or sort change,
        // or a new datasource is set
        initialRowCount: this.gos.get("infiniteInitialRowCount"),
        maxBlocksInCache: this.gos.get("maxBlocksInCache"),
        rowHeight: this.gos.getRowHeightAsNumber(),
        // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past
        // the current page and request first row of next page
        overflowSize: this.gos.get("cacheOverflowSize"),
        // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the
        // server for one page at a time. so the default if not specified is 100.
        blockSize: this.gos.get("cacheBlockSize"),
        // the cache could create this, however it is also used by the pages, so handy to create it
        // here as the settings are also passed to the pages
        lastAccessedSequence: new NumberSequence()
      };
      this.infiniteCache = this.createBean(new InfiniteCache(this.cacheParams));
      this.eventService.dispatchEventOnce({
        type: Events.EVENT_ROW_COUNT_READY
      });
      const event = this.createModelUpdatedEvent();
      this.eventService.dispatchEvent(event);
    }
    updateRowHeights() {
      this.forEachNode((node) => {
        node.setRowHeight(this.rowHeight);
        node.setRowTop(this.rowHeight * node.rowIndex);
      });
      const event = this.createModelUpdatedEvent();
      this.eventService.dispatchEvent(event);
    }
    destroyCache() {
      if (this.infiniteCache) {
        this.infiniteCache = this.destroyBean(this.infiniteCache);
      }
    }
    onCacheUpdated() {
      const event = this.createModelUpdatedEvent();
      this.eventService.dispatchEvent(event);
    }
    getRow(rowIndex) {
      if (!this.infiniteCache) {
        return void 0;
      }
      if (rowIndex >= this.infiniteCache.getRowCount()) {
        return void 0;
      }
      return this.infiniteCache.getRow(rowIndex);
    }
    getRowNode(id) {
      let result;
      this.forEachNode((rowNode) => {
        if (rowNode.id === id) {
          result = rowNode;
        }
      });
      return result;
    }
    forEachNode(callback) {
      if (this.infiniteCache) {
        this.infiniteCache.forEachNodeDeep(callback);
      }
    }
    getTopLevelRowCount() {
      return this.getRowCount();
    }
    getTopLevelRowDisplayedIndex(topLevelIndex) {
      return topLevelIndex;
    }
    getRowIndexAtPixel(pixel) {
      if (this.rowHeight !== 0) {
        const rowIndexForPixel = Math.floor(pixel / this.rowHeight);
        const lastRowIndex = this.getRowCount() - 1;
        if (rowIndexForPixel > lastRowIndex) {
          return lastRowIndex;
        }
        return rowIndexForPixel;
      }
      return 0;
    }
    getRowCount() {
      return this.infiniteCache ? this.infiniteCache.getRowCount() : 0;
    }
    isRowPresent(rowNode) {
      const foundRowNode = this.getRowNode(rowNode.id);
      return !!foundRowNode;
    }
    refreshCache() {
      if (this.infiniteCache) {
        this.infiniteCache.refreshCache();
      }
    }
    purgeCache() {
      if (this.infiniteCache) {
        this.infiniteCache.purgeCache();
      }
    }
    // for iRowModel
    isLastRowIndexKnown() {
      if (this.infiniteCache) {
        return this.infiniteCache.isLastRowIndexKnown();
      }
      return false;
    }
    setRowCount(rowCount, lastRowIndexKnown) {
      if (this.infiniteCache) {
        this.infiniteCache.setRowCount(rowCount, lastRowIndexKnown);
      }
    }
  };
  __decorateClass2([
    Autowired("filterManager")
  ], InfiniteRowModel.prototype, "filterManager", 2);
  __decorateClass2([
    Autowired("sortController")
  ], InfiniteRowModel.prototype, "sortController", 2);
  __decorateClass2([
    Autowired("selectionService")
  ], InfiniteRowModel.prototype, "selectionService", 2);
  __decorateClass2([
    Autowired("rowRenderer")
  ], InfiniteRowModel.prototype, "rowRenderer", 2);
  __decorateClass2([
    Autowired("rowNodeBlockLoader")
  ], InfiniteRowModel.prototype, "rowNodeBlockLoader", 2);
  __decorateClass2([
    PostConstruct
  ], InfiniteRowModel.prototype, "init", 1);
  __decorateClass2([
    PreDestroy
  ], InfiniteRowModel.prototype, "destroyDatasource", 1);
  InfiniteRowModel = __decorateClass2([
    Bean("rowModel")
  ], InfiniteRowModel);
  var VERSION2 = "31.3.2";
  var InfiniteRowModelModule = {
    version: VERSION2,
    moduleName: "@ag-grid-community/infinite-row-model",
    rowModel: "infinite",
    beans: [InfiniteRowModel]
  };
  var __defProp3 = Object.defineProperty;
  var __defProps2 = Object.defineProperties;
  var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
  var __hasOwnProp22 = Object.prototype.hasOwnProperty;
  var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues2 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp22.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    if (__getOwnPropSymbols2)
      for (var prop of __getOwnPropSymbols2(b)) {
        if (__propIsEnum2.call(b, prop))
          __defNormalProp2(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
  var __decorateClass3 = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc3(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp3(target, key, result);
    return result;
  };
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve2, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var BaseCreator = class {
    setBeans(beans) {
      this.beans = beans;
    }
    getFileName(fileName) {
      const extension = this.getDefaultFileExtension();
      if (fileName == null || !fileName.length) {
        fileName = this.getDefaultFileName();
      }
      return fileName.indexOf(".") === -1 ? `${fileName}.${extension}` : fileName;
    }
    getData(params) {
      const serializingSession = this.createSerializingSession(params);
      return this.beans.gridSerializer.serialize(serializingSession, params);
    }
    getDefaultFileName() {
      return `export.${this.getDefaultFileExtension()}`;
    }
  };
  var BaseGridSerializingSession = class {
    constructor(config) {
      this.groupColumns = [];
      const {
        columnModel,
        valueService,
        gos,
        processCellCallback,
        processHeaderCallback,
        processGroupHeaderCallback,
        processRowGroupCallback
      } = config;
      this.columnModel = columnModel;
      this.valueService = valueService;
      this.gos = gos;
      this.processCellCallback = processCellCallback;
      this.processHeaderCallback = processHeaderCallback;
      this.processGroupHeaderCallback = processGroupHeaderCallback;
      this.processRowGroupCallback = processRowGroupCallback;
    }
    prepare(columnsToExport) {
      this.groupColumns = columnsToExport.filter((col) => !!col.getColDef().showRowGroup);
    }
    extractHeaderValue(column) {
      const value = this.getHeaderName(this.processHeaderCallback, column);
      return value != null ? value : "";
    }
    extractRowCellValue(column, index, accumulatedRowIndex, type, node) {
      const hideOpenParents = this.gos.get("groupHideOpenParents");
      const value = (!hideOpenParents || node.footer) && this.shouldRenderGroupSummaryCell(node, column, index) ? this.createValueForGroupNode(column, node) : this.valueService.getValue(column, node);
      const processedValue = this.processCell({
        accumulatedRowIndex,
        rowNode: node,
        column,
        value,
        processCellCallback: this.processCellCallback,
        type
      });
      return processedValue;
    }
    shouldRenderGroupSummaryCell(node, column, currentColumnIndex) {
      var _a;
      const isGroupNode = node && node.group;
      if (!isGroupNode) {
        return false;
      }
      const currentColumnGroupIndex = this.groupColumns.indexOf(column);
      if (currentColumnGroupIndex !== -1) {
        if (((_a = node.groupData) == null ? void 0 : _a[column.getId()]) != null) {
          return true;
        }
        if (this.gos.isRowModelType("serverSide") && node.group) {
          return true;
        }
        if (node.footer && node.level === -1) {
          const colDef = column.getColDef();
          const isFullWidth = colDef == null || colDef.showRowGroup === true;
          return isFullWidth || colDef.showRowGroup === this.columnModel.getRowGroupColumns()[0].getId();
        }
      }
      const isGroupUseEntireRow = this.gos.isGroupUseEntireRow(this.columnModel.isPivotMode());
      return currentColumnIndex === 0 && isGroupUseEntireRow;
    }
    getHeaderName(callback, column) {
      if (callback) {
        return callback(this.gos.addGridCommonParams({ column }));
      }
      return this.columnModel.getDisplayNameForColumn(column, "csv", true);
    }
    createValueForGroupNode(column, node) {
      if (this.processRowGroupCallback) {
        return this.processRowGroupCallback(this.gos.addGridCommonParams({ column, node }));
      }
      const isTreeData = this.gos.get("treeData");
      const isSuppressGroupMaintainValueType = this.gos.get("suppressGroupMaintainValueType");
      const getValueFromNode = (node2) => {
        var _a, _b;
        if (isTreeData || isSuppressGroupMaintainValueType) {
          return node2.key;
        }
        const value = (_a = node2.groupData) == null ? void 0 : _a[column.getId()];
        if (!value || !node2.rowGroupColumn || node2.rowGroupColumn.getColDef().useValueFormatterForExport === false) {
          return value;
        }
        return (_b = this.valueService.formatValue(node2.rowGroupColumn, node2, value)) != null ? _b : value;
      };
      const isFooter = node.footer;
      const keys2 = [getValueFromNode(node)];
      if (!this.gos.isGroupMultiAutoColumn()) {
        while (node.parent) {
          node = node.parent;
          keys2.push(getValueFromNode(node));
        }
      }
      const groupValue = keys2.reverse().join(" -> ");
      return isFooter ? `Total ${groupValue}` : groupValue;
    }
    processCell(params) {
      var _a;
      const { accumulatedRowIndex, rowNode, column, value, processCellCallback, type } = params;
      if (processCellCallback) {
        return {
          value: (_a = processCellCallback(this.gos.addGridCommonParams({
            accumulatedRowIndex,
            column,
            node: rowNode,
            value,
            type,
            parseValue: (valueToParse) => this.valueService.parseValue(column, rowNode, valueToParse, this.valueService.getValue(column, rowNode)),
            formatValue: (valueToFormat) => {
              var _a2;
              return (_a2 = this.valueService.formatValue(column, rowNode, valueToFormat)) != null ? _a2 : valueToFormat;
            }
          }))) != null ? _a : ""
        };
      }
      if (column.getColDef().useValueFormatterForExport !== false) {
        return {
          value: value != null ? value : "",
          valueFormatted: this.valueService.formatValue(column, rowNode, value)
        };
      }
      return { value: value != null ? value : "" };
    }
  };
  var Downloader = class {
    static download(fileName, content) {
      const win = document.defaultView || window;
      if (!win) {
        console.warn("AG Grid: There is no `window` associated with the current `document`");
        return;
      }
      const element = document.createElement("a");
      const url = win.URL.createObjectURL(content);
      element.setAttribute("href", url);
      element.setAttribute("download", fileName);
      element.style.display = "none";
      document.body.appendChild(element);
      element.dispatchEvent(new MouseEvent("click", {
        bubbles: false,
        cancelable: true,
        view: win
      }));
      document.body.removeChild(element);
      win.setTimeout(() => {
        win.URL.revokeObjectURL(url);
      }, 0);
    }
  };
  var LINE_SEPARATOR = "\r\n";
  var CsvSerializingSession = class extends BaseGridSerializingSession {
    constructor(config) {
      super(config);
      this.isFirstLine = true;
      this.result = "";
      const { suppressQuotes, columnSeparator } = config;
      this.suppressQuotes = suppressQuotes;
      this.columnSeparator = columnSeparator;
    }
    addCustomContent(content) {
      if (!content) {
        return;
      }
      if (typeof content === "string") {
        if (!/^\s*\n/.test(content)) {
          this.beginNewLine();
        }
        content = content.replace(/\r?\n/g, LINE_SEPARATOR);
        this.result += content;
      } else {
        content.forEach((row) => {
          this.beginNewLine();
          row.forEach((cell, index) => {
            if (index !== 0) {
              this.result += this.columnSeparator;
            }
            this.result += this.putInQuotes(cell.data.value || "");
            if (cell.mergeAcross) {
              this.appendEmptyCells(cell.mergeAcross);
            }
          });
        });
      }
    }
    onNewHeaderGroupingRow() {
      this.beginNewLine();
      return {
        onColumn: this.onNewHeaderGroupingRowColumn.bind(this)
      };
    }
    onNewHeaderGroupingRowColumn(columnGroup, header, index, span) {
      if (index != 0) {
        this.result += this.columnSeparator;
      }
      this.result += this.putInQuotes(header);
      this.appendEmptyCells(span);
    }
    appendEmptyCells(count) {
      for (let i = 1; i <= count; i++) {
        this.result += this.columnSeparator + this.putInQuotes("");
      }
    }
    onNewHeaderRow() {
      this.beginNewLine();
      return {
        onColumn: this.onNewHeaderRowColumn.bind(this)
      };
    }
    onNewHeaderRowColumn(column, index) {
      if (index != 0) {
        this.result += this.columnSeparator;
      }
      this.result += this.putInQuotes(this.extractHeaderValue(column));
    }
    onNewBodyRow() {
      this.beginNewLine();
      return {
        onColumn: this.onNewBodyRowColumn.bind(this)
      };
    }
    onNewBodyRowColumn(column, index, node) {
      var _a;
      if (index != 0) {
        this.result += this.columnSeparator;
      }
      const rowCellValue = this.extractRowCellValue(column, index, index, "csv", node);
      this.result += this.putInQuotes((_a = rowCellValue.valueFormatted) != null ? _a : rowCellValue.value);
    }
    putInQuotes(value) {
      if (this.suppressQuotes) {
        return value;
      }
      if (value === null || value === void 0) {
        return '""';
      }
      let stringValue;
      if (typeof value === "string") {
        stringValue = value;
      } else if (typeof value.toString === "function") {
        stringValue = value.toString();
      } else {
        console.warn("AG Grid: unknown value type during csv conversion");
        stringValue = "";
      }
      const valueEscaped = stringValue.replace(/"/g, '""');
      return '"' + valueEscaped + '"';
    }
    parse() {
      return this.result;
    }
    beginNewLine() {
      if (!this.isFirstLine) {
        this.result += LINE_SEPARATOR;
      }
      this.isFirstLine = false;
    }
  };
  var CsvCreator = class extends BaseCreator {
    postConstruct() {
      this.setBeans({
        gridSerializer: this.gridSerializer,
        gos: this.gos
      });
    }
    getMergedParams(params) {
      const baseParams = this.gos.get("defaultCsvExportParams");
      return Object.assign({}, baseParams, params);
    }
    export(userParams) {
      if (this.isExportSuppressed()) {
        console.warn(`AG Grid: Export cancelled. Export is not allowed as per your configuration.`);
        return;
      }
      const mergedParams = this.getMergedParams(userParams);
      const data = this.getData(mergedParams);
      const packagedFile = new Blob(["\uFEFF", data], { type: "text/plain" });
      const fileName = typeof mergedParams.fileName === "function" ? mergedParams.fileName(this.gos.getGridCommonParams()) : mergedParams.fileName;
      Downloader.download(this.getFileName(fileName), packagedFile);
    }
    exportDataAsCsv(params) {
      this.export(params);
    }
    getDataAsCsv(params, skipDefaultParams = false) {
      const mergedParams = skipDefaultParams ? Object.assign({}, params) : this.getMergedParams(params);
      return this.getData(mergedParams);
    }
    getDefaultFileExtension() {
      return "csv";
    }
    createSerializingSession(params) {
      const { columnModel, valueService, gos } = this;
      const {
        processCellCallback,
        processHeaderCallback,
        processGroupHeaderCallback,
        processRowGroupCallback,
        suppressQuotes,
        columnSeparator
      } = params;
      return new CsvSerializingSession({
        columnModel,
        valueService,
        gos,
        processCellCallback: processCellCallback || void 0,
        processHeaderCallback: processHeaderCallback || void 0,
        processGroupHeaderCallback: processGroupHeaderCallback || void 0,
        processRowGroupCallback: processRowGroupCallback || void 0,
        suppressQuotes: suppressQuotes || false,
        columnSeparator: columnSeparator || ","
      });
    }
    isExportSuppressed() {
      return this.gos.get("suppressCsvExport");
    }
  };
  __decorateClass3([
    Autowired("columnModel")
  ], CsvCreator.prototype, "columnModel", 2);
  __decorateClass3([
    Autowired("valueService")
  ], CsvCreator.prototype, "valueService", 2);
  __decorateClass3([
    Autowired("gridSerializer")
  ], CsvCreator.prototype, "gridSerializer", 2);
  __decorateClass3([
    Autowired("gridOptionsService")
  ], CsvCreator.prototype, "gos", 2);
  __decorateClass3([
    PostConstruct
  ], CsvCreator.prototype, "postConstruct", 1);
  CsvCreator = __decorateClass3([
    Bean("csvCreator")
  ], CsvCreator);
  var RowType = /* @__PURE__ */ ((RowType2) => {
    RowType2[RowType2["HEADER_GROUPING"] = 0] = "HEADER_GROUPING";
    RowType2[RowType2["HEADER"] = 1] = "HEADER";
    RowType2[RowType2["BODY"] = 2] = "BODY";
    return RowType2;
  })(RowType || {});
  var GridSerializer = class extends BeanStub {
    serialize(gridSerializingSession, params = {}) {
      const { allColumns, columnKeys, skipRowGroups } = params;
      const columnsToExport = this.getColumnsToExport(allColumns, skipRowGroups, columnKeys);
      const serializeChain = _.compose(
        // first pass, put in the header names of the cols
        this.prepareSession(columnsToExport),
        this.prependContent(params),
        this.exportColumnGroups(params, columnsToExport),
        this.exportHeaders(params, columnsToExport),
        this.processPinnedTopRows(params, columnsToExport),
        this.processRows(params, columnsToExport),
        this.processPinnedBottomRows(params, columnsToExport),
        this.appendContent(params)
      );
      return serializeChain(gridSerializingSession).parse();
    }
    processRow(gridSerializingSession, params, columnsToExport, node) {
      const rowSkipper = params.shouldRowBeSkipped || (() => false);
      const skipSingleChildrenGroup = this.gos.get("groupRemoveSingleChildren");
      const skipLowestSingleChildrenGroup = this.gos.get("groupRemoveLowestSingleChildren");
      const isClipboardExport = params.rowPositions != null;
      const isExplicitExportSelection = isClipboardExport || !!params.onlySelected;
      const hideOpenParents = this.gos.get("groupHideOpenParents") && !isExplicitExportSelection;
      const isLeafNode = this.columnModel.isPivotMode() ? node.leafGroup : !node.group;
      const isFooter = !!node.footer;
      const skipRowGroups = params.skipRowGroups;
      const shouldSkipLowestGroup = skipLowestSingleChildrenGroup && node.leafGroup;
      const shouldSkipCurrentGroup = node.allChildrenCount === 1 && (skipSingleChildrenGroup || shouldSkipLowestGroup);
      if (!isLeafNode && !isFooter && (params.skipRowGroups || shouldSkipCurrentGroup || hideOpenParents) || params.onlySelected && !node.isSelected() || params.skipPinnedTop && node.rowPinned === "top" || params.skipPinnedBottom && node.rowPinned === "bottom") {
        return;
      }
      const nodeIsRootNode = node.level === -1;
      if (nodeIsRootNode && !isLeafNode && !isFooter) {
        return;
      }
      const shouldRowBeSkipped = rowSkipper(this.gos.addGridCommonParams({ node }));
      if (shouldRowBeSkipped) {
        return;
      }
      const rowAccumulator = gridSerializingSession.onNewBodyRow(node);
      columnsToExport.forEach((column, index) => {
        rowAccumulator.onColumn(column, index, node);
      });
      if (params.getCustomContentBelowRow) {
        const content = params.getCustomContentBelowRow(this.gos.addGridCommonParams({ node }));
        if (content) {
          gridSerializingSession.addCustomContent(content);
        }
      }
    }
    appendContent(params) {
      return (gridSerializingSession) => {
        const appendContent = params.appendContent;
        if (appendContent) {
          gridSerializingSession.addCustomContent(appendContent);
        }
        return gridSerializingSession;
      };
    }
    prependContent(params) {
      return (gridSerializingSession) => {
        const prependContent = params.prependContent;
        if (prependContent) {
          gridSerializingSession.addCustomContent(prependContent);
        }
        return gridSerializingSession;
      };
    }
    prepareSession(columnsToExport) {
      return (gridSerializingSession) => {
        gridSerializingSession.prepare(columnsToExport);
        return gridSerializingSession;
      };
    }
    exportColumnGroups(params, columnsToExport) {
      return (gridSerializingSession) => {
        if (!params.skipColumnGroupHeaders) {
          const groupInstanceIdCreator = new GroupInstanceIdCreator();
          const displayedGroups = this.displayedGroupCreator.createDisplayedGroups(
            columnsToExport,
            groupInstanceIdCreator,
            null
          );
          this.recursivelyAddHeaderGroups(displayedGroups, gridSerializingSession, params.processGroupHeaderCallback);
        }
        return gridSerializingSession;
      };
    }
    exportHeaders(params, columnsToExport) {
      return (gridSerializingSession) => {
        if (!params.skipColumnHeaders) {
          const gridRowIterator = gridSerializingSession.onNewHeaderRow();
          columnsToExport.forEach((column, index) => {
            gridRowIterator.onColumn(column, index, void 0);
          });
        }
        return gridSerializingSession;
      };
    }
    processPinnedTopRows(params, columnsToExport) {
      return (gridSerializingSession) => {
        const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
        if (params.rowPositions) {
          params.rowPositions.filter((position) => position.rowPinned === "top").sort((a, b) => a.rowIndex - b.rowIndex).map((position) => this.pinnedRowModel.getPinnedTopRow(position.rowIndex)).forEach(processRow);
        } else {
          this.pinnedRowModel.forEachPinnedTopRow(processRow);
        }
        return gridSerializingSession;
      };
    }
    processRows(params, columnsToExport) {
      return (gridSerializingSession) => {
        const rowModel = this.rowModel;
        const rowModelType = rowModel.getType();
        const usingCsrm = rowModelType === "clientSide";
        const usingSsrm = rowModelType === "serverSide";
        const onlySelectedNonStandardModel = !usingCsrm && params.onlySelected;
        const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
        const {
          exportedRows = "filteredAndSorted"
        } = params;
        if (params.rowPositions) {
          params.rowPositions.filter((position) => position.rowPinned == null).sort((a, b) => a.rowIndex - b.rowIndex).map((position) => rowModel.getRow(position.rowIndex)).forEach(processRow);
        } else if (this.columnModel.isPivotMode()) {
          if (usingCsrm) {
            rowModel.forEachPivotNode(processRow, true);
          } else if (usingSsrm) {
            rowModel.forEachNodeAfterFilterAndSort(processRow, true);
          } else {
            rowModel.forEachNode(processRow);
          }
        } else {
          if (params.onlySelectedAllPages || onlySelectedNonStandardModel) {
            const selectedNodes = this.selectionService.getSelectedNodes();
            this.replicateSortedOrder(selectedNodes);
            selectedNodes.forEach(processRow);
          } else {
            if (exportedRows === "all") {
              rowModel.forEachNode(processRow);
            } else if (usingCsrm) {
              rowModel.forEachNodeAfterFilterAndSort(processRow, true);
            } else if (usingSsrm) {
              rowModel.forEachNodeAfterFilterAndSort(processRow, true);
            } else {
              rowModel.forEachNode(processRow);
            }
          }
        }
        return gridSerializingSession;
      };
    }
    replicateSortedOrder(rows) {
      const sortOptions = this.sortController.getSortOptions();
      const compareNodes = (rowA, rowB) => {
        var _a, _b, _c, _d;
        if (rowA.rowIndex != null && rowB.rowIndex != null) {
          return rowA.rowIndex - rowB.rowIndex;
        }
        if (rowA.level === rowB.level) {
          if (((_a = rowA.parent) == null ? void 0 : _a.id) === ((_b = rowB.parent) == null ? void 0 : _b.id)) {
            return this.rowNodeSorter.compareRowNodes(sortOptions, {
              rowNode: rowA,
              currentPos: (_c = rowA.rowIndex) != null ? _c : -1
            }, {
              rowNode: rowB,
              currentPos: (_d = rowB.rowIndex) != null ? _d : -1
            });
          }
          return compareNodes(rowA.parent, rowB.parent);
        }
        if (rowA.level > rowB.level) {
          return compareNodes(rowA.parent, rowB);
        }
        return compareNodes(rowA, rowB.parent);
      };
      rows.sort(compareNodes);
    }
    processPinnedBottomRows(params, columnsToExport) {
      return (gridSerializingSession) => {
        const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
        if (params.rowPositions) {
          params.rowPositions.filter((position) => position.rowPinned === "bottom").sort((a, b) => a.rowIndex - b.rowIndex).map((position) => this.pinnedRowModel.getPinnedBottomRow(position.rowIndex)).forEach(processRow);
        } else {
          this.pinnedRowModel.forEachPinnedBottomRow(processRow);
        }
        return gridSerializingSession;
      };
    }
    getColumnsToExport(allColumns = false, skipRowGroups = false, columnKeys) {
      const isPivotMode = this.columnModel.isPivotMode();
      if (columnKeys && columnKeys.length) {
        return this.columnModel.getGridColumns(columnKeys);
      }
      const isTreeData = this.gos.get("treeData");
      let columnsToExport = [];
      if (allColumns && !isPivotMode) {
        columnsToExport = this.columnModel.getAllGridColumns();
      } else {
        columnsToExport = this.columnModel.getAllDisplayedColumns();
      }
      if (skipRowGroups && !isTreeData) {
        columnsToExport = columnsToExport.filter((column) => column.getColId() !== GROUP_AUTO_COLUMN_ID);
      }
      return columnsToExport;
    }
    recursivelyAddHeaderGroups(displayedGroups, gridSerializingSession, processGroupHeaderCallback) {
      const directChildrenHeaderGroups = [];
      displayedGroups.forEach((columnGroupChild) => {
        const columnGroup = columnGroupChild;
        if (!columnGroup.getChildren) {
          return;
        }
        columnGroup.getChildren().forEach((it) => directChildrenHeaderGroups.push(it));
      });
      if (displayedGroups.length > 0 && displayedGroups[0] instanceof ColumnGroup) {
        this.doAddHeaderHeader(gridSerializingSession, displayedGroups, processGroupHeaderCallback);
      }
      if (directChildrenHeaderGroups && directChildrenHeaderGroups.length > 0) {
        this.recursivelyAddHeaderGroups(directChildrenHeaderGroups, gridSerializingSession, processGroupHeaderCallback);
      }
    }
    doAddHeaderHeader(gridSerializingSession, displayedGroups, processGroupHeaderCallback) {
      const gridRowIterator = gridSerializingSession.onNewHeaderGroupingRow();
      let columnIndex = 0;
      displayedGroups.forEach((columnGroupChild) => {
        const columnGroup = columnGroupChild;
        let name;
        if (processGroupHeaderCallback) {
          name = processGroupHeaderCallback(this.gos.addGridCommonParams({
            columnGroup
          }));
        } else {
          name = this.columnModel.getDisplayNameForColumnGroup(columnGroup, "header");
        }
        const collapsibleGroupRanges = columnGroup.getLeafColumns().reduce((collapsibleGroups, currentColumn, currentIdx, arr) => {
          let lastGroup = _.last(collapsibleGroups);
          const groupShow = currentColumn.getColumnGroupShow() === "open";
          if (!groupShow) {
            if (lastGroup && lastGroup[1] == null) {
              lastGroup[1] = currentIdx - 1;
            }
          } else if (!lastGroup || lastGroup[1] != null) {
            lastGroup = [currentIdx];
            collapsibleGroups.push(lastGroup);
          }
          if (currentIdx === arr.length - 1 && lastGroup && lastGroup[1] == null) {
            lastGroup[1] = currentIdx;
          }
          return collapsibleGroups;
        }, []);
        gridRowIterator.onColumn(columnGroup, name || "", columnIndex++, columnGroup.getLeafColumns().length - 1, collapsibleGroupRanges);
      });
    }
  };
  __decorateClass3([
    Autowired("displayedGroupCreator")
  ], GridSerializer.prototype, "displayedGroupCreator", 2);
  __decorateClass3([
    Autowired("columnModel")
  ], GridSerializer.prototype, "columnModel", 2);
  __decorateClass3([
    Autowired("rowModel")
  ], GridSerializer.prototype, "rowModel", 2);
  __decorateClass3([
    Autowired("pinnedRowModel")
  ], GridSerializer.prototype, "pinnedRowModel", 2);
  __decorateClass3([
    Autowired("selectionService")
  ], GridSerializer.prototype, "selectionService", 2);
  __decorateClass3([
    Autowired("rowNodeSorter")
  ], GridSerializer.prototype, "rowNodeSorter", 2);
  __decorateClass3([
    Autowired("sortController")
  ], GridSerializer.prototype, "sortController", 2);
  GridSerializer = __decorateClass3([
    Bean("gridSerializer")
  ], GridSerializer);
  var VERSION3 = "31.3.2";
  var CsvExportModule = {
    version: VERSION3,
    moduleName: "@ag-grid-community/csv-export",
    beans: [CsvCreator, GridSerializer]
  };
  var LINE_SEPARATOR2 = "\r\n";
  var XmlFactory = class {
    static createHeader(headerElement = {}) {
      const headerStart = "<?";
      const headerEnd = "?>";
      const keys2 = ["version"];
      if (!headerElement.version) {
        headerElement.version = "1.0";
      }
      if (headerElement.encoding) {
        keys2.push("encoding");
      }
      if (headerElement.standalone) {
        keys2.push("standalone");
      }
      const att = keys2.map((key) => `${key}="${headerElement[key]}"`).join(" ");
      return `${headerStart}xml ${att} ${headerEnd}`;
    }
    static createXml(xmlElement, booleanTransformer) {
      let props = "";
      if (xmlElement.properties) {
        if (xmlElement.properties.prefixedAttributes) {
          xmlElement.properties.prefixedAttributes.forEach((prefixedSet) => {
            Object.keys(prefixedSet.map).forEach((key) => {
              props += this.returnAttributeIfPopulated(prefixedSet.prefix + key, prefixedSet.map[key], booleanTransformer);
            });
          });
        }
        if (xmlElement.properties.rawMap) {
          Object.keys(xmlElement.properties.rawMap).forEach((key) => {
            props += this.returnAttributeIfPopulated(key, xmlElement.properties.rawMap[key], booleanTransformer);
          });
        }
      }
      let result = "<" + xmlElement.name + props;
      if (!xmlElement.children && xmlElement.textNode == null) {
        return result + "/>" + LINE_SEPARATOR2;
      }
      if (xmlElement.textNode != null) {
        return result + ">" + xmlElement.textNode + "</" + xmlElement.name + ">" + LINE_SEPARATOR2;
      }
      result += ">" + LINE_SEPARATOR2;
      if (xmlElement.children) {
        xmlElement.children.forEach((it) => {
          result += this.createXml(it, booleanTransformer);
        });
      }
      return result + "</" + xmlElement.name + ">" + LINE_SEPARATOR2;
    }
    static returnAttributeIfPopulated(key, value, booleanTransformer) {
      if (!value && value !== "" && value !== 0) {
        return "";
      }
      let xmlValue = value;
      if (typeof value === "boolean") {
        if (booleanTransformer) {
          xmlValue = booleanTransformer(value);
        }
      }
      return ` ${key}="${xmlValue}"`;
    }
  };
  var convertTime = (date) => {
    let time = date.getHours();
    time <<= 6;
    time = time | date.getMinutes();
    time <<= 5;
    time = time | date.getSeconds() / 2;
    return time;
  };
  var convertDate = (date) => {
    let dt = date.getFullYear() - 1980;
    dt <<= 4;
    dt = dt | date.getMonth() + 1;
    dt <<= 5;
    dt = dt | date.getDate();
    return dt;
  };
  function convertDecToHex(number, bytes) {
    let hex = "";
    for (let i = 0; i < bytes; i++) {
      hex += String.fromCharCode(number & 255);
      number >>>= 8;
    }
    return hex;
  }
  var getCrcFromCrc32TableAndByteArray = (content) => {
    if (!content.length) {
      return 0;
    }
    let crc = 0 ^ -1;
    let j = 0;
    let k = 0;
    let l = 0;
    for (let i = 0; i < content.length; i++) {
      j = content[i];
      k = (crc ^ j) & 255;
      l = crcTable[k];
      crc = crc >>> 8 ^ l;
    }
    return crc ^ -1;
  };
  var getCrcFromCrc32Table = (content) => {
    if (!content.length) {
      return 0;
    }
    if (typeof content === "string") {
      return getCrcFromCrc32TableAndByteArray(
        new TextEncoder().encode(content)
      );
    }
    return getCrcFromCrc32TableAndByteArray(content);
  };
  var crcTable = new Uint32Array([
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918e3,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ]);
  var compressBlob = (data) => __async(void 0, null, function* () {
    let chunksSize = 0;
    const chunks = [];
    const writeCompressedData = new WritableStream({
      write: (chunk) => {
        chunks.push(chunk);
        chunksSize += chunk.length;
      }
    });
    const readable = new ReadableStream({
      start: (controller) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          var _a;
          if ((_a = e.target) == null ? void 0 : _a.result) {
            controller.enqueue(e.target.result);
          }
          controller.close();
        };
        reader.readAsArrayBuffer(data);
      }
    });
    const compressStream = new window.CompressionStream("deflate-raw");
    yield readable.pipeThrough(compressStream).pipeTo(writeCompressedData);
    return {
      size: chunksSize,
      content: new Blob(chunks)
    };
  });
  var deflateLocalFile = (rawContent) => __async(void 0, null, function* () {
    const contentAsBlob = new Blob([rawContent]);
    const {
      size: compressedSize,
      content: compressedContent
    } = yield compressBlob(contentAsBlob);
    const compressedContentAsUint8Array = new Uint8Array(yield compressedContent.arrayBuffer());
    return {
      size: compressedSize,
      content: compressedContentAsUint8Array
    };
  });
  var { utf8_encode: utf8_encode2 } = _;
  var getDeflatedHeaderAndContent = (currentFile, offset) => __async(void 0, null, function* () {
    const { content } = currentFile;
    const { size: size2, content: rawContent } = !content ? { size: 0, content: Uint8Array.from([]) } : getDecodedContent(content);
    let deflatedContent = void 0;
    let deflatedSize = void 0;
    let deflationPerformed = false;
    const shouldDeflate = currentFile.type === "file" && rawContent && size2 > 0;
    if (shouldDeflate) {
      const result = yield deflateLocalFile(rawContent);
      deflatedContent = result.content;
      deflatedSize = result.size;
      deflationPerformed = true;
    }
    const headers = getHeaders(
      currentFile,
      deflationPerformed,
      offset,
      size2,
      rawContent,
      deflatedSize
    );
    return __spreadProps2(__spreadValues2({}, headers), {
      content: deflatedContent || rawContent,
      isCompressed: deflationPerformed
    });
  });
  var getHeaderAndContent = (currentFile, offset) => {
    const { content } = currentFile;
    const { content: rawContent } = !content ? { content: Uint8Array.from([]) } : getDecodedContent(content);
    const headers = getHeaders(
      currentFile,
      false,
      offset,
      rawContent.length,
      rawContent,
      void 0
    );
    return __spreadProps2(__spreadValues2({}, headers), {
      content: rawContent,
      isCompressed: false
    });
  };
  var getHeaders = (currentFile, isCompressed, offset, rawSize, rawContent, deflatedSize) => {
    const {
      content,
      path,
      created: creationDate
    } = currentFile;
    const time = convertTime(creationDate);
    const dt = convertDate(creationDate);
    const crcFlag = getCrcFromCrc32Table(rawContent);
    const zipSize = deflatedSize !== void 0 ? deflatedSize : rawSize;
    const utfPath = utf8_encode2(path);
    const isUTF8 = utfPath !== path;
    let extraFields = "";
    if (isUTF8) {
      const uExtraFieldPath = convertDecToHex(1, 1) + convertDecToHex(getCrcFromCrc32Table(utfPath), 4) + utfPath;
      extraFields = "up" + convertDecToHex(uExtraFieldPath.length, 2) + uExtraFieldPath;
    }
    const commonHeader = "\0" + // version needed to extract
    (isUTF8 ? "\0\b" : "\0\0") + // Language encoding flag (EFS) (12th bit turned on)
    convertDecToHex(isCompressed ? 8 : 0, 2) + // As per ECMA-376 Part 2 specs
    convertDecToHex(time, 2) + // last modified time
    convertDecToHex(dt, 2) + // last modified date
    convertDecToHex(zipSize ? crcFlag : 0, 4) + convertDecToHex(deflatedSize != null ? deflatedSize : rawSize, 4) + // compressed size
    convertDecToHex(rawSize, 4) + // uncompressed size
    convertDecToHex(utfPath.length, 2) + // file name length
    convertDecToHex(extraFields.length, 2);
    const localFileHeader = "PK" + commonHeader + utfPath + extraFields;
    const centralDirectoryHeader = "PK\0" + commonHeader + // file header
    "\0\0\0\0\0\0" + (content ? "\0\0\0\0" : "\0\0\0") + // external file attributes
    convertDecToHex(offset, 4) + // relative offset of local header
    utfPath + // file name
    extraFields;
    return {
      localFileHeader: Uint8Array.from(localFileHeader, (c) => c.charCodeAt(0)),
      centralDirectoryHeader: Uint8Array.from(centralDirectoryHeader, (c) => c.charCodeAt(0))
    };
  };
  var buildCentralDirectoryEnd = (tLen, cLen, lLen) => {
    const str = "PK\0\0\0\0" + convertDecToHex(tLen, 2) + // total number of entries in the central folder
    convertDecToHex(tLen, 2) + // total number of entries in the central folder
    convertDecToHex(cLen, 4) + // size of the central folder
    convertDecToHex(lLen, 4) + // central folder start offset
    "\0\0";
    return Uint8Array.from(str, (c) => c.charCodeAt(0));
  };
  var convertStringToByteArray = (str) => {
    const bytes = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) {
      bytes[i] = str.charCodeAt(i);
    }
    return bytes;
  };
  var getDecodedContent = (content) => {
    let contentToUse;
    if (typeof content === "string") {
      const base64String = atob(content.split(";base64,")[1]);
      contentToUse = convertStringToByteArray(base64String);
    } else {
      contentToUse = content;
    }
    return {
      size: contentToUse.length,
      content: contentToUse
    };
  };
  var ZipContainer = class {
    static addFolders(paths) {
      paths.forEach(this.addFolder.bind(this));
    }
    static addFolder(path) {
      this.folders.push({
        path,
        created: /* @__PURE__ */ new Date(),
        isBase64: false,
        type: "folder"
      });
    }
    static addFile(path, content, isBase64 = false) {
      this.files.push({
        path,
        created: /* @__PURE__ */ new Date(),
        content: isBase64 ? content : new TextEncoder().encode(content),
        isBase64,
        type: "file"
      });
    }
    static getZipFile(mimeType = "application/zip") {
      return __async(this, null, function* () {
        const textOutput = yield this.buildCompressedFileStream();
        this.clearStream();
        return new Blob([textOutput], { type: mimeType });
      });
    }
    static getUncompressedZipFile(mimeType = "application/zip") {
      const textOutput = this.buildFileStream();
      this.clearStream();
      return new Blob([textOutput], { type: mimeType });
    }
    static clearStream() {
      this.folders = [];
      this.files = [];
    }
    static packageFiles(files) {
      let fileData = new Uint8Array(0);
      let folderData = new Uint8Array(0);
      let filesContentAndHeaderLength = 0;
      let folderHeadersLength = 0;
      for (const currentFile of files) {
        const {
          localFileHeader,
          centralDirectoryHeader,
          content
        } = currentFile;
        const dataWithHeader = new Uint8Array(fileData.length + localFileHeader.length);
        dataWithHeader.set(fileData);
        dataWithHeader.set(localFileHeader, fileData.length);
        fileData = dataWithHeader;
        const dataWithContent = new Uint8Array(fileData.length + content.length);
        dataWithContent.set(fileData);
        dataWithContent.set(content, fileData.length);
        fileData = dataWithContent;
        const folderDataWithFolderHeader = new Uint8Array(folderData.length + centralDirectoryHeader.length);
        folderDataWithFolderHeader.set(folderData);
        folderDataWithFolderHeader.set(centralDirectoryHeader, folderData.length);
        folderData = folderDataWithFolderHeader;
        filesContentAndHeaderLength += localFileHeader.length + content.length;
        folderHeadersLength += centralDirectoryHeader.length;
      }
      const folderEnd = buildCentralDirectoryEnd(
        files.length,
        folderHeadersLength,
        filesContentAndHeaderLength
      );
      const result = new Uint8Array(fileData.length + folderData.length + folderEnd.length);
      result.set(fileData);
      result.set(folderData, fileData.length);
      result.set(folderEnd, fileData.length + folderData.length);
      return result;
    }
    static buildCompressedFileStream() {
      return __async(this, null, function* () {
        const totalFiles = [...this.folders, ...this.files];
        const readyFiles = [];
        let lL = 0;
        for (const currentFile of totalFiles) {
          const output = yield getDeflatedHeaderAndContent(currentFile, lL);
          const { localFileHeader, content } = output;
          readyFiles.push(output);
          lL += localFileHeader.length + content.length;
        }
        return this.packageFiles(readyFiles);
      });
    }
    static buildFileStream() {
      const totalFiles = [...this.folders, ...this.files];
      const readyFiles = [];
      let lL = 0;
      for (const currentFile of totalFiles) {
        const readyFile = getHeaderAndContent(currentFile, lL);
        const { localFileHeader, content } = readyFile;
        readyFiles.push(readyFile);
        lL += localFileHeader.length + content.length;
      }
      return this.packageFiles(readyFiles);
    }
  };
  ZipContainer.folders = [];
  ZipContainer.files = [];
  ModuleRegistry.__registerModules([ClientSideRowModelModule, InfiniteRowModelModule, CsvExportModule], false, void 0);

  // node_modules/vue/dist/vue.esm-bundler.js
  var vue_esm_bundler_exports = {};
  __export(vue_esm_bundler_exports, {
    BaseTransition: () => BaseTransition,
    BaseTransitionPropsValidators: () => BaseTransitionPropsValidators,
    Comment: () => Comment,
    DeprecationTypes: () => DeprecationTypes,
    EffectScope: () => EffectScope,
    ErrorCodes: () => ErrorCodes,
    ErrorTypeStrings: () => ErrorTypeStrings,
    Fragment: () => Fragment,
    KeepAlive: () => KeepAlive,
    ReactiveEffect: () => ReactiveEffect,
    Static: () => Static,
    Suspense: () => Suspense,
    Teleport: () => Teleport,
    Text: () => Text,
    TrackOpTypes: () => TrackOpTypes,
    Transition: () => Transition,
    TransitionGroup: () => TransitionGroup,
    TriggerOpTypes: () => TriggerOpTypes,
    VueElement: () => VueElement,
    assertNumber: () => assertNumber,
    callWithAsyncErrorHandling: () => callWithAsyncErrorHandling,
    callWithErrorHandling: () => callWithErrorHandling,
    camelize: () => camelize2,
    capitalize: () => capitalize2,
    cloneVNode: () => cloneVNode,
    compatUtils: () => compatUtils,
    compile: () => compileToFunction,
    computed: () => computed2,
    createApp: () => createApp,
    createBlock: () => createBlock,
    createCommentVNode: () => createCommentVNode,
    createElementBlock: () => createElementBlock,
    createElementVNode: () => createBaseVNode,
    createHydrationRenderer: () => createHydrationRenderer,
    createPropsRestProxy: () => createPropsRestProxy,
    createRenderer: () => createRenderer,
    createSSRApp: () => createSSRApp,
    createSlots: () => createSlots,
    createStaticVNode: () => createStaticVNode,
    createTextVNode: () => createTextVNode,
    createVNode: () => createVNode,
    customRef: () => customRef,
    defineAsyncComponent: () => defineAsyncComponent,
    defineComponent: () => defineComponent,
    defineCustomElement: () => defineCustomElement,
    defineEmits: () => defineEmits,
    defineExpose: () => defineExpose,
    defineModel: () => defineModel,
    defineOptions: () => defineOptions,
    defineProps: () => defineProps,
    defineSSRCustomElement: () => defineSSRCustomElement,
    defineSlots: () => defineSlots,
    devtools: () => devtools,
    effect: () => effect,
    effectScope: () => effectScope,
    getCurrentInstance: () => getCurrentInstance,
    getCurrentScope: () => getCurrentScope,
    getTransitionRawChildren: () => getTransitionRawChildren,
    guardReactiveProps: () => guardReactiveProps,
    h: () => h,
    handleError: () => handleError,
    hasInjectionContext: () => hasInjectionContext,
    hydrate: () => hydrate,
    initCustomFormatter: () => initCustomFormatter,
    initDirectivesForSSR: () => initDirectivesForSSR,
    inject: () => inject,
    isMemoSame: () => isMemoSame,
    isProxy: () => isProxy,
    isReactive: () => isReactive,
    isReadonly: () => isReadonly,
    isRef: () => isRef2,
    isRuntimeOnly: () => isRuntimeOnly,
    isShallow: () => isShallow,
    isVNode: () => isVNode,
    markRaw: () => markRaw,
    mergeDefaults: () => mergeDefaults,
    mergeModels: () => mergeModels,
    mergeProps: () => mergeProps,
    nextTick: () => nextTick,
    normalizeClass: () => normalizeClass,
    normalizeProps: () => normalizeProps,
    normalizeStyle: () => normalizeStyle,
    onActivated: () => onActivated,
    onBeforeMount: () => onBeforeMount,
    onBeforeUnmount: () => onBeforeUnmount,
    onBeforeUpdate: () => onBeforeUpdate,
    onDeactivated: () => onDeactivated,
    onErrorCaptured: () => onErrorCaptured,
    onMounted: () => onMounted,
    onRenderTracked: () => onRenderTracked,
    onRenderTriggered: () => onRenderTriggered,
    onScopeDispose: () => onScopeDispose,
    onServerPrefetch: () => onServerPrefetch,
    onUnmounted: () => onUnmounted,
    onUpdated: () => onUpdated,
    openBlock: () => openBlock,
    popScopeId: () => popScopeId,
    provide: () => provide,
    proxyRefs: () => proxyRefs,
    pushScopeId: () => pushScopeId,
    queuePostFlushCb: () => queuePostFlushCb,
    reactive: () => reactive,
    readonly: () => readonly,
    ref: () => ref,
    registerRuntimeCompiler: () => registerRuntimeCompiler,
    render: () => render,
    renderList: () => renderList,
    renderSlot: () => renderSlot,
    resolveComponent: () => resolveComponent,
    resolveDirective: () => resolveDirective,
    resolveDynamicComponent: () => resolveDynamicComponent,
    resolveFilter: () => resolveFilter,
    resolveTransitionHooks: () => resolveTransitionHooks,
    setBlockTracking: () => setBlockTracking,
    setDevtoolsHook: () => setDevtoolsHook,
    setTransitionHooks: () => setTransitionHooks,
    shallowReactive: () => shallowReactive,
    shallowReadonly: () => shallowReadonly,
    shallowRef: () => shallowRef,
    ssrContextKey: () => ssrContextKey,
    ssrUtils: () => ssrUtils,
    stop: () => stop,
    toDisplayString: () => toDisplayString,
    toHandlerKey: () => toHandlerKey,
    toHandlers: () => toHandlers,
    toRaw: () => toRaw,
    toRef: () => toRef,
    toRefs: () => toRefs,
    toValue: () => toValue,
    transformVNodeArgs: () => transformVNodeArgs,
    triggerRef: () => triggerRef,
    unref: () => unref,
    useAttrs: () => useAttrs,
    useCssModule: () => useCssModule,
    useCssVars: () => useCssVars,
    useModel: () => useModel,
    useSSRContext: () => useSSRContext,
    useSlots: () => useSlots,
    useTransitionState: () => useTransitionState,
    vModelCheckbox: () => vModelCheckbox,
    vModelDynamic: () => vModelDynamic,
    vModelRadio: () => vModelRadio,
    vModelSelect: () => vModelSelect,
    vModelText: () => vModelText,
    vShow: () => vShow,
    version: () => version,
    warn: () => warn2,
    watch: () => watch,
    watchEffect: () => watchEffect,
    watchPostEffect: () => watchPostEffect,
    watchSyncEffect: () => watchSyncEffect,
    withAsyncContext: () => withAsyncContext,
    withCtx: () => withCtx,
    withDefaults: () => withDefaults,
    withDirectives: () => withDirectives,
    withKeys: () => withKeys,
    withMemo: () => withMemo,
    withModifiers: () => withModifiers,
    withScopeId: () => withScopeId
  });

  // node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js
  var runtime_dom_esm_bundler_exports = {};
  __export(runtime_dom_esm_bundler_exports, {
    BaseTransition: () => BaseTransition,
    BaseTransitionPropsValidators: () => BaseTransitionPropsValidators,
    Comment: () => Comment,
    DeprecationTypes: () => DeprecationTypes,
    EffectScope: () => EffectScope,
    ErrorCodes: () => ErrorCodes,
    ErrorTypeStrings: () => ErrorTypeStrings,
    Fragment: () => Fragment,
    KeepAlive: () => KeepAlive,
    ReactiveEffect: () => ReactiveEffect,
    Static: () => Static,
    Suspense: () => Suspense,
    Teleport: () => Teleport,
    Text: () => Text,
    TrackOpTypes: () => TrackOpTypes,
    Transition: () => Transition,
    TransitionGroup: () => TransitionGroup,
    TriggerOpTypes: () => TriggerOpTypes,
    VueElement: () => VueElement,
    assertNumber: () => assertNumber,
    callWithAsyncErrorHandling: () => callWithAsyncErrorHandling,
    callWithErrorHandling: () => callWithErrorHandling,
    camelize: () => camelize2,
    capitalize: () => capitalize2,
    cloneVNode: () => cloneVNode,
    compatUtils: () => compatUtils,
    computed: () => computed2,
    createApp: () => createApp,
    createBlock: () => createBlock,
    createCommentVNode: () => createCommentVNode,
    createElementBlock: () => createElementBlock,
    createElementVNode: () => createBaseVNode,
    createHydrationRenderer: () => createHydrationRenderer,
    createPropsRestProxy: () => createPropsRestProxy,
    createRenderer: () => createRenderer,
    createSSRApp: () => createSSRApp,
    createSlots: () => createSlots,
    createStaticVNode: () => createStaticVNode,
    createTextVNode: () => createTextVNode,
    createVNode: () => createVNode,
    customRef: () => customRef,
    defineAsyncComponent: () => defineAsyncComponent,
    defineComponent: () => defineComponent,
    defineCustomElement: () => defineCustomElement,
    defineEmits: () => defineEmits,
    defineExpose: () => defineExpose,
    defineModel: () => defineModel,
    defineOptions: () => defineOptions,
    defineProps: () => defineProps,
    defineSSRCustomElement: () => defineSSRCustomElement,
    defineSlots: () => defineSlots,
    devtools: () => devtools,
    effect: () => effect,
    effectScope: () => effectScope,
    getCurrentInstance: () => getCurrentInstance,
    getCurrentScope: () => getCurrentScope,
    getTransitionRawChildren: () => getTransitionRawChildren,
    guardReactiveProps: () => guardReactiveProps,
    h: () => h,
    handleError: () => handleError,
    hasInjectionContext: () => hasInjectionContext,
    hydrate: () => hydrate,
    initCustomFormatter: () => initCustomFormatter,
    initDirectivesForSSR: () => initDirectivesForSSR,
    inject: () => inject,
    isMemoSame: () => isMemoSame,
    isProxy: () => isProxy,
    isReactive: () => isReactive,
    isReadonly: () => isReadonly,
    isRef: () => isRef2,
    isRuntimeOnly: () => isRuntimeOnly,
    isShallow: () => isShallow,
    isVNode: () => isVNode,
    markRaw: () => markRaw,
    mergeDefaults: () => mergeDefaults,
    mergeModels: () => mergeModels,
    mergeProps: () => mergeProps,
    nextTick: () => nextTick,
    normalizeClass: () => normalizeClass,
    normalizeProps: () => normalizeProps,
    normalizeStyle: () => normalizeStyle,
    onActivated: () => onActivated,
    onBeforeMount: () => onBeforeMount,
    onBeforeUnmount: () => onBeforeUnmount,
    onBeforeUpdate: () => onBeforeUpdate,
    onDeactivated: () => onDeactivated,
    onErrorCaptured: () => onErrorCaptured,
    onMounted: () => onMounted,
    onRenderTracked: () => onRenderTracked,
    onRenderTriggered: () => onRenderTriggered,
    onScopeDispose: () => onScopeDispose,
    onServerPrefetch: () => onServerPrefetch,
    onUnmounted: () => onUnmounted,
    onUpdated: () => onUpdated,
    openBlock: () => openBlock,
    popScopeId: () => popScopeId,
    provide: () => provide,
    proxyRefs: () => proxyRefs,
    pushScopeId: () => pushScopeId,
    queuePostFlushCb: () => queuePostFlushCb,
    reactive: () => reactive,
    readonly: () => readonly,
    ref: () => ref,
    registerRuntimeCompiler: () => registerRuntimeCompiler,
    render: () => render,
    renderList: () => renderList,
    renderSlot: () => renderSlot,
    resolveComponent: () => resolveComponent,
    resolveDirective: () => resolveDirective,
    resolveDynamicComponent: () => resolveDynamicComponent,
    resolveFilter: () => resolveFilter,
    resolveTransitionHooks: () => resolveTransitionHooks,
    setBlockTracking: () => setBlockTracking,
    setDevtoolsHook: () => setDevtoolsHook,
    setTransitionHooks: () => setTransitionHooks,
    shallowReactive: () => shallowReactive,
    shallowReadonly: () => shallowReadonly,
    shallowRef: () => shallowRef,
    ssrContextKey: () => ssrContextKey,
    ssrUtils: () => ssrUtils,
    stop: () => stop,
    toDisplayString: () => toDisplayString,
    toHandlerKey: () => toHandlerKey,
    toHandlers: () => toHandlers,
    toRaw: () => toRaw,
    toRef: () => toRef,
    toRefs: () => toRefs,
    toValue: () => toValue,
    transformVNodeArgs: () => transformVNodeArgs,
    triggerRef: () => triggerRef,
    unref: () => unref,
    useAttrs: () => useAttrs,
    useCssModule: () => useCssModule,
    useCssVars: () => useCssVars,
    useModel: () => useModel,
    useSSRContext: () => useSSRContext,
    useSlots: () => useSlots,
    useTransitionState: () => useTransitionState,
    vModelCheckbox: () => vModelCheckbox,
    vModelDynamic: () => vModelDynamic,
    vModelRadio: () => vModelRadio,
    vModelSelect: () => vModelSelect,
    vModelText: () => vModelText,
    vShow: () => vShow,
    version: () => version,
    warn: () => warn2,
    watch: () => watch,
    watchEffect: () => watchEffect,
    watchPostEffect: () => watchPostEffect,
    watchSyncEffect: () => watchSyncEffect,
    withAsyncContext: () => withAsyncContext,
    withCtx: () => withCtx,
    withDefaults: () => withDefaults,
    withDirectives: () => withDirectives,
    withKeys: () => withKeys,
    withMemo: () => withMemo,
    withModifiers: () => withModifiers,
    withScopeId: () => withScopeId
  });

  // node_modules/@vue/shared/dist/shared.esm-bundler.js
  // @__NO_SIDE_EFFECTS__
  function makeMap(str, expectsLowerCase) {
    const set2 = new Set(str.split(","));
    return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
  }
  var EMPTY_OBJ = true ? Object.freeze({}) : {};
  var EMPTY_ARR = true ? Object.freeze([]) : [];
  var NOOP = () => {
  };
  var NO = () => false;
  var isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  var isModelListener = (key) => key.startsWith("onUpdate:");
  var extend3 = Object.assign;
  var remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var hasOwn = (val, key) => hasOwnProperty.call(val, key);
  var isArray = Array.isArray;
  var isMap = (val) => toTypeString(val) === "[object Map]";
  var isSet = (val) => toTypeString(val) === "[object Set]";
  var isDate = (val) => toTypeString(val) === "[object Date]";
  var isRegExp = (val) => toTypeString(val) === "[object RegExp]";
  var isFunction2 = (val) => typeof val === "function";
  var isString = (val) => typeof val === "string";
  var isSymbol = (val) => typeof val === "symbol";
  var isObject = (val) => val !== null && typeof val === "object";
  var isPromise = (val) => {
    return (isObject(val) || isFunction2(val)) && isFunction2(val.then) && isFunction2(val.catch);
  };
  var objectToString = Object.prototype.toString;
  var toTypeString = (value) => objectToString.call(value);
  var toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  var isPlainObject = (val) => toTypeString(val) === "[object Object]";
  var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  var isReservedProp = /* @__PURE__ */ makeMap(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  var isBuiltInDirective = /* @__PURE__ */ makeMap(
    "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
  );
  var cacheStringFunction = (fn) => {
    const cache2 = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache2[str];
      return hit || (cache2[str] = fn(str));
    };
  };
  var camelizeRE = /-(\w)/g;
  var camelize2 = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_2, c) => c ? c.toUpperCase() : "");
  });
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cacheStringFunction(
    (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
  );
  var capitalize2 = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  var toHandlerKey = cacheStringFunction((str) => {
    const s = str ? `on${capitalize2(str)}` : ``;
    return s;
  });
  var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  var invokeArrayFns = (fns, ...arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](...arg);
    }
  };
  var def = (obj, key, value, writable = false) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  var looseToNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  var toNumber = (val) => {
    const n = isString(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
  };
  var _globalThis;
  var getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  var PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `NEED_HYDRATION`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `HOISTED`,
    [-2]: `BAIL`
  };
  var slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
  };
  var GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error";
  var isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
  var range = 2;
  function generateCodeFrame(source, start2 = 0, end = source.length) {
    start2 = Math.max(0, Math.min(start2, source.length));
    end = Math.max(0, Math.min(end, source.length));
    if (start2 > end)
      return "";
    let lines = source.split(/(\r?\n)/);
    const newlineSequences = lines.filter((_2, idx) => idx % 2 === 1);
    lines = lines.filter((_2, idx) => idx % 2 === 0);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
      count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
      if (count >= start2) {
        for (let j = i - range; j <= i + range || end > count; j++) {
          if (j < 0 || j >= lines.length)
            continue;
          const line = j + 1;
          res.push(
            `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
          );
          const lineLength = lines[j].length;
          const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
          if (j === i) {
            const pad = start2 - (count - (lineLength + newLineSeqLength));
            const length = Math.max(
              1,
              end > count ? lineLength - pad : end - start2
            );
            res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
          } else if (j > i) {
            if (end > count) {
              const length = Math.max(Math.min(end - count, lineLength), 1);
              res.push(`   |  ` + "^".repeat(length));
            }
            count += lineLength + newLineSeqLength;
          }
        }
        break;
      }
    }
    return res.join("\n");
  }
  function normalizeStyle(value) {
    if (isArray(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString(value) || isObject(value)) {
      return value;
    }
  }
  var listDelimiterRE = /;(?![^(]*\))/g;
  var propertyDelimiterRE = /:([^]+)/;
  var styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function stringifyStyle(styles) {
    let ret = "";
    if (!styles || isString(styles)) {
      return ret;
    }
    for (const key in styles) {
      const value = styles[key];
      if (isString(value) || typeof value === "number") {
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        ret += `${normalizedKey}:${value};`;
      }
    }
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString(value)) {
      res = value;
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  function normalizeProps(props) {
    if (!props)
      return null;
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (style) {
      props.style = normalizeStyle(style);
    }
    return props;
  }
  var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
  var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  var MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
  var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
  var isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
  var isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
  var isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
  var isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
  var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  var isBooleanAttr = /* @__PURE__ */ makeMap(
    specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
  );
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  var isKnownHtmlAttr = /* @__PURE__ */ makeMap(
    `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
  );
  var isKnownSvgAttr = /* @__PURE__ */ makeMap(
    `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
  );
  function isRenderableAttrValue(value) {
    if (value == null) {
      return false;
    }
    const type = typeof value;
    return type === "string" || type === "number" || type === "boolean";
  }
  function looseCompareArrays(a, b) {
    if (a.length !== b.length)
      return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
      equal = looseEqual(a[i], b[i]);
    }
    return equal;
  }
  function looseEqual(a, b) {
    if (a === b)
      return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isSymbol(a);
    bValidType = isSymbol(b);
    if (aValidType || bValidType) {
      return a === b;
    }
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
      if (!aValidType || !bValidType) {
        return false;
      }
      const aKeysCount = Object.keys(a).length;
      const bKeysCount = Object.keys(b).length;
      if (aKeysCount !== bKeysCount) {
        return false;
      }
      for (const key in a) {
        const aHasKey = a.hasOwnProperty(key);
        const bHasKey = b.hasOwnProperty(key);
        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
          return false;
        }
      }
    }
    return String(a) === String(b);
  }
  function looseIndexOf(arr, val) {
    return arr.findIndex((item) => looseEqual(item, val));
  }
  var isRef = (val) => {
    return !!(val && val.__v_isRef === true);
  };
  var toDisplayString = (val) => {
    return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction2(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
  };
  var replacer = (_key, val) => {
    if (isRef(val)) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce(
          (entries, [key, val2], i) => {
            entries[stringifySymbol(key, i) + " =>"] = val2;
            return entries;
          },
          {}
        )
      };
    } else if (isSet(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
      };
    } else if (isSymbol(val)) {
      return stringifySymbol(val);
    } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
      return String(val);
    }
    return val;
  };
  var stringifySymbol = (v, i = "") => {
    var _a;
    return (
      // Symbol.description in es2019+ so we need to cast here to pass
      // the lib: es2016 check
      isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
    );
  };

  // node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
  function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
  }
  var activeEffectScope;
  var EffectScope = class {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this.effects = [];
      this.cleanups = [];
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    run(fn) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      } else if (true) {
        warn(`cannot run an inactive effect scope.`);
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
      activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
      activeEffectScope = this.parent;
    }
    stop(fromParent) {
      if (this._active) {
        let i, l;
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].stop();
        }
        for (i = 0, l = this.cleanups.length; i < l; i++) {
          this.cleanups[i]();
        }
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].stop(true);
          }
        }
        if (!this.detached && this.parent && !fromParent) {
          const last2 = this.parent.scopes.pop();
          if (last2 && last2 !== this) {
            this.parent.scopes[this.index] = last2;
            last2.index = this.index;
          }
        }
        this.parent = void 0;
        this._active = false;
      }
    }
  };
  function effectScope(detached) {
    return new EffectScope(detached);
  }
  function recordEffectScope(effect2, scope = activeEffectScope) {
    if (scope && scope.active) {
      scope.effects.push(effect2);
    }
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  function onScopeDispose(fn) {
    if (activeEffectScope) {
      activeEffectScope.cleanups.push(fn);
    } else if (true) {
      warn(
        `onScopeDispose() is called when there is no active effect scope to be associated with.`
      );
    }
  }
  var activeEffect;
  var ReactiveEffect = class {
    constructor(fn, trigger2, scheduler, scope) {
      this.fn = fn;
      this.trigger = trigger2;
      this.scheduler = scheduler;
      this.active = true;
      this.deps = [];
      this._dirtyLevel = 4;
      this._trackId = 0;
      this._runnings = 0;
      this._shouldSchedule = false;
      this._depsLength = 0;
      recordEffectScope(this, scope);
    }
    get dirty() {
      if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
        this._dirtyLevel = 1;
        pauseTracking();
        for (let i = 0; i < this._depsLength; i++) {
          const dep = this.deps[i];
          if (dep.computed) {
            triggerComputed(dep.computed);
            if (this._dirtyLevel >= 4) {
              break;
            }
          }
        }
        if (this._dirtyLevel === 1) {
          this._dirtyLevel = 0;
        }
        resetTracking();
      }
      return this._dirtyLevel >= 4;
    }
    set dirty(v) {
      this._dirtyLevel = v ? 4 : 0;
    }
    run() {
      this._dirtyLevel = 0;
      if (!this.active) {
        return this.fn();
      }
      let lastShouldTrack = shouldTrack;
      let lastEffect = activeEffect;
      try {
        shouldTrack = true;
        activeEffect = this;
        this._runnings++;
        preCleanupEffect(this);
        return this.fn();
      } finally {
        postCleanupEffect(this);
        this._runnings--;
        activeEffect = lastEffect;
        shouldTrack = lastShouldTrack;
      }
    }
    stop() {
      if (this.active) {
        preCleanupEffect(this);
        postCleanupEffect(this);
        this.onStop && this.onStop();
        this.active = false;
      }
    }
  };
  function triggerComputed(computed3) {
    return computed3.value;
  }
  function preCleanupEffect(effect2) {
    effect2._trackId++;
    effect2._depsLength = 0;
  }
  function postCleanupEffect(effect2) {
    if (effect2.deps.length > effect2._depsLength) {
      for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
        cleanupDepEffect(effect2.deps[i], effect2);
      }
      effect2.deps.length = effect2._depsLength;
    }
  }
  function cleanupDepEffect(dep, effect2) {
    const trackId = dep.get(effect2);
    if (trackId !== void 0 && effect2._trackId !== trackId) {
      dep.delete(effect2);
      if (dep.size === 0) {
        dep.cleanup();
      }
    }
  }
  function effect(fn, options) {
    if (fn.effect instanceof ReactiveEffect) {
      fn = fn.effect.fn;
    }
    const _effect = new ReactiveEffect(fn, NOOP, () => {
      if (_effect.dirty) {
        _effect.run();
      }
    });
    if (options) {
      extend3(_effect, options);
      if (options.scope)
        recordEffectScope(_effect, options.scope);
    }
    if (!options || !options.lazy) {
      _effect.run();
    }
    const runner = _effect.run.bind(_effect);
    runner.effect = _effect;
    return runner;
  }
  function stop(runner) {
    runner.effect.stop();
  }
  var shouldTrack = true;
  var pauseScheduleStack = 0;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last2 = trackStack.pop();
    shouldTrack = last2 === void 0 ? true : last2;
  }
  function pauseScheduling() {
    pauseScheduleStack++;
  }
  function resetScheduling() {
    pauseScheduleStack--;
    while (!pauseScheduleStack && queueEffectSchedulers.length) {
      queueEffectSchedulers.shift()();
    }
  }
  function trackEffect(effect2, dep, debuggerEventExtraInfo) {
    var _a;
    if (dep.get(effect2) !== effect2._trackId) {
      dep.set(effect2, effect2._trackId);
      const oldDep = effect2.deps[effect2._depsLength];
      if (oldDep !== dep) {
        if (oldDep) {
          cleanupDepEffect(oldDep, effect2);
        }
        effect2.deps[effect2._depsLength++] = dep;
      } else {
        effect2._depsLength++;
      }
      if (true) {
        (_a = effect2.onTrack) == null ? void 0 : _a.call(effect2, extend3({ effect: effect2 }, debuggerEventExtraInfo));
      }
    }
  }
  var queueEffectSchedulers = [];
  function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
    var _a;
    pauseScheduling();
    for (const effect2 of dep.keys()) {
      let tracking;
      if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
        effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
        effect2._dirtyLevel = dirtyLevel;
      }
      if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
        if (true) {
          (_a = effect2.onTrigger) == null ? void 0 : _a.call(effect2, extend3({ effect: effect2 }, debuggerEventExtraInfo));
        }
        effect2.trigger();
        if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
          effect2._shouldSchedule = false;
          if (effect2.scheduler) {
            queueEffectSchedulers.push(effect2.scheduler);
          }
        }
      }
    }
    resetScheduling();
  }
  var createDep = (cleanup, computed3) => {
    const dep = /* @__PURE__ */ new Map();
    dep.cleanup = cleanup;
    dep.computed = computed3;
    return dep;
  };
  var targetMap = /* @__PURE__ */ new WeakMap();
  var ITERATE_KEY = Symbol(true ? "iterate" : "");
  var MAP_KEY_ITERATE_KEY = Symbol(true ? "Map key iterate" : "");
  function track(target, type, key) {
    if (shouldTrack && activeEffect) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
      }
      trackEffect(
        activeEffect,
        dep,
        true ? {
          target,
          type,
          key
        } : void 0
      );
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    let deps = [];
    if (type === "clear") {
      deps = [...depsMap.values()];
    } else if (key === "length" && isArray(target)) {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
          deps.push(dep);
        }
      });
    } else {
      if (key !== void 0) {
        deps.push(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            deps.push(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    pauseScheduling();
    for (const dep of deps) {
      if (dep) {
        triggerEffects(
          dep,
          4,
          true ? {
            target,
            type,
            key,
            newValue,
            oldValue,
            oldTarget
          } : void 0
        );
      }
    }
    resetScheduling();
  }
  function getDepFromReactive(object, key) {
    const depsMap = targetMap.get(object);
    return depsMap && depsMap.get(key);
  }
  var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  var builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
  );
  var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
      instrumentations[key] = function(...args) {
        const arr = toRaw(this);
        for (let i = 0, l = this.length; i < l; i++) {
          track(arr, "get", i + "");
        }
        const res = arr[key](...args);
        if (res === -1 || res === false) {
          return arr[key](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
      instrumentations[key] = function(...args) {
        pauseTracking();
        pauseScheduling();
        const res = toRaw(this)[key].apply(this, args);
        resetScheduling();
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function hasOwnProperty2(key) {
    if (!isSymbol(key))
      key = String(key);
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  var BaseReactiveHandler = class {
    constructor(_isReadonly = false, _isShallow = false) {
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    get(target, key, receiver) {
      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return isShallow2;
      } else if (key === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
        // this means the reciever is a user proxy of the reactive proxy
        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly2) {
        if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
          return Reflect.get(arrayInstrumentations, key, receiver);
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty2;
        }
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef2(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  };
  var MutableReactiveHandler = class extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(false, isShallow2);
    }
    set(target, key, value, receiver) {
      let oldValue = target[key];
      if (!this._isShallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray(target) && isRef2(oldValue) && !isRef2(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    }
    deleteProperty(target, key) {
      const hadKey = hasOwn(target, key);
      const oldValue = target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0, oldValue);
      }
      return result;
    }
    has(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    ownKeys(target) {
      track(
        target,
        "iterate",
        isArray(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    }
  };
  var ReadonlyReactiveHandler = class extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(true, isShallow2);
    }
    set(target, key) {
      if (true) {
        warn(
          `Set operation on key "${String(key)}" failed: target is readonly.`,
          target
        );
      }
      return true;
    }
    deleteProperty(target, key) {
      if (true) {
        warn(
          `Delete operation on key "${String(key)}" failed: target is readonly.`,
          target
        );
      }
      return true;
    }
  };
  var mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  var readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  var shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
    true
  );
  var shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
  var toShallow = (value) => value;
  var getProto = (v) => Reflect.getPrototypeOf(v);
  function get(target, key, isReadonly2 = false, isShallow2 = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
      if (hasChanged(key, rawKey)) {
        track(rawTarget, "get", key);
      }
      track(rawTarget, "get", rawKey);
    }
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has(key, isReadonly2 = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly2) {
      if (hasChanged(key, rawKey)) {
        track(rawTarget, "has", key);
      }
      track(rawTarget, "has", rawKey);
    }
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly2 = false) {
    target = target["__v_raw"];
    !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add2(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (true) {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get2.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (true) {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get2 ? get2.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = true ? isMap(target) ? new Map(target) : new Set(target) : void 0;
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly2, isShallow2) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      if (true) {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        warn(
          `${capitalize2(type)} operation ${key}failed: target is readonly.`,
          toRaw(this)
        );
      }
      return type === "delete" ? false : type === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get(this, key);
      },
      get size() {
        return size(this);
      },
      has,
      add: add2,
      set,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has,
      add: add2,
      set,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(
        method,
        true,
        true
      );
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  var [
    mutableInstrumentations,
    readonlyInstrumentations,
    shallowInstrumentations,
    shallowReadonlyInstrumentations
  ] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn(instrumentations, key) && key in target ? instrumentations : target,
        key,
        receiver
      );
    };
  }
  var mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  var shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  var readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  var shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
      const type = toRawType(target);
      warn(
        `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
      );
    }
  }
  var reactiveMap = /* @__PURE__ */ new WeakMap();
  var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  var readonlyMap = /* @__PURE__ */ new WeakMap();
  var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target) {
    return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target) {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      if (true) {
        warn(
          `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
            target
          )}`
        );
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(
      target,
      targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (Object.isExtensible(value)) {
      def(value, "__v_skip", true);
    }
    return value;
  }
  var toReactive = (value) => isObject(value) ? reactive(value) : value;
  var toReadonly = (value) => isObject(value) ? readonly(value) : value;
  var COMPUTED_SIDE_EFFECT_WARN = `Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free`;
  var ComputedRefImpl = class {
    constructor(getter, _setter, isReadonly2, isSSR) {
      this.getter = getter;
      this._setter = _setter;
      this.dep = void 0;
      this.__v_isRef = true;
      this["__v_isReadonly"] = false;
      this.effect = new ReactiveEffect(
        () => getter(this._value),
        () => triggerRefValue(
          this,
          this.effect._dirtyLevel === 2 ? 2 : 3
        )
      );
      this.effect.computed = this;
      this.effect.active = this._cacheable = !isSSR;
      this["__v_isReadonly"] = isReadonly2;
    }
    get value() {
      const self2 = toRaw(this);
      if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
        triggerRefValue(self2, 4);
      }
      trackRefValue(self2);
      if (self2.effect._dirtyLevel >= 2) {
        if (this._warnRecursive) {
          warn(COMPUTED_SIDE_EFFECT_WARN, `

getter: `, this.getter);
        }
        triggerRefValue(self2, 2);
      }
      return self2._value;
    }
    set value(newValue) {
      this._setter(newValue);
    }
    // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
    get _dirty() {
      return this.effect.dirty;
    }
    set _dirty(v) {
      this.effect.dirty = v;
    }
    // #endregion
  };
  function computed(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = isFunction2(getterOrOptions);
    if (onlyGetter) {
      getter = getterOrOptions;
      setter = true ? () => {
        warn("Write operation failed: computed value is readonly");
      } : NOOP;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    if (debugOptions && !isSSR) {
      cRef.effect.onTrack = debugOptions.onTrack;
      cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
  }
  function trackRefValue(ref2) {
    var _a;
    if (shouldTrack && activeEffect) {
      ref2 = toRaw(ref2);
      trackEffect(
        activeEffect,
        (_a = ref2.dep) != null ? _a : ref2.dep = createDep(
          () => ref2.dep = void 0,
          ref2 instanceof ComputedRefImpl ? ref2 : void 0
        ),
        true ? {
          target: ref2,
          type: "get",
          key: "value"
        } : void 0
      );
    }
  }
  function triggerRefValue(ref2, dirtyLevel = 4, newVal, oldVal) {
    ref2 = toRaw(ref2);
    const dep = ref2.dep;
    if (dep) {
      triggerEffects(
        dep,
        dirtyLevel,
        true ? {
          target: ref2,
          type: "set",
          key: "value",
          newValue: newVal,
          oldValue: oldVal
        } : void 0
      );
    }
  }
  function isRef2(r) {
    return !!(r && r.__v_isRef === true);
  }
  function ref(value) {
    return createRef(value, false);
  }
  function shallowRef(value) {
    return createRef(value, true);
  }
  function createRef(rawValue, shallow) {
    if (isRef2(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  var RefImpl = class {
    constructor(value, __v_isShallow) {
      this.__v_isShallow = __v_isShallow;
      this.dep = void 0;
      this.__v_isRef = true;
      this._rawValue = __v_isShallow ? value : toRaw(value);
      this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
      trackRefValue(this);
      return this._value;
    }
    set value(newVal) {
      const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
      newVal = useDirectValue ? newVal : toRaw(newVal);
      if (hasChanged(newVal, this._rawValue)) {
        const oldVal = this._rawValue;
        this._rawValue = newVal;
        this._value = useDirectValue ? newVal : toReactive(newVal);
        triggerRefValue(this, 4, newVal, oldVal);
      }
    }
  };
  function triggerRef(ref2) {
    triggerRefValue(ref2, 4, true ? ref2.value : void 0);
  }
  function unref(ref2) {
    return isRef2(ref2) ? ref2.value : ref2;
  }
  function toValue(source) {
    return isFunction2(source) ? source() : unref(source);
  }
  var shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef2(oldValue) && !isRef2(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  var CustomRefImpl = class {
    constructor(factory) {
      this.dep = void 0;
      this.__v_isRef = true;
      const { get: get2, set: set2 } = factory(
        () => trackRefValue(this),
        () => triggerRefValue(this)
      );
      this._get = get2;
      this._set = set2;
    }
    get value() {
      return this._get();
    }
    set value(newVal) {
      this._set(newVal);
    }
  };
  function customRef(factory) {
    return new CustomRefImpl(factory);
  }
  function toRefs(object) {
    if (!isProxy(object)) {
      warn(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = isArray(object) ? new Array(object.length) : {};
    for (const key in object) {
      ret[key] = propertyToRef(object, key);
    }
    return ret;
  }
  var ObjectRefImpl = class {
    constructor(_object, _key, _defaultValue) {
      this._object = _object;
      this._key = _key;
      this._defaultValue = _defaultValue;
      this.__v_isRef = true;
    }
    get value() {
      const val = this._object[this._key];
      return val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
      this._object[this._key] = newVal;
    }
    get dep() {
      return getDepFromReactive(toRaw(this._object), this._key);
    }
  };
  var GetterRefImpl = class {
    constructor(_getter) {
      this._getter = _getter;
      this.__v_isRef = true;
      this.__v_isReadonly = true;
    }
    get value() {
      return this._getter();
    }
  };
  function toRef(source, key, defaultValue) {
    if (isRef2(source)) {
      return source;
    } else if (isFunction2(source)) {
      return new GetterRefImpl(source);
    } else if (isObject(source) && arguments.length > 1) {
      return propertyToRef(source, key, defaultValue);
    } else {
      return ref(source);
    }
  }
  function propertyToRef(source, key, defaultValue) {
    const val = source[key];
    return isRef2(val) ? val : new ObjectRefImpl(source, key, defaultValue);
  }
  var TrackOpTypes = {
    "GET": "get",
    "HAS": "has",
    "ITERATE": "iterate"
  };
  var TriggerOpTypes = {
    "SET": "set",
    "ADD": "add",
    "DELETE": "delete",
    "CLEAR": "clear"
  };

  // node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js
  var stack = [];
  function pushWarningContext(vnode) {
    stack.push(vnode);
  }
  function popWarningContext() {
    stack.pop();
  }
  function warn$1(msg, ...args) {
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          // eslint-disable-next-line no-restricted-syntax
          msg + args.map((a) => {
            var _a, _b;
            return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && // avoid spamming console during tests
      true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last2 = normalizedStack[0];
      if (last2 && last2.vnode === currentVNode) {
        last2.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
      logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(
      vnode.component,
      vnode.type,
      isRoot
    )}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
  }
  function formatProps(props) {
    const res = [];
    const keys2 = Object.keys(props);
    keys2.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys2.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef2(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction2(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  function assertNumber(val, type) {
    if (false)
      return;
    if (val === void 0) {
      return;
    } else if (typeof val !== "number") {
      warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
    } else if (isNaN(val)) {
      warn$1(`${type} is NaN - the duration expression might be incorrect.`);
    }
  }
  var ErrorCodes = {
    "SETUP_FUNCTION": 0,
    "0": "SETUP_FUNCTION",
    "RENDER_FUNCTION": 1,
    "1": "RENDER_FUNCTION",
    "WATCH_GETTER": 2,
    "2": "WATCH_GETTER",
    "WATCH_CALLBACK": 3,
    "3": "WATCH_CALLBACK",
    "WATCH_CLEANUP": 4,
    "4": "WATCH_CLEANUP",
    "NATIVE_EVENT_HANDLER": 5,
    "5": "NATIVE_EVENT_HANDLER",
    "COMPONENT_EVENT_HANDLER": 6,
    "6": "COMPONENT_EVENT_HANDLER",
    "VNODE_HOOK": 7,
    "7": "VNODE_HOOK",
    "DIRECTIVE_HOOK": 8,
    "8": "DIRECTIVE_HOOK",
    "TRANSITION_HOOK": 9,
    "9": "TRANSITION_HOOK",
    "APP_ERROR_HANDLER": 10,
    "10": "APP_ERROR_HANDLER",
    "APP_WARN_HANDLER": 11,
    "11": "APP_WARN_HANDLER",
    "FUNCTION_REF": 12,
    "12": "FUNCTION_REF",
    "ASYNC_COMPONENT_LOADER": 13,
    "13": "ASYNC_COMPONENT_LOADER",
    "SCHEDULER": 14,
    "14": "SCHEDULER"
  };
  var ErrorTypeStrings$1 = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."
  };
  function callWithErrorHandling(fn, instance, type, args) {
    try {
      return args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type);
    }
  }
  function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (isFunction2(fn)) {
      const res = callWithErrorHandling(fn, instance, type, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    if (isArray(fn)) {
      const values2 = [];
      for (let i = 0; i < fn.length; i++) {
        values2.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
      }
      return values2;
    } else if (true) {
      warn$1(
        `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`
      );
    }
  }
  function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = true ? ErrorTypeStrings$1[type] : `https://vuejs.org/error-reference/#runtime-${type}`;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      const appErrorHandler = instance.appContext.config.errorHandler;
      if (appErrorHandler) {
        pauseTracking();
        callWithErrorHandling(
          appErrorHandler,
          null,
          10,
          [err, exposedInstance, errorInfo]
        );
        resetTracking();
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev);
  }
  function logError(err, type, contextVNode, throwInDev = true) {
    if (true) {
      const info = ErrorTypeStrings$1[type];
      if (contextVNode) {
        pushWarningContext(contextVNode);
      }
      warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
      if (contextVNode) {
        popWarningContext();
      }
      if (throwInDev) {
        throw err;
      } else {
        console.error(err);
      }
    } else {
      console.error(err);
    }
  }
  var isFlushing = false;
  var isFlushPending = false;
  var queue = [];
  var flushIndex = 0;
  var pendingPostFlushCbs = [];
  var activePostFlushCbs = null;
  var postFlushIndex = 0;
  var resolvedPromise = /* @__PURE__ */ Promise.resolve();
  var currentFlushPromise = null;
  var RECURSION_LIMIT = 100;
  function nextTick(fn) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
  }
  function findInsertionIndex(id) {
    let start2 = flushIndex + 1;
    let end = queue.length;
    while (start2 < end) {
      const middle = start2 + end >>> 1;
      const middleJob = queue[middle];
      const middleJobId = getId(middleJob);
      if (middleJobId < id || middleJobId === id && middleJob.pre) {
        start2 = middle + 1;
      } else {
        end = middle;
      }
    }
    return start2;
  }
  function queueJob(job) {
    if (!queue.length || !queue.includes(
      job,
      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
    )) {
      if (job.id == null) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(job.id), 0, job);
      }
      queueFlush();
    }
  }
  function queueFlush() {
    if (!isFlushing && !isFlushPending) {
      isFlushPending = true;
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) {
      queue.splice(i, 1);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray(cb)) {
      if (!activePostFlushCbs || !activePostFlushCbs.includes(
        cb,
        cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
      )) {
        pendingPostFlushCbs.push(cb);
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen2, i = isFlushing ? flushIndex + 1 : 0) {
    if (true) {
      seen2 = seen2 || /* @__PURE__ */ new Map();
    }
    for (; i < queue.length; i++) {
      const cb = queue[i];
      if (cb && cb.pre) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        if (checkRecursiveUpdates(seen2, cb)) {
          continue;
        }
        queue.splice(i, 1);
        i--;
        cb();
      }
    }
  }
  function flushPostFlushCbs(seen2) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)].sort(
        (a, b) => getId(a) - getId(b)
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      if (true) {
        seen2 = seen2 || /* @__PURE__ */ new Map();
      }
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        const cb = activePostFlushCbs[postFlushIndex];
        if (checkRecursiveUpdates(seen2, cb)) {
          continue;
        }
        if (cb.active !== false)
          cb();
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  var getId = (job) => job.id == null ? Infinity : job.id;
  var comparator = (a, b) => {
    const diff = getId(a) - getId(b);
    if (diff === 0) {
      if (a.pre && !b.pre)
        return -1;
      if (b.pre && !a.pre)
        return 1;
    }
    return diff;
  };
  function flushJobs(seen2) {
    isFlushPending = false;
    isFlushing = true;
    if (true) {
      seen2 = seen2 || /* @__PURE__ */ new Map();
    }
    queue.sort(comparator);
    const check = true ? (job) => checkRecursiveUpdates(seen2, job) : NOOP;
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && job.active !== false) {
          if (check(job)) {
            continue;
          }
          callWithErrorHandling(job, null, 14);
        }
      }
    } finally {
      flushIndex = 0;
      queue.length = 0;
      flushPostFlushCbs(seen2);
      isFlushing = false;
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs(seen2);
      }
    }
  }
  function checkRecursiveUpdates(seen2, fn) {
    if (!seen2.has(fn)) {
      seen2.set(fn, 1);
    } else {
      const count = seen2.get(fn);
      if (count > RECURSION_LIMIT) {
        const instance = fn.ownerInstance;
        const componentName = instance && getComponentName(instance.type);
        handleError(
          `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
          null,
          10
        );
        return true;
      } else {
        seen2.set(fn, count + 1);
      }
    }
  }
  var isHmrUpdating = false;
  var hmrDirtyComponents = /* @__PURE__ */ new Set();
  if (true) {
    getGlobalThis().__VUE_HMR_RUNTIME__ = {
      createRecord: tryWrap(createRecord),
      rerender: tryWrap(rerender),
      reload: tryWrap(reload)
    };
  }
  var map = /* @__PURE__ */ new Map();
  function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
      createRecord(id, instance.type);
      record = map.get(id);
    }
    record.instances.add(instance);
  }
  function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
  }
  function createRecord(id, initialDef) {
    if (map.has(id)) {
      return false;
    }
    map.set(id, {
      initialDef: normalizeClassComponent(initialDef),
      instances: /* @__PURE__ */ new Set()
    });
    return true;
  }
  function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
  }
  function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) {
      return;
    }
    record.initialDef.render = newRender;
    [...record.instances].forEach((instance) => {
      if (newRender) {
        instance.render = newRender;
        normalizeClassComponent(instance.type).render = newRender;
      }
      instance.renderCache = [];
      isHmrUpdating = true;
      instance.effect.dirty = true;
      instance.update();
      isHmrUpdating = false;
    });
  }
  function reload(id, newComp) {
    const record = map.get(id);
    if (!record)
      return;
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record.initialDef, newComp);
    const instances = [...record.instances];
    for (const instance of instances) {
      const oldComp = normalizeClassComponent(instance.type);
      if (!hmrDirtyComponents.has(oldComp)) {
        if (oldComp !== record.initialDef) {
          updateComponentDef(oldComp, newComp);
        }
        hmrDirtyComponents.add(oldComp);
      }
      instance.appContext.propsCache.delete(instance.type);
      instance.appContext.emitsCache.delete(instance.type);
      instance.appContext.optionsCache.delete(instance.type);
      if (instance.ceReload) {
        hmrDirtyComponents.add(oldComp);
        instance.ceReload(newComp.styles);
        hmrDirtyComponents.delete(oldComp);
      } else if (instance.parent) {
        instance.parent.effect.dirty = true;
        queueJob(() => {
          instance.parent.update();
          hmrDirtyComponents.delete(oldComp);
        });
      } else if (instance.appContext.reload) {
        instance.appContext.reload();
      } else if (typeof window !== "undefined") {
        window.location.reload();
      } else {
        console.warn(
          "[HMR] Root or manually mounted instance modified. Full reload required."
        );
      }
    }
    queuePostFlushCb(() => {
      for (const instance of instances) {
        hmrDirtyComponents.delete(
          normalizeClassComponent(instance.type)
        );
      }
    });
  }
  function updateComponentDef(oldComp, newComp) {
    extend3(oldComp, newComp);
    for (const key in oldComp) {
      if (key !== "__file" && !(key in newComp)) {
        delete oldComp[key];
      }
    }
  }
  function tryWrap(fn) {
    return (id, arg) => {
      try {
        return fn(id, arg);
      } catch (e) {
        console.error(e);
        console.warn(
          `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
        );
      }
    };
  }
  var devtools$1;
  var buffer = [];
  var devtoolsNotInstalled = false;
  function emit$1(event, ...args) {
    if (devtools$1) {
      devtools$1.emit(event, ...args);
    } else if (!devtoolsNotInstalled) {
      buffer.push({ event, args });
    }
  }
  function setDevtoolsHook$1(hook, target) {
    var _a, _b;
    devtools$1 = hook;
    if (devtools$1) {
      devtools$1.enabled = true;
      buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
      buffer = [];
    } else if (
      // handle late devtools injection - only do this if we are in an actual
      // browser environment to avoid the timer handle stalling test runner exit
      // (#4815)
      typeof window !== "undefined" && // some envs mock window but not fully
      window.HTMLElement && // also exclude jsdom
      // eslint-disable-next-line no-restricted-syntax
      !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
    ) {
      const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
      replay.push((newHook) => {
        setDevtoolsHook$1(newHook, target);
      });
      setTimeout(() => {
        if (!devtools$1) {
          target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
          devtoolsNotInstalled = true;
          buffer = [];
        }
      }, 3e3);
    } else {
      devtoolsNotInstalled = true;
      buffer = [];
    }
  }
  function devtoolsInitApp(app, version2) {
    emit$1("app:init", app, version2, {
      Fragment,
      Text,
      Comment,
      Static
    });
  }
  function devtoolsUnmountApp(app) {
    emit$1("app:unmount", app);
  }
  var devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:added"
    /* COMPONENT_ADDED */
  );
  var devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:updated"
    /* COMPONENT_UPDATED */
  );
  var _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:removed"
    /* COMPONENT_REMOVED */
  );
  var devtoolsComponentRemoved = (component) => {
    if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
    !devtools$1.cleanupBuffer(component)) {
      _devtoolsComponentRemoved(component);
    }
  };
  // @__NO_SIDE_EFFECTS__
  function createDevtoolsComponentHook(hook) {
    return (component) => {
      emit$1(
        hook,
        component.appContext.app,
        component.uid,
        component.parent ? component.parent.uid : void 0,
        component
      );
    };
  }
  var devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
    "perf:start"
    /* PERFORMANCE_START */
  );
  var devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
    "perf:end"
    /* PERFORMANCE_END */
  );
  function createDevtoolsPerformanceHook(hook) {
    return (component, type, time) => {
      emit$1(hook, component.appContext.app, component.uid, component, type, time);
    };
  }
  function devtoolsComponentEmit(component, event, params) {
    emit$1(
      "component:emit",
      component.appContext.app,
      component,
      event,
      params
    );
  }
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted)
      return;
    const props = instance.vnode.props || EMPTY_OBJ;
    if (true) {
      const {
        emitsOptions,
        propsOptions: [propsOptions]
      } = instance;
      if (emitsOptions) {
        if (!(event in emitsOptions) && true) {
          if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
            warn$1(
              `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`
            );
          }
        } else {
          const validator = emitsOptions[event];
          if (isFunction2(validator)) {
            const isValid = validator(...rawArgs);
            if (!isValid) {
              warn$1(
                `Invalid event arguments: event validation failed for event "${event}".`
              );
            }
          }
        }
      }
    }
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modelArg = isModelListener2 && event.slice(7);
    if (modelArg && modelArg in props) {
      const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
      const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
      if (trim) {
        args = rawArgs.map((a) => isString(a) ? a.trim() : a);
      }
      if (number) {
        args = rawArgs.map(looseToNumber);
      }
    }
    if (true) {
      devtoolsComponentEmit(instance, event, args);
    }
    if (true) {
      const lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
        warn$1(
          `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
            instance,
            instance.type
          )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(
            event
          )}" instead of "${event}".`
        );
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
    props[handlerName = toHandlerKey(camelize2(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache2 = appContext.emitsCache;
    const cached = cache2.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !isFunction2(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend3(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject(comp)) {
        cache2.set(comp, null);
      }
      return null;
    }
    if (isArray(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend3(normalized, raw);
    }
    if (isObject(comp)) {
      cache2.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
  }
  var currentRenderingInstance = null;
  var currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function pushScopeId(id) {
    currentScopeId = id;
  }
  function popScopeId() {
    currentScopeId = null;
  }
  var withScopeId = (_id) => withCtx;
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx)
      return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      if (true) {
        devtoolsComponentUpdated(ctx);
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  var accessedAttrs = false;
  function markAttrsAccessed() {
    accessedAttrs = true;
  }
  function renderComponentRoot(instance) {
    const {
      type: Component2,
      vnode,
      proxy,
      withProxy,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render: render2,
      renderCache,
      props,
      data,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    const prev = setCurrentRenderingInstance(instance);
    let result;
    let fallthroughAttrs;
    if (true) {
      accessedAttrs = false;
    }
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = setupState.__isScriptSetup ? new Proxy(proxyToUse, {
          get(target, key, receiver) {
            warn$1(
              `Property '${String(
                key
              )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target, key, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render2.call(
            thisProxy,
            proxyToUse,
            renderCache,
            true ? shallowReadonly(props) : props,
            setupState,
            data,
            ctx
          )
        );
        fallthroughAttrs = attrs;
      } else {
        const render22 = Component2;
        if (attrs === props) {
          markAttrsAccessed();
        }
        result = normalizeVNode(
          render22.length > 1 ? render22(
            true ? shallowReadonly(props) : props,
            true ? {
              get attrs() {
                markAttrsAccessed();
                return shallowReadonly(attrs);
              },
              slots,
              emit: emit2
            } : { attrs, slots, emit: emit2 }
          ) : render22(
            true ? shallowReadonly(props) : props,
            null
          )
        );
        fallthroughAttrs = Component2.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root = result;
    let setRoot = void 0;
    if (result.patchFlag > 0 && result.patchFlag & 2048) {
      [root, setRoot] = getChildRoot(result);
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys2 = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root;
      if (keys2.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys2.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root = cloneVNode(root, fallthroughAttrs, false, true);
        } else if (!accessedAttrs && root.type !== Comment) {
          const allAttrs = Object.keys(attrs);
          const eventAttrs = [];
          const extraAttrs = [];
          for (let i = 0, l = allAttrs.length; i < l; i++) {
            const key = allAttrs[i];
            if (isOn(key)) {
              if (!isModelListener(key)) {
                eventAttrs.push(key[2].toLowerCase() + key.slice(3));
              }
            } else {
              extraAttrs.push(key);
            }
          }
          if (extraAttrs.length) {
            warn$1(
              `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
            );
          }
          if (eventAttrs.length) {
            warn$1(
              `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
            );
          }
        }
      }
    }
    if (vnode.dirs) {
      if (!isElementRoot(root)) {
        warn$1(
          `Runtime directive used on component with non-element root node. The directives will not function as intended.`
        );
      }
      root = cloneVNode(root, null, false, true);
      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      if (!isElementRoot(root)) {
        warn$1(
          `Component inside <Transition> renders non-element root node that cannot be animated.`
        );
      }
      root.transition = vnode.transition;
    }
    if (setRoot) {
      setRoot(root);
    } else {
      result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  var getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren, false);
    if (!childRoot) {
      return [vnode, void 0];
    } else if (childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
      return getChildRoot(childRoot);
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
      rawChildren[index] = updatedRoot;
      if (dynamicChildren) {
        if (dynamicIndex > -1) {
          dynamicChildren[dynamicIndex] = updatedRoot;
        } else if (updatedRoot.patchFlag > 0) {
          vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
        }
      }
    };
    return [normalizeVNode(childRoot), setRoot];
  };
  function filterSingleRoot(children, recurse = true) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (isVNode(child)) {
        if (child.type !== Comment || child.children === "v-if") {
          if (singleRoot) {
            return;
          } else {
            singleRoot = child;
            if (recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
              return filterSingleRoot(singleRoot.children);
            }
          }
        }
      } else {
        return;
      }
    }
    return singleRoot;
  }
  var getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  var filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  var isElementRoot = (vnode) => {
    return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) {
      return true;
    }
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i = 0; i < dynamicProps.length; i++) {
          const key = dynamicProps[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
      const key = nextKeys[i];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent) {
      const root = parent.subTree;
      if (root.suspense && root.suspense.activeBranch === vnode) {
        root.el = vnode.el;
      }
      if (root === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      } else {
        break;
      }
    }
  }
  var COMPONENTS = "components";
  var DIRECTIVES = "directives";
  function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  var NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveDynamicComponent(component) {
    if (isString(component)) {
      return resolveAsset(COMPONENTS, component, false) || component;
    } else {
      return component || NULL_DYNAMIC_COMPONENT;
    }
  }
  function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
  }
  function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component2 = instance.type;
      if (type === COMPONENTS) {
        const selfName = getComponentName(
          Component2,
          false
        );
        if (selfName && (selfName === name || selfName === camelize2(name) || selfName === capitalize2(camelize2(name)))) {
          return Component2;
        }
      }
      const res = (
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component2[type], name) || // global registration
        resolve(instance.appContext[type], name)
      );
      if (!res && maybeSelfReference) {
        return Component2;
      }
      if (warnMissing && !res) {
        const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
        warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
      }
      return res;
    } else if (true) {
      warn$1(
        `resolve${capitalize2(type.slice(0, -1))} can only be used in render() or setup().`
      );
    }
  }
  function resolve(registry, name) {
    return registry && (registry[name] || registry[camelize2(name)] || registry[capitalize2(camelize2(name))]);
  }
  var isSuspense = (type) => type.__isSuspense;
  var suspenseId = 0;
  var SuspenseImpl = {
    name: "Suspense",
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
      if (n1 == null) {
        mountSuspense(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          rendererInternals
        );
      } else {
        if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
          n2.suspense = n1.suspense;
          n2.suspense.vnode = n2;
          n2.el = n1.el;
          return;
        }
        patchSuspense(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          namespace,
          slotScopeIds,
          optimized,
          rendererInternals
        );
      }
    },
    hydrate: hydrateSuspense,
    normalize: normalizeSuspenseChildren
  };
  var Suspense = SuspenseImpl;
  function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if (isFunction2(eventListener)) {
      eventListener();
    }
  }
  function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    const {
      p: patch,
      o: { createElement }
    } = rendererInternals;
    const hiddenContainer = createElement("div");
    const suspense = vnode.suspense = createSuspenseBoundary(
      vnode,
      parentSuspense,
      parentComponent,
      container,
      hiddenContainer,
      anchor,
      namespace,
      slotScopeIds,
      optimized,
      rendererInternals
    );
    patch(
      null,
      suspense.pendingBranch = vnode.ssContent,
      hiddenContainer,
      null,
      parentComponent,
      suspense,
      namespace,
      slotScopeIds
    );
    if (suspense.deps > 0) {
      triggerEvent(vnode, "onPending");
      triggerEvent(vnode, "onFallback");
      patch(
        null,
        vnode.ssFallback,
        container,
        anchor,
        parentComponent,
        null,
        // fallback tree will not have suspense context
        namespace,
        slotScopeIds
      );
      setActiveBranch(suspense, vnode.ssFallback);
    } else {
      suspense.resolve(false, true);
    }
  }
  function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = n2.suspense = n1.suspense;
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
      suspense.pendingBranch = newBranch;
      if (isSameVNodeType(newBranch, pendingBranch)) {
        patch(
          pendingBranch,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else if (isInFallback) {
          if (!isHydrating) {
            patch(
              activeBranch,
              newFallback,
              container,
              anchor,
              parentComponent,
              null,
              // fallback tree will not have suspense context
              namespace,
              slotScopeIds,
              optimized
            );
            setActiveBranch(suspense, newFallback);
          }
        }
      } else {
        suspense.pendingId = suspenseId++;
        if (isHydrating) {
          suspense.isHydrating = false;
          suspense.activeBranch = pendingBranch;
        } else {
          unmount(pendingBranch, parentComponent, suspense);
        }
        suspense.deps = 0;
        suspense.effects.length = 0;
        suspense.hiddenContainer = createElement("div");
        if (isInFallback) {
          patch(
            null,
            newBranch,
            suspense.hiddenContainer,
            null,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else {
            patch(
              activeBranch,
              newFallback,
              container,
              anchor,
              parentComponent,
              null,
              // fallback tree will not have suspense context
              namespace,
              slotScopeIds,
              optimized
            );
            setActiveBranch(suspense, newFallback);
          }
        } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
          patch(
            activeBranch,
            newBranch,
            container,
            anchor,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          suspense.resolve(true);
        } else {
          patch(
            null,
            newBranch,
            suspense.hiddenContainer,
            null,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          if (suspense.deps <= 0) {
            suspense.resolve();
          }
        }
      }
    } else {
      if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, newBranch);
      } else {
        triggerEvent(n2, "onPending");
        suspense.pendingBranch = newBranch;
        if (newBranch.shapeFlag & 512) {
          suspense.pendingId = newBranch.component.suspenseId;
        } else {
          suspense.pendingId = suspenseId++;
        }
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          const { timeout, pendingId } = suspense;
          if (timeout > 0) {
            setTimeout(() => {
              if (suspense.pendingId === pendingId) {
                suspense.fallback(newFallback);
              }
            }, timeout);
          } else if (timeout === 0) {
            suspense.fallback(newFallback);
          }
        }
      }
    }
  }
  var hasWarned = false;
  function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    if (!hasWarned) {
      hasWarned = true;
      console[console.info ? "info" : "log"](
        `<Suspense> is an experimental feature and its API will likely change.`
      );
    }
    const {
      p: patch,
      m: move,
      um: unmount,
      n: next,
      o: { parentNode, remove: remove2 }
    } = rendererInternals;
    let parentSuspenseId;
    const isSuspensible = isVNodeSuspensible(vnode);
    if (isSuspensible) {
      if (parentSuspense && parentSuspense.pendingBranch) {
        parentSuspenseId = parentSuspense.pendingId;
        parentSuspense.deps++;
      }
    }
    const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
    if (true) {
      assertNumber(timeout, `Suspense timeout`);
    }
    const initialAnchor = anchor;
    const suspense = {
      vnode,
      parent: parentSuspense,
      parentComponent,
      namespace,
      container,
      hiddenContainer,
      deps: 0,
      pendingId: suspenseId++,
      timeout: typeof timeout === "number" ? timeout : -1,
      activeBranch: null,
      pendingBranch: null,
      isInFallback: !isHydrating,
      isHydrating,
      isUnmounted: false,
      effects: [],
      resolve(resume = false, sync = false) {
        if (true) {
          if (!resume && !suspense.pendingBranch) {
            throw new Error(
              `suspense.resolve() is called without a pending branch.`
            );
          }
          if (suspense.isUnmounted) {
            throw new Error(
              `suspense.resolve() is called on an already unmounted suspense boundary.`
            );
          }
        }
        const {
          vnode: vnode2,
          activeBranch,
          pendingBranch,
          pendingId,
          effects,
          parentComponent: parentComponent2,
          container: container2
        } = suspense;
        let delayEnter = false;
        if (suspense.isHydrating) {
          suspense.isHydrating = false;
        } else if (!resume) {
          delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
          if (delayEnter) {
            activeBranch.transition.afterLeave = () => {
              if (pendingId === suspense.pendingId) {
                move(
                  pendingBranch,
                  container2,
                  anchor === initialAnchor ? next(activeBranch) : anchor,
                  0
                );
                queuePostFlushCb(effects);
              }
            };
          }
          if (activeBranch) {
            if (parentNode(activeBranch.el) !== suspense.hiddenContainer) {
              anchor = next(activeBranch);
            }
            unmount(activeBranch, parentComponent2, suspense, true);
          }
          if (!delayEnter) {
            move(pendingBranch, container2, anchor, 0);
          }
        }
        setActiveBranch(suspense, pendingBranch);
        suspense.pendingBranch = null;
        suspense.isInFallback = false;
        let parent = suspense.parent;
        let hasUnresolvedAncestor = false;
        while (parent) {
          if (parent.pendingBranch) {
            parent.effects.push(...effects);
            hasUnresolvedAncestor = true;
            break;
          }
          parent = parent.parent;
        }
        if (!hasUnresolvedAncestor && !delayEnter) {
          queuePostFlushCb(effects);
        }
        suspense.effects = [];
        if (isSuspensible) {
          if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0 && !sync) {
              parentSuspense.resolve();
            }
          }
        }
        triggerEvent(vnode2, "onResolve");
      },
      fallback(fallbackVNode) {
        if (!suspense.pendingBranch) {
          return;
        }
        const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
        triggerEvent(vnode2, "onFallback");
        const anchor2 = next(activeBranch);
        const mountFallback = () => {
          if (!suspense.isInFallback) {
            return;
          }
          patch(
            null,
            fallbackVNode,
            container2,
            anchor2,
            parentComponent2,
            null,
            // fallback tree will not have suspense context
            namespace2,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, fallbackVNode);
        };
        const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = mountFallback;
        }
        suspense.isInFallback = true;
        unmount(
          activeBranch,
          parentComponent2,
          null,
          // no suspense so unmount hooks fire now
          true
          // shouldRemove
        );
        if (!delayEnter) {
          mountFallback();
        }
      },
      move(container2, anchor2, type) {
        suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
        suspense.container = container2;
      },
      next() {
        return suspense.activeBranch && next(suspense.activeBranch);
      },
      registerDep(instance, setupRenderEffect, optimized2) {
        const isInPendingSuspense = !!suspense.pendingBranch;
        if (isInPendingSuspense) {
          suspense.deps++;
        }
        const hydratedEl = instance.vnode.el;
        instance.asyncDep.catch((err) => {
          handleError(err, instance, 0);
        }).then((asyncSetupResult) => {
          if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
            return;
          }
          instance.asyncResolved = true;
          const { vnode: vnode2 } = instance;
          if (true) {
            pushWarningContext(vnode2);
          }
          handleSetupResult(instance, asyncSetupResult, false);
          if (hydratedEl) {
            vnode2.el = hydratedEl;
          }
          const placeholder = !hydratedEl && instance.subTree.el;
          setupRenderEffect(
            instance,
            vnode2,
            // component may have been moved before resolve.
            // if this is not a hydration, instance.subTree will be the comment
            // placeholder.
            parentNode(hydratedEl || instance.subTree.el),
            // anchor will not be used if this is hydration, so only need to
            // consider the comment placeholder case.
            hydratedEl ? null : next(instance.subTree),
            suspense,
            namespace,
            optimized2
          );
          if (placeholder) {
            remove2(placeholder);
          }
          updateHOCHostEl(instance, vnode2.el);
          if (true) {
            popWarningContext();
          }
          if (isInPendingSuspense && --suspense.deps === 0) {
            suspense.resolve();
          }
        });
      },
      unmount(parentSuspense2, doRemove) {
        suspense.isUnmounted = true;
        if (suspense.activeBranch) {
          unmount(
            suspense.activeBranch,
            parentComponent,
            parentSuspense2,
            doRemove
          );
        }
        if (suspense.pendingBranch) {
          unmount(
            suspense.pendingBranch,
            parentComponent,
            parentSuspense2,
            doRemove
          );
        }
      }
    };
    return suspense;
  }
  function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    const suspense = vnode.suspense = createSuspenseBoundary(
      vnode,
      parentSuspense,
      parentComponent,
      node.parentNode,
      // eslint-disable-next-line no-restricted-globals
      document.createElement("div"),
      null,
      namespace,
      slotScopeIds,
      optimized,
      rendererInternals,
      true
    );
    const result = hydrateNode(
      node,
      suspense.pendingBranch = vnode.ssContent,
      parentComponent,
      suspense,
      slotScopeIds,
      optimized
    );
    if (suspense.deps === 0) {
      suspense.resolve(false, true);
    }
    return result;
  }
  function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32;
    vnode.ssContent = normalizeSuspenseSlot(
      isSlotChildren ? children.default : children
    );
    vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
  }
  function normalizeSuspenseSlot(s) {
    let block;
    if (isFunction2(s)) {
      const trackBlock = isBlockTreeEnabled && s._c;
      if (trackBlock) {
        s._d = false;
        openBlock();
      }
      s = s();
      if (trackBlock) {
        s._d = true;
        block = currentBlock;
        closeBlock();
      }
    }
    if (isArray(s)) {
      const singleChild = filterSingleRoot(s);
      if (!singleChild && s.filter((child) => child !== NULL_DYNAMIC_COMPONENT).length > 0) {
        warn$1(`<Suspense> slots expect a single root node.`);
      }
      s = singleChild;
    }
    s = normalizeVNode(s);
    if (block && !s.dynamicChildren) {
      s.dynamicChildren = block.filter((c) => c !== s);
    }
    return s;
  }
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    let el = branch.el;
    while (!el && branch.component) {
      branch = branch.component.subTree;
      el = branch.el;
    }
    vnode.el = el;
    if (parentComponent && parentComponent.subTree === vnode) {
      parentComponent.vnode.el = el;
      updateHOCHostEl(parentComponent, el);
    }
  }
  function isVNodeSuspensible(vnode) {
    const suspensible = vnode.props && vnode.props.suspensible;
    return suspensible != null && suspensible !== false;
  }
  function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type] || (target[type] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        pauseTracking();
        const reset2 = setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type, args);
        reset2();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    } else if (true) {
      const apiName = toHandlerKey(ErrorTypeStrings$1[type].replace(/ hook$/, ""));
      warn$1(
        `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
      );
    }
  }
  var createHook = (lifecycle) => (hook, target = currentInstance) => {
    if (!isInSSRComponentSetup || lifecycle === "sp") {
      injectHook(lifecycle, (...args) => hook(...args), target);
    }
  };
  var onBeforeMount = createHook("bm");
  var onMounted = createHook("m");
  var onBeforeUpdate = createHook("bu");
  var onUpdated = createHook("u");
  var onBeforeUnmount = createHook("bum");
  var onUnmounted = createHook("um");
  var onServerPrefetch = createHook("sp");
  var onRenderTriggered = createHook(
    "rtg"
  );
  var onRenderTracked = createHook(
    "rtc"
  );
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
      warn$1("Do not use built-in directive ids as custom directive id: " + name);
    }
  }
  function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
      warn$1(`withDirectives can only be used inside render functions.`);
      return vnode;
    }
    const instance = getComponentPublicInstance(currentRenderingInstance);
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
      if (dir) {
        if (isFunction2(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      if (oldBindings) {
        binding.oldValue = oldBindings[i].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  function renderList(source, renderItem, cache2, index) {
    let ret;
    const cached = cache2 && cache2[index];
    if (isArray(source) || isString(source)) {
      ret = new Array(source.length);
      for (let i = 0, l = source.length; i < l; i++) {
        ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
      }
    } else if (typeof source === "number") {
      if (!Number.isInteger(source)) {
        warn$1(`The v-for range expect an integer value but got ${source}.`);
      }
      ret = new Array(source);
      for (let i = 0; i < source; i++) {
        ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
      }
    } else if (isObject(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(
          source,
          (item, i) => renderItem(item, i, void 0, cached && cached[i])
        );
      } else {
        const keys2 = Object.keys(source);
        ret = new Array(keys2.length);
        for (let i = 0, l = keys2.length; i < l; i++) {
          const key = keys2[i];
          ret[i] = renderItem(source[key], key, i, cached && cached[i]);
        }
      }
    } else {
      ret = [];
    }
    if (cache2) {
      cache2[index] = ret;
    }
    return ret;
  }
  function createSlots(slots, dynamicSlots) {
    for (let i = 0; i < dynamicSlots.length; i++) {
      const slot = dynamicSlots[i];
      if (isArray(slot)) {
        for (let j = 0; j < slot.length; j++) {
          slots[slot[j].name] = slot[j].fn;
        }
      } else if (slot) {
        slots[slot.name] = slot.key ? (...args) => {
          const res = slot.fn(...args);
          if (res)
            res.key = slot.key;
          return res;
        } : slot.fn;
      }
    }
    return slots;
  }
  // @__NO_SIDE_EFFECTS__
  function defineComponent(options, extraOptions) {
    return isFunction2(options) ? (
      // #8326: extend call and options.name access are considered side-effects
      // by Rollup, so we have to wrap it in a pure-annotated IIFE.
      /* @__PURE__ */ (() => extend3({ name: options.name }, extraOptions, { setup: options }))()
    ) : options;
  }
  var isAsyncWrapper = (i) => !!i.type.__asyncLoader;
  // @__NO_SIDE_EFFECTS__
  function defineAsyncComponent(source) {
    if (isFunction2(source)) {
      source = { loader: source };
    }
    const {
      loader,
      loadingComponent,
      errorComponent,
      delay = 200,
      timeout,
      // undefined = never times out
      suspensible = true,
      onError: userOnError
    } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = () => {
      retries++;
      pendingRequest = null;
      return load();
    };
    const load = () => {
      let thisRequest;
      return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
        err = err instanceof Error ? err : new Error(String(err));
        if (userOnError) {
          return new Promise((resolve2, reject) => {
            const userRetry = () => resolve2(retry());
            const userFail = () => reject(err);
            userOnError(err, userRetry, userFail, retries + 1);
          });
        } else {
          throw err;
        }
      }).then((comp) => {
        if (thisRequest !== pendingRequest && pendingRequest) {
          return pendingRequest;
        }
        if (!comp) {
          warn$1(
            `Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`
          );
        }
        if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
          comp = comp.default;
        }
        if (comp && !isObject(comp) && !isFunction2(comp)) {
          throw new Error(`Invalid async component load result: ${comp}`);
        }
        resolvedComp = comp;
        return comp;
      }));
    };
    return /* @__PURE__ */ defineComponent({
      name: "AsyncComponentWrapper",
      __asyncLoader: load,
      get __asyncResolved() {
        return resolvedComp;
      },
      setup() {
        const instance = currentInstance;
        if (resolvedComp) {
          return () => createInnerComp(resolvedComp, instance);
        }
        const onError = (err) => {
          pendingRequest = null;
          handleError(
            err,
            instance,
            13,
            !errorComponent
          );
        };
        if (suspensible && instance.suspense || isInSSRComponentSetup) {
          return load().then((comp) => {
            return () => createInnerComp(comp, instance);
          }).catch((err) => {
            onError(err);
            return () => errorComponent ? createVNode(errorComponent, {
              error: err
            }) : null;
          });
        }
        const loaded = ref(false);
        const error2 = ref();
        const delayed = ref(!!delay);
        if (delay) {
          setTimeout(() => {
            delayed.value = false;
          }, delay);
        }
        if (timeout != null) {
          setTimeout(() => {
            if (!loaded.value && !error2.value) {
              const err = new Error(
                `Async component timed out after ${timeout}ms.`
              );
              onError(err);
              error2.value = err;
            }
          }, timeout);
        }
        load().then(() => {
          loaded.value = true;
          if (instance.parent && isKeepAlive(instance.parent.vnode)) {
            instance.parent.effect.dirty = true;
            queueJob(instance.parent.update);
          }
        }).catch((err) => {
          onError(err);
          error2.value = err;
        });
        return () => {
          if (loaded.value && resolvedComp) {
            return createInnerComp(resolvedComp, instance);
          } else if (error2.value && errorComponent) {
            return createVNode(errorComponent, {
              error: error2.value
            });
          } else if (loadingComponent && !delayed.value) {
            return createVNode(loadingComponent);
          }
        };
      }
    });
  }
  function createInnerComp(comp, parent) {
    const { ref: ref2, props, children, ce } = parent.vnode;
    const vnode = createVNode(comp, props, children);
    vnode.ref = ref2;
    vnode.ce = ce;
    delete parent.vnode.ce;
    return vnode;
  }
  function renderSlot(slots, name, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
      if (name !== "default")
        props.name = name;
      return createVNode("slot", props, fallback && fallback());
    }
    let slot = slots[name];
    if (slot && slot.length > 1) {
      warn$1(
        `SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`
      );
      slot = () => [];
    }
    if (slot && slot._c) {
      slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(
      Fragment,
      {
        key: props.key || // slot content array of a dynamic conditional slot may have a branch
        // key attached in the `createSlots` helper, respect that
        validSlotContent && validSlotContent.key || `_${name}`
      },
      validSlotContent || (fallback ? fallback() : []),
      validSlotContent && slots._ === 1 ? 64 : -2
    );
    if (!noSlotted && rendered.scopeId) {
      rendered.slotScopeIds = [rendered.scopeId + "-s"];
    }
    if (slot && slot._c) {
      slot._d = true;
    }
    return rendered;
  }
  function ensureValidVNode(vnodes) {
    return vnodes.some((child) => {
      if (!isVNode(child))
        return true;
      if (child.type === Comment)
        return false;
      if (child.type === Fragment && !ensureValidVNode(child.children))
        return false;
      return true;
    }) ? vnodes : null;
  }
  function toHandlers(obj, preserveCaseIfNecessary) {
    const ret = {};
    if (!isObject(obj)) {
      warn$1(`v-on with no argument expects an object value.`);
      return ret;
    }
    for (const key in obj) {
      ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
    }
    return ret;
  }
  var getPublicInstance = (i) => {
    if (!i)
      return null;
    if (isStatefulComponent(i))
      return getComponentPublicInstance(i);
    return getPublicInstance(i.parent);
  };
  var publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend3(/* @__PURE__ */ Object.create(null), {
      $: (i) => i,
      $el: (i) => i.vnode.el,
      $data: (i) => i.data,
      $props: (i) => true ? shallowReadonly(i.props) : i.props,
      $attrs: (i) => true ? shallowReadonly(i.attrs) : i.attrs,
      $slots: (i) => true ? shallowReadonly(i.slots) : i.slots,
      $refs: (i) => true ? shallowReadonly(i.refs) : i.refs,
      $parent: (i) => getPublicInstance(i.parent),
      $root: (i) => getPublicInstance(i.root),
      $emit: (i) => i.emit,
      $options: (i) => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
      $forceUpdate: (i) => i.f || (i.f = () => {
        i.effect.dirty = true;
        queueJob(i.update);
      }),
      $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
      $watch: (i) => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP
    })
  );
  var isReservedPrefix = (key) => key === "_" || key === "$";
  var hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
  var PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      if (key === "__v_skip") {
        return true;
      }
      const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
      if (key === "__isVue") {
        return true;
      }
      let normalizedProps;
      if (key[0] !== "$") {
        const n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 1:
              return setupState[key];
            case 2:
              return data[key];
            case 4:
              return ctx[key];
            case 3:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          accessCache[key] = 2;
          return data[key];
        } else if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
        ) {
          accessCache[key] = 3;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
          accessCache[key] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance.attrs, "get", "");
          markAttrsAccessed();
        } else if (key === "$slots") {
          track(instance, "get", key);
        }
        return publicGetter(instance);
      } else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) && (cssModule = cssModule[key])
      ) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (
        // global properties
        globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
      ) {
        {
          return globalProperties[key];
        }
      } else if (currentRenderingInstance && (!isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
      // to infinite warning loop
      key.indexOf("__v") !== 0)) {
        if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
          warn$1(
            `Property ${JSON.stringify(
              key
            )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
          );
        } else if (instance === currentRenderingInstance) {
          warn$1(
            `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
          );
        }
      }
    },
    set({ _: instance }, key, value) {
      const { data, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (setupState.__isScriptSetup && hasOwn(setupState, key)) {
        warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
        return false;
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        data[key] = value;
        return true;
      } else if (hasOwn(instance.props, key)) {
        warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        warn$1(
          `Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`
        );
        return false;
      } else {
        if (key in instance.appContext.config.globalProperties) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            value
          });
        } else {
          ctx[key] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx, appContext, propsOptions }
    }, key) {
      let normalizedProps;
      return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
    },
    defineProperty(target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  if (true) {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
      warn$1(
        `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
      );
      return Reflect.ownKeys(target);
    };
  }
  var RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend3(
    {},
    PublicInstanceProxyHandlers,
    {
      get(target, key) {
        if (key === Symbol.unscopables) {
          return;
        }
        return PublicInstanceProxyHandlers.get(target, key, target);
      },
      has(_2, key) {
        const has2 = key[0] !== "_" && !isGloballyAllowed(key);
        if (!has2 && PublicInstanceProxyHandlers.has(_2, key)) {
          warn$1(
            `Property ${JSON.stringify(
              key
            )} should not start with _ which is a reserved prefix for Vue internals.`
          );
        }
        return has2;
      }
    }
  );
  function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
      configurable: true,
      enumerable: false,
      get: () => instance
    });
    Object.keys(publicPropertiesMap).forEach((key) => {
      Object.defineProperty(target, key, {
        configurable: true,
        enumerable: false,
        get: () => publicPropertiesMap[key](instance),
        // intercepted by the proxy so no need for implementation,
        // but needed to prevent set errors
        set: NOOP
      });
    });
    return target;
  }
  function exposePropsOnRenderContext(instance) {
    const {
      ctx,
      propsOptions: [propsOptions]
    } = instance;
    if (propsOptions) {
      Object.keys(propsOptions).forEach((key) => {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => instance.props[key],
          set: NOOP
        });
      });
    }
  }
  function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys(toRaw(setupState)).forEach((key) => {
      if (!setupState.__isScriptSetup) {
        if (isReservedPrefix(key[0])) {
          warn$1(
            `setup() return property ${JSON.stringify(
              key
            )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
          );
          return;
        }
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => setupState[key],
          set: NOOP
        });
      }
    });
  }
  var warnRuntimeUsage = (method) => warn$1(
    `${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
  );
  function defineProps() {
    if (true) {
      warnRuntimeUsage(`defineProps`);
    }
    return null;
  }
  function defineEmits() {
    if (true) {
      warnRuntimeUsage(`defineEmits`);
    }
    return null;
  }
  function defineExpose(exposed) {
    if (true) {
      warnRuntimeUsage(`defineExpose`);
    }
  }
  function defineOptions(options) {
    if (true) {
      warnRuntimeUsage(`defineOptions`);
    }
  }
  function defineSlots() {
    if (true) {
      warnRuntimeUsage(`defineSlots`);
    }
    return null;
  }
  function defineModel() {
    if (true) {
      warnRuntimeUsage("defineModel");
    }
  }
  function withDefaults(props, defaults) {
    if (true) {
      warnRuntimeUsage(`withDefaults`);
    }
    return null;
  }
  function useSlots() {
    return getContext().slots;
  }
  function useAttrs() {
    return getContext().attrs;
  }
  function getContext() {
    const i = getCurrentInstance();
    if (!i) {
      warn$1(`useContext() called without active instance.`);
    }
    return i.setupContext || (i.setupContext = createSetupContext(i));
  }
  function normalizePropsOrEmits(props) {
    return isArray(props) ? props.reduce(
      (normalized, p2) => (normalized[p2] = null, normalized),
      {}
    ) : props;
  }
  function mergeDefaults(raw, defaults) {
    const props = normalizePropsOrEmits(raw);
    for (const key in defaults) {
      if (key.startsWith("__skip"))
        continue;
      let opt = props[key];
      if (opt) {
        if (isArray(opt) || isFunction2(opt)) {
          opt = props[key] = { type: opt, default: defaults[key] };
        } else {
          opt.default = defaults[key];
        }
      } else if (opt === null) {
        opt = props[key] = { default: defaults[key] };
      } else if (true) {
        warn$1(`props default key "${key}" has no corresponding declaration.`);
      }
      if (opt && defaults[`__skip_${key}`]) {
        opt.skipFactory = true;
      }
    }
    return props;
  }
  function mergeModels(a, b) {
    if (!a || !b)
      return a || b;
    if (isArray(a) && isArray(b))
      return a.concat(b);
    return extend3({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
  }
  function createPropsRestProxy(props, excludedKeys) {
    const ret = {};
    for (const key in props) {
      if (!excludedKeys.includes(key)) {
        Object.defineProperty(ret, key, {
          enumerable: true,
          get: () => props[key]
        });
      }
    }
    return ret;
  }
  function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    if (!ctx) {
      warn$1(
        `withAsyncContext called without active current instance. This is likely a bug.`
      );
    }
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if (isPromise(awaitable)) {
      awaitable = awaitable.catch((e) => {
        setCurrentInstance(ctx);
        throw e;
      });
    }
    return [awaitable, () => setCurrentInstance(ctx)];
  }
  function createDuplicateChecker() {
    const cache2 = /* @__PURE__ */ Object.create(null);
    return (type, key) => {
      if (cache2[key]) {
        warn$1(`${type} property "${key}" is already defined in ${cache2[key]}.`);
      } else {
        cache2[key] = type;
      }
    };
  }
  var shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook(options.beforeCreate, instance, "bc");
    }
    const {
      // state
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      // lifecycle
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render: render2,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      // public API
      expose,
      inheritAttrs,
      // assets
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = true ? createDuplicateChecker() : null;
    if (true) {
      const [propsOptions] = instance.propsOptions;
      if (propsOptions) {
        for (const key in propsOptions) {
          checkDuplicateProperties("Props", key);
        }
      }
    }
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction2(methodHandler)) {
          if (true) {
            Object.defineProperty(ctx, key, {
              value: methodHandler.bind(publicThis),
              configurable: true,
              enumerable: true,
              writable: true
            });
          } else {
            ctx[key] = methodHandler.bind(publicThis);
          }
          if (true) {
            checkDuplicateProperties("Methods", key);
          }
        } else if (true) {
          warn$1(
            `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
          );
        }
      }
    }
    if (dataOptions) {
      if (!isFunction2(dataOptions)) {
        warn$1(
          `The data option must be a function. Plain object usage is no longer supported.`
        );
      }
      const data = dataOptions.call(publicThis, publicThis);
      if (isPromise(data)) {
        warn$1(
          `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
        );
      }
      if (!isObject(data)) {
        warn$1(`data() should return an object.`);
      } else {
        instance.data = reactive(data);
        if (true) {
          for (const key in data) {
            checkDuplicateProperties("Data", key);
            if (!isReservedPrefix(key[0])) {
              Object.defineProperty(ctx, key, {
                configurable: true,
                enumerable: true,
                get: () => data[key],
                set: NOOP
              });
            }
          }
        }
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get2 = isFunction2(opt) ? opt.bind(publicThis, publicThis) : isFunction2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        if (get2 === NOOP) {
          warn$1(`Computed property "${key}" has no getter.`);
        }
        const set2 = !isFunction2(opt) && isFunction2(opt.set) ? opt.set.bind(publicThis) : true ? () => {
          warn$1(
            `Write operation failed: computed property "${key}" is readonly.`
          );
        } : NOOP;
        const c = computed2({
          get: get2,
          set: set2
        });
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => c.value,
          set: (v) => c.value = v
        });
        if (true) {
          checkDuplicateProperties("Computed", key);
        }
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render2 && instance.render === NOOP) {
      instance.render = render2;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components)
      instance.components = components;
    if (directives)
      instance.directives = directives;
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef2(injected)) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
      if (true) {
        checkDuplicateProperties("Inject", key);
      }
    }
  }
  function callHook(hook, instance, type) {
    callWithAsyncErrorHandling(
      isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type
    );
  }
  function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString(raw)) {
      const handler = ctx[raw];
      if (isFunction2(handler)) {
        watch(getter, handler);
      } else if (true) {
        warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
      }
    } else if (isFunction2(raw)) {
      watch(getter, raw.bind(publicThis));
    } else if (isObject(raw)) {
      if (isArray(raw)) {
        raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
      } else {
        const handler = isFunction2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction2(handler)) {
          watch(getter, handler, raw);
        } else if (true) {
          warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
      }
    } else if (true) {
      warn$1(`Invalid watch option: "${key}"`, raw);
    }
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
      mixins: globalMixins,
      optionsCache: cache2,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache2.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
        );
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    if (isObject(base)) {
      cache2.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m) => mergeOptions(to, m, strats, true)
      );
    }
    for (const key in from) {
      if (asMixin && key === "expose") {
        warn$1(
          `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
        );
      } else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
      }
    }
    return to;
  }
  var internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return extend3(
        isFunction2(to) ? to.call(this, this) : to,
        isFunction2(from) ? from.call(this, this) : from
      );
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray(raw)) {
      const res = {};
      for (let i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend3(/* @__PURE__ */ Object.create(null), to, from) : from;
  }
  function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
      if (isArray(to) && isArray(from)) {
        return [.../* @__PURE__ */ new Set([...to, ...from])];
      }
      return extend3(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to),
        normalizePropsOrEmits(from != null ? from : {})
      );
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to, from) {
    if (!to)
      return from;
    if (!from)
      return to;
    const merged = extend3(/* @__PURE__ */ Object.create(null), to);
    for (const key in from) {
      merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  var uid$1 = 0;
  function createAppAPI(render2, hydrate2) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction2(rootComponent)) {
        rootComponent = extend3({}, rootComponent);
      }
      if (rootProps != null && !isObject(rootProps)) {
        warn$1(`root props passed to app.mount() must be an object.`);
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = /* @__PURE__ */ new WeakSet();
      let isMounted = false;
      const app = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v) {
          if (true) {
            warn$1(
              `app.config cannot be replaced. Modify individual options instead.`
            );
          }
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) {
            warn$1(`Plugin has already been applied to target app.`);
          } else if (plugin && isFunction2(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options);
          } else if (isFunction2(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options);
          } else if (true) {
            warn$1(
              `A plugin must either be a function or an object with an "install" function.`
            );
          }
          return app;
        },
        mixin(mixin) {
          if (__VUE_OPTIONS_API__) {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            } else if (true) {
              warn$1(
                "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
              );
            }
          } else if (true) {
            warn$1("Mixins are only available in builds supporting Options API");
          }
          return app;
        },
        component(name, component) {
          if (true) {
            validateComponentName(name, context.config);
          }
          if (!component) {
            return context.components[name];
          }
          if (context.components[name]) {
            warn$1(`Component "${name}" has already been registered in target app.`);
          }
          context.components[name] = component;
          return app;
        },
        directive(name, directive) {
          if (true) {
            validateDirectiveName(name);
          }
          if (!directive) {
            return context.directives[name];
          }
          if (context.directives[name]) {
            warn$1(`Directive "${name}" has already been registered in target app.`);
          }
          context.directives[name] = directive;
          return app;
        },
        mount(rootContainer, isHydrate, namespace) {
          if (!isMounted) {
            if (rootContainer.__vue_app__) {
              warn$1(
                `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
              );
            }
            const vnode = createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (namespace === true) {
              namespace = "svg";
            } else if (namespace === false) {
              namespace = void 0;
            }
            if (true) {
              context.reload = () => {
                render2(
                  cloneVNode(vnode),
                  rootContainer,
                  namespace
                );
              };
            }
            if (isHydrate && hydrate2) {
              hydrate2(vnode, rootContainer);
            } else {
              render2(vnode, rootContainer, namespace);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            if (true) {
              app._instance = vnode.component;
              devtoolsInitApp(app, version);
            }
            return getComponentPublicInstance(vnode.component);
          } else if (true) {
            warn$1(
              `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
            );
          }
        },
        unmount() {
          if (isMounted) {
            render2(null, app._container);
            if (true) {
              app._instance = null;
              devtoolsUnmountApp(app);
            }
            delete app._container.__vue_app__;
          } else if (true) {
            warn$1(`Cannot unmount an app that is not mounted.`);
          }
        },
        provide(key, value) {
          if (key in context.provides) {
            warn$1(
              `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
            );
          }
          context.provides[key] = value;
          return app;
        },
        runWithContext(fn) {
          const lastApp = currentApp;
          currentApp = app;
          try {
            return fn();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app;
    };
  }
  var currentApp = null;
  function provide(key, value) {
    if (!currentInstance) {
      if (true) {
        warn$1(`provide() can only be used inside setup().`);
      }
    } else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else if (true) {
        warn$1(`injection "${String(key)}" not found.`);
      }
    } else if (true) {
      warn$1(`inject() can only be used inside setup() or functional components.`);
    }
  }
  function hasInjectionContext() {
    return !!(currentInstance || currentRenderingInstance || currentApp);
  }
  var internalObjectProto = {};
  var createInternalObject = () => Object.create(internalObjectProto);
  var isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = createInternalObject();
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (true) {
      validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function isInHmrContext(instance) {
    while (instance) {
      if (instance.type.__hmrId)
        return true;
      instance = instance.parent;
    }
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
      // always force full diff in dev
      // - #1942 if hmr is enabled with sfc component
      // - vite#872 non-sfc component used by sfc component
      !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)
    ) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i = 0; i < propsToUpdate.length; i++) {
          let key = propsToUpdate[i];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options) {
            if (hasOwn(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize2(key);
              props[camelizedKey] = resolvePropValue(
                options,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || // for camelCase
        !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && // for camelCase
            (rawPrevProps[key] !== void 0 || // for kebab-case
            rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(
                options,
                rawCurrentProps,
                key,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn(rawProps, key) && true) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance.attrs, "set", "");
    }
    if (true) {
      validateProps(rawProps || {}, props, instance);
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn(options, camelKey = camelize2(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i = 0; i < needCastKeys.length; i++) {
        const key = needCastKeys[i];
        props[key] = resolvePropValue(
          options,
          rawCurrentProps,
          key,
          castValues[key],
          instance,
          !hasOwn(castValues, key)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction2(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            const reset2 = setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(
              null,
              props
            );
            reset2();
          }
        } else {
          value = defaultValue;
        }
      }
      if (opt[
        0
        /* shouldCast */
      ]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[
          1
          /* shouldCastTrue */
        ] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache2 = appContext.propsCache;
    const cached = cache2.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !isFunction2(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
        extend3(normalized, props);
        if (keys2)
          needCastKeys.push(...keys2);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject(comp)) {
        cache2.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray(raw)) {
      for (let i = 0; i < raw.length; i++) {
        if (!isString(raw[i])) {
          warn$1(`props must be strings when using array syntax.`, raw[i]);
        }
        const normalizedKey = camelize2(raw[i]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      if (!isObject(raw)) {
        warn$1(`invalid props options`, raw);
      }
      for (const key in raw) {
        const normalizedKey = camelize2(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray(opt) || isFunction2(opt) ? { type: opt } : extend3({}, opt);
          if (prop) {
            const booleanIndex = getTypeIndex(Boolean, prop.type);
            const stringIndex = getTypeIndex(String, prop.type);
            prop[
              0
              /* shouldCast */
            ] = booleanIndex > -1;
            prop[
              1
              /* shouldCastTrue */
            ] = stringIndex < 0 || booleanIndex < stringIndex;
            if (booleanIndex > -1 || hasOwn(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject(comp)) {
      cache2.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$" && !isReservedProp(key)) {
      return true;
    } else if (true) {
      warn$1(`Invalid prop name: "${key}" is a reserved property.`);
    }
    return false;
  }
  function getType(ctor) {
    if (ctor === null) {
      return "null";
    }
    if (typeof ctor === "function") {
      return ctor.name || "";
    } else if (typeof ctor === "object") {
      const name = ctor.constructor && ctor.constructor.name;
      return name || "";
    }
    return "";
  }
  function isSameType(a, b) {
    return getType(a) === getType(b);
  }
  function getTypeIndex(type, expectedTypes) {
    if (isArray(expectedTypes)) {
      return expectedTypes.findIndex((t) => isSameType(t, type));
    } else if (isFunction2(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
  }
  function validateProps(rawProps, props, instance) {
    const resolvedValues = toRaw(props);
    const options = instance.propsOptions[0];
    for (const key in options) {
      let opt = options[key];
      if (opt == null)
        continue;
      validateProp(
        key,
        resolvedValues[key],
        opt,
        true ? shallowReadonly(resolvedValues) : resolvedValues,
        !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key))
      );
    }
  }
  function validateProp(name, value, prop, props, isAbsent) {
    const { type, required, validator, skipCheck } = prop;
    if (required && isAbsent) {
      warn$1('Missing required prop: "' + name + '"');
      return;
    }
    if (value == null && !required) {
      return;
    }
    if (type != null && type !== true && !skipCheck) {
      let isValid = false;
      const types = isArray(type) ? type : [type];
      const expectedTypes = [];
      for (let i = 0; i < types.length && !isValid; i++) {
        const { valid, expectedType } = assertType(value, types[i]);
        expectedTypes.push(expectedType || "");
        isValid = valid;
      }
      if (!isValid) {
        warn$1(getInvalidTypeMessage(name, value, expectedTypes));
        return;
      }
    }
    if (validator && !validator(value, props)) {
      warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
  }
  var isSimpleType = /* @__PURE__ */ makeMap(
    "String,Number,Boolean,Function,Symbol,BigInt"
  );
  function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
      const t = typeof value;
      valid = t === expectedType.toLowerCase();
      if (!valid && t === "object") {
        valid = value instanceof type;
      }
    } else if (expectedType === "Object") {
      valid = isObject(value);
    } else if (expectedType === "Array") {
      valid = isArray(value);
    } else if (expectedType === "null") {
      valid = value === null;
    } else {
      valid = value instanceof type;
    }
    return {
      valid,
      expectedType
    };
  }
  function getInvalidTypeMessage(name, value, expectedTypes) {
    if (expectedTypes.length === 0) {
      return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
    }
    let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize2).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = toRawType(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
      message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    if (isExplicable(receivedType)) {
      message += `with value ${receivedValue}.`;
    }
    return message;
  }
  function styleValue(value, type) {
    if (type === "String") {
      return `"${value}"`;
    } else if (type === "Number") {
      return `${Number(value)}`;
    } else {
      return `${value}`;
    }
  }
  function isExplicable(type) {
    const explicitTypes = ["string", "number", "boolean"];
    return explicitTypes.some((elem) => type.toLowerCase() === elem);
  }
  function isBoolean(...args) {
    return args.some((elem) => elem.toLowerCase() === "boolean");
  }
  var isInternalKey = (key) => key[0] === "_" || key === "$stable";
  var normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  var normalizeSlot = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (currentInstance && (!ctx || ctx.root === currentInstance.root)) {
        warn$1(
          `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
        );
      }
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  var normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key))
        continue;
      const value = rawSlots[key];
      if (isFunction2(value)) {
        slots[key] = normalizeSlot(key, value, ctx);
      } else if (value != null) {
        if (true) {
          warn$1(
            `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
          );
        }
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  var normalizeVNodeSlots = (instance, children) => {
    if (!isKeepAlive(instance.vnode) && true) {
      warn$1(
        `Non-function value encountered for default slot. Prefer function slots for better performance.`
      );
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  var initSlots = (instance, children) => {
    const slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        extend3(slots, children);
        def(slots, "_", type, true);
      } else {
        normalizeObjectSlots(children, slots);
      }
    } else if (children) {
      normalizeVNodeSlots(instance, children);
    }
  };
  var updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        if (isHmrUpdating) {
          extend3(slots, children);
          trigger(instance, "set", "$slots");
        } else if (optimized && type === 1) {
          needDeletionCheck = false;
        } else {
          extend3(slots, children);
          if (!optimized && type === 1) {
            delete slots._;
          }
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
          delete slots[key];
        }
      }
    }
  };
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray(rawRef)) {
      rawRef.forEach(
        (r, i) => setRef(
          r,
          oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref2 } = rawRef;
    if (!owner) {
      warn$1(
        `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
      );
      return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref2) {
      if (isString(oldRef)) {
        refs[oldRef] = null;
        if (hasOwn(setupState, oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef2(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction2(ref2)) {
      callWithErrorHandling(ref2, owner, 12, [value, refs]);
    } else {
      const _isString = isString(ref2);
      const _isRef = isRef2(ref2);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
            if (isUnmount) {
              isArray(existing) && remove(existing, refValue);
            } else {
              if (!isArray(existing)) {
                if (_isString) {
                  refs[ref2] = [refValue];
                  if (hasOwn(setupState, ref2)) {
                    setupState[ref2] = refs[ref2];
                  }
                } else {
                  ref2.value = [refValue];
                  if (rawRef.k)
                    refs[rawRef.k] = ref2.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref2] = value;
            if (hasOwn(setupState, ref2)) {
              setupState[ref2] = value;
            }
          } else if (_isRef) {
            ref2.value = value;
            if (rawRef.k)
              refs[rawRef.k] = value;
          } else if (true) {
            warn$1("Invalid template ref type:", ref2, `(${typeof ref2})`);
          }
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      } else if (true) {
        warn$1("Invalid template ref type:", ref2, `(${typeof ref2})`);
      }
    }
  }
  var hasLoggedMismatchError = false;
  var logMismatchError = () => {
    if (hasLoggedMismatchError) {
      return;
    }
    console.error("Hydration completed but contains mismatches.");
    hasLoggedMismatchError = true;
  };
  var isSVGContainer = (container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
  var isMathMLContainer = (container) => container.namespaceURI.includes("MathML");
  var getContainerType = (container) => {
    if (isSVGContainer(container))
      return "svg";
    if (isMathMLContainer(container))
      return "mathml";
    return void 0;
  };
  var isComment = (node) => node.nodeType === 8;
  function createHydrationFunctions(rendererInternals) {
    const {
      mt: mountComponent,
      p: patch,
      o: {
        patchProp: patchProp2,
        createText,
        nextSibling,
        parentNode,
        remove: remove2,
        insert,
        createComment
      }
    } = rendererInternals;
    const hydrate2 = (vnode, container) => {
      if (!container.hasChildNodes()) {
        warn$1(
          `Attempting to hydrate existing markup but container is empty. Performing full mount instead.`
        );
        patch(null, vnode, container);
        flushPostFlushCbs();
        container._vnode = vnode;
        return;
      }
      hydrateNode(container.firstChild, vnode, null, null, null);
      flushPostFlushCbs();
      container._vnode = vnode;
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
      optimized = optimized || !!vnode.dynamicChildren;
      const isFragmentStart = isComment(node) && node.data === "[";
      const onMismatch = () => handleMismatch(
        node,
        vnode,
        parentComponent,
        parentSuspense,
        slotScopeIds,
        isFragmentStart
      );
      const { type, ref: ref2, shapeFlag, patchFlag } = vnode;
      let domType = node.nodeType;
      vnode.el = node;
      if (true) {
        def(node, "__vnode", vnode, true);
        def(node, "__vueParentComponent", parentComponent, true);
      }
      if (patchFlag === -2) {
        optimized = false;
        vnode.dynamicChildren = null;
      }
      let nextNode = null;
      switch (type) {
        case Text:
          if (domType !== 3) {
            if (vnode.children === "") {
              insert(vnode.el = createText(""), parentNode(node), node);
              nextNode = node;
            } else {
              nextNode = onMismatch();
            }
          } else {
            if (node.data !== vnode.children) {
              warn$1(
                `Hydration text mismatch in`,
                node.parentNode,
                `
  - rendered on server: ${JSON.stringify(
                  node.data
                )}
  - expected on client: ${JSON.stringify(vnode.children)}`
              );
              logMismatchError();
              node.data = vnode.children;
            }
            nextNode = nextSibling(node);
          }
          break;
        case Comment:
          if (isTemplateNode2(node)) {
            nextNode = nextSibling(node);
            replaceNode(
              vnode.el = node.content.firstChild,
              node,
              parentComponent
            );
          } else if (domType !== 8 || isFragmentStart) {
            nextNode = onMismatch();
          } else {
            nextNode = nextSibling(node);
          }
          break;
        case Static:
          if (isFragmentStart) {
            node = nextSibling(node);
            domType = node.nodeType;
          }
          if (domType === 1 || domType === 3) {
            nextNode = node;
            const needToAdoptContent = !vnode.children.length;
            for (let i = 0; i < vnode.staticCount; i++) {
              if (needToAdoptContent)
                vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
              if (i === vnode.staticCount - 1) {
                vnode.anchor = nextNode;
              }
              nextNode = nextSibling(nextNode);
            }
            return isFragmentStart ? nextSibling(nextNode) : nextNode;
          } else {
            onMismatch();
          }
          break;
        case Fragment:
          if (!isFragmentStart) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateFragment(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
          break;
        default:
          if (shapeFlag & 1) {
            if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode2(node)) {
              nextNode = onMismatch();
            } else {
              nextNode = hydrateElement(
                node,
                vnode,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
            }
          } else if (shapeFlag & 6) {
            vnode.slotScopeIds = slotScopeIds;
            const container = parentNode(node);
            if (isFragmentStart) {
              nextNode = locateClosingAnchor(node);
            } else if (isComment(node) && node.data === "teleport start") {
              nextNode = locateClosingAnchor(node, node.data, "teleport end");
            } else {
              nextNode = nextSibling(node);
            }
            mountComponent(
              vnode,
              container,
              null,
              parentComponent,
              parentSuspense,
              getContainerType(container),
              optimized
            );
            if (isAsyncWrapper(vnode)) {
              let subTree;
              if (isFragmentStart) {
                subTree = createVNode(Fragment);
                subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
              } else {
                subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
              }
              subTree.el = node;
              vnode.component.subTree = subTree;
            }
          } else if (shapeFlag & 64) {
            if (domType !== 8) {
              nextNode = onMismatch();
            } else {
              nextNode = vnode.type.hydrate(
                node,
                vnode,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized,
                rendererInternals,
                hydrateChildren
              );
            }
          } else if (shapeFlag & 128) {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              getContainerType(parentNode(node)),
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateNode
            );
          } else if (true) {
            warn$1("Invalid HostVNode type:", type, `(${typeof type})`);
          }
      }
      if (ref2 != null) {
        setRef(ref2, null, parentSuspense, vnode);
      }
      return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
      optimized = optimized || !!vnode.dynamicChildren;
      const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
      const forcePatch = type === "input" || type === "option";
      if (true) {
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        let needCallTransitionHooks = false;
        if (isTemplateNode2(el)) {
          needCallTransitionHooks = needTransition(parentSuspense, transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
          const content = el.content.firstChild;
          if (needCallTransitionHooks) {
            transition.beforeEnter(content);
          }
          replaceNode(content, el, parentComponent);
          vnode.el = el = content;
        }
        if (shapeFlag & 16 && // skip if element has innerHTML / textContent
        !(props && (props.innerHTML || props.textContent))) {
          let next = hydrateChildren(
            el.firstChild,
            vnode,
            el,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
          let hasWarned2 = false;
          while (next) {
            if (!hasWarned2) {
              warn$1(
                `Hydration children mismatch on`,
                el,
                `
Server rendered element contains more child nodes than client vdom.`
              );
              hasWarned2 = true;
            }
            logMismatchError();
            const cur = next;
            next = next.nextSibling;
            remove2(cur);
          }
        } else if (shapeFlag & 8) {
          if (el.textContent !== vnode.children) {
            warn$1(
              `Hydration text content mismatch on`,
              el,
              `
  - rendered on server: ${el.textContent}
  - expected on client: ${vnode.children}`
            );
            logMismatchError();
            el.textContent = vnode.children;
          }
        }
        if (props) {
          if (true) {
            for (const key in props) {
              if (// #11189 skip if this node has directives that have created hooks
              // as it could have mutated the DOM in any possible way
              !(dirs && dirs.some((d) => d.dir.created)) && propHasMismatch(el, key, props[key], vnode, parentComponent)) {
                logMismatchError();
              }
              if (forcePatch && (key.endsWith("value") || key === "indeterminate") || isOn(key) && !isReservedProp(key) || // force hydrate v-bind with .prop modifiers
              key[0] === ".") {
                patchProp2(
                  el,
                  key,
                  null,
                  props[key],
                  void 0,
                  void 0,
                  parentComponent
                );
              }
            }
          } else if (props.onClick) {
            patchProp2(
              el,
              "onClick",
              null,
              props.onClick,
              void 0,
              void 0,
              parentComponent
            );
          }
        }
        let vnodeHooks;
        if (vnodeHooks = props && props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHooks, parentComponent, vnode);
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
          queueEffectWithSuspense(() => {
            vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      }
      return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
      optimized = optimized || !!parentVNode.dynamicChildren;
      const children = parentVNode.children;
      const l = children.length;
      let hasWarned2 = false;
      for (let i = 0; i < l; i++) {
        const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
        if (node) {
          node = hydrateNode(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        } else if (vnode.type === Text && !vnode.children) {
          insert(vnode.el = createText(""), container);
        } else {
          if (!hasWarned2) {
            warn$1(
              `Hydration children mismatch on`,
              container,
              `
Server rendered element contains fewer child nodes than client vdom.`
            );
            hasWarned2 = true;
          }
          logMismatchError();
          patch(
            null,
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            getContainerType(container),
            slotScopeIds
          );
        }
      }
      return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
      const { slotScopeIds: fragmentSlotScopeIds } = vnode;
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      const container = parentNode(node);
      const next = hydrateChildren(
        nextSibling(node),
        vnode,
        container,
        parentComponent,
        parentSuspense,
        slotScopeIds,
        optimized
      );
      if (next && isComment(next) && next.data === "]") {
        return nextSibling(vnode.anchor = next);
      } else {
        logMismatchError();
        insert(vnode.anchor = createComment(`]`), container, next);
        return next;
      }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
      warn$1(
        `Hydration node mismatch:
- rendered on server:`,
        node,
        node.nodeType === 3 ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``,
        `
- expected on client:`,
        vnode.type
      );
      logMismatchError();
      vnode.el = null;
      if (isFragment) {
        const end = locateClosingAnchor(node);
        while (true) {
          const next2 = nextSibling(node);
          if (next2 && next2 !== end) {
            remove2(next2);
          } else {
            break;
          }
        }
      }
      const next = nextSibling(node);
      const container = parentNode(node);
      remove2(node);
      patch(
        null,
        vnode,
        container,
        next,
        parentComponent,
        parentSuspense,
        getContainerType(container),
        slotScopeIds
      );
      return next;
    };
    const locateClosingAnchor = (node, open = "[", close = "]") => {
      let match = 0;
      while (node) {
        node = nextSibling(node);
        if (node && isComment(node)) {
          if (node.data === open)
            match++;
          if (node.data === close) {
            if (match === 0) {
              return nextSibling(node);
            } else {
              match--;
            }
          }
        }
      }
      return node;
    };
    const replaceNode = (newNode, oldNode, parentComponent) => {
      const parentNode2 = oldNode.parentNode;
      if (parentNode2) {
        parentNode2.replaceChild(newNode, oldNode);
      }
      let parent = parentComponent;
      while (parent) {
        if (parent.vnode.el === oldNode) {
          parent.vnode.el = parent.subTree.el = newNode;
        }
        parent = parent.parent;
      }
    };
    const isTemplateNode2 = (node) => {
      return node.nodeType === 1 && node.tagName.toLowerCase() === "template";
    };
    return [hydrate2, hydrateNode];
  }
  function propHasMismatch(el, key, clientValue, vnode, instance) {
    let mismatchType;
    let mismatchKey;
    let actual;
    let expected;
    if (key === "class") {
      actual = el.getAttribute("class");
      expected = normalizeClass(clientValue);
      if (!isSetEqual(toClassSet(actual || ""), toClassSet(expected))) {
        mismatchType = mismatchKey = `class`;
      }
    } else if (key === "style") {
      actual = el.getAttribute("style") || "";
      expected = isString(clientValue) ? clientValue : stringifyStyle(normalizeStyle(clientValue));
      const actualMap = toStyleMap(actual);
      const expectedMap = toStyleMap(expected);
      if (vnode.dirs) {
        for (const { dir, value } of vnode.dirs) {
          if (dir.name === "show" && !value) {
            expectedMap.set("display", "none");
          }
        }
      }
      if (instance) {
        resolveCssVars(instance, vnode, expectedMap);
      }
      if (!isMapEqual(actualMap, expectedMap)) {
        mismatchType = mismatchKey = "style";
      }
    } else if (el instanceof SVGElement && isKnownSvgAttr(key) || el instanceof HTMLElement && (isBooleanAttr(key) || isKnownHtmlAttr(key))) {
      if (isBooleanAttr(key)) {
        actual = el.hasAttribute(key);
        expected = includeBooleanAttr(clientValue);
      } else if (clientValue == null) {
        actual = el.hasAttribute(key);
        expected = false;
      } else {
        if (el.hasAttribute(key)) {
          actual = el.getAttribute(key);
        } else if (key === "value" && el.tagName === "TEXTAREA") {
          actual = el.value;
        } else {
          actual = false;
        }
        expected = isRenderableAttrValue(clientValue) ? String(clientValue) : false;
      }
      if (actual !== expected) {
        mismatchType = `attribute`;
        mismatchKey = key;
      }
    }
    if (mismatchType) {
      const format = (v) => v === false ? `(not rendered)` : `${mismatchKey}="${v}"`;
      const preSegment = `Hydration ${mismatchType} mismatch on`;
      const postSegment = `
  - rendered on server: ${format(actual)}
  - expected on client: ${format(expected)}
  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
  You should fix the source of the mismatch.`;
      {
        warn$1(preSegment, el, postSegment);
      }
      return true;
    }
    return false;
  }
  function toClassSet(str) {
    return new Set(str.trim().split(/\s+/));
  }
  function isSetEqual(a, b) {
    if (a.size !== b.size) {
      return false;
    }
    for (const s of a) {
      if (!b.has(s)) {
        return false;
      }
    }
    return true;
  }
  function toStyleMap(str) {
    const styleMap = /* @__PURE__ */ new Map();
    for (const item of str.split(";")) {
      let [key, value] = item.split(":");
      key = key.trim();
      value = value && value.trim();
      if (key && value) {
        styleMap.set(key, value);
      }
    }
    return styleMap;
  }
  function isMapEqual(a, b) {
    if (a.size !== b.size) {
      return false;
    }
    for (const [key, value] of a) {
      if (value !== b.get(key)) {
        return false;
      }
    }
    return true;
  }
  function resolveCssVars(instance, vnode, expectedMap) {
    const root = instance.subTree;
    if (instance.getCssVars && (vnode === root || root && root.type === Fragment && root.children.includes(vnode))) {
      const cssVars = instance.getCssVars();
      for (const key in cssVars) {
        expectedMap.set(`--${key}`, String(cssVars[key]));
      }
    }
    if (vnode === root && instance.parent) {
      resolveCssVars(instance.parent, instance.vnode, expectedMap);
    }
  }
  var supported;
  var perf;
  function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
      perf.mark(`vue-${type}-${instance.uid}`);
    }
    if (true) {
      devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
    }
  }
  function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
      const startTag = `vue-${type}-${instance.uid}`;
      const endTag = startTag + `:end`;
      perf.mark(endTag);
      perf.measure(
        `<${formatComponentName(instance, instance.type)}> ${type}`,
        startTag,
        endTag
      );
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
    }
    if (true) {
      devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
    }
  }
  function isSupported() {
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function initFeatureFlags() {
    const needWarn = [];
    if (typeof __VUE_OPTIONS_API__ !== "boolean") {
      needWarn.push(`__VUE_OPTIONS_API__`);
      getGlobalThis().__VUE_OPTIONS_API__ = true;
    }
    if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {
      needWarn.push(`__VUE_PROD_DEVTOOLS__`);
      getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== "boolean") {
      needWarn.push(`__VUE_PROD_HYDRATION_MISMATCH_DETAILS__`);
      getGlobalThis().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
    }
    if (needWarn.length) {
      const multi = needWarn.length > 1;
      console.warn(
        `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
      );
    }
  }
  var queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    {
      initFeatureFlags();
    }
    const target = getGlobalThis();
    target.__VUE__ = true;
    if (true) {
      setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type, ref: ref2, shapeFlag } = n2;
      switch (type) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace);
          } else if (true) {
            patchStaticNode(n1, n2, container, namespace);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (true) {
            warn$1("Invalid VNode type:", type, `(${typeof type})`);
          }
      }
      if (ref2 != null && parentComponent) {
        setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateText(n2.children),
          container,
          anchor
        );
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateComment(n2.children || ""),
          container,
          anchor
        );
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, namespace) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace,
        n2.el,
        n2.anchor
      );
    };
    const patchStaticNode = (n1, n2, container, namespace) => {
      if (n2.children !== n1.children) {
        const anchor = hostNextSibling(n1.anchor);
        removeStaticNode(n1);
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace
        );
      } else {
        n2.el = n1.el;
        n2.anchor = n1.anchor;
      }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      if (n2.type === "svg") {
        namespace = "svg";
      } else if (n2.type === "math") {
        namespace = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { props, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(
        vnode.type,
        namespace,
        props && props.is,
        props
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(
              el,
              key,
              null,
              props[key],
              namespace,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value, namespace);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      if (true) {
        def(el, "__vnode", vnode, true);
        def(el, "__vueParentComponent", parentComponent, true);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i = 0; i < slotScopeIds.length; i++) {
          hostSetScopeId(el, slotScopeIds[i]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
          subTree = filterSingleRoot(subTree.children) || subTree;
        }
        if (vnode === subTree) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start2 = 0) => {
      for (let i = start2; i < children.length; i++) {
        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      if (true) {
        el.__vnode = n2;
      }
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (isHmrUpdating) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds
        );
        if (true) {
          traverseStaticChildren(n1, n2);
        }
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(
            el,
            n2,
            oldProps,
            newProps,
            parentComponent,
            parentSuspense,
            namespace
          );
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              const key = propsToUpdate[i];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(
                  el,
                  key,
                  prev,
                  next,
                  namespace,
                  n1.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          namespace
        );
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
      for (let i = 0; i < newChildren.length; i++) {
        const oldVNode = oldChildren[i];
        const newVNode = newChildren[i];
        const container = (
          // oldVNode may be an errored async setup() component inside Suspense
          // which will not have a mounted element
          oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
          // of the Fragment itself so it can move its children.
          (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
          // which also requires the correct parent container
          !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
          oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
            // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer
          )
        );
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(
                el,
                key,
                oldProps[key],
                null,
                namespace,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
        for (const key in newProps) {
          if (isReservedProp(key))
            continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(
              el,
              key,
              prev,
              next,
              namespace,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (
        // #5523 dev root fragment may inherit directives
        isHmrUpdating || patchFlag & 2048
      ) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(
          // #10007
          // such fragment like `<></>` will be compiled into
          // a fragment which doesn't have a children.
          // In this case fallback to an empty array
          n2.children || [],
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          if (true) {
            traverseStaticChildren(n1, n2);
          } else if (
            // #2080 if the stable fragment has a key, it's a <template v-for> that may
            //  get moved around. Make sure all root level vnodes inherit el.
            // #2134 or if it's a component root, it may also get moved around
            // as the component is being moved.
            n2.key != null || parentComponent && n2 === parentComponent.subTree
          ) {
            traverseStaticChildren(
              n1,
              n2,
              true
              /* shallow */
            );
          }
        } else {
          patchChildren(
            n1,
            n2,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n2,
            container,
            anchor,
            namespace,
            optimized
          );
        } else {
          mountComponent(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            optimized
          );
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
      const instance = initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      );
      if (instance.type.__hmrId) {
        registerHMR(instance);
      }
      if (true) {
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
      }
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        if (true) {
          startMeasure(instance, `init`);
        }
        setupComponent(instance);
        if (true) {
          endMeasure(instance, `init`);
        }
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace,
          optimized
        );
      }
      if (true) {
        popWarningContext();
        endMeasure(instance, `mount`);
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          if (true) {
            pushWarningContext(n2);
          }
          updateComponentPreRender(instance, n2, optimized);
          if (true) {
            popWarningContext();
          }
          return;
        } else {
          instance.next = n2;
          invalidateJob(instance.update);
          instance.effect.dirty = true;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m, parent } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          if (el && hydrateNode) {
            const hydrateSubTree = () => {
              if (true) {
                startMeasure(instance, `render`);
              }
              instance.subTree = renderComponentRoot(instance);
              if (true) {
                endMeasure(instance, `render`);
              }
              if (true) {
                startMeasure(instance, `hydrate`);
              }
              hydrateNode(
                el,
                instance.subTree,
                instance,
                parentSuspense,
                null
              );
              if (true) {
                endMeasure(instance, `hydrate`);
              }
            };
            if (isAsyncWrapperVNode) {
              initialVNode.type.__asyncLoader().then(
                // note: we are moving the render call into an async callback,
                // which means it won't track dependencies - but it's ok because
                // a server-rendered async wrapper is already in resolved state
                // and it will never need to change.
                () => !instance.isUnmounted && hydrateSubTree()
              );
            } else {
              hydrateSubTree();
            }
          } else {
            if (true) {
              startMeasure(instance, `render`);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            if (true) {
              endMeasure(instance, `render`);
            }
            if (true) {
              startMeasure(instance, `patch`);
            }
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace
            );
            if (true) {
              endMeasure(instance, `patch`);
            }
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          if (true) {
            devtoolsComponentAdded(instance);
          }
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u, parent, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next;
          let vnodeHook;
          if (true) {
            pushWarningContext(next || instance.vnode);
          }
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          toggleRecurse(instance, true);
          if (true) {
            startMeasure(instance, `render`);
          }
          const nextTree = renderComponentRoot(instance);
          if (true) {
            endMeasure(instance, `render`);
          }
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          if (true) {
            startMeasure(instance, `patch`);
          }
          patch(
            prevTree,
            nextTree,
            // parent may have changed if it's in a teleport
            hostParentNode(prevTree.el),
            // anchor may have changed if it's in a fragment
            getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace
          );
          if (true) {
            endMeasure(instance, `patch`);
          }
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, next, vnode),
              parentSuspense
            );
          }
          if (true) {
            devtoolsComponentUpdated(instance);
          }
          if (true) {
            popWarningContext();
          }
        }
      };
      const effect2 = instance.effect = new ReactiveEffect(
        componentUpdateFn,
        NOOP,
        () => queueJob(update),
        instance.scope
        // track it in component's effect scope
      );
      const update = instance.update = () => {
        if (effect2.dirty) {
          effect2.run();
        }
      };
      update.id = instance.uid;
      toggleRecurse(instance, true);
      if (true) {
        effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
        effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
        update.ownerInstance = instance;
      }
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i;
      for (i = 0; i < commonLength; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        patch(
          c1[i],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let i = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i <= e1 && i <= e2) {
        const n1 = c1[i];
        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i > e1) {
        if (i <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i <= e2) {
            patch(
              null,
              c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            i++;
          }
        }
      } else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        const s1 = i;
        const s2 = i;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i = s2; i <= e2; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (nextChild.key != null) {
            if (keyToNewIndexMap.has(nextChild.key)) {
              warn$1(
                `Duplicate keys found during update:`,
                JSON.stringify(nextChild.key),
                `Make sure keys are unique.`
              );
            }
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        let j;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++)
          newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          const prevChild = c1[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e2; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c2[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          const nextIndex = s2 + i;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(nextChild, container, anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type.move(vnode, container, anchor, internals);
        return;
      }
      if (type === Fragment) {
        hostInsert(el, container, anchor);
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type,
        props,
        ref: ref2,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs,
        memoIndex
      } = vnode;
      if (patchFlag === -2) {
        optimized = false;
      }
      if (ref2 != null) {
        setRef(ref2, null, parentSuspense, vnode, true);
      }
      if (memoIndex != null) {
        parentComponent.renderCache[memoIndex] = void 0;
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            internals,
            doRemove
          );
        } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
        (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type, el, anchor, transition } = vnode;
      if (type === Fragment) {
        if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
          vnode.children.forEach((child) => {
            if (child.type === Comment) {
              hostRemove(child.el);
            } else {
              remove2(child);
            }
          });
        } else {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      if (instance.type.__hmrId) {
        unregisterHMR(instance);
      }
      const { bum, scope, update, subTree, um, m, a } = instance;
      invalidateMount(m);
      invalidateMount(a);
      if (bum) {
        invokeArrayFns(bum);
      }
      scope.stop();
      if (update) {
        update.active = false;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
      if (true) {
        devtoolsComponentRemoved(instance);
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
      for (let i = start2; i < children.length; i++) {
        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      return hostNextSibling(vnode.anchor || vnode.el);
    };
    let isFlushing2 = false;
    const render2 = (vnode, container, namespace) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace
        );
      }
      if (!isFlushing2) {
        isFlushing2 = true;
        flushPreFlushCbs();
        flushPostFlushCbs();
        isFlushing2 = false;
      }
      container._vnode = vnode;
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate2;
    let hydrateNode;
    if (createHydrationFns) {
      [hydrate2, hydrateNode] = createHydrationFns(
        internals
      );
    }
    return {
      render: render2,
      hydrate: hydrate2,
      createApp: createAppAPI(render2, hydrate2)
    };
  }
  function resolveChildrenNamespace({ type, props }, currentNamespace) {
    return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect: effect2, update }, allowed) {
    effect2.allowRecurse = update.allowRecurse = allowed;
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray(ch1) && isArray(ch2)) {
      for (let i = 0; i < ch1.length; i++) {
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }
          if (!shallow && c2.patchFlag !== -2)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          c2.el = c1.el;
        }
        if (c2.type === Comment && !c2.el) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
      const arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p2[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p2[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p2[v];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  function invalidateMount(hooks) {
    if (hooks) {
      for (let i = 0; i < hooks.length; i++)
        hooks[i].active = false;
    }
  }
  var ssrContextKey = Symbol.for("v-scx");
  var useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      if (!ctx) {
        warn$1(
          `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
        );
      }
      return ctx;
    }
  };
  function watchEffect(effect2, options) {
    return doWatch(effect2, null, options);
  }
  function watchPostEffect(effect2, options) {
    return doWatch(
      effect2,
      null,
      true ? extend3({}, options, { flush: "post" }) : { flush: "post" }
    );
  }
  function watchSyncEffect(effect2, options) {
    return doWatch(
      effect2,
      null,
      true ? extend3({}, options, { flush: "sync" }) : { flush: "sync" }
    );
  }
  var INITIAL_WATCHER_VALUE = {};
  function watch(source, cb, options) {
    if (!isFunction2(cb)) {
      warn$1(
        `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
      );
    }
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, {
    immediate,
    deep,
    flush,
    once,
    onTrack,
    onTrigger
  } = EMPTY_OBJ) {
    if (cb && once) {
      const _cb = cb;
      cb = (...args) => {
        _cb(...args);
        unwatch();
      };
    }
    if (deep !== void 0 && typeof deep === "number") {
      warn$1(
        `watch() "deep" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.`
      );
    }
    if (!cb) {
      if (immediate !== void 0) {
        warn$1(
          `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
      if (deep !== void 0) {
        warn$1(
          `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
      if (once !== void 0) {
        warn$1(
          `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
    }
    const warnInvalidSource = (s) => {
      warn$1(
        `Invalid watch source: `,
        s,
        `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
      );
    };
    const instance = currentInstance;
    const reactiveGetter = (source2) => deep === true ? source2 : (
      // for deep: false, only traverse root-level properties
      traverse(source2, deep === false ? 1 : void 0)
    );
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef2(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => reactiveGetter(source);
      forceTrigger = true;
    } else if (isArray(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
      getter = () => source.map((s) => {
        if (isRef2(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return reactiveGetter(s);
        } else if (isFunction2(s)) {
          return callWithErrorHandling(s, instance, 2);
        } else {
          warnInvalidSource(s);
        }
      });
    } else if (isFunction2(source)) {
      if (cb) {
        getter = () => callWithErrorHandling(source, instance, 2);
      } else {
        getter = () => {
          if (cleanup) {
            cleanup();
          }
          return callWithAsyncErrorHandling(
            source,
            instance,
            3,
            [onCleanup]
          );
        };
      }
    } else {
      getter = NOOP;
      warnInvalidSource(source);
    }
    if (cb && deep) {
      const baseGetter = getter;
      getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn) => {
      cleanup = effect2.onStop = () => {
        callWithErrorHandling(fn, instance, 4);
        cleanup = effect2.onStop = void 0;
      };
    };
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      onCleanup = NOOP;
      if (!cb) {
        getter();
      } else if (immediate) {
        callWithAsyncErrorHandling(cb, instance, 3, [
          getter(),
          isMultiSource ? [] : void 0,
          onCleanup
        ]);
      }
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else {
        return NOOP;
      }
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = () => {
      if (!effect2.active || !effect2.dirty) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
          if (cleanup) {
            cleanup();
          }
          callWithAsyncErrorHandling(cb, instance, 3, [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            onCleanup
          ]);
          oldValue = newValue;
        }
      } else {
        effect2.run();
      }
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") {
      scheduler = job;
    } else if (flush === "post") {
      scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    } else {
      job.pre = true;
      if (instance)
        job.id = instance.uid;
      scheduler = () => queueJob(job);
    }
    const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
    const scope = getCurrentScope();
    const unwatch = () => {
      effect2.stop();
      if (scope) {
        remove(scope.effects, effect2);
      }
    };
    if (true) {
      effect2.onTrack = onTrack;
      effect2.onTrigger = onTrigger;
    }
    if (cb) {
      if (immediate) {
        job();
      } else {
        oldValue = effect2.run();
      }
    } else if (flush === "post") {
      queuePostRenderEffect(
        effect2.run.bind(effect2),
        instance && instance.suspense
      );
    } else {
      effect2.run();
    }
    if (ssrCleanup)
      ssrCleanup.push(unwatch);
    return unwatch;
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction2(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const reset2 = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    reset2();
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  function traverse(value, depth = Infinity, seen2) {
    if (depth <= 0 || !isObject(value) || value["__v_skip"]) {
      return value;
    }
    seen2 = seen2 || /* @__PURE__ */ new Set();
    if (seen2.has(value)) {
      return value;
    }
    seen2.add(value);
    depth--;
    if (isRef2(value)) {
      traverse(value.value, depth, seen2);
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        traverse(value[i], depth, seen2);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach((v) => {
        traverse(v, depth, seen2);
      });
    } else if (isPlainObject(value)) {
      for (const key in value) {
        traverse(value[key], depth, seen2);
      }
      for (const key of Object.getOwnPropertySymbols(value)) {
        if (Object.prototype.propertyIsEnumerable.call(value, key)) {
          traverse(value[key], depth, seen2);
        }
      }
    }
    return value;
  }
  var isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  var KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
      include: [String, RegExp, Array],
      exclude: [String, RegExp, Array],
      max: [String, Number]
    },
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const sharedContext = instance.ctx;
      if (!sharedContext.renderer) {
        return () => {
          const children = slots.default && slots.default();
          return children && children.length === 1 ? children[0] : children;
        };
      }
      const cache2 = /* @__PURE__ */ new Map();
      const keys2 = /* @__PURE__ */ new Set();
      let current = null;
      if (true) {
        instance.__v_cache = cache2;
      }
      const parentSuspense = instance.suspense;
      const {
        renderer: {
          p: patch,
          m: move,
          um: _unmount,
          o: { createElement }
        }
      } = sharedContext;
      const storageContainer = createElement("div");
      sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
        const instance2 = vnode.component;
        move(vnode, container, anchor, 0, parentSuspense);
        patch(
          instance2.vnode,
          vnode,
          container,
          anchor,
          instance2,
          parentSuspense,
          namespace,
          vnode.slotScopeIds,
          optimized
        );
        queuePostRenderEffect(() => {
          instance2.isDeactivated = false;
          if (instance2.a) {
            invokeArrayFns(instance2.a);
          }
          const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
          if (vnodeHook) {
            invokeVNodeHook(vnodeHook, instance2.parent, vnode);
          }
        }, parentSuspense);
        if (true) {
          devtoolsComponentAdded(instance2);
        }
      };
      sharedContext.deactivate = (vnode) => {
        const instance2 = vnode.component;
        invalidateMount(instance2.m);
        invalidateMount(instance2.a);
        move(vnode, storageContainer, null, 1, parentSuspense);
        queuePostRenderEffect(() => {
          if (instance2.da) {
            invokeArrayFns(instance2.da);
          }
          const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
          if (vnodeHook) {
            invokeVNodeHook(vnodeHook, instance2.parent, vnode);
          }
          instance2.isDeactivated = true;
        }, parentSuspense);
        if (true) {
          devtoolsComponentAdded(instance2);
        }
      };
      function unmount(vnode) {
        resetShapeFlag(vnode);
        _unmount(vnode, instance, parentSuspense, true);
      }
      function pruneCache(filter) {
        cache2.forEach((vnode, key) => {
          const name = getComponentName(vnode.type);
          if (name && (!filter || !filter(name))) {
            pruneCacheEntry(key);
          }
        });
      }
      function pruneCacheEntry(key) {
        const cached = cache2.get(key);
        if (!current || !isSameVNodeType(cached, current)) {
          unmount(cached);
        } else if (current) {
          resetShapeFlag(current);
        }
        cache2.delete(key);
        keys2.delete(key);
      }
      watch(
        () => [props.include, props.exclude],
        ([include, exclude]) => {
          include && pruneCache((name) => matches(include, name));
          exclude && pruneCache((name) => !matches(exclude, name));
        },
        // prune post-render after `current` has been updated
        { flush: "post", deep: true }
      );
      let pendingCacheKey = null;
      const cacheSubtree = () => {
        if (pendingCacheKey != null) {
          if (isSuspense(instance.subTree.type)) {
            queuePostRenderEffect(() => {
              cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
            }, instance.subTree.suspense);
          } else {
            cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
          }
        }
      };
      onMounted(cacheSubtree);
      onUpdated(cacheSubtree);
      onBeforeUnmount(() => {
        cache2.forEach((cached) => {
          const { subTree, suspense } = instance;
          const vnode = getInnerChild(subTree);
          if (cached.type === vnode.type && cached.key === vnode.key) {
            resetShapeFlag(vnode);
            const da = vnode.component.da;
            da && queuePostRenderEffect(da, suspense);
            return;
          }
          unmount(cached);
        });
      });
      return () => {
        pendingCacheKey = null;
        if (!slots.default) {
          return null;
        }
        const children = slots.default();
        const rawVNode = children[0];
        if (children.length > 1) {
          if (true) {
            warn$1(`KeepAlive should contain exactly one component child.`);
          }
          current = null;
          return children;
        } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
          current = null;
          return rawVNode;
        }
        let vnode = getInnerChild(rawVNode);
        const comp = vnode.type;
        const name = getComponentName(
          isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
        );
        const { include, exclude, max } = props;
        if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
          current = vnode;
          return rawVNode;
        }
        const key = vnode.key == null ? comp : vnode.key;
        const cachedVNode = cache2.get(key);
        if (vnode.el) {
          vnode = cloneVNode(vnode);
          if (rawVNode.shapeFlag & 128) {
            rawVNode.ssContent = vnode;
          }
        }
        pendingCacheKey = key;
        if (cachedVNode) {
          vnode.el = cachedVNode.el;
          vnode.component = cachedVNode.component;
          if (vnode.transition) {
            setTransitionHooks(vnode, vnode.transition);
          }
          vnode.shapeFlag |= 512;
          keys2.delete(key);
          keys2.add(key);
        } else {
          keys2.add(key);
          if (max && keys2.size > parseInt(max, 10)) {
            pruneCacheEntry(keys2.values().next().value);
          }
        }
        vnode.shapeFlag |= 256;
        current = vnode;
        return isSuspense(rawVNode.type) ? rawVNode : vnode;
      };
    }
  };
  var KeepAlive = KeepAliveImpl;
  function matches(pattern, name) {
    if (isArray(pattern)) {
      return pattern.some((p2) => matches(p2, name));
    } else if (isString(pattern)) {
      return pattern.split(",").includes(name);
    } else if (isRegExp(pattern)) {
      return pattern.test(name);
    }
    return false;
  }
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(
      type,
      hook,
      keepAliveRoot,
      true
      /* prepend */
    );
    onUnmounted(() => {
      remove(keepAliveRoot[type], injected);
    }, target);
  }
  function resetShapeFlag(vnode) {
    vnode.shapeFlag &= ~256;
    vnode.shapeFlag &= ~512;
  }
  function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
  }
  var leaveCbKey = Symbol("_leaveCb");
  var enterCbKey = Symbol("_enterCb");
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(() => {
      state.isMounted = true;
    });
    onBeforeUnmount(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  var TransitionHookValidator = [Function, Array];
  var BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  };
  var recursiveGetSubtree = (instance) => {
    const subTree = instance.subTree;
    return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
  };
  var BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      return () => {
        const children = slots.default && getTransitionRawChildren(slots.default(), true);
        if (!children || !children.length) {
          return;
        }
        let child = children[0];
        if (children.length > 1) {
          let hasFound = false;
          for (const c of children) {
            if (c.type !== Comment) {
              if (hasFound) {
                warn$1(
                  "<transition> can only be used on a single element or component. Use <transition-group> for lists."
                );
                break;
              }
              child = c;
              hasFound = true;
              if (false)
                break;
            }
          }
        }
        const rawProps = toRaw(props);
        const { mode } = rawProps;
        if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
          warn$1(`invalid <transition> mode: ${mode}`);
        }
        if (state.isLeaving) {
          return emptyPlaceholder(child);
        }
        const innerChild = getKeepAliveChild(child);
        if (!innerChild) {
          return emptyPlaceholder(child);
        }
        let enterHooks = resolveTransitionHooks(
          innerChild,
          rawProps,
          state,
          instance,
          // #11061, ensure enterHooks is fresh after clone
          (hooks) => enterHooks = hooks
        );
        setTransitionHooks(innerChild, enterHooks);
        const oldChild = instance.subTree;
        const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
        if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
          const leavingHooks = resolveTransitionHooks(
            oldInnerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(oldInnerChild, leavingHooks);
          if (mode === "out-in" && innerChild.type !== Comment) {
            state.isLeaving = true;
            leavingHooks.afterLeave = () => {
              state.isLeaving = false;
              if (instance.update.active !== false) {
                instance.effect.dirty = true;
                instance.update();
              }
            };
            return emptyPlaceholder(child);
          } else if (mode === "in-out" && innerChild.type !== Comment) {
            leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
              const leavingVNodesCache = getLeavingNodesForType(
                state,
                oldInnerChild
              );
              leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
              el[leaveCbKey] = () => {
                earlyRemove();
                el[leaveCbKey] = void 0;
                delete enterHooks.delayedLeave;
              };
              enterHooks.delayedLeave = delayedLeave;
            };
          }
        }
        return child;
      };
    }
  };
  var BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = /* @__PURE__ */ Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props, state, instance, postClone) {
    const {
      appear,
      mode,
      persisted = false,
      onBeforeEnter,
      onEnter,
      onAfterEnter,
      onEnterCancelled,
      onBeforeLeave,
      onLeave,
      onAfterLeave,
      onLeaveCancelled,
      onBeforeAppear,
      onAppear,
      onAfterAppear,
      onAppearCancelled
    } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook3 = (hook, args) => {
      hook && callWithAsyncErrorHandling(
        hook,
        instance,
        9,
        args
      );
    };
    const callAsyncHook = (hook, args) => {
      const done = args[1];
      callHook3(hook, args);
      if (isArray(hook)) {
        if (hook.every((hook2) => hook2.length <= 1))
          done();
      } else if (hook.length <= 1) {
        done();
      }
    };
    const hooks = {
      mode,
      persisted,
      beforeEnter(el) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el[leaveCbKey]) {
          el[leaveCbKey](
            true
            /* cancelled */
          );
        }
        const leavingVNode = leavingVNodesCache[key];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
          leavingVNode.el[leaveCbKey]();
        }
        callHook3(hook, [el]);
      },
      enter(el) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el[enterCbKey] = (cancelled) => {
          if (called)
            return;
          called = true;
          if (cancelled) {
            callHook3(cancelHook, [el]);
          } else {
            callHook3(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el[enterCbKey] = void 0;
        };
        if (hook) {
          callAsyncHook(hook, [el, done]);
        } else {
          done();
        }
      },
      leave(el, remove2) {
        const key2 = String(vnode.key);
        if (el[enterCbKey]) {
          el[enterCbKey](
            true
            /* cancelled */
          );
        }
        if (state.isUnmounting) {
          return remove2();
        }
        callHook3(onBeforeLeave, [el]);
        let called = false;
        const done = el[leaveCbKey] = (cancelled) => {
          if (called)
            return;
          called = true;
          remove2();
          if (cancelled) {
            callHook3(onLeaveCancelled, [el]);
          } else {
            callHook3(onAfterLeave, [el]);
          }
          el[leaveCbKey] = void 0;
          if (leavingVNodesCache[key2] === vnode) {
            delete leavingVNodesCache[key2];
          }
        };
        leavingVNodesCache[key2] = vnode;
        if (onLeave) {
          callAsyncHook(onLeave, [el, done]);
        } else {
          done();
        }
      },
      clone(vnode2) {
        const hooks2 = resolveTransitionHooks(
          vnode2,
          props,
          state,
          instance,
          postClone
        );
        if (postClone)
          postClone(hooks2);
        return hooks2;
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getKeepAliveChild(vnode) {
    if (!isKeepAlive(vnode)) {
      return vnode;
    }
    if (vnode.component) {
      return vnode.component.subTree;
    }
    const { shapeFlag, children } = vnode;
    if (children) {
      if (shapeFlag & 16) {
        return children[0];
      }
      if (shapeFlag & 32 && isFunction2(children.default)) {
        return children.default();
      }
    }
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
      let child = children[i];
      const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
      if (child.type === Fragment) {
        if (child.patchFlag & 128)
          keyedFragmentCount++;
        ret = ret.concat(
          getTransitionRawChildren(child.children, keepComment, key)
        );
      } else if (keepComment || child.type !== Comment) {
        ret.push(key != null ? cloneVNode(child, { key }) : child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i = 0; i < ret.length; i++) {
        ret[i].patchFlag = -2;
      }
    }
    return ret;
  }
  var isTeleport = (type) => type.__isTeleport;
  var isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
  var isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
  var isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
  var resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if (isString(targetSelector)) {
      if (!select) {
        warn$1(
          `Current renderer does not support string target for Teleports. (missing querySelector renderer option)`
        );
        return null;
      } else {
        const target = select(targetSelector);
        if (!target && !isTeleportDisabled(props)) {
          warn$1(
            `Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
          );
        }
        return target;
      }
    } else {
      if (!targetSelector && !isTeleportDisabled(props)) {
        warn$1(`Invalid Teleport target: ${targetSelector}`);
      }
      return targetSelector;
    }
  };
  var TeleportImpl = {
    name: "Teleport",
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
      const {
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        o: { insert, querySelector, createText, createComment }
      } = internals;
      const disabled = isTeleportDisabled(n2.props);
      let { shapeFlag, children, dynamicChildren } = n2;
      if (isHmrUpdating) {
        optimized = false;
        dynamicChildren = null;
      }
      if (n1 == null) {
        const placeholder = n2.el = true ? createComment("teleport start") : createText("");
        const mainAnchor = n2.anchor = true ? createComment("teleport end") : createText("");
        insert(placeholder, container, anchor);
        insert(mainAnchor, container, anchor);
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = n2.targetAnchor = createText("");
        if (target) {
          insert(targetAnchor, target);
          if (namespace === "svg" || isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace === "mathml" || isTargetMathML(target)) {
            namespace = "mathml";
          }
        } else if (!disabled) {
          warn$1("Invalid Teleport target on mount:", target, `(${typeof target})`);
        }
        const mount = (container2, anchor2) => {
          if (shapeFlag & 16) {
            mountChildren(
              children,
              container2,
              anchor2,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        if (disabled) {
          mount(container, mainAnchor);
        } else if (target) {
          mount(target, targetAnchor);
        }
      } else {
        n2.el = n1.el;
        const mainAnchor = n2.anchor = n1.anchor;
        const target = n2.target = n1.target;
        const targetAnchor = n2.targetAnchor = n1.targetAnchor;
        const wasDisabled = isTeleportDisabled(n1.props);
        const currentContainer = wasDisabled ? container : target;
        const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
        if (namespace === "svg" || isTargetSVG(target)) {
          namespace = "svg";
        } else if (namespace === "mathml" || isTargetMathML(target)) {
          namespace = "mathml";
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            currentContainer,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          traverseStaticChildren(n1, n2, true);
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            currentContainer,
            currentAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            false
          );
        }
        if (disabled) {
          if (!wasDisabled) {
            moveTeleport(
              n2,
              container,
              mainAnchor,
              internals,
              1
            );
          } else {
            if (n2.props && n1.props && n2.props.to !== n1.props.to) {
              n2.props.to = n1.props.to;
            }
          }
        } else {
          if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
            const nextTarget = n2.target = resolveTarget(
              n2.props,
              querySelector
            );
            if (nextTarget) {
              moveTeleport(
                n2,
                nextTarget,
                null,
                internals,
                0
              );
            } else if (true) {
              warn$1(
                "Invalid Teleport target on update:",
                target,
                `(${typeof target})`
              );
            }
          } else if (wasDisabled) {
            moveTeleport(
              n2,
              target,
              targetAnchor,
              internals,
              1
            );
          }
        }
      }
      updateCssVars(n2);
    },
    remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
      const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
      if (target) {
        hostRemove(targetAnchor);
      }
      doRemove && hostRemove(anchor);
      if (shapeFlag & 16) {
        const shouldRemove = doRemove || !isTeleportDisabled(props);
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          unmount(
            child,
            parentComponent,
            parentSuspense,
            shouldRemove,
            !!child.dynamicChildren
          );
        }
      }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
  };
  function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) {
      insert(el, container, parentAnchor);
    }
    if (!isReorder || isTeleportDisabled(props)) {
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          move(
            children[i],
            container,
            parentAnchor,
            2
          );
        }
      }
    }
    if (isReorder) {
      insert(anchor, container, parentAnchor);
    }
  }
  function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
    o: { nextSibling, parentNode, querySelector }
  }, hydrateChildren) {
    const target = vnode.target = resolveTarget(
      vnode.props,
      querySelector
    );
    if (target) {
      const targetNode = target._lpa || target.firstChild;
      if (vnode.shapeFlag & 16) {
        if (isTeleportDisabled(vnode.props)) {
          vnode.anchor = hydrateChildren(
            nextSibling(node),
            vnode,
            parentNode(node),
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
          vnode.targetAnchor = targetNode;
        } else {
          vnode.anchor = nextSibling(node);
          let targetAnchor = targetNode;
          while (targetAnchor) {
            targetAnchor = nextSibling(targetAnchor);
            if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          hydrateChildren(
            targetNode,
            vnode,
            target,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
      }
      updateCssVars(vnode);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
  }
  var Teleport = TeleportImpl;
  function updateCssVars(vnode) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
      let node = vnode.children[0].el;
      while (node && node !== vnode.targetAnchor) {
        if (node.nodeType === 1)
          node.setAttribute("data-v-owner", ctx.uid);
        node = node.nextSibling;
      }
      ctx.ut();
    }
  }
  var Fragment = Symbol.for("v-fgt");
  var Text = Symbol.for("v-txt");
  var Comment = Symbol.for("v-cmt");
  var Static = Symbol.for("v-stc");
  var blockStack = [];
  var currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  var isBlockTreeEnabled = 1;
  function setBlockTracking(value) {
    isBlockTreeEnabled += value;
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
      n1.shapeFlag &= ~256;
      n2.shapeFlag &= ~512;
      return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
  }
  var vnodeArgsTransformer;
  function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
  }
  var createVNodeWithArgsTransform = (...args) => {
    return _createVNode(
      ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args
    );
  };
  var normalizeKey = ({ key }) => key != null ? key : null;
  var normalizeRef = ({
    ref: ref2,
    ref_key,
    ref_for
  }) => {
    if (typeof ref2 === "number") {
      ref2 = "" + ref2;
    }
    return ref2 != null ? isString(ref2) || isRef2(ref2) || isFunction2(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
  };
  function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString(children) ? 8 : 16;
    }
    if (vnode.key !== vnode.key) {
      warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  var createVNode = true ? createVNodeWithArgsTransform : _createVNode;
  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      if (!type) {
        warn$1(`Invalid vnode type when creating vnode: ${type}.`);
      }
      type = Comment;
    }
    if (isVNode(type)) {
      const cloned = cloneVNode(
        type,
        props,
        true
        /* mergeRef: true */
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag = -2;
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject(style)) {
        if (isProxy(style) && !isArray(style)) {
          style = extend3({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction2(type) ? 2 : 0;
    if (shapeFlag & 4 && isProxy(type)) {
      type = toRaw(type);
      warn$1(
        `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
        `
Component that was made reactive: `,
        type
      );
    }
    return createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props) {
    if (!props)
      return null;
    return isProxy(props) || isInternalObject(props) ? extend3({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
    const { props, ref: ref2, patchFlag, children, transition } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? (
        // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref2 ? isArray(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
      ) : ref2,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children: patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
      target: vnode.target,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    if (transition && cloneTransition) {
      setTransitionHooks(
        cloned,
        transition.clone(cloned)
      );
    }
    return cloned;
  }
  function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if (isArray(vnode.children)) {
      cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createStaticVNode(content, numberOfNodes) {
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray(child)) {
      return createVNode(
        Fragment,
        null,
        // #3666, avoid reference pollution when reusing vnode
        child.slice()
      );
    } else if (typeof child === "object") {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray(children)) {
      type = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        const slotFlag = children._;
        if (!slotFlag && !isInternalObject(children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction2(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      const toMerge = args[i];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  var emptyAppContext = createAppContext();
  var uid = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type,
      parent,
      appContext,
      root: null,
      // to be immediately set
      next: null,
      subTree: null,
      // will be set synchronously right after creation
      effect: null,
      update: null,
      // will be set synchronously right after creation
      scope: new EffectScope(
        true
        /* detached */
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      accessCache: null,
      renderCache: [],
      // local resolved assets
      components: null,
      directives: null,
      // resolved props and emits options
      propsOptions: normalizePropsOptions(type, appContext),
      emitsOptions: normalizeEmitsOptions(type, appContext),
      // emit
      emit: null,
      // to be set immediately
      emitted: null,
      // props default value
      propsDefaults: EMPTY_OBJ,
      // inheritAttrs
      inheritAttrs: type.inheritAttrs,
      // state
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      attrsProxy: null,
      slotsProxy: null,
      // suspense related
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      // lifecycle hooks
      // not using enums here because it results in computed properties
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    if (true) {
      instance.ctx = createDevRenderContext(instance);
    } else {
      instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  var currentInstance = null;
  var getCurrentInstance = () => currentInstance || currentRenderingInstance;
  var internalSetCurrentInstance;
  var setInSSRSetupState;
  {
    const g = getGlobalThis();
    const registerGlobalSetter = (key, setter) => {
      let setters;
      if (!(setters = g[key]))
        setters = g[key] = [];
      setters.push(setter);
      return (v) => {
        if (setters.length > 1)
          setters.forEach((set2) => set2(v));
        else
          setters[0](v);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v) => currentInstance = v
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v) => isInSSRComponentSetup = v
    );
  }
  var setCurrentInstance = (instance) => {
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
      instance.scope.off();
      internalSetCurrentInstance(prev);
    };
  };
  var unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  var isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
  function validateComponentName(name, { isNativeTag }) {
    if (isBuiltInTag(name) || isNativeTag(name)) {
      warn$1(
        "Do not use built-in or reserved HTML elements as component id: " + name
      );
    }
  }
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  var isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    var _a;
    const Component2 = instance.type;
    if (true) {
      if (Component2.name) {
        validateComponentName(Component2.name, instance.appContext.config);
      }
      if (Component2.components) {
        const names = Object.keys(Component2.components);
        for (let i = 0; i < names.length; i++) {
          validateComponentName(names[i], instance.appContext.config);
        }
      }
      if (Component2.directives) {
        const names = Object.keys(Component2.directives);
        for (let i = 0; i < names.length; i++) {
          validateDirectiveName(names[i]);
        }
      }
      if (Component2.compilerOptions && isRuntimeOnly()) {
        warn$1(
          `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
        );
      }
    }
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    if (true) {
      exposePropsOnRenderContext(instance);
    }
    const { setup } = Component2;
    if (setup) {
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      const reset2 = setCurrentInstance(instance);
      pauseTracking();
      const setupResult = callWithErrorHandling(
        setup,
        instance,
        0,
        [
          true ? shallowReadonly(instance.props) : instance.props,
          setupContext
        ]
      );
      resetTracking();
      reset2();
      if (isPromise(setupResult)) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
          if (!instance.suspense) {
            const name = (_a = Component2.name) != null ? _a : "Anonymous";
            warn$1(
              `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
            );
          }
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction2(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject(setupResult)) {
      if (isVNode(setupResult)) {
        warn$1(
          `setup() should not return VNodes directly - return a render function instead.`
        );
      }
      if (true) {
        instance.devtoolsRawSetupState = setupResult;
      }
      instance.setupState = proxyRefs(setupResult);
      if (true) {
        exposeSetupStateOnRenderContext(instance);
      }
    } else if (setupResult !== void 0) {
      warn$1(
        `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
      );
    }
    finishComponentSetup(instance, isSSR);
  }
  var compile;
  var installWithProxy;
  function registerRuntimeCompiler(_compile) {
    compile = _compile;
    installWithProxy = (i) => {
      if (i.render._rc) {
        i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
      }
    };
  }
  var isRuntimeOnly = () => !compile;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component2 = instance.type;
    if (!instance.render) {
      if (!isSSR && compile && !Component2.render) {
        const template = Component2.template || resolveMergedOptions(instance).template;
        if (template) {
          if (true) {
            startMeasure(instance, `compile`);
          }
          const { isCustomElement, compilerOptions } = instance.appContext.config;
          const { delimiters, compilerOptions: componentCompilerOptions } = Component2;
          const finalCompilerOptions = extend3(
            extend3(
              {
                isCustomElement,
                delimiters
              },
              compilerOptions
            ),
            componentCompilerOptions
          );
          Component2.render = compile(template, finalCompilerOptions);
          if (true) {
            endMeasure(instance, `compile`);
          }
        }
      }
      instance.render = Component2.render || NOOP;
      if (installWithProxy) {
        installWithProxy(instance);
      }
    }
    if (__VUE_OPTIONS_API__ && true) {
      const reset2 = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset2();
      }
    }
    if (!Component2.render && instance.render === NOOP && !isSSR) {
      if (!compile && Component2.template) {
        warn$1(
          `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
        );
      } else {
        warn$1(`Component is missing template or render function: `, Component2);
      }
    }
  }
  var attrsProxyHandlers = true ? {
    get(target, key) {
      markAttrsAccessed();
      track(target, "get", "");
      return target[key];
    },
    set() {
      warn$1(`setupContext.attrs is readonly.`);
      return false;
    },
    deleteProperty() {
      warn$1(`setupContext.attrs is readonly.`);
      return false;
    }
  } : {
    get(target, key) {
      track(target, "get", "");
      return target[key];
    }
  };
  function getSlotsProxy(instance) {
    return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
      get(target, key) {
        track(instance, "get", "$slots");
        return target[key];
      }
    }));
  }
  function createSetupContext(instance) {
    const expose = (exposed) => {
      if (true) {
        if (instance.exposed) {
          warn$1(`expose() should be called only once per setup().`);
        }
        if (exposed != null) {
          let exposedType = typeof exposed;
          if (exposedType === "object") {
            if (isArray(exposed)) {
              exposedType = "array";
            } else if (isRef2(exposed)) {
              exposedType = "ref";
            }
          }
          if (exposedType !== "object") {
            warn$1(
              `expose() should be passed a plain object, received ${exposedType}.`
            );
          }
        }
      }
      instance.exposed = exposed || {};
    };
    if (true) {
      let attrsProxy;
      return Object.freeze({
        get attrs() {
          return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
        },
        get slots() {
          return getSlotsProxy(instance);
        },
        get emit() {
          return (event, ...args) => instance.emit(event, ...args);
        },
        expose
      });
    } else {
      return {
        attrs: new Proxy(instance.attrs, attrsProxyHandlers),
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getComponentPublicInstance(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has(target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    } else {
      return instance.proxy;
    }
  }
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component2, includeInferred = true) {
    return isFunction2(Component2) ? Component2.displayName || Component2.name : Component2.name || includeInferred && Component2.__name;
  }
  function formatComponentName(instance, Component2, isRoot = false) {
    let name = getComponentName(Component2);
    if (!name && Component2.__file) {
      const match = Component2.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component2) {
            return key;
          }
        }
      };
      name = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction2(value) && "__vccOpts" in value;
  }
  var computed2 = (getterOrOptions, debugOptions) => {
    const c = computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
    if (true) {
      const i = getCurrentInstance();
      if (i && i.appContext.config.warnRecursiveComputed) {
        c._warnRecursive = true;
      }
    }
    return c;
  };
  function useModel(props, name, options = EMPTY_OBJ) {
    const i = getCurrentInstance();
    if (!i) {
      warn$1(`useModel() called without active instance.`);
      return ref();
    }
    if (!i.propsOptions[0][name]) {
      warn$1(`useModel() called with prop "${name}" which is not declared.`);
      return ref();
    }
    const camelizedName = camelize2(name);
    const hyphenatedName = hyphenate(name);
    const res = customRef((track2, trigger2) => {
      let localValue;
      watchSyncEffect(() => {
        const propValue = props[name];
        if (hasChanged(localValue, propValue)) {
          localValue = propValue;
          trigger2();
        }
      });
      return {
        get() {
          track2();
          return options.get ? options.get(localValue) : localValue;
        },
        set(value) {
          const rawProps = i.vnode.props;
          if (!(rawProps && // check if parent has passed v-model
          (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps)) && hasChanged(value, localValue)) {
            localValue = value;
            trigger2();
          }
          i.emit(`update:${name}`, options.set ? options.set(value) : value);
        }
      };
    });
    const modifierKey = name === "modelValue" ? "modelModifiers" : `${name}Modifiers`;
    res[Symbol.iterator] = () => {
      let i2 = 0;
      return {
        next() {
          if (i2 < 2) {
            return { value: i2++ ? props[modifierKey] || {} : res, done: false };
          } else {
            return { done: true };
          }
        }
      };
    };
    return res;
  }
  function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
      if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  }
  function initCustomFormatter() {
    if (typeof window === "undefined") {
      return;
    }
    const vueStyle = { style: "color:#3ba776" };
    const numberStyle = { style: "color:#1677ff" };
    const stringStyle = { style: "color:#f5222d" };
    const keywordStyle = { style: "color:#eb2f96" };
    const formatter = {
      header(obj) {
        if (!isObject(obj)) {
          return null;
        }
        if (obj.__isVue) {
          return ["div", vueStyle, `VueInstance`];
        } else if (isRef2(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, genRefFlag(obj)],
            "<",
            formatValue(obj.value),
            `>`
          ];
        } else if (isReactive(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
            "<",
            formatValue(obj),
            `>${isReadonly(obj) ? ` (readonly)` : ``}`
          ];
        } else if (isReadonly(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
            "<",
            formatValue(obj),
            ">"
          ];
        }
        return null;
      },
      hasBody(obj) {
        return obj && obj.__isVue;
      },
      body(obj) {
        if (obj && obj.__isVue) {
          return [
            "div",
            {},
            ...formatInstance(obj.$)
          ];
        }
      }
    };
    function formatInstance(instance) {
      const blocks = [];
      if (instance.type.props && instance.props) {
        blocks.push(createInstanceBlock("props", toRaw(instance.props)));
      }
      if (instance.setupState !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("setup", instance.setupState));
      }
      if (instance.data !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("data", toRaw(instance.data)));
      }
      const computed3 = extractKeys(instance, "computed");
      if (computed3) {
        blocks.push(createInstanceBlock("computed", computed3));
      }
      const injected = extractKeys(instance, "inject");
      if (injected) {
        blocks.push(createInstanceBlock("injected", injected));
      }
      blocks.push([
        "div",
        {},
        [
          "span",
          {
            style: keywordStyle.style + ";opacity:0.66"
          },
          "$ (internal): "
        ],
        ["object", { object: instance }]
      ]);
      return blocks;
    }
    function createInstanceBlock(type, target) {
      target = extend3({}, target);
      if (!Object.keys(target).length) {
        return ["span", {}];
      }
      return [
        "div",
        { style: "line-height:1.25em;margin-bottom:0.6em" },
        [
          "div",
          {
            style: "color:#476582"
          },
          type
        ],
        [
          "div",
          {
            style: "padding-left:1.25em"
          },
          ...Object.keys(target).map((key) => {
            return [
              "div",
              {},
              ["span", keywordStyle, key + ": "],
              formatValue(target[key], false)
            ];
          })
        ]
      ];
    }
    function formatValue(v, asRaw = true) {
      if (typeof v === "number") {
        return ["span", numberStyle, v];
      } else if (typeof v === "string") {
        return ["span", stringStyle, JSON.stringify(v)];
      } else if (typeof v === "boolean") {
        return ["span", keywordStyle, v];
      } else if (isObject(v)) {
        return ["object", { object: asRaw ? toRaw(v) : v }];
      } else {
        return ["span", stringStyle, String(v)];
      }
    }
    function extractKeys(instance, type) {
      const Comp = instance.type;
      if (isFunction2(Comp)) {
        return;
      }
      const extracted = {};
      for (const key in instance.ctx) {
        if (isKeyOfType(Comp, key, type)) {
          extracted[key] = instance.ctx[key];
        }
      }
      return extracted;
    }
    function isKeyOfType(Comp, key, type) {
      const opts = Comp[type];
      if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {
        return true;
      }
      if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
        return true;
      }
      if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
        return true;
      }
    }
    function genRefFlag(v) {
      if (isShallow(v)) {
        return `ShallowRef`;
      }
      if (v.effect) {
        return `ComputedRef`;
      }
      return `Ref`;
    }
    if (window.devtoolsFormatters) {
      window.devtoolsFormatters.push(formatter);
    } else {
      window.devtoolsFormatters = [formatter];
    }
  }
  function withMemo(memo, render2, cache2, index) {
    const cached = cache2[index];
    if (cached && isMemoSame(cached, memo)) {
      return cached;
    }
    const ret = render2();
    ret.memo = memo.slice();
    ret.memoIndex = index;
    return cache2[index] = ret;
  }
  function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) {
      return false;
    }
    for (let i = 0; i < prev.length; i++) {
      if (hasChanged(prev[i], memo[i])) {
        return false;
      }
    }
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(cached);
    }
    return true;
  }
  var version = "3.4.31";
  var warn2 = true ? warn$1 : NOOP;
  var ErrorTypeStrings = ErrorTypeStrings$1;
  var devtools = true ? devtools$1 : void 0;
  var setDevtoolsHook = true ? setDevtoolsHook$1 : NOOP;
  var _ssrUtils = {
    createComponentInstance,
    setupComponent,
    renderComponentRoot,
    setCurrentRenderingInstance,
    isVNode,
    normalizeVNode,
    getComponentPublicInstance
  };
  var ssrUtils = _ssrUtils;
  var resolveFilter = null;
  var compatUtils = null;
  var DeprecationTypes = null;

  // node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js
  var svgNS = "http://www.w3.org/2000/svg";
  var mathmlNS = "http://www.w3.org/1998/Math/MathML";
  var doc = typeof document !== "undefined" ? document : null;
  var templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  var nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, namespace, is, props) => {
      const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, namespace, start2, end) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      if (start2 && (start2 === end || start2.nextSibling)) {
        while (true) {
          parent.insertBefore(start2.cloneNode(true), anchor);
          if (start2 === end || !(start2 = start2.nextSibling))
            break;
        }
      } else {
        templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
        const template = templateContainer.content;
        if (namespace === "svg" || namespace === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent.insertBefore(template, anchor);
      }
      return [
        // first
        before ? before.nextSibling : parent.firstChild,
        // last
        anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };
  var TRANSITION = "transition";
  var ANIMATION = "animation";
  var vtcKey = Symbol("_vtc");
  var Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
  Transition.displayName = "Transition";
  var DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  var TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend3(
    {},
    BaseTransitionPropsValidators,
    DOMTransitionPropsValidators
  );
  var callHook2 = (hook, args = []) => {
    if (isArray(hook)) {
      hook.forEach((h2) => h2(...args));
    } else if (hook) {
      hook(...args);
    }
  };
  var hasExplicitCallback = (hook) => {
    return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
  };
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
      if (!(key in DOMTransitionPropsValidators)) {
        baseProps[key] = rawProps[key];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const {
      name = "v",
      type,
      duration,
      enterFromClass = `${name}-enter-from`,
      enterActiveClass = `${name}-enter-active`,
      enterToClass = `${name}-enter-to`,
      appearFromClass = enterFromClass,
      appearActiveClass = enterActiveClass,
      appearToClass = enterToClass,
      leaveFromClass = `${name}-leave-from`,
      leaveActiveClass = `${name}-leave-active`,
      leaveToClass = `${name}-leave-to`
    } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const {
      onBeforeEnter,
      onEnter,
      onEnterCancelled,
      onLeave,
      onLeaveCancelled,
      onBeforeAppear = onBeforeEnter,
      onAppear = onEnter,
      onAppearCancelled = onEnterCancelled
    } = baseProps;
    const finishEnter = (el, isAppear, done) => {
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el, done) => {
      el._isLeaving = false;
      removeTransitionClass(el, leaveFromClass);
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve2 = () => finishEnter(el, isAppear, done);
        callHook2(hook, [el, resolve2]);
        nextFrame(() => {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type, enterDuration, resolve2);
          }
        });
      };
    };
    return extend3(baseProps, {
      onBeforeEnter(el) {
        callHook2(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear(el) {
        callHook2(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el, done) {
        el._isLeaving = true;
        const resolve2 = () => finishLeave(el, done);
        addTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveActiveClass);
        forceReflow();
        nextFrame(() => {
          if (!el._isLeaving) {
            return;
          }
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el, type, leaveDuration, resolve2);
          }
        });
        callHook2(onLeave, [el, resolve2]);
      },
      onEnterCancelled(el) {
        finishEnter(el, false);
        callHook2(onEnterCancelled, [el]);
      },
      onAppearCancelled(el) {
        finishEnter(el, true);
        callHook2(onAppearCancelled, [el]);
      },
      onLeaveCancelled(el) {
        finishLeave(el);
        callHook2(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration) {
    if (duration == null) {
      return null;
    } else if (isObject(duration)) {
      return [NumberOf(duration.enter), NumberOf(duration.leave)];
    } else {
      const n = NumberOf(duration);
      return [n, n];
    }
  }
  function NumberOf(val) {
    const res = toNumber(val);
    if (true) {
      assertNumber(res, "<transition> explicit duration");
    }
    return res;
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
    (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el[vtcKey] = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb);
    });
  }
  var endId = 0;
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id === el._endId) {
        resolve2();
      }
    };
    if (explicitTimeout) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
      return resolve2();
    }
    const endEvent = type + "end";
    let ended = 0;
    const end = () => {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e) => {
      if (e.target === el && ++ended >= propCount) {
        end();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key) => (styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
      getStyleProperties(`${TRANSITION}Property`).toString()
    );
    return {
      type,
      timeout,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
  }
  function toMs(s) {
    if (s === "auto")
      return 0;
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }
  function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  var vShowOriginalDisplay = Symbol("_vod");
  var vShowHidden = Symbol("_vsh");
  var vShow = {
    beforeMount(el, { value }, { transition }) {
      el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted(el, { value }, { transition }) {
      if (transition && value) {
        transition.enter(el);
      }
    },
    updated(el, { value, oldValue }, { transition }) {
      if (!value === !oldValue)
        return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, () => {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount(el, { value }) {
      setDisplay(el, value);
    }
  };
  if (true) {
    vShow.name = "show";
  }
  function setDisplay(el, value) {
    el.style.display = value ? el[vShowOriginalDisplay] : "none";
    el[vShowHidden] = !value;
  }
  function initVShowForSSR() {
    vShow.getSSRProps = ({ value }) => {
      if (!value) {
        return { style: { display: "none" } };
      }
    };
  }
  var CSS_VAR_TEXT = Symbol(true ? "CSS_VAR_TEXT" : "");
  function useCssVars(getter) {
    const instance = getCurrentInstance();
    if (!instance) {
      warn2(`useCssVars is called without current active component instance.`);
      return;
    }
    const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
      Array.from(
        document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
      ).forEach((node) => setVarsOnNode(node, vars));
    };
    if (true) {
      instance.getCssVars = () => getter(instance.proxy);
    }
    const setVars = () => {
      const vars = getter(instance.proxy);
      setVarsOnVNode(instance.subTree, vars);
      updateTeleports(vars);
    };
    onMounted(() => {
      watchPostEffect(setVars);
      const ob = new MutationObserver(setVars);
      ob.observe(instance.subTree.el.parentNode, { childList: true });
      onUnmounted(() => ob.disconnect());
    });
  }
  function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128) {
      const suspense = vnode.suspense;
      vnode = suspense.activeBranch;
      if (suspense.pendingBranch && !suspense.isHydrating) {
        suspense.effects.push(() => {
          setVarsOnVNode(suspense.activeBranch, vars);
        });
      }
    }
    while (vnode.component) {
      vnode = vnode.component.subTree;
    }
    if (vnode.shapeFlag & 1 && vnode.el) {
      setVarsOnNode(vnode.el, vars);
    } else if (vnode.type === Fragment) {
      vnode.children.forEach((c) => setVarsOnVNode(c, vars));
    } else if (vnode.type === Static) {
      let { el, anchor } = vnode;
      while (el) {
        setVarsOnNode(el, vars);
        if (el === anchor)
          break;
        el = el.nextSibling;
      }
    }
  }
  function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
      const style = el.style;
      let cssText = "";
      for (const key in vars) {
        style.setProperty(`--${key}`, vars[key]);
        cssText += `--${key}: ${vars[key]};`;
      }
      style[CSS_VAR_TEXT] = cssText;
    }
  }
  var displayRE = /(^|;)\s*display\s*:/;
  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
      if (prev) {
        if (!isString(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        } else {
          for (const prevStyle of prev.split(";")) {
            const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
      }
      for (const key in next) {
        if (key === "display") {
          hasControlledDisplay = true;
        }
        setStyle(style, key, next[key]);
      }
    } else {
      if (isCssString) {
        if (prev !== next) {
          const cssVarText = style[CSS_VAR_TEXT];
          if (cssVarText) {
            next += ";" + cssVarText;
          }
          style.cssText = next;
          hasControlledDisplay = displayRE.test(next);
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el) {
      el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
      if (el[vShowHidden]) {
        style.display = "none";
      }
    }
  }
  var semicolonRE = /[^\\];\s*$/;
  var importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray(val)) {
      val.forEach((v) => setStyle(style, name, v));
    } else {
      if (val == null)
        val = "";
      if (true) {
        if (semicolonRE.test(val)) {
          warn2(
            `Unexpected semicolon at the end of '${name}' style value: '${val}'`
          );
        }
      }
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(
            hyphenate(prefixed),
            val.replace(importantRE, ""),
            "important"
          );
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  var prefixes = ["Webkit", "Moz", "ms"];
  var prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize2(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize2(name);
    for (let i = 0; i < prefixes.length; i++) {
      const prefixed = prefixes[i] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  var xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(
          key,
          isBoolean2 ? "" : isSymbol(value) ? String(value) : value
        );
      }
    }
  }
  function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === "innerHTML" || key === "textContent") {
      if (prevChildren) {
        unmountChildren(prevChildren, parentComponent, parentSuspense);
      }
      el[key] = value == null ? "" : value;
      return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
      const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
      const newValue = value == null ? "" : String(value);
      if (oldValue !== newValue || !("_value" in el)) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      el._value = value;
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type = typeof el[key];
      if (type === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type === "string") {
        value = "";
        needRemove = true;
      } else if (type === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e) {
      if (!needRemove) {
        warn2(
          `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
          e
        );
      }
    }
    needRemove && el.removeAttribute(key);
  }
  function addEventListener2(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener2(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  var veiKey = Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = true ? sanitizeEventValue(nextValue, rawName) : nextValue;
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(
          true ? sanitizeEventValue(nextValue, rawName) : nextValue,
          instance
        );
        addEventListener2(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener2(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  var optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
  }
  var cachedNow = 0;
  var p = /* @__PURE__ */ Promise.resolve();
  var getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      if (!e._vts) {
        e._vts = Date.now();
      } else if (e._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e, invoker.value),
        instance,
        5,
        [e]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function sanitizeEventValue(value, propName) {
    if (isFunction2(value) || isArray(value)) {
      return value;
    }
    warn2(
      `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof value}.`
    );
    return NOOP;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map(
        (fn) => (e2) => !e2._stopped && fn && fn(e2)
      );
    } else {
      return value;
    }
  }
  var isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
  key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
  var patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    const isSVG = namespace === "svg";
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(
        el,
        key,
        nextValue,
        prevChildren,
        parentComponent,
        parentSuspense,
        unmountChildren
      );
      if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
        patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
      }
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && isNativeOn(key) && isFunction2(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key === "width" || key === "height") {
      const tag = el.tagName;
      if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key) && isString(value)) {
      return false;
    }
    return key in el;
  }
  // @__NO_SIDE_EFFECTS__
  function defineCustomElement(options, extraOptions, hydrate2) {
    const Comp = defineComponent(options, extraOptions);
    class VueCustomElement extends VueElement {
      constructor(initialProps) {
        super(Comp, initialProps, hydrate2);
      }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
  }
  var defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options, extraOptions) => {
    return /* @__PURE__ */ defineCustomElement(options, extraOptions, hydrate);
  };
  var BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
  };
  var VueElement = class _VueElement extends BaseClass {
    constructor(_def, _props = {}, hydrate2) {
      super();
      this._def = _def;
      this._props = _props;
      this._instance = null;
      this._connected = false;
      this._resolved = false;
      this._numberProps = null;
      this._ob = null;
      if (this.shadowRoot && hydrate2) {
        hydrate2(this._createVNode(), this.shadowRoot);
      } else {
        if (this.shadowRoot) {
          warn2(
            `Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`
          );
        }
        this.attachShadow({ mode: "open" });
        if (!this._def.__asyncLoader) {
          this._resolveProps(this._def);
        }
      }
    }
    connectedCallback() {
      this._connected = true;
      if (!this._instance) {
        if (this._resolved) {
          this._update();
        } else {
          this._resolveDef();
        }
      }
    }
    disconnectedCallback() {
      this._connected = false;
      nextTick(() => {
        if (!this._connected) {
          if (this._ob) {
            this._ob.disconnect();
            this._ob = null;
          }
          render(null, this.shadowRoot);
          this._instance = null;
        }
      });
    }
    /**
     * resolve inner component definition (handle possible async component)
     */
    _resolveDef() {
      this._resolved = true;
      for (let i = 0; i < this.attributes.length; i++) {
        this._setAttr(this.attributes[i].name);
      }
      this._ob = new MutationObserver((mutations) => {
        for (const m of mutations) {
          this._setAttr(m.attributeName);
        }
      });
      this._ob.observe(this, { attributes: true });
      const resolve2 = (def2, isAsync = false) => {
        const { props, styles } = def2;
        let numberProps;
        if (props && !isArray(props)) {
          for (const key in props) {
            const opt = props[key];
            if (opt === Number || opt && opt.type === Number) {
              if (key in this._props) {
                this._props[key] = toNumber(this._props[key]);
              }
              (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize2(key)] = true;
            }
          }
        }
        this._numberProps = numberProps;
        if (isAsync) {
          this._resolveProps(def2);
        }
        this._applyStyles(styles);
        this._update();
      };
      const asyncDef = this._def.__asyncLoader;
      if (asyncDef) {
        asyncDef().then((def2) => resolve2(def2, true));
      } else {
        resolve2(this._def);
      }
    }
    _resolveProps(def2) {
      const { props } = def2;
      const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});
      for (const key of Object.keys(this)) {
        if (key[0] !== "_" && declaredPropKeys.includes(key)) {
          this._setProp(key, this[key], true, false);
        }
      }
      for (const key of declaredPropKeys.map(camelize2)) {
        Object.defineProperty(this, key, {
          get() {
            return this._getProp(key);
          },
          set(val) {
            this._setProp(key, val);
          }
        });
      }
    }
    _setAttr(key) {
      let value = this.hasAttribute(key) ? this.getAttribute(key) : void 0;
      const camelKey = camelize2(key);
      if (this._numberProps && this._numberProps[camelKey]) {
        value = toNumber(value);
      }
      this._setProp(camelKey, value, false);
    }
    /**
     * @internal
     */
    _getProp(key) {
      return this._props[key];
    }
    /**
     * @internal
     */
    _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
      if (val !== this._props[key]) {
        this._props[key] = val;
        if (shouldUpdate && this._instance) {
          this._update();
        }
        if (shouldReflect) {
          if (val === true) {
            this.setAttribute(hyphenate(key), "");
          } else if (typeof val === "string" || typeof val === "number") {
            this.setAttribute(hyphenate(key), val + "");
          } else if (!val) {
            this.removeAttribute(hyphenate(key));
          }
        }
      }
    }
    _update() {
      render(this._createVNode(), this.shadowRoot);
    }
    _createVNode() {
      const vnode = createVNode(this._def, extend3({}, this._props));
      if (!this._instance) {
        vnode.ce = (instance) => {
          this._instance = instance;
          instance.isCE = true;
          if (true) {
            instance.ceReload = (newStyles) => {
              if (this._styles) {
                this._styles.forEach((s) => this.shadowRoot.removeChild(s));
                this._styles.length = 0;
              }
              this._applyStyles(newStyles);
              this._instance = null;
              this._update();
            };
          }
          const dispatch2 = (event, args) => {
            this.dispatchEvent(
              new CustomEvent(event, {
                detail: args
              })
            );
          };
          instance.emit = (event, ...args) => {
            dispatch2(event, args);
            if (hyphenate(event) !== event) {
              dispatch2(hyphenate(event), args);
            }
          };
          let parent = this;
          while (parent = parent && (parent.parentNode || parent.host)) {
            if (parent instanceof _VueElement) {
              instance.parent = parent._instance;
              instance.provides = parent._instance.provides;
              break;
            }
          }
        };
      }
      return vnode;
    }
    _applyStyles(styles) {
      if (styles) {
        styles.forEach((css) => {
          const s = document.createElement("style");
          s.textContent = css;
          this.shadowRoot.appendChild(s);
          if (true) {
            (this._styles || (this._styles = [])).push(s);
          }
        });
      }
    }
  };
  function useCssModule(name = "$style") {
    {
      const instance = getCurrentInstance();
      if (!instance) {
        warn2(`useCssModule must be called inside setup()`);
        return EMPTY_OBJ;
      }
      const modules = instance.type.__cssModules;
      if (!modules) {
        warn2(`Current instance does not have CSS modules injected.`);
        return EMPTY_OBJ;
      }
      const mod = modules[name];
      if (!mod) {
        warn2(`Current instance does not have CSS module named "${name}".`);
        return EMPTY_OBJ;
      }
      return mod;
    }
  }
  var positionMap = /* @__PURE__ */ new WeakMap();
  var newPositionMap = /* @__PURE__ */ new WeakMap();
  var moveCbKey = Symbol("_moveCb");
  var enterCbKey2 = Symbol("_enterCb");
  var TransitionGroupImpl = {
    name: "TransitionGroup",
    props: /* @__PURE__ */ extend3({}, TransitionPropsValidators, {
      tag: String,
      moveClass: String
    }),
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      let prevChildren;
      let children;
      onUpdated(() => {
        if (!prevChildren.length) {
          return;
        }
        const moveClass = props.moveClass || `${props.name || "v"}-move`;
        if (!hasCSSTransform(
          prevChildren[0].el,
          instance.vnode.el,
          moveClass
        )) {
          return;
        }
        prevChildren.forEach(callPendingCbs);
        prevChildren.forEach(recordPosition);
        const movedChildren = prevChildren.filter(applyTranslation);
        forceReflow();
        movedChildren.forEach((c) => {
          const el = c.el;
          const style = el.style;
          addTransitionClass(el, moveClass);
          style.transform = style.webkitTransform = style.transitionDuration = "";
          const cb = el[moveCbKey] = (e) => {
            if (e && e.target !== el) {
              return;
            }
            if (!e || /transform$/.test(e.propertyName)) {
              el.removeEventListener("transitionend", cb);
              el[moveCbKey] = null;
              removeTransitionClass(el, moveClass);
            }
          };
          el.addEventListener("transitionend", cb);
        });
      });
      return () => {
        const rawProps = toRaw(props);
        const cssTransitionProps = resolveTransitionProps(rawProps);
        let tag = rawProps.tag || Fragment;
        prevChildren = [];
        if (children) {
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.el && child.el instanceof Element) {
              prevChildren.push(child);
              setTransitionHooks(
                child,
                resolveTransitionHooks(
                  child,
                  cssTransitionProps,
                  state,
                  instance
                )
              );
              positionMap.set(
                child,
                child.el.getBoundingClientRect()
              );
            }
          }
        }
        children = slots.default ? getTransitionRawChildren(slots.default()) : [];
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.key != null) {
            setTransitionHooks(
              child,
              resolveTransitionHooks(child, cssTransitionProps, state, instance)
            );
          } else if (true) {
            warn2(`<TransitionGroup> children must be keyed.`);
          }
        }
        return createVNode(tag, null, children);
      };
    }
  };
  var removeMode = (props) => delete props.mode;
  /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
  var TransitionGroup = TransitionGroupImpl;
  function callPendingCbs(c) {
    const el = c.el;
    if (el[moveCbKey]) {
      el[moveCbKey]();
    }
    if (el[enterCbKey2]) {
      el[enterCbKey2]();
    }
  }
  function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
  }
  function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
      const s = c.el.style;
      s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
      s.transitionDuration = "0s";
      return c;
    }
  }
  function hasCSSTransform(el, root, moveClass) {
    const clone = el.cloneNode();
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.forEach((cls) => {
        cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
      });
    }
    moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
    clone.style.display = "none";
    const container = root.nodeType === 1 ? root : root.parentNode;
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
  }
  var getModelAssigner = (vnode) => {
    const fn = vnode.props["onUpdate:modelValue"] || false;
    return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
  };
  function onCompositionStart(e) {
    e.target.composing = true;
  }
  function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
      target.composing = false;
      target.dispatchEvent(new Event("input"));
    }
  }
  var assignKey = Symbol("_assign");
  var vModelText = {
    created(el, { modifiers: { lazy, trim, number } }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      const castToNumber = number || vnode.props && vnode.props.type === "number";
      addEventListener2(el, lazy ? "change" : "input", (e) => {
        if (e.target.composing)
          return;
        let domValue = el.value;
        if (trim) {
          domValue = domValue.trim();
        }
        if (castToNumber) {
          domValue = looseToNumber(domValue);
        }
        el[assignKey](domValue);
      });
      if (trim) {
        addEventListener2(el, "change", () => {
          el.value = el.value.trim();
        });
      }
      if (!lazy) {
        addEventListener2(el, "compositionstart", onCompositionStart);
        addEventListener2(el, "compositionend", onCompositionEnd);
        addEventListener2(el, "change", onCompositionEnd);
      }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(el, { value }) {
      el.value = value == null ? "" : value;
    },
    beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      if (el.composing)
        return;
      const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
      const newValue = value == null ? "" : value;
      if (elValue === newValue) {
        return;
      }
      if (document.activeElement === el && el.type !== "range") {
        if (lazy && value === oldValue) {
          return;
        }
        if (trim && el.value.trim() === newValue) {
          return;
        }
      }
      el.value = newValue;
    }
  };
  var vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created(el, _2, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      addEventListener2(el, "change", () => {
        const modelValue = el._modelValue;
        const elementValue = getValue(el);
        const checked = el.checked;
        const assign = el[assignKey];
        if (isArray(modelValue)) {
          const index = looseIndexOf(modelValue, elementValue);
          const found = index !== -1;
          if (checked && !found) {
            assign(modelValue.concat(elementValue));
          } else if (!checked && found) {
            const filtered = [...modelValue];
            filtered.splice(index, 1);
            assign(filtered);
          }
        } else if (isSet(modelValue)) {
          const cloned = new Set(modelValue);
          if (checked) {
            cloned.add(elementValue);
          } else {
            cloned.delete(elementValue);
          }
          assign(cloned);
        } else {
          assign(getCheckboxValue(el, checked));
        }
      });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate(el, binding, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      setChecked(el, binding, vnode);
    }
  };
  function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if (isArray(value)) {
      el.checked = looseIndexOf(value, vnode.props.value) > -1;
    } else if (isSet(value)) {
      el.checked = value.has(vnode.props.value);
    } else if (value !== oldValue) {
      el.checked = looseEqual(value, getCheckboxValue(el, true));
    }
  }
  var vModelRadio = {
    created(el, { value }, vnode) {
      el.checked = looseEqual(value, vnode.props.value);
      el[assignKey] = getModelAssigner(vnode);
      addEventListener2(el, "change", () => {
        el[assignKey](getValue(el));
      });
    },
    beforeUpdate(el, { value, oldValue }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      if (value !== oldValue) {
        el.checked = looseEqual(value, vnode.props.value);
      }
    }
  };
  var vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created(el, { value, modifiers: { number } }, vnode) {
      const isSetModel = isSet(value);
      addEventListener2(el, "change", () => {
        const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
          (o) => number ? looseToNumber(getValue(o)) : getValue(o)
        );
        el[assignKey](
          el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
        );
        el._assigning = true;
        nextTick(() => {
          el._assigning = false;
        });
      });
      el[assignKey] = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted(el, { value, modifiers: { number } }) {
      setSelected(el, value);
    },
    beforeUpdate(el, _binding, vnode) {
      el[assignKey] = getModelAssigner(vnode);
    },
    updated(el, { value, modifiers: { number } }) {
      if (!el._assigning) {
        setSelected(el, value);
      }
    }
  };
  function setSelected(el, value, number) {
    const isMultiple = el.multiple;
    const isArrayValue = isArray(value);
    if (isMultiple && !isArrayValue && !isSet(value)) {
      warn2(
        `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`
      );
      return;
    }
    for (let i = 0, l = el.options.length; i < l; i++) {
      const option = el.options[i];
      const optionValue = getValue(option);
      if (isMultiple) {
        if (isArrayValue) {
          const optionType = typeof optionValue;
          if (optionType === "string" || optionType === "number") {
            option.selected = value.some((v) => String(v) === String(optionValue));
          } else {
            option.selected = looseIndexOf(value, optionValue) > -1;
          }
        } else {
          option.selected = value.has(optionValue);
        }
      } else if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i)
          el.selectedIndex = i;
        return;
      }
    }
    if (!isMultiple && el.selectedIndex !== -1) {
      el.selectedIndex = -1;
    }
  }
  function getValue(el) {
    return "_value" in el ? el._value : el.value;
  }
  function getCheckboxValue(el, checked) {
    const key = checked ? "_trueValue" : "_falseValue";
    return key in el ? el[key] : checked;
  }
  var vModelDynamic = {
    created(el, binding, vnode) {
      callModelHook(el, binding, vnode, null, "created");
    },
    mounted(el, binding, vnode) {
      callModelHook(el, binding, vnode, null, "mounted");
    },
    beforeUpdate(el, binding, vnode, prevVNode) {
      callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
    },
    updated(el, binding, vnode, prevVNode) {
      callModelHook(el, binding, vnode, prevVNode, "updated");
    }
  };
  function resolveDynamicModel(tagName, type) {
    switch (tagName) {
      case "SELECT":
        return vModelSelect;
      case "TEXTAREA":
        return vModelText;
      default:
        switch (type) {
          case "checkbox":
            return vModelCheckbox;
          case "radio":
            return vModelRadio;
          default:
            return vModelText;
        }
    }
  }
  function callModelHook(el, binding, vnode, prevVNode, hook) {
    const modelToUse = resolveDynamicModel(
      el.tagName,
      vnode.props && vnode.props.type
    );
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
  }
  function initVModelForSSR() {
    vModelText.getSSRProps = ({ value }) => ({ value });
    vModelRadio.getSSRProps = ({ value }, vnode) => {
      if (vnode.props && looseEqual(vnode.props.value, value)) {
        return { checked: true };
      }
    };
    vModelCheckbox.getSSRProps = ({ value }, vnode) => {
      if (isArray(value)) {
        if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
          return { checked: true };
        }
      } else if (isSet(value)) {
        if (vnode.props && value.has(vnode.props.value)) {
          return { checked: true };
        }
      } else if (value) {
        return { checked: true };
      }
    };
    vModelDynamic.getSSRProps = (binding, vnode) => {
      if (typeof vnode.type !== "string") {
        return;
      }
      const modelToUse = resolveDynamicModel(
        // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
        vnode.type.toUpperCase(),
        vnode.props && vnode.props.type
      );
      if (modelToUse.getSSRProps) {
        return modelToUse.getSSRProps(binding, vnode);
      }
    };
  }
  var systemModifiers = ["ctrl", "shift", "alt", "meta"];
  var modifierGuards = {
    stop: (e) => e.stopPropagation(),
    prevent: (e) => e.preventDefault(),
    self: (e) => e.target !== e.currentTarget,
    ctrl: (e) => !e.ctrlKey,
    shift: (e) => !e.shiftKey,
    alt: (e) => !e.altKey,
    meta: (e) => !e.metaKey,
    left: (e) => "button" in e && e.button !== 0,
    middle: (e) => "button" in e && e.button !== 1,
    right: (e) => "button" in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
  };
  var withModifiers = (fn, modifiers) => {
    const cache2 = fn._withMods || (fn._withMods = {});
    const cacheKey = modifiers.join(".");
    return cache2[cacheKey] || (cache2[cacheKey] = (event, ...args) => {
      for (let i = 0; i < modifiers.length; i++) {
        const guard = modifierGuards[modifiers[i]];
        if (guard && guard(event, modifiers))
          return;
      }
      return fn(event, ...args);
    });
  };
  var keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  };
  var withKeys = (fn, modifiers) => {
    const cache2 = fn._withKeys || (fn._withKeys = {});
    const cacheKey = modifiers.join(".");
    return cache2[cacheKey] || (cache2[cacheKey] = (event) => {
      if (!("key" in event)) {
        return;
      }
      const eventKey = hyphenate(event.key);
      if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
        return fn(event);
      }
    });
  };
  var rendererOptions = /* @__PURE__ */ extend3({ patchProp }, nodeOps);
  var renderer;
  var enabledHydration = false;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  function ensureHydrationRenderer() {
    renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
    enabledHydration = true;
    return renderer;
  }
  var render = (...args) => {
    ensureRenderer().render(...args);
  };
  var hydrate = (...args) => {
    ensureHydrationRenderer().hydrate(...args);
  };
  var createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    if (true) {
      injectNativeTagCheck(app);
      injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container)
        return;
      const component = app._component;
      if (!isFunction2(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      container.innerHTML = "";
      const proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  };
  var createSSRApp = (...args) => {
    const app = ensureHydrationRenderer().createApp(...args);
    if (true) {
      injectNativeTagCheck(app);
      injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (container) {
        return mount(container, true, resolveRootNamespace(container));
      }
    };
    return app;
  };
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
      value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
      writable: false
    });
  }
  function injectCompilerOptionsCheck(app) {
    if (isRuntimeOnly()) {
      const isCustomElement = app.config.isCustomElement;
      Object.defineProperty(app.config, "isCustomElement", {
        get() {
          return isCustomElement;
        },
        set() {
          warn2(
            `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
          );
        }
      });
      const compilerOptions = app.config.compilerOptions;
      const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
      Object.defineProperty(app.config, "compilerOptions", {
        get() {
          warn2(msg);
          return compilerOptions;
        },
        set() {
          warn2(msg);
        }
      });
    }
  }
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
      if (!res) {
        warn2(
          `Failed to mount app: mount target selector "${container}" returned null.`
        );
      }
      return res;
    }
    if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
      warn2(
        `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
      );
    }
    return container;
  }
  var ssrDirectiveInitialized = false;
  var initDirectivesForSSR = () => {
    if (!ssrDirectiveInitialized) {
      ssrDirectiveInitialized = true;
      initVModelForSSR();
      initVShowForSSR();
    }
  };

  // node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js
  var FRAGMENT = Symbol(true ? `Fragment` : ``);
  var TELEPORT = Symbol(true ? `Teleport` : ``);
  var SUSPENSE = Symbol(true ? `Suspense` : ``);
  var KEEP_ALIVE = Symbol(true ? `KeepAlive` : ``);
  var BASE_TRANSITION = Symbol(true ? `BaseTransition` : ``);
  var OPEN_BLOCK = Symbol(true ? `openBlock` : ``);
  var CREATE_BLOCK = Symbol(true ? `createBlock` : ``);
  var CREATE_ELEMENT_BLOCK = Symbol(true ? `createElementBlock` : ``);
  var CREATE_VNODE = Symbol(true ? `createVNode` : ``);
  var CREATE_ELEMENT_VNODE = Symbol(true ? `createElementVNode` : ``);
  var CREATE_COMMENT = Symbol(true ? `createCommentVNode` : ``);
  var CREATE_TEXT = Symbol(true ? `createTextVNode` : ``);
  var CREATE_STATIC = Symbol(true ? `createStaticVNode` : ``);
  var RESOLVE_COMPONENT = Symbol(true ? `resolveComponent` : ``);
  var RESOLVE_DYNAMIC_COMPONENT = Symbol(
    true ? `resolveDynamicComponent` : ``
  );
  var RESOLVE_DIRECTIVE = Symbol(true ? `resolveDirective` : ``);
  var RESOLVE_FILTER = Symbol(true ? `resolveFilter` : ``);
  var WITH_DIRECTIVES = Symbol(true ? `withDirectives` : ``);
  var RENDER_LIST = Symbol(true ? `renderList` : ``);
  var RENDER_SLOT = Symbol(true ? `renderSlot` : ``);
  var CREATE_SLOTS = Symbol(true ? `createSlots` : ``);
  var TO_DISPLAY_STRING = Symbol(true ? `toDisplayString` : ``);
  var MERGE_PROPS = Symbol(true ? `mergeProps` : ``);
  var NORMALIZE_CLASS = Symbol(true ? `normalizeClass` : ``);
  var NORMALIZE_STYLE = Symbol(true ? `normalizeStyle` : ``);
  var NORMALIZE_PROPS = Symbol(true ? `normalizeProps` : ``);
  var GUARD_REACTIVE_PROPS = Symbol(true ? `guardReactiveProps` : ``);
  var TO_HANDLERS = Symbol(true ? `toHandlers` : ``);
  var CAMELIZE = Symbol(true ? `camelize` : ``);
  var CAPITALIZE = Symbol(true ? `capitalize` : ``);
  var TO_HANDLER_KEY = Symbol(true ? `toHandlerKey` : ``);
  var SET_BLOCK_TRACKING = Symbol(true ? `setBlockTracking` : ``);
  var PUSH_SCOPE_ID = Symbol(true ? `pushScopeId` : ``);
  var POP_SCOPE_ID = Symbol(true ? `popScopeId` : ``);
  var WITH_CTX = Symbol(true ? `withCtx` : ``);
  var UNREF = Symbol(true ? `unref` : ``);
  var IS_REF = Symbol(true ? `isRef` : ``);
  var WITH_MEMO = Symbol(true ? `withMemo` : ``);
  var IS_MEMO_SAME = Symbol(true ? `isMemoSame` : ``);
  var helperNameMap = {
    [FRAGMENT]: `Fragment`,
    [TELEPORT]: `Teleport`,
    [SUSPENSE]: `Suspense`,
    [KEEP_ALIVE]: `KeepAlive`,
    [BASE_TRANSITION]: `BaseTransition`,
    [OPEN_BLOCK]: `openBlock`,
    [CREATE_BLOCK]: `createBlock`,
    [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
    [CREATE_VNODE]: `createVNode`,
    [CREATE_ELEMENT_VNODE]: `createElementVNode`,
    [CREATE_COMMENT]: `createCommentVNode`,
    [CREATE_TEXT]: `createTextVNode`,
    [CREATE_STATIC]: `createStaticVNode`,
    [RESOLVE_COMPONENT]: `resolveComponent`,
    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
    [RESOLVE_DIRECTIVE]: `resolveDirective`,
    [RESOLVE_FILTER]: `resolveFilter`,
    [WITH_DIRECTIVES]: `withDirectives`,
    [RENDER_LIST]: `renderList`,
    [RENDER_SLOT]: `renderSlot`,
    [CREATE_SLOTS]: `createSlots`,
    [TO_DISPLAY_STRING]: `toDisplayString`,
    [MERGE_PROPS]: `mergeProps`,
    [NORMALIZE_CLASS]: `normalizeClass`,
    [NORMALIZE_STYLE]: `normalizeStyle`,
    [NORMALIZE_PROPS]: `normalizeProps`,
    [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
    [TO_HANDLERS]: `toHandlers`,
    [CAMELIZE]: `camelize`,
    [CAPITALIZE]: `capitalize`,
    [TO_HANDLER_KEY]: `toHandlerKey`,
    [SET_BLOCK_TRACKING]: `setBlockTracking`,
    [PUSH_SCOPE_ID]: `pushScopeId`,
    [POP_SCOPE_ID]: `popScopeId`,
    [WITH_CTX]: `withCtx`,
    [UNREF]: `unref`,
    [IS_REF]: `isRef`,
    [WITH_MEMO]: `withMemo`,
    [IS_MEMO_SAME]: `isMemoSame`
  };
  function registerRuntimeHelpers(helpers) {
    Object.getOwnPropertySymbols(helpers).forEach((s) => {
      helperNameMap[s] = helpers[s];
    });
  }
  var locStub = {
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 },
    source: ""
  };
  function createRoot(children, source = "") {
    return {
      type: 0,
      source,
      children,
      helpers: /* @__PURE__ */ new Set(),
      components: [],
      directives: [],
      hoists: [],
      imports: [],
      cached: 0,
      temps: 0,
      codegenNode: void 0,
      loc: locStub
    };
  }
  function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
    if (context) {
      if (isBlock) {
        context.helper(OPEN_BLOCK);
        context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
      } else {
        context.helper(getVNodeHelper(context.inSSR, isComponent2));
      }
      if (directives) {
        context.helper(WITH_DIRECTIVES);
      }
    }
    return {
      type: 13,
      tag,
      props,
      children,
      patchFlag,
      dynamicProps,
      directives,
      isBlock,
      disableTracking,
      isComponent: isComponent2,
      loc
    };
  }
  function createArrayExpression(elements, loc = locStub) {
    return {
      type: 17,
      loc,
      elements
    };
  }
  function createObjectExpression(properties, loc = locStub) {
    return {
      type: 15,
      loc,
      properties
    };
  }
  function createObjectProperty(key, value) {
    return {
      type: 16,
      loc: locStub,
      key: isString(key) ? createSimpleExpression(key, true) : key,
      value
    };
  }
  function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
    return {
      type: 4,
      loc,
      content,
      isStatic,
      constType: isStatic ? 3 : constType
    };
  }
  function createCompoundExpression(children, loc = locStub) {
    return {
      type: 8,
      loc,
      children
    };
  }
  function createCallExpression(callee, args = [], loc = locStub) {
    return {
      type: 14,
      loc,
      callee,
      arguments: args
    };
  }
  function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
    return {
      type: 18,
      params,
      returns,
      newline,
      isSlot,
      loc
    };
  }
  function createConditionalExpression(test, consequent, alternate, newline = true) {
    return {
      type: 19,
      test,
      consequent,
      alternate,
      newline,
      loc: locStub
    };
  }
  function createCacheExpression(index, value, isVNode2 = false) {
    return {
      type: 20,
      index,
      value,
      isVNode: isVNode2,
      loc: locStub
    };
  }
  function createBlockStatement(body) {
    return {
      type: 21,
      body,
      loc: locStub
    };
  }
  function getVNodeHelper(ssr, isComponent2) {
    return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
  }
  function getVNodeBlockHelper(ssr, isComponent2) {
    return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
  }
  function convertToBlock(node, { helper, removeHelper, inSSR }) {
    if (!node.isBlock) {
      node.isBlock = true;
      removeHelper(getVNodeHelper(inSSR, node.isComponent));
      helper(OPEN_BLOCK);
      helper(getVNodeBlockHelper(inSSR, node.isComponent));
    }
  }
  var defaultDelimitersOpen = new Uint8Array([123, 123]);
  var defaultDelimitersClose = new Uint8Array([125, 125]);
  function isTagStartChar(c) {
    return c >= 97 && c <= 122 || c >= 65 && c <= 90;
  }
  function isWhitespace(c) {
    return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
  }
  function isEndOfTagSection(c) {
    return c === 47 || c === 62 || isWhitespace(c);
  }
  function toCharCodes(str) {
    const ret = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) {
      ret[i] = str.charCodeAt(i);
    }
    return ret;
  }
  var Sequences = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    // CDATA[
    CdataEnd: new Uint8Array([93, 93, 62]),
    // ]]>
    CommentEnd: new Uint8Array([45, 45, 62]),
    // `-->`
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    // `<\/script`
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    // `</style`
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
    // `</title`
    TextareaEnd: new Uint8Array([
      60,
      47,
      116,
      101,
      120,
      116,
      97,
      114,
      101,
      97
    ])
    // `</textarea
  };
  var Tokenizer = class {
    constructor(stack3, cbs) {
      this.stack = stack3;
      this.cbs = cbs;
      this.state = 1;
      this.buffer = "";
      this.sectionStart = 0;
      this.index = 0;
      this.entityStart = 0;
      this.baseState = 1;
      this.inRCDATA = false;
      this.inXML = false;
      this.inVPre = false;
      this.newlines = [];
      this.mode = 0;
      this.delimiterOpen = defaultDelimitersOpen;
      this.delimiterClose = defaultDelimitersClose;
      this.delimiterIndex = -1;
      this.currentSequence = void 0;
      this.sequenceIndex = 0;
    }
    get inSFCRoot() {
      return this.mode === 2 && this.stack.length === 0;
    }
    reset() {
      this.state = 1;
      this.mode = 0;
      this.buffer = "";
      this.sectionStart = 0;
      this.index = 0;
      this.baseState = 1;
      this.inRCDATA = false;
      this.currentSequence = void 0;
      this.newlines.length = 0;
      this.delimiterOpen = defaultDelimitersOpen;
      this.delimiterClose = defaultDelimitersClose;
    }
    /**
     * Generate Position object with line / column information using recorded
     * newline positions. We know the index is always going to be an already
     * processed index, so all the newlines up to this index should have been
     * recorded.
     */
    getPos(index) {
      let line = 1;
      let column = index + 1;
      for (let i = this.newlines.length - 1; i >= 0; i--) {
        const newlineIndex = this.newlines[i];
        if (index > newlineIndex) {
          line = i + 2;
          column = index - newlineIndex;
          break;
        }
      }
      return {
        column,
        line,
        offset: index
      };
    }
    peek() {
      return this.buffer.charCodeAt(this.index + 1);
    }
    stateText(c) {
      if (c === 60) {
        if (this.index > this.sectionStart) {
          this.cbs.ontext(this.sectionStart, this.index);
        }
        this.state = 5;
        this.sectionStart = this.index;
      } else if (!this.inVPre && c === this.delimiterOpen[0]) {
        this.state = 2;
        this.delimiterIndex = 0;
        this.stateInterpolationOpen(c);
      }
    }
    stateInterpolationOpen(c) {
      if (c === this.delimiterOpen[this.delimiterIndex]) {
        if (this.delimiterIndex === this.delimiterOpen.length - 1) {
          const start2 = this.index + 1 - this.delimiterOpen.length;
          if (start2 > this.sectionStart) {
            this.cbs.ontext(this.sectionStart, start2);
          }
          this.state = 3;
          this.sectionStart = start2;
        } else {
          this.delimiterIndex++;
        }
      } else if (this.inRCDATA) {
        this.state = 32;
        this.stateInRCDATA(c);
      } else {
        this.state = 1;
        this.stateText(c);
      }
    }
    stateInterpolation(c) {
      if (c === this.delimiterClose[0]) {
        this.state = 4;
        this.delimiterIndex = 0;
        this.stateInterpolationClose(c);
      }
    }
    stateInterpolationClose(c) {
      if (c === this.delimiterClose[this.delimiterIndex]) {
        if (this.delimiterIndex === this.delimiterClose.length - 1) {
          this.cbs.oninterpolation(this.sectionStart, this.index + 1);
          if (this.inRCDATA) {
            this.state = 32;
          } else {
            this.state = 1;
          }
          this.sectionStart = this.index + 1;
        } else {
          this.delimiterIndex++;
        }
      } else {
        this.state = 3;
        this.stateInterpolation(c);
      }
    }
    stateSpecialStartSequence(c) {
      const isEnd = this.sequenceIndex === this.currentSequence.length;
      const isMatch = isEnd ? (
        // If we are at the end of the sequence, make sure the tag name has ended
        isEndOfTagSection(c)
      ) : (
        // Otherwise, do a case-insensitive comparison
        (c | 32) === this.currentSequence[this.sequenceIndex]
      );
      if (!isMatch) {
        this.inRCDATA = false;
      } else if (!isEnd) {
        this.sequenceIndex++;
        return;
      }
      this.sequenceIndex = 0;
      this.state = 6;
      this.stateInTagName(c);
    }
    /** Look for an end tag. For <title> and <textarea>, also decode entities. */
    stateInRCDATA(c) {
      if (this.sequenceIndex === this.currentSequence.length) {
        if (c === 62 || isWhitespace(c)) {
          const endOfText = this.index - this.currentSequence.length;
          if (this.sectionStart < endOfText) {
            const actualIndex = this.index;
            this.index = endOfText;
            this.cbs.ontext(this.sectionStart, endOfText);
            this.index = actualIndex;
          }
          this.sectionStart = endOfText + 2;
          this.stateInClosingTagName(c);
          this.inRCDATA = false;
          return;
        }
        this.sequenceIndex = 0;
      }
      if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
        this.sequenceIndex += 1;
      } else if (this.sequenceIndex === 0) {
        if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
          if (c === this.delimiterOpen[0]) {
            this.state = 2;
            this.delimiterIndex = 0;
            this.stateInterpolationOpen(c);
          }
        } else if (this.fastForwardTo(60)) {
          this.sequenceIndex = 1;
        }
      } else {
        this.sequenceIndex = Number(c === 60);
      }
    }
    stateCDATASequence(c) {
      if (c === Sequences.Cdata[this.sequenceIndex]) {
        if (++this.sequenceIndex === Sequences.Cdata.length) {
          this.state = 28;
          this.currentSequence = Sequences.CdataEnd;
          this.sequenceIndex = 0;
          this.sectionStart = this.index + 1;
        }
      } else {
        this.sequenceIndex = 0;
        this.state = 23;
        this.stateInDeclaration(c);
      }
    }
    /**
     * When we wait for one specific character, we can speed things up
     * by skipping through the buffer until we find it.
     *
     * @returns Whether the character was found.
     */
    fastForwardTo(c) {
      while (++this.index < this.buffer.length) {
        const cc = this.buffer.charCodeAt(this.index);
        if (cc === 10) {
          this.newlines.push(this.index);
        }
        if (cc === c) {
          return true;
        }
      }
      this.index = this.buffer.length - 1;
      return false;
    }
    /**
     * Comments and CDATA end with `-->` and `]]>`.
     *
     * Their common qualities are:
     * - Their end sequences have a distinct character they start with.
     * - That character is then repeated, so we have to check multiple repeats.
     * - All characters but the start character of the sequence can be skipped.
     */
    stateInCommentLike(c) {
      if (c === this.currentSequence[this.sequenceIndex]) {
        if (++this.sequenceIndex === this.currentSequence.length) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, this.index - 2);
          } else {
            this.cbs.oncomment(this.sectionStart, this.index - 2);
          }
          this.sequenceIndex = 0;
          this.sectionStart = this.index + 1;
          this.state = 1;
        }
      } else if (this.sequenceIndex === 0) {
        if (this.fastForwardTo(this.currentSequence[0])) {
          this.sequenceIndex = 1;
        }
      } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
        this.sequenceIndex = 0;
      }
    }
    startSpecial(sequence, offset) {
      this.enterRCDATA(sequence, offset);
      this.state = 31;
    }
    enterRCDATA(sequence, offset) {
      this.inRCDATA = true;
      this.currentSequence = sequence;
      this.sequenceIndex = offset;
    }
    stateBeforeTagName(c) {
      if (c === 33) {
        this.state = 22;
        this.sectionStart = this.index + 1;
      } else if (c === 63) {
        this.state = 24;
        this.sectionStart = this.index + 1;
      } else if (isTagStartChar(c)) {
        this.sectionStart = this.index;
        if (this.mode === 0) {
          this.state = 6;
        } else if (this.inSFCRoot) {
          this.state = 34;
        } else if (!this.inXML) {
          if (c === 116) {
            this.state = 30;
          } else {
            this.state = c === 115 ? 29 : 6;
          }
        } else {
          this.state = 6;
        }
      } else if (c === 47) {
        this.state = 8;
      } else {
        this.state = 1;
        this.stateText(c);
      }
    }
    stateInTagName(c) {
      if (isEndOfTagSection(c)) {
        this.handleTagName(c);
      }
    }
    stateInSFCRootTagName(c) {
      if (isEndOfTagSection(c)) {
        const tag = this.buffer.slice(this.sectionStart, this.index);
        if (tag !== "template") {
          this.enterRCDATA(toCharCodes(`</` + tag), 0);
        }
        this.handleTagName(c);
      }
    }
    handleTagName(c) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = 11;
      this.stateBeforeAttrName(c);
    }
    stateBeforeClosingTagName(c) {
      if (isWhitespace(c))
        ;
      else if (c === 62) {
        if (true) {
          this.cbs.onerr(14, this.index);
        }
        this.state = 1;
        this.sectionStart = this.index + 1;
      } else {
        this.state = isTagStartChar(c) ? 9 : 27;
        this.sectionStart = this.index;
      }
    }
    stateInClosingTagName(c) {
      if (c === 62 || isWhitespace(c)) {
        this.cbs.onclosetag(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = 10;
        this.stateAfterClosingTagName(c);
      }
    }
    stateAfterClosingTagName(c) {
      if (c === 62) {
        this.state = 1;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeAttrName(c) {
      if (c === 62) {
        this.cbs.onopentagend(this.index);
        if (this.inRCDATA) {
          this.state = 32;
        } else {
          this.state = 1;
        }
        this.sectionStart = this.index + 1;
      } else if (c === 47) {
        this.state = 7;
        if (this.peek() !== 62) {
          this.cbs.onerr(22, this.index);
        }
      } else if (c === 60 && this.peek() === 47) {
        this.cbs.onopentagend(this.index);
        this.state = 5;
        this.sectionStart = this.index;
      } else if (!isWhitespace(c)) {
        if (c === 61) {
          this.cbs.onerr(
            19,
            this.index
          );
        }
        this.handleAttrStart(c);
      }
    }
    handleAttrStart(c) {
      if (c === 118 && this.peek() === 45) {
        this.state = 13;
        this.sectionStart = this.index;
      } else if (c === 46 || c === 58 || c === 64 || c === 35) {
        this.cbs.ondirname(this.index, this.index + 1);
        this.state = 14;
        this.sectionStart = this.index + 1;
      } else {
        this.state = 12;
        this.sectionStart = this.index;
      }
    }
    stateInSelfClosingTag(c) {
      if (c === 62) {
        this.cbs.onselfclosingtag(this.index);
        this.state = 1;
        this.sectionStart = this.index + 1;
        this.inRCDATA = false;
      } else if (!isWhitespace(c)) {
        this.state = 11;
        this.stateBeforeAttrName(c);
      }
    }
    stateInAttrName(c) {
      if (c === 61 || isEndOfTagSection(c)) {
        this.cbs.onattribname(this.sectionStart, this.index);
        this.handleAttrNameEnd(c);
      } else if (c === 34 || c === 39 || c === 60) {
        this.cbs.onerr(
          17,
          this.index
        );
      }
    }
    stateInDirName(c) {
      if (c === 61 || isEndOfTagSection(c)) {
        this.cbs.ondirname(this.sectionStart, this.index);
        this.handleAttrNameEnd(c);
      } else if (c === 58) {
        this.cbs.ondirname(this.sectionStart, this.index);
        this.state = 14;
        this.sectionStart = this.index + 1;
      } else if (c === 46) {
        this.cbs.ondirname(this.sectionStart, this.index);
        this.state = 16;
        this.sectionStart = this.index + 1;
      }
    }
    stateInDirArg(c) {
      if (c === 61 || isEndOfTagSection(c)) {
        this.cbs.ondirarg(this.sectionStart, this.index);
        this.handleAttrNameEnd(c);
      } else if (c === 91) {
        this.state = 15;
      } else if (c === 46) {
        this.cbs.ondirarg(this.sectionStart, this.index);
        this.state = 16;
        this.sectionStart = this.index + 1;
      }
    }
    stateInDynamicDirArg(c) {
      if (c === 93) {
        this.state = 14;
      } else if (c === 61 || isEndOfTagSection(c)) {
        this.cbs.ondirarg(this.sectionStart, this.index + 1);
        this.handleAttrNameEnd(c);
        if (true) {
          this.cbs.onerr(
            27,
            this.index
          );
        }
      }
    }
    stateInDirModifier(c) {
      if (c === 61 || isEndOfTagSection(c)) {
        this.cbs.ondirmodifier(this.sectionStart, this.index);
        this.handleAttrNameEnd(c);
      } else if (c === 46) {
        this.cbs.ondirmodifier(this.sectionStart, this.index);
        this.sectionStart = this.index + 1;
      }
    }
    handleAttrNameEnd(c) {
      this.sectionStart = this.index;
      this.state = 17;
      this.cbs.onattribnameend(this.index);
      this.stateAfterAttrName(c);
    }
    stateAfterAttrName(c) {
      if (c === 61) {
        this.state = 18;
      } else if (c === 47 || c === 62) {
        this.cbs.onattribend(0, this.sectionStart);
        this.sectionStart = -1;
        this.state = 11;
        this.stateBeforeAttrName(c);
      } else if (!isWhitespace(c)) {
        this.cbs.onattribend(0, this.sectionStart);
        this.handleAttrStart(c);
      }
    }
    stateBeforeAttrValue(c) {
      if (c === 34) {
        this.state = 19;
        this.sectionStart = this.index + 1;
      } else if (c === 39) {
        this.state = 20;
        this.sectionStart = this.index + 1;
      } else if (!isWhitespace(c)) {
        this.sectionStart = this.index;
        this.state = 21;
        this.stateInAttrValueNoQuotes(c);
      }
    }
    handleInAttrValue(c, quote) {
      if (c === quote || this.fastForwardTo(quote)) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.cbs.onattribend(
          quote === 34 ? 3 : 2,
          this.index + 1
        );
        this.state = 11;
      }
    }
    stateInAttrValueDoubleQuotes(c) {
      this.handleInAttrValue(c, 34);
    }
    stateInAttrValueSingleQuotes(c) {
      this.handleInAttrValue(c, 39);
    }
    stateInAttrValueNoQuotes(c) {
      if (isWhitespace(c) || c === 62) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.cbs.onattribend(1, this.index);
        this.state = 11;
        this.stateBeforeAttrName(c);
      } else if (c === 34 || c === 39 || c === 60 || c === 61 || c === 96) {
        this.cbs.onerr(
          18,
          this.index
        );
      } else
        ;
    }
    stateBeforeDeclaration(c) {
      if (c === 91) {
        this.state = 26;
        this.sequenceIndex = 0;
      } else {
        this.state = c === 45 ? 25 : 23;
      }
    }
    stateInDeclaration(c) {
      if (c === 62 || this.fastForwardTo(62)) {
        this.state = 1;
        this.sectionStart = this.index + 1;
      }
    }
    stateInProcessingInstruction(c) {
      if (c === 62 || this.fastForwardTo(62)) {
        this.cbs.onprocessinginstruction(this.sectionStart, this.index);
        this.state = 1;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeComment(c) {
      if (c === 45) {
        this.state = 28;
        this.currentSequence = Sequences.CommentEnd;
        this.sequenceIndex = 2;
        this.sectionStart = this.index + 1;
      } else {
        this.state = 23;
      }
    }
    stateInSpecialComment(c) {
      if (c === 62 || this.fastForwardTo(62)) {
        this.cbs.oncomment(this.sectionStart, this.index);
        this.state = 1;
        this.sectionStart = this.index + 1;
      }
    }
    stateBeforeSpecialS(c) {
      if (c === Sequences.ScriptEnd[3]) {
        this.startSpecial(Sequences.ScriptEnd, 4);
      } else if (c === Sequences.StyleEnd[3]) {
        this.startSpecial(Sequences.StyleEnd, 4);
      } else {
        this.state = 6;
        this.stateInTagName(c);
      }
    }
    stateBeforeSpecialT(c) {
      if (c === Sequences.TitleEnd[3]) {
        this.startSpecial(Sequences.TitleEnd, 4);
      } else if (c === Sequences.TextareaEnd[3]) {
        this.startSpecial(Sequences.TextareaEnd, 4);
      } else {
        this.state = 6;
        this.stateInTagName(c);
      }
    }
    startEntity() {
    }
    stateInEntity() {
    }
    /**
     * Iterates through the buffer, calling the function corresponding to the current state.
     *
     * States that are more likely to be hit are higher up, as a performance improvement.
     */
    parse(input) {
      this.buffer = input;
      while (this.index < this.buffer.length) {
        const c = this.buffer.charCodeAt(this.index);
        if (c === 10) {
          this.newlines.push(this.index);
        }
        switch (this.state) {
          case 1: {
            this.stateText(c);
            break;
          }
          case 2: {
            this.stateInterpolationOpen(c);
            break;
          }
          case 3: {
            this.stateInterpolation(c);
            break;
          }
          case 4: {
            this.stateInterpolationClose(c);
            break;
          }
          case 31: {
            this.stateSpecialStartSequence(c);
            break;
          }
          case 32: {
            this.stateInRCDATA(c);
            break;
          }
          case 26: {
            this.stateCDATASequence(c);
            break;
          }
          case 19: {
            this.stateInAttrValueDoubleQuotes(c);
            break;
          }
          case 12: {
            this.stateInAttrName(c);
            break;
          }
          case 13: {
            this.stateInDirName(c);
            break;
          }
          case 14: {
            this.stateInDirArg(c);
            break;
          }
          case 15: {
            this.stateInDynamicDirArg(c);
            break;
          }
          case 16: {
            this.stateInDirModifier(c);
            break;
          }
          case 28: {
            this.stateInCommentLike(c);
            break;
          }
          case 27: {
            this.stateInSpecialComment(c);
            break;
          }
          case 11: {
            this.stateBeforeAttrName(c);
            break;
          }
          case 6: {
            this.stateInTagName(c);
            break;
          }
          case 34: {
            this.stateInSFCRootTagName(c);
            break;
          }
          case 9: {
            this.stateInClosingTagName(c);
            break;
          }
          case 5: {
            this.stateBeforeTagName(c);
            break;
          }
          case 17: {
            this.stateAfterAttrName(c);
            break;
          }
          case 20: {
            this.stateInAttrValueSingleQuotes(c);
            break;
          }
          case 18: {
            this.stateBeforeAttrValue(c);
            break;
          }
          case 8: {
            this.stateBeforeClosingTagName(c);
            break;
          }
          case 10: {
            this.stateAfterClosingTagName(c);
            break;
          }
          case 29: {
            this.stateBeforeSpecialS(c);
            break;
          }
          case 30: {
            this.stateBeforeSpecialT(c);
            break;
          }
          case 21: {
            this.stateInAttrValueNoQuotes(c);
            break;
          }
          case 7: {
            this.stateInSelfClosingTag(c);
            break;
          }
          case 23: {
            this.stateInDeclaration(c);
            break;
          }
          case 22: {
            this.stateBeforeDeclaration(c);
            break;
          }
          case 25: {
            this.stateBeforeComment(c);
            break;
          }
          case 24: {
            this.stateInProcessingInstruction(c);
            break;
          }
          case 33: {
            this.stateInEntity();
            break;
          }
        }
        this.index++;
      }
      this.cleanup();
      this.finish();
    }
    /**
     * Remove data that has already been consumed from the buffer.
     */
    cleanup() {
      if (this.sectionStart !== this.index) {
        if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
          this.cbs.ontext(this.sectionStart, this.index);
          this.sectionStart = this.index;
        } else if (this.state === 19 || this.state === 20 || this.state === 21) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = this.index;
        }
      }
    }
    finish() {
      this.handleTrailingData();
      this.cbs.onend();
    }
    /** Handle any trailing data. */
    handleTrailingData() {
      const endIndex = this.buffer.length;
      if (this.sectionStart >= endIndex) {
        return;
      }
      if (this.state === 28) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, endIndex);
        } else {
          this.cbs.oncomment(this.sectionStart, endIndex);
        }
      } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9)
        ;
      else {
        this.cbs.ontext(this.sectionStart, endIndex);
      }
    }
    emitCodePoint(cp, consumed) {
    }
  };
  var deprecationData = {
    ["COMPILER_IS_ON_ELEMENT"]: {
      message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
      link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
    },
    ["COMPILER_V_BIND_SYNC"]: {
      message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
      link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
    },
    ["COMPILER_V_BIND_OBJECT_ORDER"]: {
      message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
      link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
    },
    ["COMPILER_V_ON_NATIVE"]: {
      message: `.native modifier for v-on has been removed as is no longer necessary.`,
      link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
    },
    ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
      message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
      link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
    },
    ["COMPILER_NATIVE_TEMPLATE"]: {
      message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
    },
    ["COMPILER_INLINE_TEMPLATE"]: {
      message: `"inline-template" has been removed in Vue 3.`,
      link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
    },
    ["COMPILER_FILTERS"]: {
      message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
      link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
    }
  };
  function getCompatValue(key, { compatConfig }) {
    const value = compatConfig && compatConfig[key];
    if (key === "MODE") {
      return value || 3;
    } else {
      return value;
    }
  }
  function isCompatEnabled(key, context) {
    const mode = getCompatValue("MODE", context);
    const value = getCompatValue(key, context);
    return mode === 3 ? value === true : value !== false;
  }
  function checkCompatEnabled(key, context, loc, ...args) {
    const enabled = isCompatEnabled(key, context);
    if (enabled) {
      warnDeprecation(key, context, loc, ...args);
    }
    return enabled;
  }
  function warnDeprecation(key, context, loc, ...args) {
    const val = getCompatValue(key, context);
    if (val === "suppress-warning") {
      return;
    }
    const { message, link } = deprecationData[key];
    const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
    const err = new SyntaxError(msg);
    err.code = key;
    if (loc)
      err.loc = loc;
    context.onWarn(err);
  }
  function defaultOnError(error2) {
    throw error2;
  }
  function defaultOnWarn(msg) {
    console.warn(`[Vue warn] ${msg.message}`);
  }
  function createCompilerError(code, loc, messages, additionalMessage) {
    const msg = true ? (messages || errorMessages)[code] + (additionalMessage || ``) : `https://vuejs.org/error-reference/#compiler-${code}`;
    const error2 = new SyntaxError(String(msg));
    error2.code = code;
    error2.loc = loc;
    return error2;
  }
  var errorMessages = {
    // parse errors
    [0]: "Illegal comment.",
    [1]: "CDATA section is allowed only in XML context.",
    [2]: "Duplicate attribute.",
    [3]: "End tag cannot have attributes.",
    [4]: "Illegal '/' in tags.",
    [5]: "Unexpected EOF in tag.",
    [6]: "Unexpected EOF in CDATA section.",
    [7]: "Unexpected EOF in comment.",
    [8]: "Unexpected EOF in script.",
    [9]: "Unexpected EOF in tag.",
    [10]: "Incorrectly closed comment.",
    [11]: "Incorrectly opened comment.",
    [12]: "Illegal tag name. Use '&lt;' to print '<'.",
    [13]: "Attribute value was expected.",
    [14]: "End tag name was expected.",
    [15]: "Whitespace was expected.",
    [16]: "Unexpected '<!--' in comment.",
    [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
    [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
    [19]: "Attribute name cannot start with '='.",
    [21]: "'<?' is allowed only in XML context.",
    [20]: `Unexpected null character.`,
    [22]: "Illegal '/' in tags.",
    // Vue-specific parse errors
    [23]: "Invalid end tag.",
    [24]: "Element is missing end tag.",
    [25]: "Interpolation end sign was not found.",
    [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
    [26]: "Legal directive name was expected.",
    // transform errors
    [28]: `v-if/v-else-if is missing expression.`,
    [29]: `v-if/else branches must use unique keys.`,
    [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
    [31]: `v-for is missing expression.`,
    [32]: `v-for has invalid expression.`,
    [33]: `<template v-for> key should be placed on the <template> tag.`,
    [34]: `v-bind is missing expression.`,
    [52]: `v-bind with same-name shorthand only allows static argument.`,
    [35]: `v-on is missing expression.`,
    [36]: `Unexpected custom directive on <slot> outlet.`,
    [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
    [38]: `Duplicate slot names found. `,
    [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
    [40]: `v-slot can only be used on components or <template> tags.`,
    [41]: `v-model is missing expression.`,
    [42]: `v-model value must be a valid JavaScript member expression.`,
    [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
    [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
    [45]: `Error parsing JavaScript expression: `,
    [46]: `<KeepAlive> expects exactly one child component.`,
    [51]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,
    // generic errors
    [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
    [48]: `ES module mode is not supported in this build of compiler.`,
    [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
    [50]: `"scopeId" option is only supported in module mode.`,
    // just to fulfill types
    [53]: ``
  };
  var isStaticExp = (p2) => p2.type === 4 && p2.isStatic;
  function isCoreComponent(tag) {
    switch (tag) {
      case "Teleport":
      case "teleport":
        return TELEPORT;
      case "Suspense":
      case "suspense":
        return SUSPENSE;
      case "KeepAlive":
      case "keep-alive":
        return KEEP_ALIVE;
      case "BaseTransition":
      case "base-transition":
        return BASE_TRANSITION;
    }
  }
  var nonIdentifierRE = /^\d|[^\$\w\xA0-\uFFFF]/;
  var isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
  var validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
  var validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
  var whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
  var isMemberExpressionBrowser = (path) => {
    path = path.trim().replace(whitespaceRE, (s) => s.trim());
    let state = 0;
    let stateStack = [];
    let currentOpenBracketCount = 0;
    let currentOpenParensCount = 0;
    let currentStringType = null;
    for (let i = 0; i < path.length; i++) {
      const char = path.charAt(i);
      switch (state) {
        case 0:
          if (char === "[") {
            stateStack.push(state);
            state = 1;
            currentOpenBracketCount++;
          } else if (char === "(") {
            stateStack.push(state);
            state = 2;
            currentOpenParensCount++;
          } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
            return false;
          }
          break;
        case 1:
          if (char === `'` || char === `"` || char === "`") {
            stateStack.push(state);
            state = 3;
            currentStringType = char;
          } else if (char === `[`) {
            currentOpenBracketCount++;
          } else if (char === `]`) {
            if (!--currentOpenBracketCount) {
              state = stateStack.pop();
            }
          }
          break;
        case 2:
          if (char === `'` || char === `"` || char === "`") {
            stateStack.push(state);
            state = 3;
            currentStringType = char;
          } else if (char === `(`) {
            currentOpenParensCount++;
          } else if (char === `)`) {
            if (i === path.length - 1) {
              return false;
            }
            if (!--currentOpenParensCount) {
              state = stateStack.pop();
            }
          }
          break;
        case 3:
          if (char === currentStringType) {
            state = stateStack.pop();
            currentStringType = null;
          }
          break;
      }
    }
    return !currentOpenBracketCount && !currentOpenParensCount;
  };
  var isMemberExpression = isMemberExpressionBrowser;
  function assert(condition, msg) {
    if (!condition) {
      throw new Error(msg || `unexpected compiler condition`);
    }
  }
  function findDir(node, name, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
      const p2 = node.props[i];
      if (p2.type === 7 && (allowEmpty || p2.exp) && (isString(name) ? p2.name === name : name.test(p2.name))) {
        return p2;
      }
    }
  }
  function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
      const p2 = node.props[i];
      if (p2.type === 6) {
        if (dynamicOnly)
          continue;
        if (p2.name === name && (p2.value || allowEmpty)) {
          return p2;
        }
      } else if (p2.name === "bind" && (p2.exp || allowEmpty) && isStaticArgOf(p2.arg, name)) {
        return p2;
      }
    }
  }
  function isStaticArgOf(arg, name) {
    return !!(arg && isStaticExp(arg) && arg.content === name);
  }
  function hasDynamicKeyVBind(node) {
    return node.props.some(
      (p2) => p2.type === 7 && p2.name === "bind" && (!p2.arg || // v-bind="obj"
      p2.arg.type !== 4 || // v-bind:[_ctx.foo]
      !p2.arg.isStatic)
      // v-bind:[foo]
    );
  }
  function isText$1(node) {
    return node.type === 5 || node.type === 2;
  }
  function isVSlot(p2) {
    return p2.type === 7 && p2.name === "slot";
  }
  function isTemplateNode(node) {
    return node.type === 1 && node.tagType === 3;
  }
  function isSlotOutlet(node) {
    return node.type === 1 && node.tagType === 2;
  }
  var propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
  function getUnnormalizedProps(props, callPath = []) {
    if (props && !isString(props) && props.type === 14) {
      const callee = props.callee;
      if (!isString(callee) && propsHelperSet.has(callee)) {
        return getUnnormalizedProps(
          props.arguments[0],
          callPath.concat(props)
        );
      }
    }
    return [props, callPath];
  }
  function injectProp(node, prop, context) {
    let propsWithInjection;
    let props = node.type === 13 ? node.props : node.arguments[2];
    let callPath = [];
    let parentCall;
    if (props && !isString(props) && props.type === 14) {
      const ret = getUnnormalizedProps(props);
      props = ret[0];
      callPath = ret[1];
      parentCall = callPath[callPath.length - 1];
    }
    if (props == null || isString(props)) {
      propsWithInjection = createObjectExpression([prop]);
    } else if (props.type === 14) {
      const first = props.arguments[0];
      if (!isString(first) && first.type === 15) {
        if (!hasProp(prop, first)) {
          first.properties.unshift(prop);
        }
      } else {
        if (props.callee === TO_HANDLERS) {
          propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
            createObjectExpression([prop]),
            props
          ]);
        } else {
          props.arguments.unshift(createObjectExpression([prop]));
        }
      }
      !propsWithInjection && (propsWithInjection = props);
    } else if (props.type === 15) {
      if (!hasProp(prop, props)) {
        props.properties.unshift(prop);
      }
      propsWithInjection = props;
    } else {
      propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
        createObjectExpression([prop]),
        props
      ]);
      if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
        parentCall = callPath[callPath.length - 2];
      }
    }
    if (node.type === 13) {
      if (parentCall) {
        parentCall.arguments[0] = propsWithInjection;
      } else {
        node.props = propsWithInjection;
      }
    } else {
      if (parentCall) {
        parentCall.arguments[0] = propsWithInjection;
      } else {
        node.arguments[2] = propsWithInjection;
      }
    }
  }
  function hasProp(prop, props) {
    let result = false;
    if (prop.key.type === 4) {
      const propKeyName = prop.key.content;
      result = props.properties.some(
        (p2) => p2.key.type === 4 && p2.key.content === propKeyName
      );
    }
    return result;
  }
  function toValidAssetId(name, type) {
    return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
      return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
    })}`;
  }
  function getMemoedVNodeCall(node) {
    if (node.type === 14 && node.callee === WITH_MEMO) {
      return node.arguments[1].returns;
    } else {
      return node;
    }
  }
  var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;
  var defaultParserOptions = {
    parseMode: "base",
    ns: 0,
    delimiters: [`{{`, `}}`],
    getNamespace: () => 0,
    isVoidTag: NO,
    isPreTag: NO,
    isCustomElement: NO,
    onError: defaultOnError,
    onWarn: defaultOnWarn,
    comments: true,
    prefixIdentifiers: false
  };
  var currentOptions = defaultParserOptions;
  var currentRoot = null;
  var currentInput = "";
  var currentOpenTag = null;
  var currentProp = null;
  var currentAttrValue = "";
  var currentAttrStartIndex = -1;
  var currentAttrEndIndex = -1;
  var inPre = 0;
  var inVPre = false;
  var currentVPreBoundary = null;
  var stack2 = [];
  var tokenizer = new Tokenizer(stack2, {
    onerr: emitError,
    ontext(start2, end) {
      onText(getSlice(start2, end), start2, end);
    },
    ontextentity(char, start2, end) {
      onText(char, start2, end);
    },
    oninterpolation(start2, end) {
      if (inVPre) {
        return onText(getSlice(start2, end), start2, end);
      }
      let innerStart = start2 + tokenizer.delimiterOpen.length;
      let innerEnd = end - tokenizer.delimiterClose.length;
      while (isWhitespace(currentInput.charCodeAt(innerStart))) {
        innerStart++;
      }
      while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
        innerEnd--;
      }
      let exp = getSlice(innerStart, innerEnd);
      if (exp.includes("&")) {
        {
          exp = currentOptions.decodeEntities(exp, false);
        }
      }
      addNode({
        type: 5,
        content: createExp(exp, false, getLoc(innerStart, innerEnd)),
        loc: getLoc(start2, end)
      });
    },
    onopentagname(start2, end) {
      const name = getSlice(start2, end);
      currentOpenTag = {
        type: 1,
        tag: name,
        ns: currentOptions.getNamespace(name, stack2[0], currentOptions.ns),
        tagType: 0,
        // will be refined on tag close
        props: [],
        children: [],
        loc: getLoc(start2 - 1, end),
        codegenNode: void 0
      };
    },
    onopentagend(end) {
      endOpenTag(end);
    },
    onclosetag(start2, end) {
      const name = getSlice(start2, end);
      if (!currentOptions.isVoidTag(name)) {
        let found = false;
        for (let i = 0; i < stack2.length; i++) {
          const e = stack2[i];
          if (e.tag.toLowerCase() === name.toLowerCase()) {
            found = true;
            if (i > 0) {
              emitError(24, stack2[0].loc.start.offset);
            }
            for (let j = 0; j <= i; j++) {
              const el = stack2.shift();
              onCloseTag(el, end, j < i);
            }
            break;
          }
        }
        if (!found) {
          emitError(23, backTrack(start2, 60));
        }
      }
    },
    onselfclosingtag(end) {
      const name = currentOpenTag.tag;
      currentOpenTag.isSelfClosing = true;
      endOpenTag(end);
      if (stack2[0] && stack2[0].tag === name) {
        onCloseTag(stack2.shift(), end);
      }
    },
    onattribname(start2, end) {
      currentProp = {
        type: 6,
        name: getSlice(start2, end),
        nameLoc: getLoc(start2, end),
        value: void 0,
        loc: getLoc(start2)
      };
    },
    ondirname(start2, end) {
      const raw = getSlice(start2, end);
      const name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
      if (!inVPre && name === "") {
        emitError(26, start2);
      }
      if (inVPre || name === "") {
        currentProp = {
          type: 6,
          name: raw,
          nameLoc: getLoc(start2, end),
          value: void 0,
          loc: getLoc(start2)
        };
      } else {
        currentProp = {
          type: 7,
          name,
          rawName: raw,
          exp: void 0,
          arg: void 0,
          modifiers: raw === "." ? ["prop"] : [],
          loc: getLoc(start2)
        };
        if (name === "pre") {
          inVPre = tokenizer.inVPre = true;
          currentVPreBoundary = currentOpenTag;
          const props = currentOpenTag.props;
          for (let i = 0; i < props.length; i++) {
            if (props[i].type === 7) {
              props[i] = dirToAttr(props[i]);
            }
          }
        }
      }
    },
    ondirarg(start2, end) {
      if (start2 === end)
        return;
      const arg = getSlice(start2, end);
      if (inVPre) {
        currentProp.name += arg;
        setLocEnd(currentProp.nameLoc, end);
      } else {
        const isStatic = arg[0] !== `[`;
        currentProp.arg = createExp(
          isStatic ? arg : arg.slice(1, -1),
          isStatic,
          getLoc(start2, end),
          isStatic ? 3 : 0
        );
      }
    },
    ondirmodifier(start2, end) {
      const mod = getSlice(start2, end);
      if (inVPre) {
        currentProp.name += "." + mod;
        setLocEnd(currentProp.nameLoc, end);
      } else if (currentProp.name === "slot") {
        const arg = currentProp.arg;
        if (arg) {
          arg.content += "." + mod;
          setLocEnd(arg.loc, end);
        }
      } else {
        currentProp.modifiers.push(mod);
      }
    },
    onattribdata(start2, end) {
      currentAttrValue += getSlice(start2, end);
      if (currentAttrStartIndex < 0)
        currentAttrStartIndex = start2;
      currentAttrEndIndex = end;
    },
    onattribentity(char, start2, end) {
      currentAttrValue += char;
      if (currentAttrStartIndex < 0)
        currentAttrStartIndex = start2;
      currentAttrEndIndex = end;
    },
    onattribnameend(end) {
      const start2 = currentProp.loc.start.offset;
      const name = getSlice(start2, end);
      if (currentProp.type === 7) {
        currentProp.rawName = name;
      }
      if (currentOpenTag.props.some(
        (p2) => (p2.type === 7 ? p2.rawName : p2.name) === name
      )) {
        emitError(2, start2);
      }
    },
    onattribend(quote, end) {
      if (currentOpenTag && currentProp) {
        setLocEnd(currentProp.loc, end);
        if (quote !== 0) {
          if (currentAttrValue.includes("&")) {
            currentAttrValue = currentOptions.decodeEntities(
              currentAttrValue,
              true
            );
          }
          if (currentProp.type === 6) {
            if (currentProp.name === "class") {
              currentAttrValue = condense(currentAttrValue).trim();
            }
            if (quote === 1 && !currentAttrValue) {
              emitError(13, end);
            }
            currentProp.value = {
              type: 2,
              content: currentAttrValue,
              loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
            };
            if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
              tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
            }
          } else {
            let expParseMode = 0;
            currentProp.exp = createExp(
              currentAttrValue,
              false,
              getLoc(currentAttrStartIndex, currentAttrEndIndex),
              0,
              expParseMode
            );
            if (currentProp.name === "for") {
              currentProp.forParseResult = parseForExpression(currentProp.exp);
            }
            let syncIndex = -1;
            if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.indexOf("sync")) > -1 && checkCompatEnabled(
              "COMPILER_V_BIND_SYNC",
              currentOptions,
              currentProp.loc,
              currentProp.rawName
            )) {
              currentProp.name = "model";
              currentProp.modifiers.splice(syncIndex, 1);
            }
          }
        }
        if (currentProp.type !== 7 || currentProp.name !== "pre") {
          currentOpenTag.props.push(currentProp);
        }
      }
      currentAttrValue = "";
      currentAttrStartIndex = currentAttrEndIndex = -1;
    },
    oncomment(start2, end) {
      if (currentOptions.comments) {
        addNode({
          type: 3,
          content: getSlice(start2, end),
          loc: getLoc(start2 - 4, end + 3)
        });
      }
    },
    onend() {
      const end = currentInput.length;
      if (tokenizer.state !== 1) {
        switch (tokenizer.state) {
          case 5:
          case 8:
            emitError(5, end);
            break;
          case 3:
          case 4:
            emitError(
              25,
              tokenizer.sectionStart
            );
            break;
          case 28:
            if (tokenizer.currentSequence === Sequences.CdataEnd) {
              emitError(6, end);
            } else {
              emitError(7, end);
            }
            break;
          case 6:
          case 7:
          case 9:
          case 11:
          case 12:
          case 13:
          case 14:
          case 15:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
            emitError(9, end);
            break;
        }
      }
      for (let index = 0; index < stack2.length; index++) {
        onCloseTag(stack2[index], end - 1);
        emitError(24, stack2[index].loc.start.offset);
      }
    },
    oncdata(start2, end) {
      if (stack2[0].ns !== 0) {
        onText(getSlice(start2, end), start2, end);
      } else {
        emitError(1, start2 - 9);
      }
    },
    onprocessinginstruction(start2) {
      if ((stack2[0] ? stack2[0].ns : currentOptions.ns) === 0) {
        emitError(
          21,
          start2 - 1
        );
      }
    }
  });
  var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  var stripParensRE = /^\(|\)$/g;
  function parseForExpression(input) {
    const loc = input.loc;
    const exp = input.content;
    const inMatch = exp.match(forAliasRE);
    if (!inMatch)
      return;
    const [, LHS, RHS] = inMatch;
    const createAliasExpression = (content, offset, asParam = false) => {
      const start2 = loc.start.offset + offset;
      const end = start2 + content.length;
      return createExp(
        content,
        false,
        getLoc(start2, end),
        0,
        asParam ? 1 : 0
        /* Normal */
      );
    };
    const result = {
      source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
      value: void 0,
      key: void 0,
      index: void 0,
      finalized: false
    };
    let valueContent = LHS.trim().replace(stripParensRE, "").trim();
    const trimmedOffset = LHS.indexOf(valueContent);
    const iteratorMatch = valueContent.match(forIteratorRE);
    if (iteratorMatch) {
      valueContent = valueContent.replace(forIteratorRE, "").trim();
      const keyContent = iteratorMatch[1].trim();
      let keyOffset;
      if (keyContent) {
        keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
        result.key = createAliasExpression(keyContent, keyOffset, true);
      }
      if (iteratorMatch[2]) {
        const indexContent = iteratorMatch[2].trim();
        if (indexContent) {
          result.index = createAliasExpression(
            indexContent,
            exp.indexOf(
              indexContent,
              result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
            ),
            true
          );
        }
      }
    }
    if (valueContent) {
      result.value = createAliasExpression(valueContent, trimmedOffset, true);
    }
    return result;
  }
  function getSlice(start2, end) {
    return currentInput.slice(start2, end);
  }
  function endOpenTag(end) {
    if (tokenizer.inSFCRoot) {
      currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
    }
    addNode(currentOpenTag);
    const { tag, ns } = currentOpenTag;
    if (ns === 0 && currentOptions.isPreTag(tag)) {
      inPre++;
    }
    if (currentOptions.isVoidTag(tag)) {
      onCloseTag(currentOpenTag, end);
    } else {
      stack2.unshift(currentOpenTag);
      if (ns === 1 || ns === 2) {
        tokenizer.inXML = true;
      }
    }
    currentOpenTag = null;
  }
  function onText(content, start2, end) {
    {
      const tag = stack2[0] && stack2[0].tag;
      if (tag !== "script" && tag !== "style" && content.includes("&")) {
        content = currentOptions.decodeEntities(content, false);
      }
    }
    const parent = stack2[0] || currentRoot;
    const lastNode = parent.children[parent.children.length - 1];
    if (lastNode && lastNode.type === 2) {
      lastNode.content += content;
      setLocEnd(lastNode.loc, end);
    } else {
      parent.children.push({
        type: 2,
        content,
        loc: getLoc(start2, end)
      });
    }
  }
  function onCloseTag(el, end, isImplied = false) {
    if (isImplied) {
      setLocEnd(el.loc, backTrack(end, 60));
    } else {
      setLocEnd(el.loc, lookAhead(end, 62) + 1);
    }
    if (tokenizer.inSFCRoot) {
      if (el.children.length) {
        el.innerLoc.end = extend3({}, el.children[el.children.length - 1].loc.end);
      } else {
        el.innerLoc.end = extend3({}, el.innerLoc.start);
      }
      el.innerLoc.source = getSlice(
        el.innerLoc.start.offset,
        el.innerLoc.end.offset
      );
    }
    const { tag, ns } = el;
    if (!inVPre) {
      if (tag === "slot") {
        el.tagType = 2;
      } else if (isFragmentTemplate(el)) {
        el.tagType = 3;
      } else if (isComponent(el)) {
        el.tagType = 1;
      }
    }
    if (!tokenizer.inRCDATA) {
      el.children = condenseWhitespace(el.children, el.tag);
    }
    if (ns === 0 && currentOptions.isPreTag(tag)) {
      inPre--;
    }
    if (currentVPreBoundary === el) {
      inVPre = tokenizer.inVPre = false;
      currentVPreBoundary = null;
    }
    if (tokenizer.inXML && (stack2[0] ? stack2[0].ns : currentOptions.ns) === 0) {
      tokenizer.inXML = false;
    }
    {
      const props = el.props;
      if (isCompatEnabled(
        "COMPILER_V_IF_V_FOR_PRECEDENCE",
        currentOptions
      )) {
        let hasIf = false;
        let hasFor = false;
        for (let i = 0; i < props.length; i++) {
          const p2 = props[i];
          if (p2.type === 7) {
            if (p2.name === "if") {
              hasIf = true;
            } else if (p2.name === "for") {
              hasFor = true;
            }
          }
          if (hasIf && hasFor) {
            warnDeprecation(
              "COMPILER_V_IF_V_FOR_PRECEDENCE",
              currentOptions,
              el.loc
            );
            break;
          }
        }
      }
      if (!tokenizer.inSFCRoot && isCompatEnabled(
        "COMPILER_NATIVE_TEMPLATE",
        currentOptions
      ) && el.tag === "template" && !isFragmentTemplate(el)) {
        warnDeprecation(
          "COMPILER_NATIVE_TEMPLATE",
          currentOptions,
          el.loc
        );
        const parent = stack2[0] || currentRoot;
        const index = parent.children.indexOf(el);
        parent.children.splice(index, 1, ...el.children);
      }
      const inlineTemplateProp = props.find(
        (p2) => p2.type === 6 && p2.name === "inline-template"
      );
      if (inlineTemplateProp && checkCompatEnabled(
        "COMPILER_INLINE_TEMPLATE",
        currentOptions,
        inlineTemplateProp.loc
      ) && el.children.length) {
        inlineTemplateProp.value = {
          type: 2,
          content: getSlice(
            el.children[0].loc.start.offset,
            el.children[el.children.length - 1].loc.end.offset
          ),
          loc: inlineTemplateProp.loc
        };
      }
    }
  }
  function lookAhead(index, c) {
    let i = index;
    while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1)
      i++;
    return i;
  }
  function backTrack(index, c) {
    let i = index;
    while (currentInput.charCodeAt(i) !== c && i >= 0)
      i--;
    return i;
  }
  var specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
  function isFragmentTemplate({ tag, props }) {
    if (tag === "template") {
      for (let i = 0; i < props.length; i++) {
        if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
          return true;
        }
      }
    }
    return false;
  }
  function isComponent({ tag, props }) {
    if (currentOptions.isCustomElement(tag)) {
      return false;
    }
    if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
      return true;
    }
    for (let i = 0; i < props.length; i++) {
      const p2 = props[i];
      if (p2.type === 6) {
        if (p2.name === "is" && p2.value) {
          if (p2.value.content.startsWith("vue:")) {
            return true;
          } else if (checkCompatEnabled(
            "COMPILER_IS_ON_ELEMENT",
            currentOptions,
            p2.loc
          )) {
            return true;
          }
        }
      } else if (
        // :is on plain element - only treat as component in compat mode
        p2.name === "bind" && isStaticArgOf(p2.arg, "is") && checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          currentOptions,
          p2.loc
        )
      ) {
        return true;
      }
    }
    return false;
  }
  function isUpperCase(c) {
    return c > 64 && c < 91;
  }
  var windowsNewlineRE = /\r\n/g;
  function condenseWhitespace(nodes, tag) {
    const shouldCondense = currentOptions.whitespace !== "preserve";
    let removedWhitespace = false;
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (node.type === 2) {
        if (!inPre) {
          if (isAllWhitespace(node.content)) {
            const prev = nodes[i - 1] && nodes[i - 1].type;
            const next = nodes[i + 1] && nodes[i + 1].type;
            if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
              removedWhitespace = true;
              nodes[i] = null;
            } else {
              node.content = " ";
            }
          } else if (shouldCondense) {
            node.content = condense(node.content);
          }
        } else {
          node.content = node.content.replace(windowsNewlineRE, "\n");
        }
      }
    }
    if (inPre && tag && currentOptions.isPreTag(tag)) {
      const first = nodes[0];
      if (first && first.type === 2) {
        first.content = first.content.replace(/^\r?\n/, "");
      }
    }
    return removedWhitespace ? nodes.filter(Boolean) : nodes;
  }
  function isAllWhitespace(str) {
    for (let i = 0; i < str.length; i++) {
      if (!isWhitespace(str.charCodeAt(i))) {
        return false;
      }
    }
    return true;
  }
  function hasNewlineChar(str) {
    for (let i = 0; i < str.length; i++) {
      const c = str.charCodeAt(i);
      if (c === 10 || c === 13) {
        return true;
      }
    }
    return false;
  }
  function condense(str) {
    let ret = "";
    let prevCharIsWhitespace = false;
    for (let i = 0; i < str.length; i++) {
      if (isWhitespace(str.charCodeAt(i))) {
        if (!prevCharIsWhitespace) {
          ret += " ";
          prevCharIsWhitespace = true;
        }
      } else {
        ret += str[i];
        prevCharIsWhitespace = false;
      }
    }
    return ret;
  }
  function addNode(node) {
    (stack2[0] || currentRoot).children.push(node);
  }
  function getLoc(start2, end) {
    return {
      start: tokenizer.getPos(start2),
      // @ts-expect-error allow late attachment
      end: end == null ? end : tokenizer.getPos(end),
      // @ts-expect-error allow late attachment
      source: end == null ? end : getSlice(start2, end)
    };
  }
  function setLocEnd(loc, end) {
    loc.end = tokenizer.getPos(end);
    loc.source = getSlice(loc.start.offset, end);
  }
  function dirToAttr(dir) {
    const attr = {
      type: 6,
      name: dir.rawName,
      nameLoc: getLoc(
        dir.loc.start.offset,
        dir.loc.start.offset + dir.rawName.length
      ),
      value: void 0,
      loc: dir.loc
    };
    if (dir.exp) {
      const loc = dir.exp.loc;
      if (loc.end.offset < dir.loc.end.offset) {
        loc.start.offset--;
        loc.start.column--;
        loc.end.offset++;
        loc.end.column++;
      }
      attr.value = {
        type: 2,
        content: dir.exp.content,
        loc
      };
    }
    return attr;
  }
  function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0) {
    const exp = createSimpleExpression(content, isStatic, loc, constType);
    return exp;
  }
  function emitError(code, index, message) {
    currentOptions.onError(
      createCompilerError(code, getLoc(index, index), void 0, message)
    );
  }
  function reset() {
    tokenizer.reset();
    currentOpenTag = null;
    currentProp = null;
    currentAttrValue = "";
    currentAttrStartIndex = -1;
    currentAttrEndIndex = -1;
    stack2.length = 0;
  }
  function baseParse(input, options) {
    reset();
    currentInput = input;
    currentOptions = extend3({}, defaultParserOptions);
    if (options) {
      let key;
      for (key in options) {
        if (options[key] != null) {
          currentOptions[key] = options[key];
        }
      }
    }
    if (true) {
      if (!currentOptions.decodeEntities) {
        throw new Error(
          `[@vue/compiler-core] decodeEntities option is required in browser builds.`
        );
      }
    }
    tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
    tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
    const delimiters = options && options.delimiters;
    if (delimiters) {
      tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
      tokenizer.delimiterClose = toCharCodes(delimiters[1]);
    }
    const root = currentRoot = createRoot([], input);
    tokenizer.parse(currentInput);
    root.loc = getLoc(0, input.length);
    root.children = condenseWhitespace(root.children);
    currentRoot = null;
    return root;
  }
  function hoistStatic(root, context) {
    walk2(
      root,
      context,
      // Root node is unfortunately non-hoistable due to potential parent
      // fallthrough attributes.
      isSingleElementRoot(root, root.children[0])
    );
  }
  function isSingleElementRoot(root, child) {
    const { children } = root;
    return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
  }
  function walk2(node, context, doNotHoistNode = false) {
    const { children } = node;
    const originalCount = children.length;
    let hoistedCount = 0;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.type === 1 && child.tagType === 0) {
        const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
        if (constantType > 0) {
          if (constantType >= 2) {
            child.codegenNode.patchFlag = -1 + (true ? ` /* HOISTED */` : ``);
            child.codegenNode = context.hoist(child.codegenNode);
            hoistedCount++;
            continue;
          }
        } else {
          const codegenNode = child.codegenNode;
          if (codegenNode.type === 13) {
            const flag = getPatchFlag(codegenNode);
            if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
              const props = getNodeProps(child);
              if (props) {
                codegenNode.props = context.hoist(props);
              }
            }
            if (codegenNode.dynamicProps) {
              codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
            }
          }
        }
      }
      if (child.type === 1) {
        const isComponent2 = child.tagType === 1;
        if (isComponent2) {
          context.scopes.vSlot++;
        }
        walk2(child, context);
        if (isComponent2) {
          context.scopes.vSlot--;
        }
      } else if (child.type === 11) {
        walk2(child, context, child.children.length === 1);
      } else if (child.type === 9) {
        for (let i2 = 0; i2 < child.branches.length; i2++) {
          walk2(
            child.branches[i2],
            context,
            child.branches[i2].children.length === 1
          );
        }
      }
    }
    if (hoistedCount && context.transformHoist) {
      context.transformHoist(children, context, node);
    }
    if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
      const hoisted = context.hoist(
        createArrayExpression(node.codegenNode.children)
      );
      if (context.hmr) {
        hoisted.content = `[...${hoisted.content}]`;
      }
      node.codegenNode.children = hoisted;
    }
  }
  function getConstantType(node, context) {
    const { constantCache } = context;
    switch (node.type) {
      case 1:
        if (node.tagType !== 0) {
          return 0;
        }
        const cached = constantCache.get(node);
        if (cached !== void 0) {
          return cached;
        }
        const codegenNode = node.codegenNode;
        if (codegenNode.type !== 13) {
          return 0;
        }
        if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject" && node.tag !== "math") {
          return 0;
        }
        const flag = getPatchFlag(codegenNode);
        if (!flag) {
          let returnType2 = 3;
          const generatedPropsType = getGeneratedPropsConstantType(node, context);
          if (generatedPropsType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (generatedPropsType < returnType2) {
            returnType2 = generatedPropsType;
          }
          for (let i = 0; i < node.children.length; i++) {
            const childType = getConstantType(node.children[i], context);
            if (childType === 0) {
              constantCache.set(node, 0);
              return 0;
            }
            if (childType < returnType2) {
              returnType2 = childType;
            }
          }
          if (returnType2 > 1) {
            for (let i = 0; i < node.props.length; i++) {
              const p2 = node.props[i];
              if (p2.type === 7 && p2.name === "bind" && p2.exp) {
                const expType = getConstantType(p2.exp, context);
                if (expType === 0) {
                  constantCache.set(node, 0);
                  return 0;
                }
                if (expType < returnType2) {
                  returnType2 = expType;
                }
              }
            }
          }
          if (codegenNode.isBlock) {
            for (let i = 0; i < node.props.length; i++) {
              const p2 = node.props[i];
              if (p2.type === 7) {
                constantCache.set(node, 0);
                return 0;
              }
            }
            context.removeHelper(OPEN_BLOCK);
            context.removeHelper(
              getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
            );
            codegenNode.isBlock = false;
            context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
          }
          constantCache.set(node, returnType2);
          return returnType2;
        } else {
          constantCache.set(node, 0);
          return 0;
        }
      case 2:
      case 3:
        return 3;
      case 9:
      case 11:
      case 10:
        return 0;
      case 5:
      case 12:
        return getConstantType(node.content, context);
      case 4:
        return node.constType;
      case 8:
        let returnType = 3;
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          if (isString(child) || isSymbol(child)) {
            continue;
          }
          const childType = getConstantType(child, context);
          if (childType === 0) {
            return 0;
          } else if (childType < returnType) {
            returnType = childType;
          }
        }
        return returnType;
      default:
        if (true)
          ;
        return 0;
    }
  }
  var allowHoistedHelperSet = /* @__PURE__ */ new Set([
    NORMALIZE_CLASS,
    NORMALIZE_STYLE,
    NORMALIZE_PROPS,
    GUARD_REACTIVE_PROPS
  ]);
  function getConstantTypeOfHelperCall(value, context) {
    if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
      const arg = value.arguments[0];
      if (arg.type === 4) {
        return getConstantType(arg, context);
      } else if (arg.type === 14) {
        return getConstantTypeOfHelperCall(arg, context);
      }
    }
    return 0;
  }
  function getGeneratedPropsConstantType(node, context) {
    let returnType = 3;
    const props = getNodeProps(node);
    if (props && props.type === 15) {
      const { properties } = props;
      for (let i = 0; i < properties.length; i++) {
        const { key, value } = properties[i];
        const keyType = getConstantType(key, context);
        if (keyType === 0) {
          return keyType;
        }
        if (keyType < returnType) {
          returnType = keyType;
        }
        let valueType;
        if (value.type === 4) {
          valueType = getConstantType(value, context);
        } else if (value.type === 14) {
          valueType = getConstantTypeOfHelperCall(value, context);
        } else {
          valueType = 0;
        }
        if (valueType === 0) {
          return valueType;
        }
        if (valueType < returnType) {
          returnType = valueType;
        }
      }
    }
    return returnType;
  }
  function getNodeProps(node) {
    const codegenNode = node.codegenNode;
    if (codegenNode.type === 13) {
      return codegenNode.props;
    }
  }
  function getPatchFlag(node) {
    const flag = node.patchFlag;
    return flag ? parseInt(flag, 10) : void 0;
  }
  function createTransformContext(root, {
    filename = "",
    prefixIdentifiers = false,
    hoistStatic: hoistStatic2 = false,
    hmr = false,
    cacheHandlers = false,
    nodeTransforms = [],
    directiveTransforms = {},
    transformHoist = null,
    isBuiltInComponent = NOOP,
    isCustomElement = NOOP,
    expressionPlugins = [],
    scopeId = null,
    slotted = true,
    ssr = false,
    inSSR = false,
    ssrCssVars = ``,
    bindingMetadata = EMPTY_OBJ,
    inline = false,
    isTS = false,
    onError = defaultOnError,
    onWarn = defaultOnWarn,
    compatConfig
  }) {
    const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
    const context = {
      // options
      filename,
      selfName: nameMatch && capitalize2(camelize2(nameMatch[1])),
      prefixIdentifiers,
      hoistStatic: hoistStatic2,
      hmr,
      cacheHandlers,
      nodeTransforms,
      directiveTransforms,
      transformHoist,
      isBuiltInComponent,
      isCustomElement,
      expressionPlugins,
      scopeId,
      slotted,
      ssr,
      inSSR,
      ssrCssVars,
      bindingMetadata,
      inline,
      isTS,
      onError,
      onWarn,
      compatConfig,
      // state
      root,
      helpers: /* @__PURE__ */ new Map(),
      components: /* @__PURE__ */ new Set(),
      directives: /* @__PURE__ */ new Set(),
      hoists: [],
      imports: [],
      constantCache: /* @__PURE__ */ new WeakMap(),
      temps: 0,
      cached: 0,
      identifiers: /* @__PURE__ */ Object.create(null),
      scopes: {
        vFor: 0,
        vSlot: 0,
        vPre: 0,
        vOnce: 0
      },
      parent: null,
      grandParent: null,
      currentNode: root,
      childIndex: 0,
      inVOnce: false,
      // methods
      helper(name) {
        const count = context.helpers.get(name) || 0;
        context.helpers.set(name, count + 1);
        return name;
      },
      removeHelper(name) {
        const count = context.helpers.get(name);
        if (count) {
          const currentCount = count - 1;
          if (!currentCount) {
            context.helpers.delete(name);
          } else {
            context.helpers.set(name, currentCount);
          }
        }
      },
      helperString(name) {
        return `_${helperNameMap[context.helper(name)]}`;
      },
      replaceNode(node) {
        if (true) {
          if (!context.currentNode) {
            throw new Error(`Node being replaced is already removed.`);
          }
          if (!context.parent) {
            throw new Error(`Cannot replace root node.`);
          }
        }
        context.parent.children[context.childIndex] = context.currentNode = node;
      },
      removeNode(node) {
        if (!context.parent) {
          throw new Error(`Cannot remove root node.`);
        }
        const list = context.parent.children;
        const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
        if (removalIndex < 0) {
          throw new Error(`node being removed is not a child of current parent`);
        }
        if (!node || node === context.currentNode) {
          context.currentNode = null;
          context.onNodeRemoved();
        } else {
          if (context.childIndex > removalIndex) {
            context.childIndex--;
            context.onNodeRemoved();
          }
        }
        context.parent.children.splice(removalIndex, 1);
      },
      onNodeRemoved: NOOP,
      addIdentifiers(exp) {
      },
      removeIdentifiers(exp) {
      },
      hoist(exp) {
        if (isString(exp))
          exp = createSimpleExpression(exp);
        context.hoists.push(exp);
        const identifier = createSimpleExpression(
          `_hoisted_${context.hoists.length}`,
          false,
          exp.loc,
          2
        );
        identifier.hoisted = exp;
        return identifier;
      },
      cache(exp, isVNode2 = false) {
        return createCacheExpression(context.cached++, exp, isVNode2);
      }
    };
    {
      context.filters = /* @__PURE__ */ new Set();
    }
    return context;
  }
  function transform(root, options) {
    const context = createTransformContext(root, options);
    traverseNode(root, context);
    if (options.hoistStatic) {
      hoistStatic(root, context);
    }
    if (!options.ssr) {
      createRootCodegen(root, context);
    }
    root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = context.imports;
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
    root.transformed = true;
    {
      root.filters = [...context.filters];
    }
  }
  function createRootCodegen(root, context) {
    const { helper } = context;
    const { children } = root;
    if (children.length === 1) {
      const child = children[0];
      if (isSingleElementRoot(root, child) && child.codegenNode) {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          convertToBlock(codegenNode, context);
        }
        root.codegenNode = codegenNode;
      } else {
        root.codegenNode = child;
      }
    } else if (children.length > 1) {
      let patchFlag = 64;
      let patchFlagText = PatchFlagNames[64];
      if (children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
        patchFlagText += `, ${PatchFlagNames[2048]}`;
      }
      root.codegenNode = createVNodeCall(
        context,
        helper(FRAGMENT),
        void 0,
        root.children,
        patchFlag + (true ? ` /* ${patchFlagText} */` : ``),
        void 0,
        void 0,
        true,
        void 0,
        false
      );
    } else
      ;
  }
  function traverseChildren(parent, context) {
    let i = 0;
    const nodeRemoved = () => {
      i--;
    };
    for (; i < parent.children.length; i++) {
      const child = parent.children[i];
      if (isString(child))
        continue;
      context.grandParent = context.parent;
      context.parent = parent;
      context.childIndex = i;
      context.onNodeRemoved = nodeRemoved;
      traverseNode(child, context);
    }
  }
  function traverseNode(node, context) {
    context.currentNode = node;
    const { nodeTransforms } = context;
    const exitFns = [];
    for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
      const onExit = nodeTransforms[i2](node, context);
      if (onExit) {
        if (isArray(onExit)) {
          exitFns.push(...onExit);
        } else {
          exitFns.push(onExit);
        }
      }
      if (!context.currentNode) {
        return;
      } else {
        node = context.currentNode;
      }
    }
    switch (node.type) {
      case 3:
        if (!context.ssr) {
          context.helper(CREATE_COMMENT);
        }
        break;
      case 5:
        if (!context.ssr) {
          context.helper(TO_DISPLAY_STRING);
        }
        break;
      case 9:
        for (let i2 = 0; i2 < node.branches.length; i2++) {
          traverseNode(node.branches[i2], context);
        }
        break;
      case 10:
      case 11:
      case 1:
      case 0:
        traverseChildren(node, context);
        break;
    }
    context.currentNode = node;
    let i = exitFns.length;
    while (i--) {
      exitFns[i]();
    }
  }
  function createStructuralDirectiveTransform(name, fn) {
    const matches2 = isString(name) ? (n) => n === name : (n) => name.test(n);
    return (node, context) => {
      if (node.type === 1) {
        const { props } = node;
        if (node.tagType === 3 && props.some(isVSlot)) {
          return;
        }
        const exitFns = [];
        for (let i = 0; i < props.length; i++) {
          const prop = props[i];
          if (prop.type === 7 && matches2(prop.name)) {
            props.splice(i, 1);
            i--;
            const onExit = fn(node, prop, context);
            if (onExit)
              exitFns.push(onExit);
          }
        }
        return exitFns;
      }
    };
  }
  var PURE_ANNOTATION = `/*#__PURE__*/`;
  var aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
  function createCodegenContext(ast, {
    mode = "function",
    prefixIdentifiers = mode === "module",
    sourceMap = false,
    filename = `template.vue.html`,
    scopeId = null,
    optimizeImports = false,
    runtimeGlobalName = `Vue`,
    runtimeModuleName = `vue`,
    ssrRuntimeModuleName = "vue/server-renderer",
    ssr = false,
    isTS = false,
    inSSR = false
  }) {
    const context = {
      mode,
      prefixIdentifiers,
      sourceMap,
      filename,
      scopeId,
      optimizeImports,
      runtimeGlobalName,
      runtimeModuleName,
      ssrRuntimeModuleName,
      ssr,
      isTS,
      inSSR,
      source: ast.source,
      code: ``,
      column: 1,
      line: 1,
      offset: 0,
      indentLevel: 0,
      pure: false,
      map: void 0,
      helper(key) {
        return `_${helperNameMap[key]}`;
      },
      push(code, newlineIndex = -2, node) {
        context.code += code;
      },
      indent() {
        newline(++context.indentLevel);
      },
      deindent(withoutNewLine = false) {
        if (withoutNewLine) {
          --context.indentLevel;
        } else {
          newline(--context.indentLevel);
        }
      },
      newline() {
        newline(context.indentLevel);
      }
    };
    function newline(n) {
      context.push(
        "\n" + `  `.repeat(n),
        0
        /* Start */
      );
    }
    return context;
  }
  function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    if (options.onContextCreated)
      options.onContextCreated(context);
    const {
      mode,
      push,
      prefixIdentifiers,
      indent,
      deindent,
      newline,
      scopeId,
      ssr
    } = context;
    const helpers = Array.from(ast.helpers);
    const hasHelpers = helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== "module";
    const preambleContext = context;
    {
      genFunctionPreamble(ast, preambleContext);
    }
    const functionName = ssr ? `ssrRender` : `render`;
    const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
    const signature = args.join(", ");
    {
      push(`function ${functionName}(${signature}) {`);
    }
    indent();
    if (useWithBlock) {
      push(`with (_ctx) {`);
      indent();
      if (hasHelpers) {
        push(
          `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
          -1
          /* End */
        );
        newline();
      }
    }
    if (ast.components.length) {
      genAssets(ast.components, "component", context);
      if (ast.directives.length || ast.temps > 0) {
        newline();
      }
    }
    if (ast.directives.length) {
      genAssets(ast.directives, "directive", context);
      if (ast.temps > 0) {
        newline();
      }
    }
    if (ast.filters && ast.filters.length) {
      newline();
      genAssets(ast.filters, "filter", context);
      newline();
    }
    if (ast.temps > 0) {
      push(`let `);
      for (let i = 0; i < ast.temps; i++) {
        push(`${i > 0 ? `, ` : ``}_temp${i}`);
      }
    }
    if (ast.components.length || ast.directives.length || ast.temps) {
      push(
        `
`,
        0
        /* Start */
      );
      newline();
    }
    if (!ssr) {
      push(`return `);
    }
    if (ast.codegenNode) {
      genNode(ast.codegenNode, context);
    } else {
      push(`null`);
    }
    if (useWithBlock) {
      deindent();
      push(`}`);
    }
    deindent();
    push(`}`);
    return {
      ast,
      code: context.code,
      preamble: ``,
      map: context.map ? context.map.toJSON() : void 0
    };
  }
  function genFunctionPreamble(ast, context) {
    const {
      ssr,
      prefixIdentifiers,
      push,
      newline,
      runtimeModuleName,
      runtimeGlobalName,
      ssrRuntimeModuleName
    } = context;
    const VueBinding = runtimeGlobalName;
    const helpers = Array.from(ast.helpers);
    if (helpers.length > 0) {
      {
        push(
          `const _Vue = ${VueBinding}
`,
          -1
          /* End */
        );
        if (ast.hoists.length) {
          const staticHelpers = [
            CREATE_VNODE,
            CREATE_ELEMENT_VNODE,
            CREATE_COMMENT,
            CREATE_TEXT,
            CREATE_STATIC
          ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
          push(
            `const { ${staticHelpers} } = _Vue
`,
            -1
            /* End */
          );
        }
      }
    }
    genHoists(ast.hoists, context);
    newline();
    push(`return `);
  }
  function genAssets(assets, type, { helper, push, newline, isTS }) {
    const resolver = helper(
      type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
    );
    for (let i = 0; i < assets.length; i++) {
      let id = assets[i];
      const maybeSelfReference = id.endsWith("__self");
      if (maybeSelfReference) {
        id = id.slice(0, -6);
      }
      push(
        `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
      );
      if (i < assets.length - 1) {
        newline();
      }
    }
  }
  function genHoists(hoists, context) {
    if (!hoists.length) {
      return;
    }
    context.pure = true;
    const { push, newline, helper, scopeId, mode } = context;
    newline();
    for (let i = 0; i < hoists.length; i++) {
      const exp = hoists[i];
      if (exp) {
        push(
          `const _hoisted_${i + 1} = ${``}`
        );
        genNode(exp, context);
        newline();
      }
    }
    context.pure = false;
  }
  function isText(n) {
    return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
  }
  function genNodeListAsArray(nodes, context) {
    const multilines = nodes.length > 3 || nodes.some((n) => isArray(n) || !isText(n));
    context.push(`[`);
    multilines && context.indent();
    genNodeList(nodes, context, multilines);
    multilines && context.deindent();
    context.push(`]`);
  }
  function genNodeList(nodes, context, multilines = false, comma = true) {
    const { push, newline } = context;
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (isString(node)) {
        push(
          node,
          -3
          /* Unknown */
        );
      } else if (isArray(node)) {
        genNodeListAsArray(node, context);
      } else {
        genNode(node, context);
      }
      if (i < nodes.length - 1) {
        if (multilines) {
          comma && push(",");
          newline();
        } else {
          comma && push(", ");
        }
      }
    }
  }
  function genNode(node, context) {
    if (isString(node)) {
      context.push(
        node,
        -3
        /* Unknown */
      );
      return;
    }
    if (isSymbol(node)) {
      context.push(context.helper(node));
      return;
    }
    switch (node.type) {
      case 1:
      case 9:
      case 11:
        assert(
          node.codegenNode != null,
          `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`
        );
        genNode(node.codegenNode, context);
        break;
      case 2:
        genText(node, context);
        break;
      case 4:
        genExpression(node, context);
        break;
      case 5:
        genInterpolation(node, context);
        break;
      case 12:
        genNode(node.codegenNode, context);
        break;
      case 8:
        genCompoundExpression(node, context);
        break;
      case 3:
        genComment(node, context);
        break;
      case 13:
        genVNodeCall(node, context);
        break;
      case 14:
        genCallExpression(node, context);
        break;
      case 15:
        genObjectExpression(node, context);
        break;
      case 17:
        genArrayExpression(node, context);
        break;
      case 18:
        genFunctionExpression(node, context);
        break;
      case 19:
        genConditionalExpression(node, context);
        break;
      case 20:
        genCacheExpression(node, context);
        break;
      case 21:
        genNodeList(node.body, context, true, false);
        break;
      case 22:
        break;
      case 23:
        break;
      case 24:
        break;
      case 25:
        break;
      case 26:
        break;
      case 10:
        break;
      default:
        if (true) {
          assert(false, `unhandled codegen node type: ${node.type}`);
          const exhaustiveCheck = node;
          return exhaustiveCheck;
        }
    }
  }
  function genText(node, context) {
    context.push(JSON.stringify(node.content), -3, node);
  }
  function genExpression(node, context) {
    const { content, isStatic } = node;
    context.push(
      isStatic ? JSON.stringify(content) : content,
      -3,
      node
    );
  }
  function genInterpolation(node, context) {
    const { push, helper, pure } = context;
    if (pure)
      push(PURE_ANNOTATION);
    push(`${helper(TO_DISPLAY_STRING)}(`);
    genNode(node.content, context);
    push(`)`);
  }
  function genCompoundExpression(node, context) {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (isString(child)) {
        context.push(
          child,
          -3
          /* Unknown */
        );
      } else {
        genNode(child, context);
      }
    }
  }
  function genExpressionAsPropertyKey(node, context) {
    const { push } = context;
    if (node.type === 8) {
      push(`[`);
      genCompoundExpression(node, context);
      push(`]`);
    } else if (node.isStatic) {
      const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
      push(text, -2, node);
    } else {
      push(`[${node.content}]`, -3, node);
    }
  }
  function genComment(node, context) {
    const { push, helper, pure } = context;
    if (pure) {
      push(PURE_ANNOTATION);
    }
    push(
      `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
      -3,
      node
    );
  }
  function genVNodeCall(node, context) {
    const { push, helper, pure } = context;
    const {
      tag,
      props,
      children,
      patchFlag,
      dynamicProps,
      directives,
      isBlock,
      disableTracking,
      isComponent: isComponent2
    } = node;
    if (directives) {
      push(helper(WITH_DIRECTIVES) + `(`);
    }
    if (isBlock) {
      push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
    }
    if (pure) {
      push(PURE_ANNOTATION);
    }
    const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
    push(helper(callHelper) + `(`, -2, node);
    genNodeList(
      genNullableArgs([tag, props, children, patchFlag, dynamicProps]),
      context
    );
    push(`)`);
    if (isBlock) {
      push(`)`);
    }
    if (directives) {
      push(`, `);
      genNode(directives, context);
      push(`)`);
    }
  }
  function genNullableArgs(args) {
    let i = args.length;
    while (i--) {
      if (args[i] != null)
        break;
    }
    return args.slice(0, i + 1).map((arg) => arg || `null`);
  }
  function genCallExpression(node, context) {
    const { push, helper, pure } = context;
    const callee = isString(node.callee) ? node.callee : helper(node.callee);
    if (pure) {
      push(PURE_ANNOTATION);
    }
    push(callee + `(`, -2, node);
    genNodeList(node.arguments, context);
    push(`)`);
  }
  function genObjectExpression(node, context) {
    const { push, indent, deindent, newline } = context;
    const { properties } = node;
    if (!properties.length) {
      push(`{}`, -2, node);
      return;
    }
    const multilines = properties.length > 1 || properties.some((p2) => p2.value.type !== 4);
    push(multilines ? `{` : `{ `);
    multilines && indent();
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      genExpressionAsPropertyKey(key, context);
      push(`: `);
      genNode(value, context);
      if (i < properties.length - 1) {
        push(`,`);
        newline();
      }
    }
    multilines && deindent();
    push(multilines ? `}` : ` }`);
  }
  function genArrayExpression(node, context) {
    genNodeListAsArray(node.elements, context);
  }
  function genFunctionExpression(node, context) {
    const { push, indent, deindent } = context;
    const { params, returns, body, newline, isSlot } = node;
    if (isSlot) {
      push(`_${helperNameMap[WITH_CTX]}(`);
    }
    push(`(`, -2, node);
    if (isArray(params)) {
      genNodeList(params, context);
    } else if (params) {
      genNode(params, context);
    }
    push(`) => `);
    if (newline || body) {
      push(`{`);
      indent();
    }
    if (returns) {
      if (newline) {
        push(`return `);
      }
      if (isArray(returns)) {
        genNodeListAsArray(returns, context);
      } else {
        genNode(returns, context);
      }
    } else if (body) {
      genNode(body, context);
    }
    if (newline || body) {
      deindent();
      push(`}`);
    }
    if (isSlot) {
      if (node.isNonScopedSlot) {
        push(`, undefined, true`);
      }
      push(`)`);
    }
  }
  function genConditionalExpression(node, context) {
    const { test, consequent, alternate, newline: needNewline } = node;
    const { push, indent, deindent, newline } = context;
    if (test.type === 4) {
      const needsParens = !isSimpleIdentifier(test.content);
      needsParens && push(`(`);
      genExpression(test, context);
      needsParens && push(`)`);
    } else {
      push(`(`);
      genNode(test, context);
      push(`)`);
    }
    needNewline && indent();
    context.indentLevel++;
    needNewline || push(` `);
    push(`? `);
    genNode(consequent, context);
    context.indentLevel--;
    needNewline && newline();
    needNewline || push(` `);
    push(`: `);
    const isNested = alternate.type === 19;
    if (!isNested) {
      context.indentLevel++;
    }
    genNode(alternate, context);
    if (!isNested) {
      context.indentLevel--;
    }
    needNewline && deindent(
      true
      /* without newline */
    );
  }
  function genCacheExpression(node, context) {
    const { push, helper, indent, deindent, newline } = context;
    push(`_cache[${node.index}] || (`);
    if (node.isVNode) {
      indent();
      push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
      newline();
    }
    push(`_cache[${node.index}] = `);
    genNode(node.value, context);
    if (node.isVNode) {
      push(`,`);
      newline();
      push(`${helper(SET_BLOCK_TRACKING)}(1),`);
      newline();
      push(`_cache[${node.index}]`);
      deindent();
    }
    push(`)`);
  }
  var prohibitedKeywordRE = new RegExp(
    "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
  );
  var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
  function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
    const exp = node.content;
    if (!exp.trim()) {
      return;
    }
    try {
      new Function(
        asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`
      );
    } catch (e) {
      let message = e.message;
      const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
      if (keywordMatch) {
        message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
      }
      context.onError(
        createCompilerError(
          45,
          node.loc,
          void 0,
          message
        )
      );
    }
  }
  var transformExpression = (node, context) => {
    if (node.type === 5) {
      node.content = processExpression(
        node.content,
        context
      );
    } else if (node.type === 1) {
      for (let i = 0; i < node.props.length; i++) {
        const dir = node.props[i];
        if (dir.type === 7 && dir.name !== "for") {
          const exp = dir.exp;
          const arg = dir.arg;
          if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
            dir.exp = processExpression(
              exp,
              context,
              // slot args must be processed as function params
              dir.name === "slot"
            );
          }
          if (arg && arg.type === 4 && !arg.isStatic) {
            dir.arg = processExpression(arg, context);
          }
        }
      }
    }
  };
  function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
    {
      if (true) {
        validateBrowserExpression(node, context, asParams, asRawStatements);
      }
      return node;
    }
  }
  var transformIf = createStructuralDirectiveTransform(
    /^(if|else|else-if)$/,
    (node, dir, context) => {
      return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        const siblings = context.parent.children;
        let i = siblings.indexOf(ifNode);
        let key = 0;
        while (i-- >= 0) {
          const sibling = siblings[i];
          if (sibling && sibling.type === 9) {
            key += sibling.branches.length;
          }
        }
        return () => {
          if (isRoot) {
            ifNode.codegenNode = createCodegenNodeForBranch(
              branch,
              key,
              context
            );
          } else {
            const parentCondition = getParentCondition(ifNode.codegenNode);
            parentCondition.alternate = createCodegenNodeForBranch(
              branch,
              key + ifNode.branches.length - 1,
              context
            );
          }
        };
      });
    }
  );
  function processIf(node, dir, context, processCodegen) {
    if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
      const loc = dir.exp ? dir.exp.loc : node.loc;
      context.onError(
        createCompilerError(28, dir.loc)
      );
      dir.exp = createSimpleExpression(`true`, false, loc);
    }
    if (dir.exp) {
      validateBrowserExpression(dir.exp, context);
    }
    if (dir.name === "if") {
      const branch = createIfBranch(node, dir);
      const ifNode = {
        type: 9,
        loc: node.loc,
        branches: [branch]
      };
      context.replaceNode(ifNode);
      if (processCodegen) {
        return processCodegen(ifNode, branch, true);
      }
    } else {
      const siblings = context.parent.children;
      const comments = [];
      let i = siblings.indexOf(node);
      while (i-- >= -1) {
        const sibling = siblings[i];
        if (sibling && sibling.type === 3) {
          context.removeNode(sibling);
          comments.unshift(sibling);
          continue;
        }
        if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
          context.removeNode(sibling);
          continue;
        }
        if (sibling && sibling.type === 9) {
          if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
            context.onError(
              createCompilerError(30, node.loc)
            );
          }
          context.removeNode();
          const branch = createIfBranch(node, dir);
          if (comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
          !(context.parent && context.parent.type === 1 && (context.parent.tag === "transition" || context.parent.tag === "Transition"))) {
            branch.children = [...comments, ...branch.children];
          }
          if (true) {
            const key = branch.userKey;
            if (key) {
              sibling.branches.forEach(({ userKey }) => {
                if (isSameKey(userKey, key)) {
                  context.onError(
                    createCompilerError(
                      29,
                      branch.userKey.loc
                    )
                  );
                }
              });
            }
          }
          sibling.branches.push(branch);
          const onExit = processCodegen && processCodegen(sibling, branch, false);
          traverseNode(branch, context);
          if (onExit)
            onExit();
          context.currentNode = null;
        } else {
          context.onError(
            createCompilerError(30, node.loc)
          );
        }
        break;
      }
    }
  }
  function createIfBranch(node, dir) {
    const isTemplateIf = node.tagType === 3;
    return {
      type: 10,
      loc: node.loc,
      condition: dir.name === "else" ? void 0 : dir.exp,
      children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
      userKey: findProp(node, `key`),
      isTemplateIf
    };
  }
  function createCodegenNodeForBranch(branch, keyIndex, context) {
    if (branch.condition) {
      return createConditionalExpression(
        branch.condition,
        createChildrenCodegenNode(branch, keyIndex, context),
        // make sure to pass in asBlock: true so that the comment node call
        // closes the current block.
        createCallExpression(context.helper(CREATE_COMMENT), [
          true ? '"v-if"' : '""',
          "true"
        ])
      );
    } else {
      return createChildrenCodegenNode(branch, keyIndex, context);
    }
  }
  function createChildrenCodegenNode(branch, keyIndex, context) {
    const { helper } = context;
    const keyProperty = createObjectProperty(
      `key`,
      createSimpleExpression(
        `${keyIndex}`,
        false,
        locStub,
        2
      )
    );
    const { children } = branch;
    const firstChild = children[0];
    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
    if (needFragmentWrapper) {
      if (children.length === 1 && firstChild.type === 11) {
        const vnodeCall = firstChild.codegenNode;
        injectProp(vnodeCall, keyProperty, context);
        return vnodeCall;
      } else {
        let patchFlag = 64;
        let patchFlagText = PatchFlagNames[64];
        if (!branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {
          patchFlag |= 2048;
          patchFlagText += `, ${PatchFlagNames[2048]}`;
        }
        return createVNodeCall(
          context,
          helper(FRAGMENT),
          createObjectExpression([keyProperty]),
          children,
          patchFlag + (true ? ` /* ${patchFlagText} */` : ``),
          void 0,
          void 0,
          true,
          false,
          false,
          branch.loc
        );
      }
    } else {
      const ret = firstChild.codegenNode;
      const vnodeCall = getMemoedVNodeCall(ret);
      if (vnodeCall.type === 13) {
        convertToBlock(vnodeCall, context);
      }
      injectProp(vnodeCall, keyProperty, context);
      return ret;
    }
  }
  function isSameKey(a, b) {
    if (!a || a.type !== b.type) {
      return false;
    }
    if (a.type === 6) {
      if (a.value.content !== b.value.content) {
        return false;
      }
    } else {
      const exp = a.exp;
      const branchExp = b.exp;
      if (exp.type !== branchExp.type) {
        return false;
      }
      if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
        return false;
      }
    }
    return true;
  }
  function getParentCondition(node) {
    while (true) {
      if (node.type === 19) {
        if (node.alternate.type === 19) {
          node = node.alternate;
        } else {
          return node;
        }
      } else if (node.type === 20) {
        node = node.value;
      }
    }
  }
  var transformBind = (dir, _node, context) => {
    const { modifiers, loc } = dir;
    const arg = dir.arg;
    let { exp } = dir;
    if (exp && exp.type === 4 && !exp.content.trim()) {
      {
        exp = void 0;
      }
    }
    if (!exp) {
      if (arg.type !== 4 || !arg.isStatic) {
        context.onError(
          createCompilerError(
            52,
            arg.loc
          )
        );
        return {
          props: [
            createObjectProperty(arg, createSimpleExpression("", true, loc))
          ]
        };
      }
      transformBindShorthand(dir);
      exp = dir.exp;
    }
    if (arg.type !== 4) {
      arg.children.unshift(`(`);
      arg.children.push(`) || ""`);
    } else if (!arg.isStatic) {
      arg.content = `${arg.content} || ""`;
    }
    if (modifiers.includes("camel")) {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = camelize2(arg.content);
        } else {
          arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
        }
      } else {
        arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
        arg.children.push(`)`);
      }
    }
    if (!context.inSSR) {
      if (modifiers.includes("prop")) {
        injectPrefix(arg, ".");
      }
      if (modifiers.includes("attr")) {
        injectPrefix(arg, "^");
      }
    }
    return {
      props: [createObjectProperty(arg, exp)]
    };
  };
  var transformBindShorthand = (dir, context) => {
    const arg = dir.arg;
    const propName = camelize2(arg.content);
    dir.exp = createSimpleExpression(propName, false, arg.loc);
  };
  var injectPrefix = (arg, prefix) => {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = prefix + arg.content;
      } else {
        arg.content = `\`${prefix}\${${arg.content}}\``;
      }
    } else {
      arg.children.unshift(`'${prefix}' + (`);
      arg.children.push(`)`);
    }
  };
  var transformFor = createStructuralDirectiveTransform(
    "for",
    (node, dir, context) => {
      const { helper, removeHelper } = context;
      return processFor(node, dir, context, (forNode) => {
        const renderExp = createCallExpression(helper(RENDER_LIST), [
          forNode.source
        ]);
        const isTemplate = isTemplateNode(node);
        const memo = findDir(node, "memo");
        const keyProp = findProp(node, `key`, false, true);
        if (keyProp && keyProp.type === 7 && !keyProp.exp) {
          transformBindShorthand(keyProp);
        }
        const keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
        const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;
        const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
        const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
        forNode.codegenNode = createVNodeCall(
          context,
          helper(FRAGMENT),
          void 0,
          renderExp,
          fragmentFlag + (true ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``),
          void 0,
          void 0,
          true,
          !isStableFragment,
          false,
          node.loc
        );
        return () => {
          let childBlock;
          const { children } = forNode;
          if (isTemplate) {
            node.children.some((c) => {
              if (c.type === 1) {
                const key = findProp(c, "key");
                if (key) {
                  context.onError(
                    createCompilerError(
                      33,
                      key.loc
                    )
                  );
                  return true;
                }
              }
            });
          }
          const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
          const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
          if (slotOutlet) {
            childBlock = slotOutlet.codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context);
            }
          } else if (needFragmentWrapper) {
            childBlock = createVNodeCall(
              context,
              helper(FRAGMENT),
              keyProperty ? createObjectExpression([keyProperty]) : void 0,
              node.children,
              64 + (true ? ` /* ${PatchFlagNames[64]} */` : ``),
              void 0,
              void 0,
              true,
              void 0,
              false
            );
          } else {
            childBlock = children[0].codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context);
            }
            if (childBlock.isBlock !== !isStableFragment) {
              if (childBlock.isBlock) {
                removeHelper(OPEN_BLOCK);
                removeHelper(
                  getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
                );
              } else {
                removeHelper(
                  getVNodeHelper(context.inSSR, childBlock.isComponent)
                );
              }
            }
            childBlock.isBlock = !isStableFragment;
            if (childBlock.isBlock) {
              helper(OPEN_BLOCK);
              helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
            } else {
              helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
            }
          }
          if (memo) {
            const loop = createFunctionExpression(
              createForLoopParams(forNode.parseResult, [
                createSimpleExpression(`_cached`)
              ])
            );
            loop.body = createBlockStatement([
              createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
              createCompoundExpression([
                `if (_cached`,
                ...keyExp ? [` && _cached.key === `, keyExp] : [],
                ` && ${context.helperString(
                  IS_MEMO_SAME
                )}(_cached, _memo)) return _cached`
              ]),
              createCompoundExpression([`const _item = `, childBlock]),
              createSimpleExpression(`_item.memo = _memo`),
              createSimpleExpression(`return _item`)
            ]);
            renderExp.arguments.push(
              loop,
              createSimpleExpression(`_cache`),
              createSimpleExpression(String(context.cached++))
            );
          } else {
            renderExp.arguments.push(
              createFunctionExpression(
                createForLoopParams(forNode.parseResult),
                childBlock,
                true
              )
            );
          }
        };
      });
    }
  );
  function processFor(node, dir, context, processCodegen) {
    if (!dir.exp) {
      context.onError(
        createCompilerError(31, dir.loc)
      );
      return;
    }
    const parseResult = dir.forParseResult;
    if (!parseResult) {
      context.onError(
        createCompilerError(32, dir.loc)
      );
      return;
    }
    finalizeForParseResult(parseResult, context);
    const { addIdentifiers, removeIdentifiers, scopes } = context;
    const { source, value, key, index } = parseResult;
    const forNode = {
      type: 11,
      loc: dir.loc,
      source,
      valueAlias: value,
      keyAlias: key,
      objectIndexAlias: index,
      parseResult,
      children: isTemplateNode(node) ? node.children : [node]
    };
    context.replaceNode(forNode);
    scopes.vFor++;
    const onExit = processCodegen && processCodegen(forNode);
    return () => {
      scopes.vFor--;
      if (onExit)
        onExit();
    };
  }
  function finalizeForParseResult(result, context) {
    if (result.finalized)
      return;
    if (true) {
      validateBrowserExpression(result.source, context);
      if (result.key) {
        validateBrowserExpression(
          result.key,
          context,
          true
        );
      }
      if (result.index) {
        validateBrowserExpression(
          result.index,
          context,
          true
        );
      }
      if (result.value) {
        validateBrowserExpression(
          result.value,
          context,
          true
        );
      }
    }
    result.finalized = true;
  }
  function createForLoopParams({ value, key, index }, memoArgs = []) {
    return createParamsList([value, key, index, ...memoArgs]);
  }
  function createParamsList(args) {
    let i = args.length;
    while (i--) {
      if (args[i])
        break;
    }
    return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
  }
  var defaultFallback = createSimpleExpression(`undefined`, false);
  var trackSlotScopes = (node, context) => {
    if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
      const vSlot = findDir(node, "slot");
      if (vSlot) {
        vSlot.exp;
        context.scopes.vSlot++;
        return () => {
          context.scopes.vSlot--;
        };
      }
    }
  };
  var buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
    props,
    children,
    false,
    true,
    children.length ? children[0].loc : loc
  );
  function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
    context.helper(WITH_CTX);
    const { children, loc } = node;
    const slotsProperties = [];
    const dynamicSlots = [];
    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
    const onComponentSlot = findDir(node, "slot", true);
    if (onComponentSlot) {
      const { arg, exp } = onComponentSlot;
      if (arg && !isStaticExp(arg)) {
        hasDynamicSlots = true;
      }
      slotsProperties.push(
        createObjectProperty(
          arg || createSimpleExpression("default", true),
          buildSlotFn(exp, void 0, children, loc)
        )
      );
    }
    let hasTemplateSlots = false;
    let hasNamedDefaultSlot = false;
    const implicitDefaultChildren = [];
    const seenSlotNames = /* @__PURE__ */ new Set();
    let conditionalBranchIndex = 0;
    for (let i = 0; i < children.length; i++) {
      const slotElement = children[i];
      let slotDir;
      if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
        if (slotElement.type !== 3) {
          implicitDefaultChildren.push(slotElement);
        }
        continue;
      }
      if (onComponentSlot) {
        context.onError(
          createCompilerError(37, slotDir.loc)
        );
        break;
      }
      hasTemplateSlots = true;
      const { children: slotChildren, loc: slotLoc } = slotElement;
      const {
        arg: slotName = createSimpleExpression(`default`, true),
        exp: slotProps,
        loc: dirLoc
      } = slotDir;
      let staticSlotName;
      if (isStaticExp(slotName)) {
        staticSlotName = slotName ? slotName.content : `default`;
      } else {
        hasDynamicSlots = true;
      }
      const vFor = findDir(slotElement, "for");
      const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
      let vIf;
      let vElse;
      if (vIf = findDir(slotElement, "if")) {
        hasDynamicSlots = true;
        dynamicSlots.push(
          createConditionalExpression(
            vIf.exp,
            buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
            defaultFallback
          )
        );
      } else if (vElse = findDir(
        slotElement,
        /^else(-if)?$/,
        true
        /* allowEmpty */
      )) {
        let j = i;
        let prev;
        while (j--) {
          prev = children[j];
          if (prev.type !== 3) {
            break;
          }
        }
        if (prev && isTemplateNode(prev) && findDir(prev, /^(else-)?if$/)) {
          let conditional = dynamicSlots[dynamicSlots.length - 1];
          while (conditional.alternate.type === 19) {
            conditional = conditional.alternate;
          }
          conditional.alternate = vElse.exp ? createConditionalExpression(
            vElse.exp,
            buildDynamicSlot(
              slotName,
              slotFunction,
              conditionalBranchIndex++
            ),
            defaultFallback
          ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
        } else {
          context.onError(
            createCompilerError(30, vElse.loc)
          );
        }
      } else if (vFor) {
        hasDynamicSlots = true;
        const parseResult = vFor.forParseResult;
        if (parseResult) {
          finalizeForParseResult(parseResult, context);
          dynamicSlots.push(
            createCallExpression(context.helper(RENDER_LIST), [
              parseResult.source,
              createFunctionExpression(
                createForLoopParams(parseResult),
                buildDynamicSlot(slotName, slotFunction),
                true
              )
            ])
          );
        } else {
          context.onError(
            createCompilerError(
              32,
              vFor.loc
            )
          );
        }
      } else {
        if (staticSlotName) {
          if (seenSlotNames.has(staticSlotName)) {
            context.onError(
              createCompilerError(
                38,
                dirLoc
              )
            );
            continue;
          }
          seenSlotNames.add(staticSlotName);
          if (staticSlotName === "default") {
            hasNamedDefaultSlot = true;
          }
        }
        slotsProperties.push(createObjectProperty(slotName, slotFunction));
      }
    }
    if (!onComponentSlot) {
      const buildDefaultSlotProperty = (props, children2) => {
        const fn = buildSlotFn(props, void 0, children2, loc);
        if (context.compatConfig) {
          fn.isNonScopedSlot = true;
        }
        return createObjectProperty(`default`, fn);
      };
      if (!hasTemplateSlots) {
        slotsProperties.push(buildDefaultSlotProperty(void 0, children));
      } else if (implicitDefaultChildren.length && // #3766
      // with whitespace: 'preserve', whitespaces between slots will end up in
      // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
      implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
        if (hasNamedDefaultSlot) {
          context.onError(
            createCompilerError(
              39,
              implicitDefaultChildren[0].loc
            )
          );
        } else {
          slotsProperties.push(
            buildDefaultSlotProperty(void 0, implicitDefaultChildren)
          );
        }
      }
    }
    const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
    let slots = createObjectExpression(
      slotsProperties.concat(
        createObjectProperty(
          `_`,
          // 2 = compiled but dynamic = can skip normalization, but must run diff
          // 1 = compiled and static = can skip normalization AND diff as optimized
          createSimpleExpression(
            slotFlag + (true ? ` /* ${slotFlagsText[slotFlag]} */` : ``),
            false
          )
        )
      ),
      loc
    );
    if (dynamicSlots.length) {
      slots = createCallExpression(context.helper(CREATE_SLOTS), [
        slots,
        createArrayExpression(dynamicSlots)
      ]);
    }
    return {
      slots,
      hasDynamicSlots
    };
  }
  function buildDynamicSlot(name, fn, index) {
    const props = [
      createObjectProperty(`name`, name),
      createObjectProperty(`fn`, fn)
    ];
    if (index != null) {
      props.push(
        createObjectProperty(`key`, createSimpleExpression(String(index), true))
      );
    }
    return createObjectExpression(props);
  }
  function hasForwardedSlots(children) {
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      switch (child.type) {
        case 1:
          if (child.tagType === 2 || hasForwardedSlots(child.children)) {
            return true;
          }
          break;
        case 9:
          if (hasForwardedSlots(child.branches))
            return true;
          break;
        case 10:
        case 11:
          if (hasForwardedSlots(child.children))
            return true;
          break;
      }
    }
    return false;
  }
  function isNonWhitespaceContent(node) {
    if (node.type !== 2 && node.type !== 12)
      return true;
    return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
  }
  var directiveImportMap = /* @__PURE__ */ new WeakMap();
  var transformElement = (node, context) => {
    return function postTransformElement() {
      node = context.currentNode;
      if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
        return;
      }
      const { tag, props } = node;
      const isComponent2 = node.tagType === 1;
      let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
      const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
      let vnodeProps;
      let vnodeChildren;
      let vnodePatchFlag;
      let patchFlag = 0;
      let vnodeDynamicProps;
      let dynamicPropNames;
      let vnodeDirectives;
      let shouldUseBlock = (
        // dynamic component may resolve to plain elements
        isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && // <svg> and <foreignObject> must be forced into blocks so that block
        // updates inside get proper isSVG flag at runtime. (#639, #643)
        // This is technically web-specific, but splitting the logic out of core
        // leads to too much unnecessary complexity.
        (tag === "svg" || tag === "foreignObject" || tag === "math")
      );
      if (props.length > 0) {
        const propsBuildResult = buildProps(
          node,
          context,
          void 0,
          isComponent2,
          isDynamicComponent
        );
        vnodeProps = propsBuildResult.props;
        patchFlag = propsBuildResult.patchFlag;
        dynamicPropNames = propsBuildResult.dynamicPropNames;
        const directives = propsBuildResult.directives;
        vnodeDirectives = directives && directives.length ? createArrayExpression(
          directives.map((dir) => buildDirectiveArgs(dir, context))
        ) : void 0;
        if (propsBuildResult.shouldUseBlock) {
          shouldUseBlock = true;
        }
      }
      if (node.children.length > 0) {
        if (vnodeTag === KEEP_ALIVE) {
          shouldUseBlock = true;
          patchFlag |= 1024;
          if (node.children.length > 1) {
            context.onError(
              createCompilerError(46, {
                start: node.children[0].loc.start,
                end: node.children[node.children.length - 1].loc.end,
                source: ""
              })
            );
          }
        }
        const shouldBuildAsSlots = isComponent2 && // Teleport is not a real component and has dedicated runtime handling
        vnodeTag !== TELEPORT && // explained above.
        vnodeTag !== KEEP_ALIVE;
        if (shouldBuildAsSlots) {
          const { slots, hasDynamicSlots } = buildSlots(node, context);
          vnodeChildren = slots;
          if (hasDynamicSlots) {
            patchFlag |= 1024;
          }
        } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
          const child = node.children[0];
          const type = child.type;
          const hasDynamicTextChild = type === 5 || type === 8;
          if (hasDynamicTextChild && getConstantType(child, context) === 0) {
            patchFlag |= 1;
          }
          if (hasDynamicTextChild || type === 2) {
            vnodeChildren = child;
          } else {
            vnodeChildren = node.children;
          }
        } else {
          vnodeChildren = node.children;
        }
      }
      if (patchFlag !== 0) {
        if (true) {
          if (patchFlag < 0) {
            vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
          } else {
            const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);
            vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
          }
        } else {
          vnodePatchFlag = String(patchFlag);
        }
        if (dynamicPropNames && dynamicPropNames.length) {
          vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
        }
      }
      node.codegenNode = createVNodeCall(
        context,
        vnodeTag,
        vnodeProps,
        vnodeChildren,
        vnodePatchFlag,
        vnodeDynamicProps,
        vnodeDirectives,
        !!shouldUseBlock,
        false,
        isComponent2,
        node.loc
      );
    };
  };
  function resolveComponentType(node, context, ssr = false) {
    let { tag } = node;
    const isExplicitDynamic = isComponentTag(tag);
    const isProp = findProp(
      node,
      "is",
      false,
      true
      /* allow empty */
    );
    if (isProp) {
      if (isExplicitDynamic || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      )) {
        let exp;
        if (isProp.type === 6) {
          exp = isProp.value && createSimpleExpression(isProp.value.content, true);
        } else {
          exp = isProp.exp;
          if (!exp) {
            exp = createSimpleExpression(`is`, false, isProp.loc);
          }
        }
        if (exp) {
          return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
            exp
          ]);
        }
      } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
        tag = isProp.value.content.slice(4);
      }
    }
    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
    if (builtIn) {
      if (!ssr)
        context.helper(builtIn);
      return builtIn;
    }
    context.helper(RESOLVE_COMPONENT);
    context.components.add(tag);
    return toValidAssetId(tag, `component`);
  }
  function buildProps(node, context, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
    const { tag, loc: elementLoc, children } = node;
    let properties = [];
    const mergeArgs = [];
    const runtimeDirectives = [];
    const hasChildren = children.length > 0;
    let shouldUseBlock = false;
    let patchFlag = 0;
    let hasRef = false;
    let hasClassBinding = false;
    let hasStyleBinding = false;
    let hasHydrationEventBinding = false;
    let hasDynamicKeys = false;
    let hasVnodeHook = false;
    const dynamicPropNames = [];
    const pushMergeArg = (arg) => {
      if (properties.length) {
        mergeArgs.push(
          createObjectExpression(dedupeProperties(properties), elementLoc)
        );
        properties = [];
      }
      if (arg)
        mergeArgs.push(arg);
    };
    const pushRefVForMarker = () => {
      if (context.scopes.vFor > 0) {
        properties.push(
          createObjectProperty(
            createSimpleExpression("ref_for", true),
            createSimpleExpression("true")
          )
        );
      }
    };
    const analyzePatchFlag = ({ key, value }) => {
      if (isStaticExp(key)) {
        const name = key.content;
        const isEventHandler = isOn(name);
        if (isEventHandler && (!isComponent2 || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
        // dedicated fast path.
        name.toLowerCase() !== "onclick" && // omit v-model handlers
        name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
        !isReservedProp(name)) {
          hasHydrationEventBinding = true;
        }
        if (isEventHandler && isReservedProp(name)) {
          hasVnodeHook = true;
        }
        if (isEventHandler && value.type === 14) {
          value = value.arguments[0];
        }
        if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
          return;
        }
        if (name === "ref") {
          hasRef = true;
        } else if (name === "class") {
          hasClassBinding = true;
        } else if (name === "style") {
          hasStyleBinding = true;
        } else if (name !== "key" && !dynamicPropNames.includes(name)) {
          dynamicPropNames.push(name);
        }
        if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
          dynamicPropNames.push(name);
        }
      } else {
        hasDynamicKeys = true;
      }
    };
    for (let i = 0; i < props.length; i++) {
      const prop = props[i];
      if (prop.type === 6) {
        const { loc, name, nameLoc, value } = prop;
        let isStatic = true;
        if (name === "ref") {
          hasRef = true;
          pushRefVForMarker();
        }
        if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          context
        ))) {
          continue;
        }
        properties.push(
          createObjectProperty(
            createSimpleExpression(name, true, nameLoc),
            createSimpleExpression(
              value ? value.content : "",
              isStatic,
              value ? value.loc : loc
            )
          )
        );
      } else {
        const { name, arg, exp, loc, modifiers } = prop;
        const isVBind = name === "bind";
        const isVOn = name === "on";
        if (name === "slot") {
          if (!isComponent2) {
            context.onError(
              createCompilerError(40, loc)
            );
          }
          continue;
        }
        if (name === "once" || name === "memo") {
          continue;
        }
        if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          context
        ))) {
          continue;
        }
        if (isVOn && ssr) {
          continue;
        }
        if (
          // #938: elements with dynamic keys should be forced into blocks
          isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
          // before children
          isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
        ) {
          shouldUseBlock = true;
        }
        if (isVBind && isStaticArgOf(arg, "ref")) {
          pushRefVForMarker();
        }
        if (!arg && (isVBind || isVOn)) {
          hasDynamicKeys = true;
          if (exp) {
            if (isVBind) {
              pushRefVForMarker();
              pushMergeArg();
              {
                if (true) {
                  const hasOverridableKeys = mergeArgs.some((arg2) => {
                    if (arg2.type === 15) {
                      return arg2.properties.some(({ key }) => {
                        if (key.type !== 4 || !key.isStatic) {
                          return true;
                        }
                        return key.content !== "class" && key.content !== "style" && !isOn(key.content);
                      });
                    } else {
                      return true;
                    }
                  });
                  if (hasOverridableKeys) {
                    checkCompatEnabled(
                      "COMPILER_V_BIND_OBJECT_ORDER",
                      context,
                      loc
                    );
                  }
                }
                if (isCompatEnabled(
                  "COMPILER_V_BIND_OBJECT_ORDER",
                  context
                )) {
                  mergeArgs.unshift(exp);
                  continue;
                }
              }
              mergeArgs.push(exp);
            } else {
              pushMergeArg({
                type: 14,
                loc,
                callee: context.helper(TO_HANDLERS),
                arguments: isComponent2 ? [exp] : [exp, `true`]
              });
            }
          } else {
            context.onError(
              createCompilerError(
                isVBind ? 34 : 35,
                loc
              )
            );
          }
          continue;
        }
        if (isVBind && modifiers.includes("prop")) {
          patchFlag |= 32;
        }
        const directiveTransform = context.directiveTransforms[name];
        if (directiveTransform) {
          const { props: props2, needRuntime } = directiveTransform(prop, node, context);
          !ssr && props2.forEach(analyzePatchFlag);
          if (isVOn && arg && !isStaticExp(arg)) {
            pushMergeArg(createObjectExpression(props2, elementLoc));
          } else {
            properties.push(...props2);
          }
          if (needRuntime) {
            runtimeDirectives.push(prop);
            if (isSymbol(needRuntime)) {
              directiveImportMap.set(prop, needRuntime);
            }
          }
        } else if (!isBuiltInDirective(name)) {
          runtimeDirectives.push(prop);
          if (hasChildren) {
            shouldUseBlock = true;
          }
        }
      }
    }
    let propsExpression = void 0;
    if (mergeArgs.length) {
      pushMergeArg();
      if (mergeArgs.length > 1) {
        propsExpression = createCallExpression(
          context.helper(MERGE_PROPS),
          mergeArgs,
          elementLoc
        );
      } else {
        propsExpression = mergeArgs[0];
      }
    } else if (properties.length) {
      propsExpression = createObjectExpression(
        dedupeProperties(properties),
        elementLoc
      );
    }
    if (hasDynamicKeys) {
      patchFlag |= 16;
    } else {
      if (hasClassBinding && !isComponent2) {
        patchFlag |= 2;
      }
      if (hasStyleBinding && !isComponent2) {
        patchFlag |= 4;
      }
      if (dynamicPropNames.length) {
        patchFlag |= 8;
      }
      if (hasHydrationEventBinding) {
        patchFlag |= 32;
      }
    }
    if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
      patchFlag |= 512;
    }
    if (!context.inSSR && propsExpression) {
      switch (propsExpression.type) {
        case 15:
          let classKeyIndex = -1;
          let styleKeyIndex = -1;
          let hasDynamicKey = false;
          for (let i = 0; i < propsExpression.properties.length; i++) {
            const key = propsExpression.properties[i].key;
            if (isStaticExp(key)) {
              if (key.content === "class") {
                classKeyIndex = i;
              } else if (key.content === "style") {
                styleKeyIndex = i;
              }
            } else if (!key.isHandlerKey) {
              hasDynamicKey = true;
            }
          }
          const classProp = propsExpression.properties[classKeyIndex];
          const styleProp = propsExpression.properties[styleKeyIndex];
          if (!hasDynamicKey) {
            if (classProp && !isStaticExp(classProp.value)) {
              classProp.value = createCallExpression(
                context.helper(NORMALIZE_CLASS),
                [classProp.value]
              );
            }
            if (styleProp && // the static style is compiled into an object,
            // so use `hasStyleBinding` to ensure that it is a dynamic style binding
            (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
            // v-bind:style with static literal object
            styleProp.value.type === 17)) {
              styleProp.value = createCallExpression(
                context.helper(NORMALIZE_STYLE),
                [styleProp.value]
              );
            }
          } else {
            propsExpression = createCallExpression(
              context.helper(NORMALIZE_PROPS),
              [propsExpression]
            );
          }
          break;
        case 14:
          break;
        default:
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [
              createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                propsExpression
              ])
            ]
          );
          break;
      }
    }
    return {
      props: propsExpression,
      directives: runtimeDirectives,
      patchFlag,
      dynamicPropNames,
      shouldUseBlock
    };
  }
  function dedupeProperties(properties) {
    const knownProps = /* @__PURE__ */ new Map();
    const deduped = [];
    for (let i = 0; i < properties.length; i++) {
      const prop = properties[i];
      if (prop.key.type === 8 || !prop.key.isStatic) {
        deduped.push(prop);
        continue;
      }
      const name = prop.key.content;
      const existing = knownProps.get(name);
      if (existing) {
        if (name === "style" || name === "class" || isOn(name)) {
          mergeAsArray2(existing, prop);
        }
      } else {
        knownProps.set(name, prop);
        deduped.push(prop);
      }
    }
    return deduped;
  }
  function mergeAsArray2(existing, incoming) {
    if (existing.value.type === 17) {
      existing.value.elements.push(incoming.value);
    } else {
      existing.value = createArrayExpression(
        [existing.value, incoming.value],
        existing.loc
      );
    }
  }
  function buildDirectiveArgs(dir, context) {
    const dirArgs = [];
    const runtime = directiveImportMap.get(dir);
    if (runtime) {
      dirArgs.push(context.helperString(runtime));
    } else {
      {
        context.helper(RESOLVE_DIRECTIVE);
        context.directives.add(dir.name);
        dirArgs.push(toValidAssetId(dir.name, `directive`));
      }
    }
    const { loc } = dir;
    if (dir.exp)
      dirArgs.push(dir.exp);
    if (dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(dir.arg);
    }
    if (Object.keys(dir.modifiers).length) {
      if (!dir.arg) {
        if (!dir.exp) {
          dirArgs.push(`void 0`);
        }
        dirArgs.push(`void 0`);
      }
      const trueExpression = createSimpleExpression(`true`, false, loc);
      dirArgs.push(
        createObjectExpression(
          dir.modifiers.map(
            (modifier) => createObjectProperty(modifier, trueExpression)
          ),
          loc
        )
      );
    }
    return createArrayExpression(dirArgs, dir.loc);
  }
  function stringifyDynamicPropNames(props) {
    let propsNamesString = `[`;
    for (let i = 0, l = props.length; i < l; i++) {
      propsNamesString += JSON.stringify(props[i]);
      if (i < l - 1)
        propsNamesString += ", ";
    }
    return propsNamesString + `]`;
  }
  function isComponentTag(tag) {
    return tag === "component" || tag === "Component";
  }
  var transformSlotOutlet = (node, context) => {
    if (isSlotOutlet(node)) {
      const { children, loc } = node;
      const { slotName, slotProps } = processSlotOutlet(node, context);
      const slotArgs = [
        context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
        slotName,
        "{}",
        "undefined",
        "true"
      ];
      let expectedLen = 2;
      if (slotProps) {
        slotArgs[2] = slotProps;
        expectedLen = 3;
      }
      if (children.length) {
        slotArgs[3] = createFunctionExpression([], children, false, false, loc);
        expectedLen = 4;
      }
      if (context.scopeId && !context.slotted) {
        expectedLen = 5;
      }
      slotArgs.splice(expectedLen);
      node.codegenNode = createCallExpression(
        context.helper(RENDER_SLOT),
        slotArgs,
        loc
      );
    }
  };
  function processSlotOutlet(node, context) {
    let slotName = `"default"`;
    let slotProps = void 0;
    const nonNameProps = [];
    for (let i = 0; i < node.props.length; i++) {
      const p2 = node.props[i];
      if (p2.type === 6) {
        if (p2.value) {
          if (p2.name === "name") {
            slotName = JSON.stringify(p2.value.content);
          } else {
            p2.name = camelize2(p2.name);
            nonNameProps.push(p2);
          }
        }
      } else {
        if (p2.name === "bind" && isStaticArgOf(p2.arg, "name")) {
          if (p2.exp) {
            slotName = p2.exp;
          } else if (p2.arg && p2.arg.type === 4) {
            const name = camelize2(p2.arg.content);
            slotName = p2.exp = createSimpleExpression(name, false, p2.arg.loc);
          }
        } else {
          if (p2.name === "bind" && p2.arg && isStaticExp(p2.arg)) {
            p2.arg.content = camelize2(p2.arg.content);
          }
          nonNameProps.push(p2);
        }
      }
    }
    if (nonNameProps.length > 0) {
      const { props, directives } = buildProps(
        node,
        context,
        nonNameProps,
        false,
        false
      );
      slotProps = props;
      if (directives.length) {
        context.onError(
          createCompilerError(
            36,
            directives[0].loc
          )
        );
      }
    }
    return {
      slotName,
      slotProps
    };
  }
  var fnExpRE = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
  var transformOn = (dir, node, context, augmentor) => {
    const { loc, modifiers, arg } = dir;
    if (!dir.exp && !modifiers.length) {
      context.onError(createCompilerError(35, loc));
    }
    let eventName;
    if (arg.type === 4) {
      if (arg.isStatic) {
        let rawName = arg.content;
        if (rawName.startsWith("vnode")) {
          context.onError(createCompilerError(51, arg.loc));
        }
        if (rawName.startsWith("vue:")) {
          rawName = `vnode-${rawName.slice(4)}`;
        }
        const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
          // for non-element and vnode lifecycle event listeners, auto convert
          // it to camelCase. See issue #2249
          toHandlerKey(camelize2(rawName))
        ) : (
          // preserve case for plain element listeners that have uppercase
          // letters, as these may be custom elements' custom events
          `on:${rawName}`
        );
        eventName = createSimpleExpression(eventString, true, arg.loc);
      } else {
        eventName = createCompoundExpression([
          `${context.helperString(TO_HANDLER_KEY)}(`,
          arg,
          `)`
        ]);
      }
    } else {
      eventName = arg;
      eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
      eventName.children.push(`)`);
    }
    let exp = dir.exp;
    if (exp && !exp.content.trim()) {
      exp = void 0;
    }
    let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
    if (exp) {
      const isMemberExp = isMemberExpression(exp.content);
      const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
      const hasMultipleStatements = exp.content.includes(`;`);
      if (true) {
        validateBrowserExpression(
          exp,
          context,
          false,
          hasMultipleStatements
        );
      }
      if (isInlineStatement || shouldCache && isMemberExp) {
        exp = createCompoundExpression([
          `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
          exp,
          hasMultipleStatements ? `}` : `)`
        ]);
      }
    }
    let ret = {
      props: [
        createObjectProperty(
          eventName,
          exp || createSimpleExpression(`() => {}`, false, loc)
        )
      ]
    };
    if (augmentor) {
      ret = augmentor(ret);
    }
    if (shouldCache) {
      ret.props[0].value = context.cache(ret.props[0].value);
    }
    ret.props.forEach((p2) => p2.key.isHandlerKey = true);
    return ret;
  };
  var transformText = (node, context) => {
    if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
      return () => {
        const children = node.children;
        let currentContainer = void 0;
        let hasText = false;
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (isText$1(child)) {
            hasText = true;
            for (let j = i + 1; j < children.length; j++) {
              const next = children[j];
              if (isText$1(next)) {
                if (!currentContainer) {
                  currentContainer = children[i] = createCompoundExpression(
                    [child],
                    child.loc
                  );
                }
                currentContainer.children.push(` + `, next);
                children.splice(j, 1);
                j--;
              } else {
                currentContainer = void 0;
                break;
              }
            }
          }
        }
        if (!hasText || // if this is a plain element with a single text child, leave it
        // as-is since the runtime has dedicated fast path for this by directly
        // setting textContent of the element.
        // for component root it's always normalized anyway.
        children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
        // custom directives can potentially add DOM elements arbitrarily,
        // we need to avoid setting textContent of the element at runtime
        // to avoid accidentally overwriting the DOM elements added
        // by the user through custom directives.
        !node.props.find(
          (p2) => p2.type === 7 && !context.directiveTransforms[p2.name]
        ) && // in compat mode, <template> tags with no special directives
        // will be rendered as a fragment so its children must be
        // converted into vnodes.
        !(node.tag === "template"))) {
          return;
        }
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (isText$1(child) || child.type === 8) {
            const callArgs = [];
            if (child.type !== 2 || child.content !== " ") {
              callArgs.push(child);
            }
            if (!context.ssr && getConstantType(child, context) === 0) {
              callArgs.push(
                1 + (true ? ` /* ${PatchFlagNames[1]} */` : ``)
              );
            }
            children[i] = {
              type: 12,
              content: child,
              loc: child.loc,
              codegenNode: createCallExpression(
                context.helper(CREATE_TEXT),
                callArgs
              )
            };
          }
        }
      };
    }
  };
  var seen$1 = /* @__PURE__ */ new WeakSet();
  var transformOnce = (node, context) => {
    if (node.type === 1 && findDir(node, "once", true)) {
      if (seen$1.has(node) || context.inVOnce || context.inSSR) {
        return;
      }
      seen$1.add(node);
      context.inVOnce = true;
      context.helper(SET_BLOCK_TRACKING);
      return () => {
        context.inVOnce = false;
        const cur = context.currentNode;
        if (cur.codegenNode) {
          cur.codegenNode = context.cache(
            cur.codegenNode,
            true
            /* isVNode */
          );
        }
      };
    }
  };
  var transformModel = (dir, node, context) => {
    const { exp, arg } = dir;
    if (!exp) {
      context.onError(
        createCompilerError(41, dir.loc)
      );
      return createTransformProps();
    }
    const rawExp = exp.loc.source;
    const expString = exp.type === 4 ? exp.content : rawExp;
    const bindingType = context.bindingMetadata[rawExp];
    if (bindingType === "props" || bindingType === "props-aliased") {
      context.onError(createCompilerError(44, exp.loc));
      return createTransformProps();
    }
    const maybeRef = false;
    if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
      context.onError(
        createCompilerError(42, exp.loc)
      );
      return createTransformProps();
    }
    const propName = arg ? arg : createSimpleExpression("modelValue", true);
    const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize2(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
    let assignmentExp;
    const eventArg = context.isTS ? `($event: any)` : `$event`;
    {
      assignmentExp = createCompoundExpression([
        `${eventArg} => ((`,
        exp,
        `) = $event)`
      ]);
    }
    const props = [
      // modelValue: foo
      createObjectProperty(propName, dir.exp),
      // "onUpdate:modelValue": $event => (foo = $event)
      createObjectProperty(eventName, assignmentExp)
    ];
    if (dir.modifiers.length && node.tagType === 1) {
      const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
      const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
      props.push(
        createObjectProperty(
          modifiersKey,
          createSimpleExpression(
            `{ ${modifiers} }`,
            false,
            dir.loc,
            2
          )
        )
      );
    }
    return createTransformProps(props);
  };
  function createTransformProps(props = []) {
    return { props };
  }
  var validDivisionCharRE = /[\w).+\-_$\]]/;
  var transformFilter = (node, context) => {
    if (!isCompatEnabled("COMPILER_FILTERS", context)) {
      return;
    }
    if (node.type === 5) {
      rewriteFilter(node.content, context);
    } else if (node.type === 1) {
      node.props.forEach((prop) => {
        if (prop.type === 7 && prop.name !== "for" && prop.exp) {
          rewriteFilter(prop.exp, context);
        }
      });
    }
  };
  function rewriteFilter(node, context) {
    if (node.type === 4) {
      parseFilter(node, context);
    } else {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (typeof child !== "object")
          continue;
        if (child.type === 4) {
          parseFilter(child, context);
        } else if (child.type === 8) {
          rewriteFilter(node, context);
        } else if (child.type === 5) {
          rewriteFilter(child.content, context);
        }
      }
    }
  }
  function parseFilter(node, context) {
    const exp = node.content;
    let inSingle = false;
    let inDouble = false;
    let inTemplateString = false;
    let inRegex = false;
    let curly = 0;
    let square = 0;
    let paren = 0;
    let lastFilterIndex = 0;
    let c, prev, i, expression, filters = [];
    for (i = 0; i < exp.length; i++) {
      prev = c;
      c = exp.charCodeAt(i);
      if (inSingle) {
        if (c === 39 && prev !== 92)
          inSingle = false;
      } else if (inDouble) {
        if (c === 34 && prev !== 92)
          inDouble = false;
      } else if (inTemplateString) {
        if (c === 96 && prev !== 92)
          inTemplateString = false;
      } else if (inRegex) {
        if (c === 47 && prev !== 92)
          inRegex = false;
      } else if (c === 124 && // pipe
      exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
        if (expression === void 0) {
          lastFilterIndex = i + 1;
          expression = exp.slice(0, i).trim();
        } else {
          pushFilter();
        }
      } else {
        switch (c) {
          case 34:
            inDouble = true;
            break;
          case 39:
            inSingle = true;
            break;
          case 96:
            inTemplateString = true;
            break;
          case 40:
            paren++;
            break;
          case 41:
            paren--;
            break;
          case 91:
            square++;
            break;
          case 93:
            square--;
            break;
          case 123:
            curly++;
            break;
          case 125:
            curly--;
            break;
        }
        if (c === 47) {
          let j = i - 1;
          let p2;
          for (; j >= 0; j--) {
            p2 = exp.charAt(j);
            if (p2 !== " ")
              break;
          }
          if (!p2 || !validDivisionCharRE.test(p2)) {
            inRegex = true;
          }
        }
      }
    }
    if (expression === void 0) {
      expression = exp.slice(0, i).trim();
    } else if (lastFilterIndex !== 0) {
      pushFilter();
    }
    function pushFilter() {
      filters.push(exp.slice(lastFilterIndex, i).trim());
      lastFilterIndex = i + 1;
    }
    if (filters.length) {
      warnDeprecation(
        "COMPILER_FILTERS",
        context,
        node.loc
      );
      for (i = 0; i < filters.length; i++) {
        expression = wrapFilter(expression, filters[i], context);
      }
      node.content = expression;
      node.ast = void 0;
    }
  }
  function wrapFilter(exp, filter, context) {
    context.helper(RESOLVE_FILTER);
    const i = filter.indexOf("(");
    if (i < 0) {
      context.filters.add(filter);
      return `${toValidAssetId(filter, "filter")}(${exp})`;
    } else {
      const name = filter.slice(0, i);
      const args = filter.slice(i + 1);
      context.filters.add(name);
      return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
    }
  }
  var seen = /* @__PURE__ */ new WeakSet();
  var transformMemo = (node, context) => {
    if (node.type === 1) {
      const dir = findDir(node, "memo");
      if (!dir || seen.has(node)) {
        return;
      }
      seen.add(node);
      return () => {
        const codegenNode = node.codegenNode || context.currentNode.codegenNode;
        if (codegenNode && codegenNode.type === 13) {
          if (node.tagType !== 1) {
            convertToBlock(codegenNode, context);
          }
          node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
            dir.exp,
            createFunctionExpression(void 0, codegenNode),
            `_cache`,
            String(context.cached++)
          ]);
        }
      };
    }
  };
  function getBaseTransformPreset(prefixIdentifiers) {
    return [
      [
        transformOnce,
        transformIf,
        transformMemo,
        transformFor,
        ...[transformFilter],
        ...true ? [transformExpression] : [],
        transformSlotOutlet,
        transformElement,
        trackSlotScopes,
        transformText
      ],
      {
        on: transformOn,
        bind: transformBind,
        model: transformModel
      }
    ];
  }
  function baseCompile(source, options = {}) {
    const onError = options.onError || defaultOnError;
    const isModuleMode = options.mode === "module";
    {
      if (options.prefixIdentifiers === true) {
        onError(createCompilerError(47));
      } else if (isModuleMode) {
        onError(createCompilerError(48));
      }
    }
    const prefixIdentifiers = false;
    if (options.cacheHandlers) {
      onError(createCompilerError(49));
    }
    if (options.scopeId && !isModuleMode) {
      onError(createCompilerError(50));
    }
    const resolvedOptions = extend3({}, options, {
      prefixIdentifiers
    });
    const ast = isString(source) ? baseParse(source, resolvedOptions) : source;
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
    transform(
      ast,
      extend3({}, resolvedOptions, {
        nodeTransforms: [
          ...nodeTransforms,
          ...options.nodeTransforms || []
          // user transforms
        ],
        directiveTransforms: extend3(
          {},
          directiveTransforms,
          options.directiveTransforms || {}
          // user transforms
        )
      })
    );
    return generate(ast, resolvedOptions);
  }
  var noopDirectiveTransform = () => ({ props: [] });

  // node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js
  var V_MODEL_RADIO = Symbol(true ? `vModelRadio` : ``);
  var V_MODEL_CHECKBOX = Symbol(true ? `vModelCheckbox` : ``);
  var V_MODEL_TEXT = Symbol(true ? `vModelText` : ``);
  var V_MODEL_SELECT = Symbol(true ? `vModelSelect` : ``);
  var V_MODEL_DYNAMIC = Symbol(true ? `vModelDynamic` : ``);
  var V_ON_WITH_MODIFIERS = Symbol(true ? `vOnModifiersGuard` : ``);
  var V_ON_WITH_KEYS = Symbol(true ? `vOnKeysGuard` : ``);
  var V_SHOW = Symbol(true ? `vShow` : ``);
  var TRANSITION2 = Symbol(true ? `Transition` : ``);
  var TRANSITION_GROUP = Symbol(true ? `TransitionGroup` : ``);
  registerRuntimeHelpers({
    [V_MODEL_RADIO]: `vModelRadio`,
    [V_MODEL_CHECKBOX]: `vModelCheckbox`,
    [V_MODEL_TEXT]: `vModelText`,
    [V_MODEL_SELECT]: `vModelSelect`,
    [V_MODEL_DYNAMIC]: `vModelDynamic`,
    [V_ON_WITH_MODIFIERS]: `withModifiers`,
    [V_ON_WITH_KEYS]: `withKeys`,
    [V_SHOW]: `vShow`,
    [TRANSITION2]: `Transition`,
    [TRANSITION_GROUP]: `TransitionGroup`
  });
  var decoder;
  function decodeHtmlBrowser(raw, asAttr = false) {
    if (!decoder) {
      decoder = document.createElement("div");
    }
    if (asAttr) {
      decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
      return decoder.children[0].getAttribute("foo");
    } else {
      decoder.innerHTML = raw;
      return decoder.textContent;
    }
  }
  var parserOptions = {
    parseMode: "html",
    isVoidTag,
    isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
    isPreTag: (tag) => tag === "pre",
    decodeEntities: decodeHtmlBrowser,
    isBuiltInComponent: (tag) => {
      if (tag === "Transition" || tag === "transition") {
        return TRANSITION2;
      } else if (tag === "TransitionGroup" || tag === "transition-group") {
        return TRANSITION_GROUP;
      }
    },
    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
    getNamespace(tag, parent, rootNamespace) {
      let ns = parent ? parent.ns : rootNamespace;
      if (parent && ns === 2) {
        if (parent.tag === "annotation-xml") {
          if (tag === "svg") {
            return 1;
          }
          if (parent.props.some(
            (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
          )) {
            ns = 0;
          }
        } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
          ns = 0;
        }
      } else if (parent && ns === 1) {
        if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
          ns = 0;
        }
      }
      if (ns === 0) {
        if (tag === "svg") {
          return 1;
        }
        if (tag === "math") {
          return 2;
        }
      }
      return ns;
    }
  };
  var transformStyle = (node) => {
    if (node.type === 1) {
      node.props.forEach((p2, i) => {
        if (p2.type === 6 && p2.name === "style" && p2.value) {
          node.props[i] = {
            type: 7,
            name: `bind`,
            arg: createSimpleExpression(`style`, true, p2.loc),
            exp: parseInlineCSS(p2.value.content, p2.loc),
            modifiers: [],
            loc: p2.loc
          };
        }
      });
    }
  };
  var parseInlineCSS = (cssText, loc) => {
    const normalized = parseStringStyle(cssText);
    return createSimpleExpression(
      JSON.stringify(normalized),
      false,
      loc,
      3
    );
  };
  function createDOMCompilerError(code, loc) {
    return createCompilerError(
      code,
      loc,
      true ? DOMErrorMessages : void 0
    );
  }
  var DOMErrorMessages = {
    [53]: `v-html is missing expression.`,
    [54]: `v-html will override element children.`,
    [55]: `v-text is missing expression.`,
    [56]: `v-text will override element children.`,
    [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
    [58]: `v-model argument is not supported on plain elements.`,
    [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
    [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
    [61]: `v-show is missing expression.`,
    [62]: `<Transition> expects exactly one child element or component.`,
    [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
  };
  var transformVHtml = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
      context.onError(
        createDOMCompilerError(53, loc)
      );
    }
    if (node.children.length) {
      context.onError(
        createDOMCompilerError(54, loc)
      );
      node.children.length = 0;
    }
    return {
      props: [
        createObjectProperty(
          createSimpleExpression(`innerHTML`, true, loc),
          exp || createSimpleExpression("", true)
        )
      ]
    };
  };
  var transformVText = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
      context.onError(
        createDOMCompilerError(55, loc)
      );
    }
    if (node.children.length) {
      context.onError(
        createDOMCompilerError(56, loc)
      );
      node.children.length = 0;
    }
    return {
      props: [
        createObjectProperty(
          createSimpleExpression(`textContent`, true),
          exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(
            context.helperString(TO_DISPLAY_STRING),
            [exp],
            loc
          ) : createSimpleExpression("", true)
        )
      ]
    };
  };
  var transformModel2 = (dir, node, context) => {
    const baseResult = transformModel(dir, node, context);
    if (!baseResult.props.length || node.tagType === 1) {
      return baseResult;
    }
    if (dir.arg) {
      context.onError(
        createDOMCompilerError(
          58,
          dir.arg.loc
        )
      );
    }
    function checkDuplicatedValue() {
      const value = findDir(node, "bind");
      if (value && isStaticArgOf(value.arg, "value")) {
        context.onError(
          createDOMCompilerError(
            60,
            value.loc
          )
        );
      }
    }
    const { tag } = node;
    const isCustomElement = context.isCustomElement(tag);
    if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
      let directiveToUse = V_MODEL_TEXT;
      let isInvalidType = false;
      if (tag === "input" || isCustomElement) {
        const type = findProp(node, `type`);
        if (type) {
          if (type.type === 7) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else if (type.value) {
            switch (type.value.content) {
              case "radio":
                directiveToUse = V_MODEL_RADIO;
                break;
              case "checkbox":
                directiveToUse = V_MODEL_CHECKBOX;
                break;
              case "file":
                isInvalidType = true;
                context.onError(
                  createDOMCompilerError(
                    59,
                    dir.loc
                  )
                );
                break;
              default:
                checkDuplicatedValue();
                break;
            }
          }
        } else if (hasDynamicKeyVBind(node)) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else {
          checkDuplicatedValue();
        }
      } else if (tag === "select") {
        directiveToUse = V_MODEL_SELECT;
      } else {
        checkDuplicatedValue();
      }
      if (!isInvalidType) {
        baseResult.needRuntime = context.helper(directiveToUse);
      }
    } else {
      context.onError(
        createDOMCompilerError(
          57,
          dir.loc
        )
      );
    }
    baseResult.props = baseResult.props.filter(
      (p2) => !(p2.key.type === 4 && p2.key.content === "modelValue")
    );
    return baseResult;
  };
  var isEventOptionModifier = /* @__PURE__ */ makeMap(`passive,once,capture`);
  var isNonKeyModifier = /* @__PURE__ */ makeMap(
    // event propagation management
    `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
  );
  var maybeKeyModifier = /* @__PURE__ */ makeMap("left,right");
  var isKeyboardEvent = /* @__PURE__ */ makeMap(
    `onkeyup,onkeydown,onkeypress`,
    true
  );
  var resolveModifiers = (key, modifiers, context, loc) => {
    const keyModifiers = [];
    const nonKeyModifiers = [];
    const eventOptionModifiers = [];
    for (let i = 0; i < modifiers.length; i++) {
      const modifier = modifiers[i];
      if (modifier === "native" && checkCompatEnabled(
        "COMPILER_V_ON_NATIVE",
        context,
        loc
      )) {
        eventOptionModifiers.push(modifier);
      } else if (isEventOptionModifier(modifier)) {
        eventOptionModifiers.push(modifier);
      } else {
        if (maybeKeyModifier(modifier)) {
          if (isStaticExp(key)) {
            if (isKeyboardEvent(key.content)) {
              keyModifiers.push(modifier);
            } else {
              nonKeyModifiers.push(modifier);
            }
          } else {
            keyModifiers.push(modifier);
            nonKeyModifiers.push(modifier);
          }
        } else {
          if (isNonKeyModifier(modifier)) {
            nonKeyModifiers.push(modifier);
          } else {
            keyModifiers.push(modifier);
          }
        }
      }
    }
    return {
      keyModifiers,
      nonKeyModifiers,
      eventOptionModifiers
    };
  };
  var transformClick = (key, event) => {
    const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
    return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
      `(`,
      key,
      `) === "onClick" ? "${event}" : (`,
      key,
      `)`
    ]) : key;
  };
  var transformOn2 = (dir, node, context) => {
    return transformOn(dir, node, context, (baseResult) => {
      const { modifiers } = dir;
      if (!modifiers.length)
        return baseResult;
      let { key, value: handlerExp } = baseResult.props[0];
      const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
      if (nonKeyModifiers.includes("right")) {
        key = transformClick(key, `onContextmenu`);
      }
      if (nonKeyModifiers.includes("middle")) {
        key = transformClick(key, `onMouseup`);
      }
      if (nonKeyModifiers.length) {
        handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
          handlerExp,
          JSON.stringify(nonKeyModifiers)
        ]);
      }
      if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
      (!isStaticExp(key) || isKeyboardEvent(key.content))) {
        handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
          handlerExp,
          JSON.stringify(keyModifiers)
        ]);
      }
      if (eventOptionModifiers.length) {
        const modifierPostfix = eventOptionModifiers.map(capitalize2).join("");
        key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
      }
      return {
        props: [createObjectProperty(key, handlerExp)]
      };
    });
  };
  var transformShow = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
      context.onError(
        createDOMCompilerError(61, loc)
      );
    }
    return {
      props: [],
      needRuntime: context.helper(V_SHOW)
    };
  };
  var transformTransition = (node, context) => {
    if (node.type === 1 && node.tagType === 1) {
      const component = context.isBuiltInComponent(node.tag);
      if (component === TRANSITION2) {
        return () => {
          if (!node.children.length) {
            return;
          }
          if (hasMultipleChildren(node)) {
            context.onError(
              createDOMCompilerError(
                62,
                {
                  start: node.children[0].loc.start,
                  end: node.children[node.children.length - 1].loc.end,
                  source: ""
                }
              )
            );
          }
          const child = node.children[0];
          if (child.type === 1) {
            for (const p2 of child.props) {
              if (p2.type === 7 && p2.name === "show") {
                node.props.push({
                  type: 6,
                  name: "persisted",
                  nameLoc: node.loc,
                  value: void 0,
                  loc: node.loc
                });
              }
            }
          }
        };
      }
    }
  };
  function hasMultipleChildren(node) {
    const children = node.children = node.children.filter(
      (c) => c.type !== 3 && !(c.type === 2 && !c.content.trim())
    );
    const child = children[0];
    return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
  }
  var ignoreSideEffectTags = (node, context) => {
    if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
      context.onError(
        createDOMCompilerError(
          63,
          node.loc
        )
      );
      context.removeNode();
    }
  };
  var DOMNodeTransforms = [
    transformStyle,
    ...true ? [transformTransition] : []
  ];
  var DOMDirectiveTransforms = {
    cloak: noopDirectiveTransform,
    html: transformVHtml,
    text: transformVText,
    model: transformModel2,
    // override compiler-core
    on: transformOn2,
    // override compiler-core
    show: transformShow
  };
  function compile2(src, options = {}) {
    return baseCompile(
      src,
      extend3({}, parserOptions, options, {
        nodeTransforms: [
          // ignore <script> and <tag>
          // this is not put inside DOMNodeTransforms because that list is used
          // by compiler-ssr to generate vnode fallback branches
          ignoreSideEffectTags,
          ...DOMNodeTransforms,
          ...options.nodeTransforms || []
        ],
        directiveTransforms: extend3(
          {},
          DOMDirectiveTransforms,
          options.directiveTransforms || {}
        ),
        transformHoist: null
      })
    );
  }

  // node_modules/vue/dist/vue.esm-bundler.js
  function initDev() {
    {
      initCustomFormatter();
    }
  }
  if (true) {
    initDev();
  }
  var compileCache = /* @__PURE__ */ new WeakMap();
  function getCache(options) {
    let c = compileCache.get(options != null ? options : EMPTY_OBJ);
    if (!c) {
      c = /* @__PURE__ */ Object.create(null);
      compileCache.set(options != null ? options : EMPTY_OBJ, c);
    }
    return c;
  }
  function compileToFunction(template, options) {
    if (!isString(template)) {
      if (template.nodeType) {
        template = template.innerHTML;
      } else {
        warn2(`invalid template option: `, template);
        return NOOP;
      }
    }
    const key = template;
    const cache2 = getCache(options);
    const cached = cache2[key];
    if (cached) {
      return cached;
    }
    if (template[0] === "#") {
      const el = document.querySelector(template);
      if (!el) {
        warn2(`Template element not found or is empty: ${template}`);
      }
      template = el ? el.innerHTML : ``;
    }
    const opts = extend3(
      {
        hoistStatic: true,
        onError: true ? onError : void 0,
        onWarn: true ? (e) => onError(e, true) : NOOP
      },
      options
    );
    if (!opts.isCustomElement && typeof customElements !== "undefined") {
      opts.isCustomElement = (tag) => !!customElements.get(tag);
    }
    const { code } = compile2(template, opts);
    function onError(err, asWarning = false) {
      const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
      const codeFrame = err.loc && generateCodeFrame(
        template,
        err.loc.start.offset,
        err.loc.end.offset
      );
      warn2(codeFrame ? `${message}
${codeFrame}` : message);
    }
    const render2 = new Function("Vue", code)(runtime_dom_esm_bundler_exports);
    render2._rc = true;
    return cache2[key] = render2;
  }
  registerRuntimeCompiler(compileToFunction);

  // app/javascript/application.js
  window.vue = vue_esm_bundler_exports;
  window.agGrid = main_esm_exports;
  window.jQuery = import_jquery3.default;
  window.$ = import_jquery3.default;
  window.moment = import_moment.default;
  (0, import_select2.default)($);
  window.callToast = function(t = "", s = 4e3, bg = "53397C") {
    (0, import_toastify_js.default)({
      text: t,
      duration: s,
      destination: "https://github.com/apvarun/toastify-js",
      newWindow: true,
      close: true,
      gravity: "top",
      // `top` or `bottom`
      position: "right",
      // `left`, `center` or `right`
      stopOnFocus: true,
      // Prevents dismissing of toast on hover
      style: {
        background: "FFFFFF"
      }
    }).showToast();
  };
  $.ajaxSetup({
    beforeSend: function() {
      $("div.spanner").addClass("show");
      $("div.overlay").addClass("show");
    },
    complete: function() {
      $("div.spanner").removeClass("show");
      $("div.overlay").removeClass("show");
    }
  });
  document.addEventListener("paste", function(e) {
    var clipboardData, pastedData;
    e.stopPropagation();
    e.preventDefault();
    clipboardData = e.clipboardData || window.clipboardData;
    pastedData = clipboardData.getData("Text");
    pastedData = pastedData.trim();
    document.execCommand("insertHTML", false, pastedData);
    console.log(pastedData);
  });
  function convertNumber(num) {
    if (!num || isNaN(parseFloat(num))) {
      return 0;
    }
    if (typeof num == "number") {
      return num;
    }
    return parseFloat(num.replaceAll(",", ""));
  }
  function convertLocalString(e) {
    if (!e) {
      return "";
    }
    return e.toLocaleString("en-US", {
      minimumFractionDigits: 3,
      maximumFractionDigits: 3
    });
  }
  function checkValueExists(arr, value) {
    return arr.some(
      (subArr) => subArr.map((item) => typeof item === "string" ? item.trim() : item).includes(value)
    );
  }
  window.checkValueExists = checkValueExists;
  window.convertNumber = convertNumber;
  window.convertLocalString = convertLocalString;
})();
/*! Bundled license information:

jquery/dist/jquery.js:
  (*!
   * jQuery JavaScript Library v3.7.1
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   *)

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.30.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

select2/dist/js/select2.js:
  (*!
   * Select2 4.1.0-rc.0
   * https://select2.github.io
   *
   * Released under the MIT license
   * https://github.com/select2/select2/blob/master/LICENSE.md
   *)
  (**
   * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
   * Released under MIT license, http://github.com/requirejs/almond/LICENSE
   *)

toastify-js/src/toastify.js:
  (*!
   * Toastify js 1.12.0
   * https://github.com/apvarun/toastify-js
   * @license MIT licensed
   *
   * Copyright (C) 2018 Varun A P
   *)

@hotwired/turbo/dist/turbo.es2017-esm.js:
  (*!
  Turbo 8.0.4
  Copyright  2024 37signals LLC
   *)

datatables.net/js/jquery.dataTables.mjs:
  (*! DataTables 1.13.11
   * 2008-2024 SpryMedia Ltd - datatables.net/license
   *)

datatables.net-dt/js/dataTables.dataTables.mjs:
  (*! DataTables styling integration
   * 2018 SpryMedia Ltd - datatables.net/license
   *)

@vue/shared/dist/shared.esm-bundler.js:
  (**
  * @vue/shared v3.4.31
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (*! #__NO_SIDE_EFFECTS__ *)

@vue/reactivity/dist/reactivity.esm-bundler.js:
  (**
  * @vue/reactivity v3.4.31
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/runtime-core/dist/runtime-core.esm-bundler.js:
  (**
  * @vue/runtime-core v3.4.31
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (*! #__NO_SIDE_EFFECTS__ *)

@vue/runtime-dom/dist/runtime-dom.esm-bundler.js:
  (**
  * @vue/runtime-dom v3.4.31
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (*! #__NO_SIDE_EFFECTS__ *)

@vue/compiler-core/dist/compiler-core.esm-bundler.js:
  (**
  * @vue/compiler-core v3.4.31
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/compiler-dom/dist/compiler-dom.esm-bundler.js:
  (**
  * @vue/compiler-dom v3.4.31
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

vue/dist/vue.esm-bundler.js:
  (**
  * vue v3.4.31
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
*/
//# sourceMappingURL=/assets/application.js.map
